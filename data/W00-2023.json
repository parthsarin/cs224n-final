{
    "article": "II rhis paper we extend rhe work by Michaelis (1999) which slwws how ro encode an arbirra1}' Minimalisr Grammar in the sense of Stab/er ( 1997)  illto a weakly equivalem mulriple contextfree grammar (MCFG). By viewing MCFG rules as tenns in a free Lawvere the01y we can translate a give11 MCFG into a regular tree grammar. The latter is characteri:able by both a tree automaton and a correspondingfonnu/a in monadic second-order (MSO) logic. The trees of the res11/ti11g regular tree language are then unpacked into the intended \"linguistic\" trees witlz an MSO rra11sducrio11 based upon tree-walking automata. Tlzis rwo-step approacl1 gives an operarional as well as a Jogi ca/ descriprinn nf the tree sets involved. Introduction Over the last couple of years, a rich class of mildly context-sensitive grammar formalisms has been proven ro be weakly equivalent. Among others, the following families of (string) Janguages are eguivalent: ST R(H R) [languages generated by string generating hyperedge replacement grammars], OUT (DTlVT) [output languages of deterministic tree-wallcing tree-tostring transducers], yDT1c(REGT) [yields of images of regular tree languages under deterministic finite-copying top-down tree transductions), MCF L [Janguages generated by multiple context-free grammars], .HCTA.L [languages generated by multi-component tree adjoining grammars), LCF RL [languages generated by linear context-free rewr.iting systems), LU SCL [languages generated by local unordered scattered context grammars) (more on these eguiva-Jences can be found, e.g., in Engelfriet 1997 , Rambow & Satta 1999 , Weir 1992) . The work by Michaelis (1999) shows how to encode an arbitrary minimalist grammar (MG) in the sense of Stabler {1997) into a weakly equivalent linear context-free rewriting system (LCFRS). The core idea is that for the set of trees appcnring as intermediate steps in converging derivations corresponding to a given MG one can define a finite partition. Thc eqt\u00fcv.alenc~ classes of this partition are formed by sets of trees where the features trigger.ing movement appear in identical structural positions. Each nonterminal in a corresponding LCFRS represents such an eguivalence class, i.e\" an infinite set of trees. We take the resulting LCFRSs as our starting point and present in this paper a translation from multiple context-free grammars (MCFGs)-which are a weakly eguivalent extension of LCFRSs-into regular tree grammars (RTGs)/monadic second-order (MSO) logic/tree automata. This is done via lifting by viewing MCFG rules as terms in a free Lawvere theory. Since this coding makes projection, tupling and composition explicit, the resulting trees contain these operations as labeled nodes. Therefore we use an MSO transduction-where the regular tree language constitutes the domain-to transform the Jifted trees into the intended ones. We think that our approach has decisive advantages. First, the operations of the relevant signature appear explicitly in the Jifted trees and are not hidden in node Jabels coding instances of rule application. Second, our path component is not dependent on the particular regular tree family or the domain defined via the MSO fonnula. The instruction set of the tree-walking automaton and the corresponding definition of the MSO transduction are universal and only serve to reverse the lifting process. In that sense the instructions are nothing eise but a restatement of the unique homomorphism which exists between the free algebra and any other algebra of the same signature. Thus, the translation from MCFGs to RTGs constitutes a considerable simplification in comparison with other characterizations since it is not built upon derivation trees using productions of the original MCFG as node labels, but rather on the Operations of projection, tuple-fonnation and composition alone. In the following sections we Jimit ourselves to the special case of MCFG rules with only one nontenninal on the right hand side (RHS). This allows a significant simplification in the presentation since it requires only one level of tupling. The extension to ehe general case of using tuples of tuples is considerably more involved and, for Jack of space, cannot be described here. Background and Basic Definitions We first present some basic definitions before we proceed with the actual translation. Let S be a set of sorts. A ma11y-sorted sig11ature E ( over S) is an indexed family (Eu,,s j u.; E S\u2022, s E S) of disjoint sets. A symbol in Eu\u2022,s is called an operator of type (tr, s), arity u:, sort s and rank jwj, where lwl denotes the Jength of w. Let X == { x 1 , x 2 , .r 3 , . .. } be a countable set of variables, and for k EI'.\\ define Xk as {x 1 , ...\u2022 \"r.k} . Then, the set of k-ary trees T(E, Xk ) over Eis built up from xk using the Operators in the. usual way: If a E Et,S u xk for some s E s and \u20ac E s\u2022 with !EI = 0 then a is a (trivial) k-ary tree of sort s. If, for some s E S and u: = s 1 \u2022 \u2022 \u2022Sn with Si E S, a E Ew ,s and t 1 , ... , tn are k-ary trees with t; of sort S; then a(t 1 , ... , tn) is a k-ary tree of sort s. Note that T(E, X1.J s:;: T(E. X1) for k 5 l. Let T (E, X)= LJkEI.' T(E, Xk )\u2022 The operator symbols induce operati ons on an algebra with the appropriate structure. ,A Ealgebra A consists of an S-indexed family of sets A = (.4 5 ) sES and for each Operator a E Ew.\" ap_: Aw -t A.5 is a function, where A.w = .4' 1 x \u2022 \u2022 \u2022 x A.'\" :!~~ c'.' -'\" ::\" \u2022.-.;;.;, 8; t= ::i. The set T(E, X) can be made into a E-algebra 'f by specifying the operations as follows. For every a E Eu.\u2022,s\u2022 where s E Sand u.; = s 1 \u2022\u2022\u2022Sn with Si E 5, and every f1, ... , tn E T(E, X) with t; of sort s; we identify a, (ti. . .. , tn) with a(ti, ... , tn)\u2022 Our main notion is that of an a/gebraic (Lawvere) theo1y. Given a set of sorts S, an algebraic theory, as an a!gebra, is an S* x S* -sorted algebra 'f, whose carriers (T( u, V) j u, V E 5 *) consist of the morphisms of the theory and whose operations are of the following types, where n E N, u = u.1 \u2022 \u2022 \u2022 Un with U; E S for 1 $ i $ n and v, W E $\u2022, projection: r.f E T(u, u; ) composition: C(u ,v,w) E T (u, v) X T(v, w) -t T(u, w) targettupling: ( )(v,u.) E T(v,ui) x \u2022\u2022\u2022X T(v,un) -t T(v,u) The projections and the operations of target tupling are required to satisfy the obvious identities for products. The composition operations must satisfy associativity. For S being a singleton and E a (many-sorted) signature over s\u2022 xs\u2022, the power set p(T(L',X)) of T(E, X) constitutes the central example of i nterest for formal Janguage theory. The carriers (p(T( k, m) ) 1 k, m E IN) of the corresponding s\u2022x s\u2022 -Lawvere algebra are constituted by the power sets of the sets T(k, m), where each T(k, m) is the set of all m-tuples of k-ary trees, i.e.T(k,m) = {(t1;.\" ,tm)l t; E T(E,Xk)} .. 1 Compositionisdefinedassubstitutionofthe projection constants and target tupling is just tupling. For reasons of space, we cannot go into more details here. More on Lawvere theories in this context and their connection to linguistics can be found in M\u00f6nnich (1998). 1 Since S is a singleton, s\u2022 can be identified with IN, because up to length each w E S' is uniquely specified. Derivarional Minimalism in Two Regular and Logical Steps A multiple context-free grammar (MCFG) is defined as a five-tup1e Q = (N, T, F, P, S) with s. T, F and P being a finite set of ranked nontenninals, tennina1s, . linear basic morphisms and productions, respectively. S E N is the start symbol. Each p E P has the form A -t f(.4a ... . , .4 11 _ 1 ) for A , .4a, ... , A11-1 E N and J E F a function from (T\u2022)k to (T*) 1 with ari ty k = Ef,;a 1 k; (k; the rank of .4;) and l thnank of .4. (cf. Seki et al. 1991) . Recallthat the basic rnorphisms are those which use only variables, constants, concatenation, composition and tupling. A regular tree grammar (RTG) is a 4-tuple 9 = (E, Fa, S, P), where E is a many-sorted signature of i11operatives and Fa a set of operatives of rank 0. S E F 0 is the starting symbol and Pis a set of productions. Each p E P has the form F -t t, with F E F 0 , and t a tenn (tree) over Eu F 0 . An application of a rule F -t t \"rewrites\" F as the tree t. Since RTG rules always just substitute some tree for a leaf-node, it is easy to see that they generate recognizable sets of trees, i.e., context-free string languages (Mezei & Wright 1967). 2 Afterthese algebraic notions, we briefly present those related to monadic second-order (MSO) logic. MSO Jogic is the extension of first-order predicate logic with monadic second-order variables and quantification over them. In particular, we are using MSO logic on trees such that individual variables x, y, ... stand for nodes in trees and monadic second-order ones X, Y, ... for sets of nodes (for more details see, e.g., Rogers 1998). Before we turn to purely logical notions, we introduce a concept which combines both automata theory and logic. We need a pa1ticular type of finite-state automaton: tree-walking automata witli MSO tests (Bloem & Engelfriet 1997) . Intuitively, those automata make transitions from nodes in a tree to other nodes along its branches. A tree-walking automaton (with tests) over \u2022some ranked alphabet E is a finite automaton Q! = (Q, .J, \u00f6, I, F) with states Q, directives .:.1, transitions o : Q x .:.J -t Q and the initial and final states J s;: Q and F s;: Q which traverses a tree along connected edges using three kinds of directives: i;-\"move up to the mother of the current node (if it has one and it is its i-th daughter)\", ,J,;-\"move to the i-th daughter of the current node (if it exists)\", and <,0(x)-\"ve1ify that ip holds at the current node\". For any tree t E T(E), such a tree-walking autornaton 2! computes a node relation Rt(2!) = {(x, y) j(x, q;) ,,;. (y, q 1 ) for some q; E I and some q 1 E F}, where for all states qk, q1 E Q and nodes x, y in t (x, qk) ==? (y, q1) iff 3d E .J : (qk, d, q 1 ) E \u00f6 and y is reachable from x in t via d. Note that x is reachable from itself if the directive was a (successful) test. It is irnportant not to confuse this relation with the walking language recognized by the automaton, i.e\" the string of directives needed to move from the initial to the final node in a walk. Bloem and Engelfriet show that these automata characterize the MSO definable node relations, i.e\" every tree-walking autornaton we specify can be inductively transfonned into an equivalent MSO fonnula and vice versa. The following paragraphs go directly back to Courcelle (1997) . Recall that the representation of objects within relational structures makes them available for the use of logical description languages. Let R be a finite set of relation symbols with the corresponding arity for each r E R given by p(r). A relational structure n = (Dn , (rn)ren.) consists of the domain Dn and the p(r)-ary relations rn. ~ D~r>, There does not seem tobe a convenient machine model for tree transfonnations. Fortunately, one can use logic directly to define the desired transduction. The classical technique of interpreting a relational structures within another one fonns the basis for MSO transductions. Intuitively, the output tree is interpreted on the input tree. E.g., suppose that we want to transduce the input tree t 1 into the output tree t 2 . The nodes of the output tree t 2 will be a subset ofthe nodes from t 1 specified with a unary MSO relation ranging over the nodes of t1. The daughter relation will be specified with a binary MSO relation with free variables x an d y rangi ng over the nodes from t 1 . We will use this concept to transform the lifted trees into the intended ones. A (non-copying) MSO transduction of a relational structure n (with set of relation symbols R) into another one Q (with set of relation symbols Q) is defined to be a tuple ( rp, ~\" (Bq )qeQ). lt consists of the formulas :p defining the domain of the transduction in n and 1/1 defining the resulting domain of Q and a family of formulas B 9 defining the new relations Q (using only definable formulas from the \"old\" structure R). In thi s sense, our description of non-contextfree phenomena with two devices with only regular power is an instance of the theorem that the image of an MSO-definable class of structures under a definable transduction is not MSO definable in general (Courcelle 1997). Translating MCFGs to RTGs Each rule of a given MCFG is recursively transf01med into a RTG rule by coding the implicit Operations of projection, tupling and compositirin :is nonterminals or terminals. This becomes possible simply by viewing the terms appearing in the rules of the MCFG as elements of a free JN x N-sorted Lawvere algebra. Tue resulting RTG then \"operates on\" this Lawvere algebra. As an example we consider the foll owing MCFG Q = (N, T , F, P, S) with .i\\T = { S, A}; T = {a 1 ,a 2 , a 3 }, F = {g,h, l} and P = {S ~ g(A),A -t h(-4),A -t !()}, where the functions g: (T*) 3 -t T*, h: (T*) 3 -t (Y-) 3 and l: (T*) 0 -t (T*) 3 are given by g(x 1 , x2, xa) = X1X2X3 h(x1, x2, X3) = (x1 ai, X2a2, X3a3) l() = (all a2, aa) The language generated by Q is {aJ'a~a~ J n > O}. Now, for 1 :::; i :::; 3 Jet 7rt denote the i-th projection which maps a 3-tuple of strings from T\u2022 to its i-th component, i.e. a 1-tuple, and Jet\u2022 denote the usual binary operation of concatenation defined for strings from T*, i.e., \u2022 maps a 2-tuple to a 1-tuple. The corresponding (Lawvere) arity of S, a 1 , a2 and a 3 is (0, 1), of A (0, 3), of \u2022 (2,1), and the one of 7r~, 7r~ and 7r~ is (3, 1). Applying the translation T given below to the MCFG Q results in the RTG 9' = ( L', Fa, S(d,l), P) with inoperatives E = (Ew,s J w E (INxJN)\u2022, s E lNxIN), operatives Fa of rank 0, and productions P which (in tree notation) look as given in Fig. l . We have L't,(3,a) = { ( )(a,a) }, Ec,(2,1) = {\u2022(2,1)}. L't,(0,1) = {al(o,1),a2(0,J) ,aa(o,1i}. L'c,(3,1) = {7rrc 3 , 1 ),7r~(3,1)\u20227r~<3,l)}, Eco,3)(3,3),(o,3) = { cca,3,3J} L'co,3)(3,1),(a,1} = { cco,3,1)} E c3,2)(2,1) ,(3,1) = { C(3,2,1)} L'(3,1)(3,1),(3,2) = {( )(3,2)} Eco,1)(0,1)(0,1),(a,3) = { ( )ca,3) } L'(3,l)(3,J)(3,1),(3,3) = { ( )(3,3) } and Fo = { 5(0,1): .4co.3)}\u2022 3 As one can see in Fig. 1 , the basic functions have been realized as tenns with tive implicit operations as nonterminal (composition and tupling) or terminal empty tupling) nodes. In the following paragraphs, we sketch the translation T from terminal mies of the example MCFG to RTG rule~. T takes each rule X ~ f (Y), where X , y E .\\\" and j E F, of the MCFG incl uding the corresponding definition of the mapping j(x 1 , \u2022\u2022\u2022\u2022 xk) with k ;::: 0 and transforms it into a RTG rule as follows. We create a mother node labeled with the appropriate binary composition C(j,k,I) such that the left daughter contains the \"lifted\" version of j(x 1 , . .\u2022 , xk) under T and the right daughter the translation of the nonterminal} \u2022. Both nonterminals X and 1' are used \u2022~unchanged\", but annotated with the corresponding Lawvere arity resulting in the following schematic presentation of the translation: X (j,IJ ~ C(j,k,IJ(T(J(x 1 , ... ,xk)), 1:(i,k)) , where f is a mapping from k-tuples to 1-tuples of terminal strings. The easiest case of translating a mapping j E F from our example via T is the terminal Arule. We simply view the mapping as a Lawvere tenn. The function l just retums a triple of a. 1 , a 2 and a. 3 \u2022 The corresponding tree has a mother node Jabeled with a ternary tupling symbol and the three unary arguments of the mapping as daughters. 4 The 5-rule is more complicated with the function g concatenating three (input) strings. The definition of the function can be written explicitly as the Lawvere term C(3, 2 ,l)(\u2022 , ( \\,,, 1 (;:-i, :.: 1 \";,:;(\u2022 ( ),_,, 2 i(r.~, ;;~))) ) . Note that the implicit binary concatenation \u2022 in g now becomes the constant \u2022c 2 ,i)\u2022 The variables are simply replaced by the projections and concatenated. The resulting term is then applied to the operative A(o, 3 ) such that we get the RHS displayed in the S(o.wrule in Fig. 1 . The recursive case of the A-rule is the most complicated. The mapping returns a trip!e, so we need a tupling \"operator\" of ap propriate arity (3, 3) as the mother node with 3 daughters. The i-th of its daughters (Jabeled with cc 3 , 2 , 1 i) is built by composing the concatenat1on constant \u2022 (2,1) with the \"tupling\"-result ( )(a, 2 ) of the corresponding projection constant r.~( 3 , 1 ) (which is substituted for the variable xi) and a particular constant tree. Namely the one which (in tenns of the underlying Lawvere algebra) simply \"lifts\" the constant ai to the Lawvere-arity of 1i[ just in order to allow for an appropriate tupling. So, the teITTJ (x 1 a 1 , x 2 a 2 , x 3 a 3 ) is interpreted as the Lawvere term ( )c 3 , 3 i ( c( \u2022 , ( ) ( 3 , 2 ) ( n~, c( a 1 , ( )c 3 ,oi)))), c( ... ), c( ... ) ) which appears as the RHS of the corresponding tree grammar rule. Since RTGs can only generate recognizable (tree) Janguages, we can characterize them with both MSO logic on trees and tree automata. 5 The tree automaton 2( 0 , is constructed by transfonning the grammar into a normal form such that each RHS is of depth one by introducing auxiliary operatives. Then we can easily construct appropriate transiti ons by basically reversing the arrow: the nonteITTJinals become state names and the mother node will be read as alphabet symbol. lt is know from Thomas (1990) how to transform this tree automaton into an MSO fonnula <p~0\u2022 by encoding its behaviour. Details for our special case can be found in Kolb et al. (2000) . Reconstructing the Intended Trees Rogers (1998) has shown the suitability of an MSO description language for linguistics which is based upon the primitive relations of immediate (<l), proper (<l+) and reflexive (<J*) dominance and proper precedence (-<). We will show how to define these relations with an MSO transduction thereby implementing the unigue homomorphism mapping the tenns into elements of the corresponding regular tree language\" At the core of the transduction is a tree-walking automaton defining the binary relation of immediate dominance ( <l) on the nodes belonging to the intended structures. lt is based on some simple observations. 6 l. Our trees feature three f\u00e4milies of labels: the \"linguistic\" symbols l, i.e., the lifted symbols of the underlying MCFG; the \"composition\" symbols C = { C(u,v,u\u2022)}; the \"tupling\" symbols ( ) (v,u) and the \"projection\" symbols n := { 7if}. 2. All nonterminal nodes in T' are Jabeled by some c E C or a \"tupling\" symbol. Note that no terminal node is labeled by some c. 3. The terminal nodes in T' are either labeled by some \" linguistic\" symbol, a \"tupling\" symbol of the form ( )(k,OJ\u2022 i.e. the \"empty\" tuple, or by some \"projection\" symbol rrf. 4. Any \"linguistic\" node dominating anything in the intended tree is on some left branch in T', i.e., it is the left daughter of some c E C and the sister of a tupling symbol whose daughters evaluate to the intended daughters. 5. For any node v labeled with some \"projection\" symbol 7rf E ll in T1 there is a unigue node \u00b5 (labeled with some c E C) which properly dominates v and which immediately dominates a node Jabeled with a \"tupling\" symbol whose i-th daughter will eventually evaluate to the value of r.f. Moreover, \u00b5 will be the first node properly dominating v which is on a left branch and bears a composition symbol. This crucial fact is arrived at by induction on the construction of Q' from Q. By 4. it is not hard to find possible dominees in any T'. lt is the problem of determining the actual \"filler\" of a candidate-dominee which makes up the complexity of the definition of <l. There are three cases to account for: 6. If the node considered carries a \"linguistic\" labe!, it evaluates to itself; 7. if it has a \"composition\" labe! c, it evaluates to whatever its leftmost daughter evaluates to; 8. if it canies a \"projection\" label rrf\u2022, it evaluates to whatever the node it \"points to\"-by (5.) the ith daughter of a \"tupling\" node which is dominated by the first C-node on a left branch dominating it~valuates to. According to the observations made above, the automaton given in Fig. 2 Starts on any node with a \"linguistic\" labe] (denoted here by l) which means for the given example \u2022 , a 1 , a 2 , a 3 . Then it has to go up the first branch, read a composition symbol and descend to its sister. If it reads a \"linguistic\" node, the automaton stops. lf it reads a composition symbol, the automaton goes to the left daughter and tries again. If it reads a tupling symbol, the automaton proceeds with its daughters. On finding a projection symbol, it searches for the appropriate \"filler\" by going upwards until it is on a leftmost branch which is labeled with a composition symbol. Then it walks to the second sister or further down the Jeftmost branch until it hits a tupling node to whose appropriate daughter it descends to find the filler. However, there is another interpretation of such an automaton. Viewed as an ordinary finitestate automaton over the alphabet L1, 2(., recognizes a regular (string-) Janguage, the walking language W which can be translated recursively into an MSO fonnula transw. defining the relation <l (see Bloem & Engelfriet 1997) . We leave the rather tedi ous process of converting the walking Janguage for the automaton given in Fig. 2 to the reader (a f\u00fcll example of such a conversion can be found in Kolb et a1. (2000) ). As desired, the domain of the transduction is characterized by the MSO formula <p21 0 , for the lifted trees. The domain, i.e\" the set of nodes, of the intended tree is characterized by the formula 1jJ which identifies the nodes with a \"linguistic\" labe! which stand indeed in ~he new dominance relation to some other node. Building on it, we define the other primitives of a tree description Janguage suited to Jinguistic needs. For reasons of space, we have to Jeave the specification of the precedence relation open. It is more complicated than dominance, but can be achieved with another tree-walking automaton. Derivacional Minimalism in Two Regular and Logical Steps Conclusion \u2022 Taking the result of Michaelis' translation of MGs as the input we have shown how to define a RTG by lifting the corresponding MCFG-rules by viewing them as tenns of a free L awvere theory. This gives us both a regular (via tree and tree-walking automata) and a Jogical characterization (via MSO Iogic and an MSO definable transduction) of the intended syntactic trees. Equivalently, we provide both an operational and a denotational account of Stabler's version of Minimalism without having to go via derivation trees. lt remains to be seen whether one can find a machine model for the entire MSO transduction. A likely candidate are the macro tree transducers (MIT) introduced in Engelfriet & Maneth (1999) . Since they characterize the class of MSO definable tree translations if extended with regular look-ahead and restricted to finite-copying, we are quite optimistic that we will be able to use them to efficiently implement the transduction. This would also characterize the class of languages we can handle. Engelfriet and Maneth show that the result of applying an MIT to a regular tree family yields the tree languages generated by context-free graph grammars.",
    "abstract": "II rhis paper we extend rhe work by Michaelis (1999) which slwws how ro encode an arbirra1}' Minimalisr Grammar in the sense of Stab/er ( 1997)  illto a weakly equivalem mulriple contextfree grammar (MCFG). By viewing MCFG rules as tenns in a free Lawvere the01y we can translate a give11 MCFG into a regular tree grammar. The latter is characteri:able by both a tree automaton and a correspondingfonnu/a in monadic second-order (MSO) logic. The trees of the res11/ti11g regular tree language are then unpacked into the intended \"linguistic\" trees witlz an MSO rra11sducrio11 based upon tree-walking automata. Tlzis rwo-step approacl1 gives an operarional as well as a Jogi ca/ descriprinn nf the tree sets involved.",
    "countries": [
        "Germany"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "11",
    "year": "2000",
    "month": "May",
    "title": "Derivational minimalism in two regular and logical steps"
}