{
    "article": "A human annotator can provide hints to a machine learner by highlighting contextual \"rationales\" for each of his or her annotations (Zaidan et al., 2007). How can one exploit this side information to better learn the desired parameters \u03b8? We present a generative model of how a given annotator, knowing the true \u03b8, stochastically chooses rationales. Thus, observing the rationales helps us infer the true \u03b8. We collect substring rationales for a sentiment classification task (Pang and Lee, 2004) and use them to obtain significant accuracy improvements for each annotator. Our new generative approach exploits the rationales more effectively than our previous \"masking SVM\" approach. It is also more principled, and could be adapted to help learn other kinds of probabilistic classifiers for quite different tasks. Background Many recent papers aim to reduce the amount of annotated data needed to train the parameters of a statistical model. Well-known paradigms include active learning, semi-supervised learning, and either domain adaptation or cross-lingual transfer from existing annotated data. A rather different paradigm is to change the actual task that is given to annotators, giving them a greater hand in shaping the learned classifier. After all, human annotators themselves are more than just black-box classifiers to be run on training data. They possess some introspective knowledge about their own classification procedure. The hope is to mine this knowledge rapidly via appropriate questions and use it to help train a machine classifier. How to do this, however, is still being explored. Hand-crafted rules An obvious option is to have the annotators directly express their knowledge by hand-crafting rules. This approach remains \"data-driven\" if the annotators repeatedly refine their system against a corpus of labeled or unlabeled examples. This achieves high performance in some domains, such as NP chunking (Brill and Ngai, 1999), but requires more analytical skill from the annotators. One empirical study (Ngai and Yarowsky, 2000) found that it also required more annotation time than active learning. Feature selection by humans More recent work has focused on statistical classifiers. Training such classifiers faces the \"credit assignment problem.\" Given a training example x with many features, which features are responsible for its annotated class y? It may take many training examples to distinguish useful vs. irrelevant features. 1 To reduce the number of training examples needed, one can ask annotators to examine or propose some candidate features. This is possible even for the very large feature sets that are typically used in NLP. In document classification, Raghavan et al.  (2006) show that feature selection by an oracle could be helpful, and that humans are both rapid and reasonably good at distinguishing highly useful n-gram features from randomly chosen ones, even when viewing these n-grams out of context. Druck et al. (2008) show annotators some features f from a fixed feature set, and ask them to choose a class label y such that p(y | f ) is as high as possible. Haghighi and Klein (2006) do the reverse: for each class label y, they ask the annotators to propose a few \"prototypical\" features f such that p(y | f ) is as high as possible. Feature selection in context The above methods consider features out of context. An annotator might have an easier time examining features in context to recognize whether they appear relevant. This is particularly true for features that are only modestly or only sometimes helpful, which may be abundant in NLP tasks. Thus, Raghavan et al. (2006) propose an active learning method in which, while classifying a training document, the annotator also identifies some features of that document as particularly relevant. E.g., the annotator might highlight particular unigrams as he or she reads the document. In their proposal, a feature that is highlighted in any document is assumed to be globally more relevant. Its dimension in feature space is scaled by a factor of 10 so that this feature has more influence on distances or inner products, and hence on the learned classifier. Concerns about marking features Despite the success of the above work, we have several concerns about asking annotators to identify globally relevant features. First, a feature in isolation really does not have a well-defined worth. A feature may be useful only in conjunction with other features, 2 or be useful only to the extent that other correlated features are not selected to do the same work. Second, it is not clear how an annotator would easily view and highlight features in context, except for the simplest feature sets. In the phrase Apple shares up 3%, there may be several features that fire on the substring Apple-responding to the string Apple, its case-invariant form apple, its lemma apple-(which would also respond to apples), its context-dependent sense Apple 2 , its part of speech noun, etc. How does the annotator indicate which of these features are relevant? Third, annotating features is only appropriate when the feature set can be easily understood by a human. This is not always the case. It would be hard for annotators to read, write, or evaluate a description of a complex syntactic configuration in NLP or a convolution filter in machine vision. Fourth, traditional annotation efforts usually try to remain agnostic about the machine learning methods and features to be used. The project's cost is justified by saying that the annotations will be reused by many researchers (perhaps in a \"shared task\"), who are free to compete on how they tackle the learning problem. Unfortunately, feature annotation commits to a particular feature set at annotation time. Subsequent research cannot easily adjust the definition of the features, or obtain annotation of new features. Annotating Rationales To solve these problems, we propose that annotators should not select features but rather mark relevant portions of the example. In earlier work (Zaidan et  al., 2007), we called these markings \"rationales.\" For example, when classifying a movie review as positive or negative, the annotator would also highlight phrases that supported that judgment. Figure 1 shows two such rationales. A multi-annotator timing study (Zaidan et al.,  2007) found that highlighting rationale phrases while reading movie reviews only doubled annotation time, although annotators marked 5-11 rationale substrings in addition to the simple binary class. The benefit justified the extra time. Furthermore, much of the benefit could have been obtained by giving rationales for only a fraction of the reviews. In the visual domain, when classifying an image as containing a zoo, the annotator might circle some animals or cages and the sign reading \"Zoo.\" The Peekaboom game (von Ahn et al., 2006) was in fact built to elicit such approximate yet relevant regions of images. Further scenarios were discussed in (Zaidan et al., 2007): rationale annotation for named entities, linguistic relations, or handwritten digits. Annotating rationales does not require the annotator to think about the feature space, nor even to know anything about it. Arguably this makes annotation easier and more flexible. It also preserves the reusability of the annotated data. Anyone is free to reuse our collected rationales (section 4) to aid in learning a classifier with richer features, or a different kind of classifier altogether, using either our procedures or novel procedures. We wish to learn the parameters \u03b8 of some classifier. How can the annotator's rationales help us to do this without many training examples? We will have to exploit a presumed relationship between the rationales and the optimal value of \u03b8 (i.e., the value that we would learn on an infinite training set). This paper exploits an explicit, parametric model of that relationship. The model's parameters \u03c6 are intended to capture what that annotator is doing when he or she marks rationales. Most importantly, they capture how he or she is influenced by the true \u03b8. Given this, our learning method will prefer values of \u03b8 that would adequately explain the rationales (as well as the training classifications). A generative approach For concreteness, we will assume that the task is document classification. Our training data consists of n triples {(x 1 , y 1 , r 1 ), ..., (x n , y n , r n )}), where x i is a document, y i is its annotated class, and r i is its rationale markup. At test time we will have to predict y n+1 from x n+1 , without any r n+1 . We propose to jointly choose parameter vectors \u03b8 and \u03c6 to maximize the following regularized conditional likelihood: 3 n i=1 p(y i , r i | x i , \u03b8, \u03c6) \u2022 p prior (\u03b8, \u03c6) (1) def = n i=1 p \u03b8 (y i | x i ) \u2022 p \u03c6 (r i | x i , y i , \u03b8) \u2022 p prior (\u03b8, \u03c6) Here we are trying to model all the annotations, both y i and r i . The first factor predicts y i using an ordinary probabilistic classifier p \u03b8 , while the novel second factor predicts r i using a model p \u03c6 of how annotators generate the rationale annotations. The crucial point is that the second factor depends on \u03b8 (since r i is supposed to reflect the relation between x i and y i that is modeled by \u03b8). As a result, the learner has an incentive to modify \u03b8 in a way that increases the second factor, even if this somewhat decreases the first factor on training data. 4 After training, one should simply use the first factor p \u03b8 (y | x) to classify test documents x. The second factor is irrelevant for test documents, since they have not been annotated with rationales r. The second factor may likewise be omitted for any training documents i that have not been annotated with rationales, as there is no r i to predict in those cases. In the extreme case where no documents are annotated with rationales, equation (1) reduces to the standard training procedure. Noisy channel design of rationale models Like ordinary class annotations, rationale annotations present us with a \"credit assignment problem,\" albeit a smaller one that is limited to features that fire \"in the vicinity\" of the rationale r. Some of these \u03b8-features were likely responsible for the classification y and hence triggered the rationale. Other such \u03b8-features were just innocent bystanders. Thus, the interesting part of our model is p \u03c6 (r | x, y, \u03b8), which models the rationale annotation process. The rationales r reflect \u03b8, but in noisy ways. Taking this noisy channel idea seriously, p \u03c6 (r | x, y, \u03b8) should consider two questions when assessing whether r is a plausible set of rationales given \u03b8. First, it needs a \"language model\" of rationales: does r consist of rationales that are well-formed a priori, i.e., before \u03b8 is considered? Second, it needs a \"channel model\": does r faithfully signal the features of \u03b8 that strongly support classifying x as y? If a feature contributes heavily to the classification of document x as class y, then the channel model should tell us which parts of document x tend to be highlighted as a result. The channel model must know about the particular kinds of features that are extracted by f and scored by \u03b8. Suppose the feature not . . . gripping, 5 with weight \u03b8 h , is predictive of the annotated class y. This raises the probabilities of the annotator's highlighting each of various words, or combinations of words, in a phrase like not the most gripping banquet on film. The channel model parameters in \u03c6 tive review-but the second factor still allows learning positive features from the first annotator's positive rationales, and negative features from the second annotator's negative rationales. 5 Our current experiments use only unigram features, to match past work, but we use this example to outline how our approach generalizes to complex linguistic (or visual) features. should specify how much each of these probabilities is raised, based on the magnitude of \u03b8 h \u2208 R, the class y, and the fact that the feature is an instance of the template <Neg> . . . <Adjective>. (Thus, \u03c6 has no parameters specific to the word gripping; it is a low-dimensional vector that only describes the annotator's general style in translating \u03b8 into r.) The language model, however, is independent of the feature set \u03b8. It models what rationales tend to look like in the input domain-e.g., documents or images. In the document case, \u03c6 should describe: How frequent and how long are typical rationales? Do their edges tend to align with punctuation or major syntactic boundaries in x? Are they rarer in the middle of a document, or in certain documents? 6 Thanks to the language model, we do not need to posit high \u03b8 features to explain every word in a rationale. The language model can \"explain away\" some words as having been highlighted only because this annotator prefers not to end a rationale in midphrase, or prefers to sweep up close-together features with a single long rationale rather than many short ones. Similarly, the language model can help explain why some words, though important, might not have been included in any rationale of r. If there are multiple annotators, one can learn different \u03c6 parameters for each annotator, reflecting their different annotation styles. 7 We found this to be useful (section 8.2). We remark that our generative modeling approach (equation ( 1 )) would also apply if r were not rationale markup, but some other kind of so-called \"side information,\" such as the feature annotations discussed in section 1. For example, Raghavan et al.  (2006) assume that if feature h is relevant-a bi-6 Our current experiments do not model this last point. However, we imagine that if the document only has a few \u03b8-features that support the classification, the annotator will probably mark most of them, whereas if such features are abundant, the annotator may lazily mark only a few of the strongest ones. A simple approach would equip \u03c6 with a different \"bias\" or \"threshold\" parameter \u03c6x for each rationale training document x, to modulate the a priori probability of marking a rationale in x. By fitting this bias parameter, we deduce how lazy the annotator was (for whatever reason) on document x. If desired, a prior on \u03c6x could consider whether x has many strong \u03b8-features, whether the annotator has recently had a coffee break, etc. 7 Given insufficient rationale data to recover some annotator's \u03c6 well, one could smooth using data from other annotators. But in our situation, \u03c6 had relatively few parameters to learn. nary distinction-iff it was selected in at least one document. But it might be more informative to observe that h was selected in 3 of the 10 documents where it appeared, and to predict this via a model p \u03c6 (3 of 10 | \u03b8 h ), where \u03c6 describes (e.g.) how to derive a binomial parameter nonlinearly from \u03b8 h . This approach would not how often h was marked and infer how relevant is feature h (i.e., infer \u03b8 h ). In this case, p \u03c6 is a simple channel that transforms relevant features into direct indicators of the feature. Our side information merely requires a more complex transformation-from relevant features into wellformed rationales, modulated by documents. Experimental Data: Movie Reviews In Zaidan et al. (2007), we introduced the \"Movie Review Polarity Dataset Enriched with Annotator Rationales.\" 8 It is based on the dataset of Pang and  Lee (2004), 9 which consists of 1000 positive and 1000 negative movie reviews, tokenized and divided into 10 folds (F 0 -F 9 ). All our experiments use F 9 as their final blind test set. The enriched dataset adds rationale annotations produced by an annotator A0, who annotated folds F 0 -F 8 of the movie review set with rationales (in the form of textual substrings) that supported the goldstandard classifications. We will use A0's data to determine the improvement of our method over a (log-linear) baseline model without rationales. We also use A0 to compare against the \"masking SVM\" method and SVM baseline of Zaidan et al. (2007). Since \u03c6 can be tuned to a particular annotator, we would also like to know how well this works with data from annotators other than A0. We randomly selected 100 reviews (50 positive and 50 negative) and collected both class and rationale annotation data from each of six new annotators A3-A8, 10 following the same procedures as (Zaidan et al., 2007). We report results using only data from A3-A5, since we used the data from A6-A8 as development data in the early stages of our work. We use this new rationale-enriched dataset 8 to determine if our method works well across annotators. We will only be able to carry out that comparison We define the basic classifier p \u03b8 in equation ( 1 ) to be a standard conditional log-linear model: p \u03b8 (y | x) def = exp( \u03b8 \u2022 f (x, y)) Z \u03b8 (x) def = u(x, y) Z \u03b8 (x) (2) where f (\u2022) extracts a feature vector from a classified document, \u03b8 are the corresponding weights of those features, and Z \u03b8 (x) def = y u(x, y) is a normalizer. We use the same set of binary features as in previous work on this dataset (Pang et al., 2002; Pang  and Lee, 2004; Zaidan et al., 2007). Specifically, let V = {v 1 , ..., v 17744 } be the set of word types with count \u2265 4 in the full 2000-document corpus. Define f h (x, y) to be y if v h appears at least once in x, and 0 otherwise. Thus \u03b8 \u2208 R 17744 , and positive weights in \u03b8 favor class label y = +1 and equally discourage y = \u22121, while negative weights do the opposite. This standard unigram feature set is linguistically impoverished, but serves as a good starting point for studying rationales. Future work should consider more complex features and how they are signaled by rationales, as discussed in section 3.2. Modeling rationale annotations with p \u03c6 The rationales collected in this task are textual segments of a document to be classified. The document itself is a word token sequence x = x 1 , ..., x M . We encode its rationales as a corresponding tag sequence r = r 1 , ..., r M , as illustrated in Figure 1 . Here r m \u2208 {I, O} according to whether the token x m is in a rationale (i.e., x m was at least partly highlighted) or outside all rationales. x 1 and x M are special boundary symbols, tagged with O. We predict the full tag sequence r at once using a conditional random field (Lafferty et al., 2001). A CRF is just another conditional log-linear model: p \u03c6 (r | x, y, \u03b8) def = exp( \u03c6 \u2022 g(r, x, y, \u03b8)) Z \u03c6 (x, y, \u03b8) def = u(r, x, y, \u03b8) Z \u03c6 (x, y, \u03b8) where g(\u2022) extracts a feature vector, \u03c6 are the corresponding weights of those features, and Z \u03c6 (x, y, \u03b8) def = r u(r, x, y, \u03b8) is a normalizer. As usual for linear-chain CRFs, g(\u2022) extracts two kinds of features: first-order \"emission\" features that relate r m to (x m , y, \u03b8), and second-order \"transition\" features that relate r m to r m\u22121 (although some of these also look at x). These two kinds of features respectively capture the \"channel model\" and \"language model\" of section 3.2. The former says r m is I because x m is associated with a relevant \u03b8-feature. The latter says r m is I simply because it is next to another I. Emission \u03c6-features (\"channel model\") Recall that our \u03b8-features (at present) correspond to unigrams. Given ( x, y, \u03b8), let us say that a unigram w \u2208 x is relevant, irrelevant, or anti-relevant if y \u2022 \u03b8 w is respectively 0, \u2248 0, or 0. That is, w is relevant if its presence in x strongly supports the annotated class y, and anti-relevant if its presence strongly supports the opposite class \u2212y. We would like to learn the extent \u03c6 rel to which annotators try to include relevant unigrams in their rationales, and the (usually lesser) extent \u03c6 antirel to which they try to exclude anti-relevant unigrams. This will help us infer \u03b8 from the rationales. The details are as follows. \u03c6 rel and \u03c6 antirel are the weights of two emission features extracted by g: How does this work? The g rel feature is a sum over all unigrams in the document x. It does not fire strongly on the irrelevant or anti-relevant unigrams, since B 10 is close to zero there. 11 But it fires positively on relevant unigrams w if they are tagged with I, and the strength of such firing increases approximately linearly with \u03b8 w . Since the weight \u03c6 rel > 0 in practice, this means that raising a relevant unigram's \u03b8 w (if y = +1) will proportionately raise its logodds of being tagged with I. Symmetrically, since \u03c6 antirel > 0 in practice, lowering an anti-relevant unigram's \u03b8 w (if y = +1) will proportionately lower its log-odds of being tagged with I, though not necessarily at the same rate as for relevant unigrams. 12 Should \u03c6 also include traditional CRF emission features, which would recognize that particular words like great tend to be tagged as I? No! Such features would undoubtedly do a better job predicting the rationales and hence increasing equation (1). However, crucially, our true goal is not to predict the rationales but to recover the classifier parameters \u03b8. Thus, if great tends to be highlighted, then the model should not be permitted to explain this directly by increasing some feature \u03c6 great , but only indirectly by increasing \u03b8 great . We therefore permit our rationale prediction model to consider only the two emission features g rel and g antirel , which see the words in x only through their \u03b8-values. Transition \u03c6-features (\"language model\") Annotators highlight more than just the relevant unigrams. (After all, they aren't told that our current \u03b8-features are unigrams.) They tend to mark full phrases, though perhaps taking care to exclude antirelevant portions. \u03c6 models these phrases' shape, via weights for several \"language model\" features. Most important are the 4 traditional CRF tag transition features g O-O , g O-I , g I-I , g I-O . For example, g O-I counts the number of O-to-I transitions in r (see Figure 1 ). Other things equal, an annotator with high \u03c6 O-I is predicted to have many rationales per 1000 words. And if \u03c6 I-I is high, rationales are predicted to be long phrases (including more irrelevant unigrams around or between the relevant ones). We also learn more refined versions of these features, which consider how the transition probabilities are influenced by the punctuation and syntax of the document x (independent of \u03b8). These refined features are more specific and hence more sparsely trained. Their weights reflect deviations from the simpler, \"backed-off\" transition features such as g O-I . (Again, see Figure 1 for examples.) Conditioning on left word. A feature of the form g t 1 (v)-t 2 is specified by a pair of tag types t 1 , t 2 \u2208 {I, O} and a vocabulary word type v. It counts the number of times an t 1 -t 2 transition occurs in r conditioned on v appearing as the first of the two word tokens where the transition occurs. Our experiments include g t 1 (v)-t 2 features that tie I-O and O-I transitions to the 4 most frequent punctuation marks v (comma, period, ?, !). Conditioning on right word. A feature g t 1 -t 2 (v) is similar, but v must appear as the second of the two word tokens where the transition occurs. Again here, we use g t 1 -t 2 (v) features that tie I-O and O-I transitions to the four punctuation marks mentioned above. We also include five features that tie O-I transitions to the words no, not, so, very, and quite, since in our development data, those words were more likely than others to start rationales. 13 Conditioning on syntactic boundary. We parsed each rationale-annotated training document (no parsing is needed at test time). 14 We then marked each word bigram x 1 -x 2 with three nonterminals: N End is the nonterminal of the largest constituent that contains x 1 and not x 2 , N Start is the nonterminal of the largest constituent that contains x 2 and not x 1 , and N Cross is the nonterminal of the smallest constituent that contains both x 1 and x 2 . For a nonterminal N and pair of tag types (t 1 , t 2 ), we define three features, g t 1 -t 2 /E=N , g t 1 -t 2 /S=N , and g t 1 -t 2 /C=N , which count the number of times a t 1 -t 2 transition occurs in r with N matching the N End , N Start , or N Cross nonterminal, respectively. Our experiments include these features for 11 common nonterminal types N (DOC, TOP, S, SBAR, FRAG, PRN, NP, VP, PP, ADJP, QP). Training: Joint Optimization of \u03b8 and \u03c6 To train our model, we use L-BFGS to locally maximize the log of the objective function (1): 15 13 These are the function words with count \u2265 40 in a random sample of 100 documents, and which were associated with the O-I tag transition at more than twice the average rate. We do not use any other lexical \u03c6-features that reference x, for fear that they would enable the learner to explain the rationales without changing \u03b8 as desired (see the end of section 5.3). 14 We parse each sentence with the Collins parser (Collins,  1999). Then the document has one big parse tree, whose root is DOC, with each sentence being a child of DOC. 15 One might expect this function to be convex because p \u03b8 and p \u03c6 are both log-linear models with no hidden variables. However, log p \u03c6 (ri | xi, yi, \u03b8) is not necessarily convex in \u03b8. n i=1 log p \u03b8 (y i | x i ) \u2212 1 2\u03c3 2 \u03b8 \u03b8 2 +C( n i=1 log p \u03c6 (r i | x i , y i , \u03b8)) \u2212 1 2\u03c3 2 \u03c6 \u03c6 2 (4) This defines p prior from (1) to be a standard diagonal Gaussian prior, with variances \u03c3 2 \u03b8 and \u03c3 2 \u03c6 for the two sets of parameters. We optimize \u03c3 2 \u03b8 in our experiments. As for \u03c3 2 \u03c6 , different values did not affect the results, since we have a large number of {I,O} rationale tags to train relatively few \u03c6 weights; so we simply use \u03c3 2 \u03c6 = 1 in all of our experiments. Note the new C factor in equation ( 4 ). Our initial experiments showed that optimizing equation ( 4 ) without C led to an increase in the likelihood of the rationale data at the expense of classification accuracy, which degraded noticeably. This is because the second sum in (4) has a much larger magnitude than the first: in a set of 100 documents, it predicts around 74,000 binary {I,O} tags, versus the one hundred binary class labels. While we are willing to reduce the log-likelihood of the training classifications (the first sum) to a certain extent, focusing too much on modeling rationales (the second sum) is clearly not our ultimate goal, and so we optimize C on development data to achieve some balance between the two terms of equation ( 4 ). Typical values of C range from 1 300 to 1 50 . 16 We perform alternating optimization on \u03b8 and \u03c6: 1. Initialize \u03b8 to maximize equation (4) but with C = 0 (i.e. based only on class data). 2. Fix \u03b8, and find \u03c6 that maximizes equation (4). 3. Fix \u03c6, and find \u03b8 that maximizes equation (4). 4. Repeat 2 and 3 until convergence. The L-BFGS method requires calculating the gradient of the objective function (4). The partial derivatives with respect to components of \u03b8 and \u03c6 involve calculating expectations of the feature functions, which can be computed in linear time (with respect to the size of the training set) using the forward-backward algorithm for CRFs. The partial derivatives also involve the derivative of (3), to determine how changing \u03b8 will affect the firing strength of the emission features g rel and g antirel . Experimental Procedures We report on two sets of experiments. In the first set, we use the annotation data that A3-A5 provided for the small set of 100 documents (as well as the data from A0 on those same 100 documents). In the second set, we used A0's abundant annotation data to evaluate our method with training set sizes up to 1600 documents, and compare it with three other methods: log-linear baseline, SVM baseline, and the SVM masking method of (Zaidan et al., 2007). Learning curves The learning curves reported in section 8.1 are generated exactly as in (Zaidan et al., 2007). Each curve shows classification accuracy at training set sizes T = 1, 2, ..., 9 folds (i.e. 200, 400, ..., 1600 training documents). For a given size T , the reported accuracy is an average of 9 experiments with different subsets of the entire training set, each of size T : 1 9 8 i=0 acc(F 9 | F i+1 \u222a . . . \u222a F i+T ) (5) where F j denotes the fold numbered j mod 9, and acc(F 9 | Y ) means classification accuracy on the held-out test set F 9 after training on set Y . We use an appropriate paired permutation test, detailed in (Zaidan et al., 2007), to test differences in (5). We call a difference significant at p < 0.05. Comparison to \"masking SVM\" method We compare our method to the \"masking SVM\" method of (Zaidan et al., 2007). Briefly, that method used rationales to construct several so-called contrast examples from every training example. A contrast example is obtained by \"masking out\" one of the rationales highlighted to support the training example's class. A good classifier should have more trouble on this modified example. Hence, Zaidan et  al. (2007) required the learned SVM to classify each contrast example with a smaller margin than the corresponding original example (and did not require it to be classified correctly). The masking SVM learner relies on a simple geometric principle; is trivial to implement on top of an existing SVM learner; and works well. However, we believe that the generative method we present here is more interesting and should apply more broadly. First, the masking method is specific to improving an SVM learner, whereas our method can be used to improve any classifier by adding a rationale-based regularizer (the second half of equation ( 4 )) to its objective function during training. More important, there are tasks where it is unclear how to generate contrast examples. For the movie review task, it was natural to mask out a rationale by pretending its words never occurred in the document. After all, most word types do not appear in most documents, so it is natural to consider the nonpresence of a word as a \"default\" state to which we can revert. But in an image classification task, how should one modify the image's features to ignore some spatial region marked as a rationale? There is usually no natural \"default\" value to which we could set the pixels. Our method, on the other hand, eliminates contrast examples altogether. 8 Experimental Results and Analysis 8.1 The added benefit of rationales Fig. 3 shows learning curves for four methods. A log-linear model shows large and significant improvements, at all training sizes, when we incorporate rationales into its training via equation (4). Moreover, the resulting classifier consistently outperforms 17 prior work, the masking SVM, which starts with a slightly better baseline classifier (an SVM) but incorporates the rationales more crudely. Table 1 : Accuracy rates using each annotator's data. In a given column, a value in italics is not significantly different from the highest value in that column, which is boldfaced. The size=20 results average over 5 experiments. To confirm that we could successfully model annotators other than A0, we performed the same comparison for annotators A3-A5; each had provided class and rationale annotations on a small 100document training set. We trained a separate \u03c6 for each annotator. Table 1 shows improvements over baseline, usually significant, at 2 training set sizes. Analysis Examining the learned weights \u03c6 gives insight into annotator behavior. High weights include I-O and O-I transitions conditioned on punctuation, e.g., \u03c6 I(.)-O = 3.55, 18 as well as rationales ending at the end of a major phrase, e.g., \u03c6 I-O/E=VP = 1.88. The large emission feature weights, e.g., \u03c6 rel = 14.68 and \u03c6 antirel = 15.30, tie rationales closely to \u03b8 values, as hoped. For example, in Figure 1 , the word w = succeeds, with \u03b8 w = 0.13, drives up p(I)/p(O) by a factor of 7 (in a positive document) relative to a word with \u03b8 w = 0. In fact, feature ablation experiments showed that almost all the classification benefit from rationales can be obtained by using only these 2 emission \u03c6-features and the 4 unconditioned transition \u03c6features. Our full \u03c6 (115 features) merely improves our ability to predict the rationales (whose likelihood does increase significantly with more features). We also checked that annotators' styles differ enough that it helps to tune \u03c6 to the \"target\" annotator A who gave the rationales. Table 3 shows that a \u03c6 model trained on A's own rationales does best at predicting new rationales from A. Table 2 shows that as 2 : Accuracy rate for an annotator's \u03b8 (rows) obtained when using some other annotator's \u03c6 (columns). Notice that the diagonal entries and the baseline column are taken from rows of Table 1 (size=100 3 : Cross-entropy per tag of rationale annotations r for each annotator (rows), when predicted from that annotator's x and \u03b8 via a possibly different annotator's \u03c6 (columns). For comparison, the trivial model is a bigram model of r, which is trained on the target annotator but ignores x and \u03b8. 5-fold cross-validation on the 100document set was used to prevent testing on training data. a result, classification performance on the test set is usually best if it was A's own \u03c6 that was used to help learn \u03b8 from A's rationales. In both cases, however, a different annotator's \u03c6 is better than nothing. Conclusions We have demonstrated a effective method for eliciting extra knowledge from naive annotators, in the form of lightweight \"rationales\" for their annotations. By explicitly modeling the annotator's rationale-marking process, we are able to infer a better model of the original annotations. We showed that our method performs significantly better than two strong baseline classifiers, and also outperforms our previous discriminative method for exploiting rationales (Zaidan et al.,  2007). We also saw that it worked across four annotators who have different rationale-marking styles. In future, we are interested in new domains that can adaptively solicit rationales for some or all training examples. Our new method, being essentially Bayesian inference, is potentially extensible to many other situations-other tasks, classifier architectures, and more complex features.",
    "abstract": "A human annotator can provide hints to a machine learner by highlighting contextual \"rationales\" for each of his or her annotations (Zaidan et al., 2007). How can one exploit this side information to better learn the desired parameters \u03b8? We present a generative model of how a given annotator, knowing the true \u03b8, stochastically chooses rationales. Thus, observing the rationales helps us infer the true \u03b8. We collect substring rationales for a sentiment classification task (Pang and Lee, 2004) and use them to obtain significant accuracy improvements for each annotator. Our new generative approach exploits the rationales more effectively than our previous \"masking SVM\" approach. It is also more principled, and could be adapted to help learn other kinds of probabilistic classifiers for quite different tasks.",
    "countries": [
        "United States"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "122",
    "year": "2008",
    "month": "October",
    "title": "Modeling Annotators: {A} Generative Approach to Learning from Annotator Rationales"
}