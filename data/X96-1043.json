{
    "article": "The TIPSTER Program aims to push the technology for access to information in large (multi-GB) text collections, in particular for the analysts in Government agencies. Technology is being developed for document detection (\"information retrieval\") and for data extraction from free text. The primary mission of the TIPSTER Common Architecture is to provide a vehicle for efficiently delivering this detection and extraction technology to the Government agencies. The Architecture also has a secondary mission of providing a convenient and efficient environment for research in document detection and data extraction. To accomplish this mission, the TIPSTER Architecture is being designed to: \u2022 provide APIs for document detection, data extraction, and the associated document management functions \u2022 support monolingual and multilingual applications \u2022 allow the interchange of modules from different suppliers (\"plug and play\") \u2022 apply to a wide range of software and hardware environments \u2022 scale to a wide range of volumes of document archives and of document flow \u2022 support appropriate application response time \u2022 support incorporation of multi-level security \u2022 enhance detection and extraction through the exchange of information, and through easier access to linguistic annotations CONCEPTS The architecture is described by a set of object classes and a set of functions associated with these objects. In addition, there is a \"functional\" section which indicates how data typically flows between these functions. Object Classes An object class is characterized by a class name, a set of named properties, and a set of operations. Unless explicitly noted otherwise, there is an operation (the property accessor function) associated with each property for reading that property's value. If the property is followed by (R, W), operations are provided both for reading and for writing that property. If the property is followed by (g), no functions are provided for reading or writing the property. Each property has a value, which may be \u2022 an object (of one or several classes) \u2022 a sequence of objects (ordered), denoted by \"sequence of...\" \u2022 a string (of characters) \u2022 an integer \u2022 a byte \u2022 a Boolean value (true or false) \u2022 a member of an enumerated type, denoted by \"one of { ... }\" \u2022 nil The operations will include both procedures (which do not return a value) and functions (which do). The notation is procedure (type of argl, type of arg2 .. The designation of a class as an Abstract Class indicates that the class is not intended to be instantiated but is intended to serve as a superclass for other classes (which will be instantiated). A class C can include operations whose name has the form \"class.C\". If D is a type of C (i.e., class D includes the specification Type of C), then the operation as inherited by D has the name \"class.D\". This facility is provided to allow for the specialization of operations which create new instances of a class. 2.20ptionality Some objects and functions will be required: they must be implemented by any system conforming to the architecture. Some objects and functions will be optional: they need not be included, but if they are, they must conform to the standard. This allows us to define standards, for example, for some linguistic annotations, without requiring all systems to generate such annotations. Correspondence to Interface Specifications This document provides an abstract definition of the architecture in terms of classes and operations. This architecture will be implemented in a number of programming languages; currently implementations are being developed in C, Tcl, and Common Lisp. This section describes the correspondence between the set of operations described in this document and the APIs for implementations of this architecture in these programming languages. Common Lisp: The classes, properties, and operations defined herein correspond to those of a Common Lisp implementation of the TIPSTER Architecture as follows: 1. (because Lisp is normally not case sensitive) each capital letter in the name of a class, property, or operation, except for the first letter in a name, will be preceded by a \"-\" in Lisp 2. each class, property, and operation corresponds to a Lisp class, property, and function 3. each argument of the form \"class\" becomes a positional argument; each argument of the form \"name: class\" becomes a keyword argument with the keyword name 4. sequences are represented as lists In Lisp, the name of the property accessor function is formed from the class name, a hyphen, and the property name (e.g., attribute-name and attribute-value). If the property is writable, the property accessor function acts as a \"generalized variable\" which can be set by serf; e.g., (serf (collection-owner collectionl) \"Mitchell\"). C: Each operation defined herein corresponds to a C function, with the same name as in the abstract architecture. All arguments in the C implementation are positional; the argument names (\"keywords\") in the abstract architecture are not used. If property Comp of a class is readable, it is accessed by the function Get Comp; if it is also writeable, it is set by the function Set Comp. Note that the abstract architecture occasionally \"overloads\" operations: the same operation name may apply to different classes of arguments. To support such overloading, the C implementations of the various classes, as well as sets and sequences, should employ a generic container structure which will allow a C function to determine the class of an actual argument. 1 The C-language typing, including the overloading of various functions, is spelled out in Appendix C. Tci: Operation names and argument lists in Tcl shall be the same as in the C implementation. Optional Arguments In addition to the arguments which are specified for each operation in this document and which are required, an implementation of the Architecture may provide optional keyword or positional arguments for any of the operations. The operation must be able to complete and to perform the specified function even if only the required arguments are given, but use of the optional arguments may provide enhanced performance or a greater range of functionality. Implementation of Sequences The architecture includes the notion 'sequence of X', where X is a type, as one of the possible values of an argument to an operation or the value of a property. In describing an implementation of the Architecture (an API), it is necessary to specify the representation or set of operations for such sequences. The C language interface (Appendix C) defines types AttributeSet, AttributeValueSet, DocumentCollectionlndexSet, QueryCollectionlndex, SpanSet, and stringSet, corresponding to \"sequence of Attribute', \"sequence of AttributeValue', \"sequence of DocumentCollectionlndex', \"sequence of QueryCollectionlndex', \"sequence of Span', and \"sequence of string' in the Architecture 2. These are referred to collectively as XSets, where X may be Attribute, Span, etc. An empty XSet is created by the operation CreateXSet 0: XSet (i.e., by one of the operations CreateAttributeSet, CreateSpanSet, etc.). The following operations apply to XSets: In addition, the operation Free, described just below, applies to all types of objects, including XSets. Storage Management A free operation must be provided for every class of object to release the memory associated with that object as well as to perform any necessary implementation specific cleanup operations. Error Handling A number of operations in the architecture describe error conditions (generally with the phrase \"it is an error if...\"). Such errors should be implemented by signaling an error rather than by returning an error value (this could be performed in C by using the longjrnp function and in Common Lisp by the error function). The C implementation provides utility routines which simplify the use of longjmp for this purpose. BASIC CLASSES Attributes A number of classes will have \"attributes\". This is a list of feature-value pairs, where the feature names are arbitrary strings and the values can be any of a number of types: assign value as the current value of attribute name of object, overwriting any prior assignment of a value to that attribute Persistent Objects The TIPSTER Architecture assumes a name space of persistent objects; each persistent object is assigned a unique name (a string). If the Architecture is operating in a networked environment, this name will presumably consist of a host name and a unique name on that host. erases the persistent instance of the object (it is an error if name is not the name of a persistent object) The (abstract) class The architecture does not require us to identify persistent object names with file names, but this may be the simplest way to manage initial implementations. In the present architecture DocumentCollectionlndexes and QueryCollectionlndexes are persistent; Collections are optionally persistent (Documents are not persistent objects themselves but have persistence as a part of a Collection). Byte Sequences The decision about the representation of a sequence of bytes, which constitutes the contents of a document, should be hidden from most applications. To do so, the class ByteSequence is introduced. The minimal requirement for an implementation of the Architecture is to be able to obtain the length of a ByteSequence, and to convert between a ByteSequence and a string: Class ByteSequence Operations Length (ByteSequence): integer returns the number of bytes in ByteSequence ConvertToString (ByteSequence): string CreateByteSequence (string): ByteSequence (In fact, the simplest implementation of a ByteSequence will probably be as a string, so the conversion will be an identity operation.) Implementations may choose to supplement these with additional operations for creating and accessing ByteSequences, for two reasons: 1. For applications involving large documents, the implementation may wish to provide the ability to directly access portions of the document. This may be done through operations which retrieve substrings of a ByteSequence, or through operations which allow a ByteSequence to be opened to a stream (for subsequent read and write operations). 2. A collection of documents needs to be converted into a TIPSTER Collection prior to processing within the Architecture. For large collections which are already in place on some data store, such as a file system or a data base, it may be highly desirable to create the TIPSTER Collection without copying the document text. A TIPSTER implementation can support this capability by allowing a ByteSequence to be created as a reference to a portion of this data store. For example, the implementation could define a \"file segment\" as a portion of a file (with start and end positions), and support operations for creating a ByteSequence from a file segment. Alternatively, an application based on a data base could define an operation for creating a ByteSequence from a data base field. DOCUMENTS AND COLLECTIONS Documents The document is the central object class in the TIPSTER architecture. As a unit of information, it serves several basic functions within the architecture: \u2022 it is the repository of information about a text, in the form of attributes and annotations (although annotations will in general refer to portions of documents) \u2022 it is the atomic unit in building collections \u2022 it is the atomic unit of retrieval in detection operations Each Document is part of one or more Collections (see Section 4.2). A Document has persistence by virtue of being a member of a Collection, and can be accessed only as a member of a Collection. Each document is given a unique identity by its ld property, which is copied by the CopyDocument and CopyBareDocument operations, and is also copied when a new collection is created by document retrieval operations. Class Document Type of AttributedObject Properties Parent: Collection the Collection of which this Document is a member; Id: string an internal document identifier, assigned automatically when a new Document is created, which is unique within an entire TIPSTER system (to insure uniqueness in a distributed system, an implementation may choose to include a host name as part of the Id) Externalld: string (R, W) a document identifier assigned by the application RawData: ByteSequence the contents of the document prior to any TIPSTER processing. The byte-sequence may include subsequences representing text in multiple languages, as well as non-text material such as pictures, audio, and tables Annotations: AnnotationSet information about portions of the document (information about the document as a whole is stored in Attributes; a Document inherits an Attributes property by virtue of being a type of Attributed Object) CopyDocument (NewParent: Collection, Document): Document makes a copy of Document, including its internal Id, Externalld, RawData, attributes, and annotations, and places the copy in collection NewParent. Annotate (Document, AnnotatorName: string) invokes annotation procedure AnnotatorName on the Document; see Section 5.6. WriteSGML (Document, AnnotationSet, AnnotationPrecedence: sequence of string): string Converts a document together with a set of Annotations into SGML format. AnnotationPrecedence, which is a list of annotation types, is used to resolve conflicts when two annotations cover the same span: the tag corresponding to the annotation type which appears first in the list is written out first. The resulting document is in a \"normalized\" SGML, with all attributes and end tags explicit. 4 Operations ReadSGML (string, Parent: Collection, Externalld: string): Document Reads a string marked up with \"normalized\" SGML, with all attributes and end tags explicit, and generates a Document with the specified Externalld, no attributes, and an AnnotationSet containing one annotation for each SGML text element marked in the input text. If the input violates these constraints (e.g., unmatched start tags) or violates SGML syntax (e.g., unmatched quotation marks within tags), an error will be signaled. 5 As noted earlier, new sources of data will need to be converted by the application into Collections of Documents before they can be processed within the TIPSTER Architecture. The functions which perform these conversions will necessarily be specific to the type of data source, and hence a TIPSTER application will be required to provide these conversion operations when a new type of data source is to be used. Collections Documents are gathered into Collections, which may have attributes on the collection level as well as on the individual documents. Collections provide a permanent repository for documents within the TIPSTER Architecture. Collections in general are persistent and hence have names; however, the Architecture also provides for volatile, unnamed Collections. Class Collection Type of PersistentObject, AttributedObject returns the \"first' document within a collection and initializes data structures internal to the collection so that NextDocument can be used to iterate through the documents in a collection. Returns nil if no documents are found in the collection. NextDocument (Collection): Document OR nil returns the \"next' document within a collection. Normally used to iterate through all documents in a collection. Returns nil if no more documents are found in the collection. FirstDocument and NextDocument must be well behaved in the presence of calls to CreateDocument and RemoveDocument. This means that a loop using FirstDocument and NextDocument must visit all documents which were in the collection when FirstDocument was called if and only if the documents are not deleted before the loop reaches them. Documents added after FirstDocument is called may or may not be encountered during the loop. DOCUMENT ANNOTATIONS: GENERAL STRUCTURE Annotations, along with attributes, provide the primary means by which information about a document is recorded and transmitted from module to module within a system. This chapter elaborates the general structure of annotations, noting some of the issues which arise at each stage. What Is Annotated? An annotation provides information about a portion of the document (including, possibly, the entire document). The portion of the document is specified by a set of spans. Each span consists in turn of a pair of integers specifying the starting and ending byte positions in the RawData of the document (with the first byte of the document counting as byte 0). Class Span Properties Start: integer End: integer Operations CreateSpan (start: integer, end: integer): Span The current span design is intended for character-based text documents which may contain additional types of information such as graphical images, audio, or video, which needs to be retained and displayed, but which would not be further processed by components of the TIPSTER Architecture. For documents which do not contain text in the form of a sequence of characters, the meaning of a span will not necessarily be compatible with this start byte/end byte convention. For instance, in compressed video, the information contained in a sequence of frames cannot be located using starting and ending byte. Similarly, in a graphical image of a document, such as a fax, the most natural definition of a primitive subimage is likely to be a rectangle. Note that the data in a fax is not even byte aligned. All of these considerations indicate that eventually an opaque type for spans with a subclass being TextSpan will be needed Most annotations will be associated with a single contiguous portion of the text, and hence with a single span. However, a set of spans is provided for in order to be able to refer to non-contiguous portions of the text. For example, an event might be described at the beginning of an article and again later in the article, but not in the intervening text; using a set of spans allows us to have an annotation for the event refer to these two passages. It would also allow for discontinuous linguistic elements, such as verb plus particle pairs (\"I gave my gun up.\"). Code Sets and Character Positions Positions in the RawData are represented internally in terms of byte offsets, rather than characters. This is necessary because the RawData may contain non-text data, such as graphics or sounds, for which character addressing would not be meaningful. However, once a text has been segmented into text and non-text portions, and the text portion into segments involving different character codes, it should be possible to provide operations at the character level (i.e., operations which are sensitive to the different sizes of characters in different codes). This segmentation into regions using different character code sets is to be recorded in the TIPSTER Architecture as Annotations on the document (see Section 6.1). By accessing these Annotations, an application can determine the code set employed at a specific position in a document, and hence the size of the character at that position. This information can be used to implement operations to extract a single character or advance to the next character position. More work is required on the multi-lingual design of the Architecture before such operations can be incorporated into the Architecture itself. Modification of the Text To allow annotations to modify the text (and, in particular, to insert characters) in such a way that subsequent accesses to the text see the modified text in place of the original text, it is necessary to require a representation of positions in a document which allows for insertions (e.g., by using integers above the length of the original string to refer to inserted elements). The current architecture does not allow for such changes; corrections to the text must be recorded as attributes on text elements which are explicitly accessed by subsequent processes. Alternatively, the application can create a new Document with a new RawText property which incorporates these modifications. Information Associated With an Annotation An annotation associates a type with a span of the document. Examples of possible types are token, sentence, paragraph, and dateline. In addition, one or more attributes may be assigned to each annotation. Class Annotation Type of AttributedObject Properties Id: string the identifier of an Annotation, which is nil when the Annotation is created and which is set when the Annotation is added to a Document; the value assigned is unique among the Annotations on that Document. Type: string Spans: sequence of Span Operations CreateAnnotation (Type: string, Spans: sequence of Span, attributes: sequence of Attribute): Annotation Examples of simple attributes on annotations (attributes whose values are single strings) include a type-of-name attribute on name annotations, which might take on such values as \"person, country\", \"company\", etc.; a pos (part of speech) attribute on token annotations, which might take on the Penn Tree Bank values, such as \"NNS\" and \"VBG\", and a root attribute on token annotations, which would record the root (uninflected) form of a token. An example of an attribute whose value is another annotation would be a coreference pointer. An even more complex attribute value would be a template object, which may in turn contain pointers to several other annotations (for the text elements filling various slots in the template object). Accessing Annotations Because annotations are central to the TIPSTER architecture, it is expected that applications will have frequent need to access, search, and select annotations on a document. To meet this need, the Architecture defines a class AnnotationSet and a number of operations operating on such sets of annotations. In particular, operations are provided to support the sequential scanning of a document (AnnotationsAt, NextAnnotations) and to support thc extraction of annotations meeting certain criteria (SclcctAnnotations). Although AnnotationSets are logically just sets of annotations, and could be implemented like other sets (e.g., as lists), a special class is provided in the expectation that implementations may wish to choose a more elaborate implementation (such as a sorted list or tree with one or more indexes) in order to implement the operations more efficiently. Each Document includes as one property an AnnotationSet, holding the annotations on that Document. Most of the operations on AnnotationSets can also be applied to Documents, and in that case apply the same operation to the AnnotationSet property of the Document. Annotation Type Declarations Introduction A central goal in creating the TIPSTER architecture is for different modules to be able to share information about a document through the use of annotations. Such information sharing will be workable only if there are precise, formal descriptions of the structure of these annotations, and if the modules which create annotations adhere to these descriptions. Therefore, annotation type declarations are introduce here which serve to document the information associated with different types of annotations. In the present architecture these declarations only serve as documentation; future generations of the architecture may seek to do type checking based on these declarations (see Appendix A. 1). Type declarations are organized into packages. A package will typically include a set of related annotation types. For example, a package may declare all the types of annotations used to represent the document structure for one message format (header, dateline, author, etc.). Another package, associated with an extraction system, would represent the annotation types corresponding to the template objects created by that system. The declaration of a package of annotation types would consist of a package name declaration followed by one or more annotation type declarations. The package name declaration has the form to indicate that the value may be of any one of the types listed; it may specify a compound type, either sequence of type which allows for a sequence of zero or more instances of type type, or optional type whose value may be either of type or be nil. Finally, type-spec may be a previously defined annotation type, specifying a reference to an annotation of that type. One or more white-space characters (blanks, tabs, or newlines) are required between successive identifiers and alphabetic names; zero or more white-space characters are allowed before and after the separator characters \": ; ()\". Any text between a left bracket and a right bracket ([...]) is considered a comment. At the end of this section the type declaration packages which would be used to describe these annotations is shown. The first example shows a single sentence and the result of three annotation procedures: tokenization with part-ofspeech assignment, name recognition, and sentence boundary recognition. Each token has a single attribute, its part of speech (pos), using the tag set from the University of Pennsylvania Tree Bank; each name also has a single attribute, indicating the type of name: person, company, etc. Annotations will typically be organized to describe a hierarchical decomposition of a text. A simple illustration would be the decomposition of a sentence into tokens. A more complex case would be a full syntactic analysis, in which a sentence is decomposed into a noun phrase and a verb phrase, a verb phrase into a verb and its complement, etc. down to the level of individual tokens. Such decompositions can be represented by annotations on nested sets of spans. Both of these are illustrated in our second example, which is an elaboration of our first example to include parse information. Each non-terminal node in the parse tree is represented by an annotation of type parse. In most cases, the hierarchical structure could be recovered from the spans. However, it may be desirable to record this structure directly through a constituents attribute whose value is a sequence of annotations representing the immediate constituents of the initial annotation. For the annotations of type parse, the constituents are either nonterminals (other annotations in the parse group) or tokens. For the sentence annotation, the constituents attribute points to the constituent tokens. A reference to another annotation is represented in the table as \"[Annotation hi]\"; for example, \"[3]\" represents a reference to annotation 3. Where the value of an attribute is a sequence of items, these items are separated by commas. No special operations are provided in the current architecture for manipulating constituents. Id At a less esoteric level, annotations can be used to record the overall structure of documents, including in particular documents which have structured headers, as is shown in our third example6: 6 lncounting characters, count one character for the newline between lines If the Addressee, Source .... annotations are recorded when the document is indexed for retrieval, it will be possible to perform retrieval selectively on information in particular fields. Our final example involves an annotation which effectively modifies the document. The current architecture does not make any specific provision for the modification of the original text. However, some allowance must be made for processes such as spelling correction. This information will be recorded as a correction attribute on token annotations and possibly on name annotations: { symbol: string, constituents: sequence of (parse or token or name)}; Invoking Annotators Each TIPSTER system will be provided with a number of \"annotators\" procedures for generating annotations. There will be annotators for different types of annotations; for example, for tokenization, for sentence segmentation, for name recognition, etc. In addition, there may be multiple annotators of a single type; e.g., multiple tokenizers. Each annotator is assigned a name (a string). It is invoked by Annotate (Document, AnnotatorName: string) or AnnotateCollection (which: Collection, destination: Collection, AnnotatorName: swing) The first form annotates a single Document. The second form annotates a Collection or a subset thereof. This uses Collection which to determine which documents to process, and Collection destination to record the annotations. For each document in collection which, if the same document (a document with the same Id) appears in destination, annotate that document in collection destination. This calling sequence allows us to selectively apply annotators to subsets of a collection, but to keep all the annotations together in the \"original\" collection. If which and destination are identical, the entire collection is annotated. Note: Future versions of the architecture will include operations for managing the set of annotators: for adding an annotator to the set of annotators, for recording the types of annotations produced by an annotator, and for searching the set of annotators. External Representation of Annotations The TIPSTER architecture provides an external, character-based representation of annotated documents, so that such documents can be interchanged among modules (possibly as part of different TIPSTER systems on different machines) without regard to the internal representation used on particular machines. A representation based on SGML has been selected in order to be able to make use of the large number of existing applications which can operate on SGML documents. In this representation, if the document consists of the text \"aaaa bbbb cccc\", and the span corresponding to \"bbbb\" has been assigned an annotation of type atype with id ident, and this annotation has attributes attribute1, attribute2, ... with values value1, value2 .... then the external representation of the annotated document will be aaaa <atype id=ident attributel=valuel attribute2=value2... >bbbb</atype> cccc This representation is produced by the WriteSGML operation, which takes as arguments a document, an AnnotationSet, and a precedence list among annotation types. This precedence list is used to determine the nesting of SGML tags if two annotations involve the same span. A complementary operation, ReadSGML, reads a SGML document which conforms to this format (with all attributes and end tags explicit) and creates a document with annotations. The specification of these operations is subject to revision based on the experience of implementors in using these SGML representations in applications. It may be desirable to have a second external representation which much more closely parallels the internal property structure of the annotations, particularly if annotations are to be exchanged over a network. Annotation Schemata and Style Sheets Different groups of annotations normally exist in some fixed structural relationships to one another. Thus, a text body may consist of paragraphs, a paragraph of sentences, a sentence of tokens, etc. For an SGML document, these relationships are provided by a DTD. At present, the Architecture includes a very limited amount of such information in the form of the PrecedenceList argument to WriteSGML; it may be desirable to include in later versions of the architecture an AnnotationSchema more analogous to a DTD. When an SGML form is generated from an annotated document, rules must be applied to realize each type of annotation as a sequence of characters. In the present version, these rules are assumed to be built in to the WriteSGML operation, but in later versions it may be desirable to provide these rules explicitly as a StyleSheet. A TIPSTER System would have a default StyleSheet, but it may be necessary to extend the WriteSGML operation to use a different, explicitly specified style sheet. TYPES OF DOCUMENT ANNOTATIONS The TIPSTER Architecture defines a number of standard annotations; these are divided into structural and linguistic annotations. If these particular annotation type names are used, they must be used for the purpose designated. However, a TIPSTER system is free to create and use any other annotation types that it wishes. These annotations all have to be described in further detail. Structural Annotations 1. The raw document may contain several types of information, including text, tables, and graphics. The TIPSTER Architecture needs to preserve all this information in the document, but for the present will only process the text information (at a subsequent stage other structures with embedded text information, such as tables, may also be processed). To delimit these different types of information, the TIPSTER Architecture will use annotations of type TextSegment, each subsuming a maximal contiguous sequence of text (and possibly other annotations, such as GraphicsSegment, which would be ignored in subsequent processing). 2. A text segment may consist of text in one or more languages and character codes. This information would be recorded by annotations of type MonolingualTextSegment which each have Language and CharacterSet attributes. 3. A document may be divided into a header and a body. The body would be annotated with a body annotation. The header may include a document identifier (to be annotated with a docid annotation) and such other properties as a title or headline, a dateline, etc. 4. A body may be divided into paragraphs; the p annotation type will be used to identify paragraphs. 5. A paragraph may be divided into sentences; the s annotation type will be used to identify sentences. 6. A sentence may be divided into tokens. The rules for tokenization for English will follow those used by the Penn Tree Bank. Tokens will be denoted by the token annotation. The capability to annotate sentences and tokens will be obligatory for a TIPSTER System, since so many other properties may be expected to assume their existence. Other levels of annotation will be optional. Linguistic Annotations 1. Names, as defined for MUC-6. This includes company names, people's names, locations, currencies, and dates. 2. Part of speech labels, using the Penn TreeBank set as a standard for English. 3, Coreference tagging, as is being defined for MUC-6. Standards for other linguistic annotations, such as phrase structure, word senses, and predicate-argument structure, may be added as more progress is made in defining these annotations for MUC evaluation. All of these linguistic annotations would be optional: the architecture would be used to establish standards whereby people who want to generate or use these annotations could communicate, but (except possibly for name recognition) this would not obligate anyone to produce these annotations. DETECTION Object Classes Detection Needs and Queries The user's request for documents is initially prepared in the form of a DetectionNeed: a document with a variety of SGML-delimited fields. A DetectionNeed is a type of Document, and so partakes of all the operations which can be applied to Documents. As a specialization of Collections, the Architecture includes DetectionNeedCollections; these are required primarily for routing operations, which typically involve sets of DetectionNeeds. The DetectionNeed is transformed in two stages: it is first transformed into a DetectionQuery, and thence into either a RetrievalQuery or a RoutingQuery. DetectionNeeds are independent of the specific retrieval engine employed, while DetectionQueries, RetrievalQueries, and RoutingQueries are specific to a particular retrieval engine. The DetectionQuery is specific to the retrieval engine but independent of the collection over which retrieval is to be performed, and the operation (retrieval or routing) to be performed; the RetrievalQuery and RoutingQuery are specific to the retrieval engine, to the operation, and to a collection (they may incorporate, for example, term weights based on the Inverse Document Frequencies in a collection). The transformation process is divided into these two stages because a retrieval system may provide specialized tools for modifying the DetectionQuery. Detection Needs Class DetectionNeed Type of Document Description A system-independent description of the contents of the documents that the user would like to retrieve. The description may be in natural language, expressed with query language operators (described below), or a combination of natural language and query language operators. Operations QueryGenerator (DetectionNeed): DetectionQuery Generate a system-specific DetectionQuery from an analysis of the DetectionNeed; the DetectionQuery has the same Externalld as the DetectionNeed. Query language operators are represented within the DetectionNeed using SGML-style tags. Each query language operator has the following syntax. <OPERATOR> argument + </OPERATOR> That is, an operator consists of an operator field marker (e.g. <OPERATOR>), one or more arguments, and an ending field marker (e.g. </OPERATOR>). Operators may be nested arbitrarily. Operator characteristics can be altered as shown. When alternatives are given (e.g. EXACT or FUZZY), the first one listed is the default. The default value for numeric arguments is 1. It is not necessary for a system to implement each operator exactly as described below. A compliant system is one that can translate any valid DetectionNeed into its own query language, and that documents how each operator is handled. A system may ignore operators that it does not implement, or it may map them to the nearest reasonable alternative in that system's query language. Any text not explicitly encapsulated in a query language operator is assumed to be implicitly encapsulated by the <SUM> operator (described below). When it is necessary to distinguish among two or more DetectionNeeds, for example when they are stored in an ASCII file, the <DETECTION-NEED> SGML tag indicates the beginning of a DetectionNeed, and the </DETECTION-NEED> SGML tag indicates the end of the DetectionNeed. Text that is not enclosed between these tags is handled in a system-dependent (i.e. not defined by the TIPSTER architecture) manner. The operators are listed below, in alphabetic order. <AND MATCH=[EXACT I FUZZY]> Document should contain all arguments. EXACT match means that each document must contain all of the arguments. FUZZY match means that a document may be returned if it lacks one or more arguments, but the document is presumably ranked lower than documents that match all arguments. <AND-NOT MATCH=[EXACT I FUZZY]> Document should contain the first argument but not the second. Only two arguments can be specified for this operator. <COMMENT> All tokens until </COMMENT> are comments, to be ignored when creating DetectionQuery objects. <DOC-ANNOTATION=name> The arguments are to be matched against that portion of the document annotated with the annotation of type \"name\". Note that annotations may denote document structure, so that this operator may be used to restrict the match to within a single phrase, sentence, paragraph, section, etc. <DOC-ATTRIBUTE=name> The arguments are to be matched against the value of attribute \"name\". <NL> The arguments are a natural language description of part of the information need. No other query operator can occur in the <NL> description of the information need. (Any operators encountered are to be treated as text.) </NL> ends the field, unless it is escaped (see below). <ESCAPE> All tokens until </ESCAPE> are query terms, not operators. If the next token is </ESCAPE> then it is a query term, and not the end of the <ESCAPE>. <NONRELEVANT> The arguments are the Ids of documents that the user has judged to be not relevant to the information need. <SUM> Functionally, this operator is like an <OR> operator: The document must contain one or more arguments. However, the user may assume that documents that match more arguments are generally ranked higher than documents that match fewer arguments. (Typically used with vector-space or probabilistic systems.) <SYNONYM> The arguments are considered synonyms. <WEIGHT n> Applies a weight of n to its argument. May affect a document's score, depending upon the retrieval algorithm used. <WORDS MATCH=[EXACT I FUZZY], DISTANCE=n, [UNORDERED I ORDERED]> Document should contain all arguments within n words. An SGML-like syntax was chosen because it is expressive, relatively easy to read, and system neutral. It allows the operator characteristics to be tailored without introducing a large number of special-purpose operators. Class DetectionNeedCollection Type of Collection Description A Collection of Documents, all of which are DetectionNeeds. this operation updates the RetrievalQuery using relevance feedback, and returns the updated (or new) Query. The relevance feedback is provided through the relevant_docs argument. Each document in this collection should have an Attribute relevant with the value \"true\" or \"false\". Furthermore, if that value is \"true\", the entry may also have one or more Annotations of type relevant-section whose Spans indicate the relevant sections of the document. Document and Query Indexes The TIPSTER Architecture provides for two types of document detection operations: retrieval and routing. In essence, retrieval involves the comparison of a single query against a large number of documents, while routing involves the comparison of a single document against a large number of queries (or \"user profiles\"). As a preliminary step for retrieval, generally, the set of documents must be pre-processed. Typically, this involves the creation of a term index, but it may also involve the gathering of various statistics about the set of documents (such as term document frequencies, term co-occurrence frequencies, and even term similarities based on cooccurrence). The result of all this preprocessing is a DocumentCollectionlndex. Retrieval is then performed by sending a query (in the form of an RetrievalQuery) to the DocumentCollectionlndex; the DocumentCollectionlndex returns a list of relevant documents. Class DocumentCollectionIndex Type of PersistentObject Description a form of a Collection which is capable of responding to DetectionQuery. For most systems, this involves the annotation of the documents in the collection with approach-specific annotations, and then the creation of an inverted index involving these annotations. For some systems, however, an \"index\" might just be a normalized copy of the original text in a form which can be scanned by high speed search software. Operations Query Monitoring The Monitor object is intended as an advisory object in the Architecture. If no Monitor object is provided, no monitoring or interruption of the RetrieveDocuments operation is possible. The RetrieveDocuments operation will not fail due solely to the absence of a nil Monitor argument. Class Monitor Description Tracks the progress of requests to a Detection component. Functional Model The following functional model diagrams are based on the notation used by Rumbaugh et al. Ovals represent processes (operations); boxes with only a top and bottom represent \"data stores\" --persistent repositories of data; fully enclosed boxes represent \"actors\" --active sources of data. Retrospective Retrieval The system begins by converting the DocumentCollection(s) into DocumentCollectionlndex(es), as shown on the left side. To retrieve information from this collection, the User produces a DetectionNeed. This DetectionNeed is converted in two stages, first to a DetectionQuery and then to an RetrievalQuery, as shown in the right column (the latter step may use information, for example, on term weights, from the DocumentCollectionIndex). Finally, the RetrievalQuery is run against the DocumentCollectionlndex to retrieve the documents; this produces a Collection of relevant documents, with a relevance attribute for each document. Routing Routing requires a DocumentCollectionIndex which is used to determine weights for the translation of a DetectionQuery into an RoutingQuery. Typically an application will be able to use a pre-existing index (for a Collection of content comparable to the documents to be routed). Each DetectionNeed (user profile) in the DetectionNeedCollection is translated in two stages: first to a DetectionQuery, and then into a RoutingQuery. These RoutingQueries are then stored and indexed in a QueryCollectionlndex. Finally, this QueryCollectionlndex can be run against a Document to produce a set of relevant queries (profiles), in the form of a DetectionNeedCollection. DocumentCollectionIndex Relevance Feedback Relevance feedback begins with an initial RetrievalQuery, which is used to retrieve a set of documents. This operation is shown as \"Retrieve Documents [1]\" in the figure below (the DocumentCollectionlndex input is not shown), and produces a Collection. A human judge (or possibly an alternative source of relevance judgments, such as an extraction system) then reviews the retrieved documents and records relevance judgments on the Collection using the relevant Attribute. This is done using a Relevance Recorder, which is not part of the Architecture but would be part of any application system which wished to support relevance feedback. The Collection is then fed, along with the original query, to an UpdateUsingRelevanceFeedback operation, producing an updated query. Finally, the updated query can be used to retrieve a new set of documents (shown as \"Retrieve Documents [2]\" at the bottom of the figure). Information extraction the extraction from a document of information concerning particular classes of events is a form of document annotation. An extraction engine adds annotations describing the events and their participants. Extraction therefore does not require any operations and classes beyond those already presented. However, because extraction will be a major component of many systems built using the Architecture, this section describes how extraction fits into the current Architecture. At present the development of extraction engines from a description of a class of events (a \"scenario\") is a black art practiced by a cadre of information extraction specialists. It is expected that in the future it will be possible for experienced users to customize extraction systems to new scenarios; this would be an interactive process which would draw upon a library of predefined template objects. Appendix A.2 presents the additional object classes which would be needed to support such customization. Representing Templates as Annotations In the terminology developed by the Message Understanding Conferences, the information extracted from a document is stored in a (filled) template, which in turn consists of a set of template objects. A template object may contain information about a real-world object (such as a person, product, or organization), a relationship, or an event. Each such template object provides information about a portion of a document and is therefore represented in the TIPSTER Architecture by an annotation. A particular extraction task will involve several kinds of template objects, for events, people, organizations, etc. Each kind of template object corresponds to a type of annotation. Thus the formal specification of a set of template objects corresponds to a set of annotation type declarations. This formal specification is supplemented by a large amount of narrative (the \"fill rules\") describing the circumstances under which a template object is to be created and the information to be placed in each slot. Each slot/value pair in the template object is represented as an attribute/value pair on the annotation. Note that the values of attributes can be lists (thus allowing for slots with multiple values) and can be references to other annotations (thus allowing for a hierarchy of filled objects, and allowing for references to other annotations, such as names which have been identified by a prior annotation process). Furthermore, each annotation has a span which can link the object to the text from which it has been derived. Some applications may want to link an individual slot in the template object to text in the document. This can be done by introducing additional annotations. Instead of having the value of the attribute corresponding to that slot be a string, it would be a reference to an annotation of type string-annotation. That annotation would (like all annotations) have a set of spans referencing the text; it would also have a value attribute holding the value of the template slot (the \"slot filler\"). This has been done for one of the slots in the example below, the role slot of personnel, but could have done it for others. If an application system involves extractions for multiple scenarios (multiple classes of events),it will be necessary to distinguish the annotations corresponding to different extraction scenarios (so that, for example, one can display all the annotations for one scenario). This can be done by adding a scenario attribute to each annotation. In similar fashion, in an application environment integrating annotation modules from different suppliers, it would be desirable to record the source of particular annotations using an annotator attribute. These additional attributes are not shown in the example below. An Example As an illustration of this approach, consider the result of annotating a document consisting of the sentence The KGB kidnapped ARPA program manager Umay B. Funded. with an information extraction system covering terrorist events. These might be encoded as a set of annotations as follows: The MUC-style template for such an event might 7 The templates shown here are loosely based on those for the MUC-6 information extraction task. the operation which generates templates from documents. Extraction is a special type of annotation, and accordingly the Extract operation is a variant of the Annotate operation (Section 5.6). For each document in collection which, if the same document (a document with the same Id) appears in destination, annotate that document in collection destination with the information extraction templates generated for that document. Class Template Object Library Description a set of system-specific rules for extracting various classes of objects, such as persons or organizations; this library could bc used in customizing an extraction system to a particular task A.2.2 Functional Model The analyst begins by preparing an ExtractionNeed. The ExtractionNeed would serve as the starting point for customization, which would be performed by the analyst using an interactive customization tool and drawing upon the Template Object Library. The result of this process would be a CustomizedExtractionSystem. Once a CustomizedExtractionSystem has been created, it can bc given a Collection specifying the documents to be annotated (the \"which\" argument) and a Collection where the annotations shall be placed (the \"destination\" argument); it will add to each document of the destination Collection the appropriate templates (in the form of annotations). APPENDIX C C LANGUAGE HEADER FILE This appendix shows the C language header file corresponding to the classes defined in the TIPSTER Architecture. Each concrete TIPSTER class has been mapped into a C language type of the same name. However, classes. DetectionNeed, DetectionQuery, and DetectionNeedCollection, are not realized as separate C language types. The first two are subtypes of Document in the Architecture, and are treated as instances of the Document type; the last is a subtype of Collection, and is treated as a Collection in the C language specifications. Any functional argument which can be of more than one TIPSTER class is declared of type void* in the C-language declarations (however, arguments which can either point to an object of class X or be NULL are declared as being of class X). APPENDIX A POSSIBLE EXTENSIONS TO THE ARCHITECTURE A.1 Enforcing Type Declarations In the current Architecture, annotation type declarations serve only as documentation; they are not processed by any component of the Architecture. It may be desirable in future versions of the Architecture to perform type checking based on such declarations. This could involve: 1. creation of a new class of document, TypeDeclarationDocument, containing a package of type declarations 2. associating a set of declaration packages with a Collection 3. requiring that any annotation added to a document in a collection conform to the associated type declaration A number of issues would need to be resolved to implement such a scheme, including the name scoping of annotation types, and the implications of modifying a type declaration after annotations of that type have been created. The overall type checking mechanism would be fairly complex and so has not been included in the current Architecture. A.2 Customizable Extraction Systems The present Architecture treats extraction engines as modules which have been hand-coded for specific tasks (extraction scenarios). In the future, it is expected that there will be more general extraction engines which can be customized by users to specific needs. This section considers the additional object classes and data flow which would be entailed, A.2.1 Object Classes The user would prepare an ExtractionNeed, using a combination of formal specification and narrative description comparable to the \"fill rules\" for MUC-5. This would then be \"translated\" to produce a CustomizedExtractionSystem. This translation would be performed by a component which will guide an analyst in producing a CustomizedExtractionSystem; this interactive translation component is labeled Customize below. Once a CustomizedExtractionSystem is created, it can be applied to documents in a collection (like other, pre-existing annotators) and will produce templates for the documents. The Extraction Need would include annotation type declarations for the annotations to be produced. These type definitions will be supplemented by fill rules in the form of comments. As the process of translating ExtractionNeeds becomes more formalized, the fill rules will accordingly also become more formalized. For example, the specifications may include the semantic class of particular slot fills. For the present, however, an ExtractionNeed is a kind of TypeDeclarationDocument: Class ExtractionNeed Type of TypeDeclarationDocument Class CustomizedExtractionSystem Description a system-specific structure, containing patterns, rules, etc. Operations Customize (ExtractionNeed): CustomizedExtractionSystem an interactive process which will guide the user in converting an ExtractionNeed CustomizedExtractionSystem Extract (which: Collection, destination: Collection, CustomizedExtractionSystem) into a APPENDIX B CLASSES AND THEIR OPERATIONS This appendix lists all the classes and their operations in an \"expanded\" form. Instead of showing the properties associated with a class, this appendix explicitly lists the operations to access (and, in some cases, to write) these properties. If property Comp of a class is readable, it is accessed by the operation GetComp; if it is also writeable, it is set by the operation SetComp. In addition, the inheritance of operations from abstract classes has been made explicit: the abstract classes themselves have been removed, and the operations are shown explicitly as part of each class which directly inherited them from the abstract class. Class",
    "abstract": "The TIPSTER Program aims to push the technology for access to information in large (multi-GB) text collections, in particular for the analysts in Government agencies. Technology is being developed for document detection (\"information retrieval\") and for data extraction from free text.",
    "countries": [
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "26",
    "year": "1996",
    "month": "May",
    "title": "{TIPSTER} Text Phase {II} Architecture Design Version 2.1p 19 {J}une 1996"
}