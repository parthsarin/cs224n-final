{
    "article": "We propose a novel model for parsing natural language sentences into their formal semantic representations. The model is able to perform integrated lexicon acquisition and semantic parsing, mapping each atomic element in a complete semantic representation to a contiguous word sequence in the input sentence in a recursive manner, where certain overlappings amongst such word sequences are allowed. It defines distributions over the novel relaxed hybrid tree structures which jointly represent both sentences and semantics. Such structures allow tractable dynamic programming algorithms to be developed for efficient learning and decoding. Trained under a discriminative setting, our model is able to incorporate a rich set of features where certain unbounded long-distance dependencies can be captured in a principled manner. We demonstrate through experiments that by exploiting a large collection of simple features, our model is shown to be competitive to previous works and achieves state-of-theart performance on standard benchmark data across four different languages. The system and code can be downloaded from Introduction Semantic parsing, the task of transforming natural language sentences into formal representations of their underlying semantics, is one of the classic goals for natural language processing and artificial intelligence. This area of research recently has received a significant amount of attention. Various models have been proposed over the past few years (Zettlemoyer and Collins, 2005 What rivers do not run through Tennessee ? Figure 1 : An example tree-structured semantic representation (above) and its corresponding natural language sentence. Mooney, 2006; Wong and Mooney, 2006; Lu et al., 2008; Jones et al., 2012) . Following previous research efforts, we perform semantic parsing under a setting where the semantics for complete sentences are provided as training data, but detailed word-level semantic information is not explicitly given during the training phase. As one example, consider the following natural language sentence paired with its corresponding semantic representation: What rivers do not run through Tennessee ? answer(exclude(river(all), traverse(stateid( tn )))) The training data consists of a set of sentences paired with semantic representations. Our goal is to learn from such pairs a model, which can be effectively used for parsing novel sentences into their semantic representations. Certain assumptions about the semantics are typically made. One common assumption is that the semantics can be represented as certain recursive structures such as trees, which consist of atomic semantic units as tree nodes. For example, the above semantics can be converted into an equivalent tree structure as illustrated in Figure 1 . We will provide more details about such tree structured semantic representations in Section 2.1. Currently, most state-of-the-art approaches that deal with such tree structured semantic representations either cast the semantic parsing problem as a statistical string-to-string transformation problem (Wong and Mooney, 2006) , which ignores the potentially useful structural information of the tree, or employ latent-variable models to capture the correspondences between words and tree nodes using a generative approach (Lu et al., 2008; Jones et al., 2012) . While generative models can be used to flexibly model the correspondences between individual words and semantic nodes of the tree, such an approach is limited to modeling local dependencies and is unable to flexibly incorporate a large set of potentially useful features. In this work, we propose a novel model for parsing natural language into tree structured semantic representations. Specifically, we propose a novel relaxed hybrid tree representation which jointly encodes both natural language sentences and semantics; such representations can be effectively learned with a latent-variable discriminative model where long-distance dependencies can be captured. We present dynamic programming algorithms for efficient learning and decoding. With a large collection of simple features, our model reports state-of-the-art results on benchmark data annotated with four different languages. Furthermore, although we focus our discussions on semantic parsing in this work, our proposed model is a general. Essentially our model is a discriminative string-to-tree model which recursively maps overlapping contiguous word sequences to tree nodes at different levels, where efficient dynamic programming algorithms can be used. Such a model may find applications in other areas of natural language processing, such as statistical machine translation and information extraction. Background Semantics Various semantic formalisms have been considered for semantic parsing. Examples include the tree-structured semantic representations (Wong and Mooney, 2006) , the lambda calculus expressions (Zettlemoyer and Collins, 2005; Wong and Mooney, 2007) , and dependency-based compositional semantic representations (Liang et al., 2013) . In this work, we specifically focus on the tree-structured representations for semantics. Each semantic representation consists of se-mantic units as its tree nodes, where each semantic unit is of the following form: m a \u2261 \u03c4 a : p \u03b1 (\u03c4 b * ) (1) Here m a is used to denote a complete semantic unit, which consists of its semantic type \u03c4 a , its function symbol p \u03b1 , as well as an argument list \u03c4 b * (we assume there are at most two arguments for each semantic unit). In other words, each semantic unit can be regarded as a function which takes in other semantics of specific types as arguments, and returns new semantics of a particular type. For example, in Figure 1 , the semantic unit at the root has a type QUERY, a function name answer, and a single argument type RIVER. Joint Representations Semantic parsing models transform sentences into their corresponding semantics. It is therefore essential to make proper assumptions about joint representations for language and semantics that capture how individual words and atomic semantic units connect to each other. Typically, different existing models employ different assumptions for establishing such connections, leading to very different definitions of joint representations. We survey in this section various representations proposed by previous works. The WASP semantic parser (Wong and Mooney, 2006) essentially casts the semantic parsing problem as a string-to-string transformation problem by employing a statistical phrase-based machine translation approach with synchronous grammars (Chiang, 2007) . Therefore, one can think of the joint representation for both language and semantics as a synchronous derivation tree consisting of those derivation steps for transforming sentences into target semantic representation strings. While this joint representation is flexible, allowing blocks of semantic structures to map to word sequences, it does not fully exploit the structural information (tree) as conveyed by the semantics. The KRISP semantic parser (Kate and Mooney, 2006) makes use of Support Vector Machines with string kernels (Lodhi et al., 2002) to recursively map contiguous word sequences into semantic units to construct a tree structure. Our relaxed hybrid tree structures also allow input word sequences to map to semantic units in a recursive manner. One key distinction, as we will see, is that our structure distinguishes words which are imme-diately associated with a particular semantic unit, from words which are remotely associated. The SCISSOR model (Ge and Mooney, 2005 ) performs integrated semantic and syntactic parsing. The model parses natural language sentences into semantically augmented parse trees whose nodes consist of both semantic and syntactic labels and then builds semantic representations based on such augmented trees. Such a joint representation conveys more information, but requires languagespecific syntactic analysis. The hybrid tree model (Lu et al., 2008) is based on the assumption that there exists an underlying generative process which jointly produces both the sentence and the semantic tree in a top-down recursive manner. The generative process results in a hybrid tree structure which consists of words as leaves and semantic units as nodes. An example hybrid tree structure is shown in Figure 2 (a) . Such a representation allows each semantic unit to map to a possibly discontiguous sequence of words. The model was shown to be effective empirically, but it implicitly assumes that both the sentence and semantics exhibit certain degree of structural similarity that allows the hybrid tree structures to be constructed. UBL (Kwiatkowski et al., 2010) is a semantic parser based on restricted higher-order unification with CCG (Steedman, 1996) . The model can be used to handle both tree structured semantic representations and lambda calculus expressions, and assumes there exist CCG derivations as joint representations in which each semantic unit is associated with a contiguous word sequence where overlappings amongst word sequences are not allowed. Jones et al. (2012) recently proposed a framework that performs semantic parsing with tree transducers. The model learns representations that are similar to the hybrid tree structures using a generative process under a Bayesian setting. Thus, their representations also potentially present similar issues as the ones mentioned above. Besides these supervised approaches, recently there are also several works that take alternative learning approaches to (mostly task-dependent) semantic parsing. Poon and Domingos (2009) proposed a model for unsupervised semantic parsing that transforms dependency trees into semantic representations using Markov logic (Richardson and Domingos, 2006) . Clarke et al. (2010) proposed a model that learns a semantic parser Approach We discuss our approach to semantic parsing in this section. The notation that we use in this paper is summarized in Table 1 . Model In standard supervised syntactic parsing, one typically has access to a complete syntactic parse tree for each sentence in the training phase, which exactly tells the correct associations between words and syntactic labels. In our problem, however, each sentence is only paired with a complete semantic representation where the correct associations between words and semantic units are unavailable. We thus need to model such information with latent variables. For a given n-m pair (where n is a complete natural language sentence, and m is a complete semantic representation), we assume there exists a latent joint representation h that consists of both n and m which tells the correct associations between words and semantic units in such a pair. We use H(n, m) 1 to denote the set of all such possible 2008 ) (left), and our novel relaxed hybrid tree representation (right). In our representation, a word w can be either immediately associated with its parent m (the words which appear inside the parenthesis), or remotely associated with m (the words that do not appear inside the parenthesis, and will also appear under a subtree rooted by one of m's children). latent joint representations that contain both n and m exactly. Given the joint representations, to model how the data is generated, one can either take a generative approach which models the joint probability distribution over (n, m, h) tuples, or a discriminative approach which models the distribution over (m, h) tuples given the observation n. Following several previous research efforts (Zettlemoyer and Collins, 2005; Kwiatkowski et al., 2010; Liang et al., 2013) , in this work we define a discriminative model using a log-linear approach: P (m, h|n; \u039b) = e \u039b\u2022\u03a6(n,m,h) m ,h \u2208H(n,m ) e \u039b\u2022\u03a6(n,m ,h ) (2) Here \u03a6(n, m, h) is a function defined over the tuple (n, m, h) that returns a vector consisting of counts of features associated with the tuple, and \u039b is a vector consisting of feature weights, which are the parameters of the model. In practice, we are only given the n-m pairs but the latent structures are not observed. We therefore consider the following marginal probability: P (m|n; \u039b) = h\u2208H(n,m) P (m, h|n; \u039b) = h\u2208H(n,m) e \u039b\u2022\u03a6(n,m,h) m ,h \u2208H(n,m ) e \u039b\u2022\u03a6(n,m ,h ) (3) The above probability is defined for a particular n-m pair. The complete log-likelihood objective for the training set is: L(\u039b) = i log P (m i |n i ; \u039b) \u2212 \u03ba||\u039b|| 2 = i log h\u2208H(n i ,m i ) P (m i , h|n i ; \u039b) \u2212 \u03ba||\u039b|| 2 (4) where (n i , m i ) refers to the i-th instance in the training set. Note that here we introduce the additional regularization term \u2212\u03ba \u2022 ||\u039b|| 2 to control over-fitting, where \u03ba is a positive scalar. Our goal is to maximize this objective function by tuning the model parameters \u039b. Let's assume \u039b = \u03bb 1 , \u03bb 2 , . . . , \u03bb N , where N is the total number of features (or the total number of parameters). Differentiating with respect to \u03bb k , the weight associated with the k-th feature \u03c6 k , yields: \u2202L(\u039b) \u2202\u03bb k = i h E P (h|n i ,m i ;\u039b) [\u03c6 k (n i , m i , h)] \u2212 i m,h E P (m,h|n i ;\u039b) [\u03c6 k (n i , m, h)] \u2212 2\u03ba\u03bb k (5) where \u03c6 k (n, m, h) refers to the number of occurrences for the k-th feature in the tuple (n, m, h). Given the objective value (4) and gradients (5), standard methods such as stochastic gradient descent or L-BFGS (Liu and Nocedal, 1989 ) can be employed to optimize the objective function. We will discuss the computation of the objective function and gradients next. Relaxed Hybrid Trees To allow tractable computation of the values for the objective function (4) and the gradients (5), Figure 3 : An example hybrid tree and an example relaxed hybrid tree representation. When the correct latent structure can not be found, the dependency between the words \"how many\" and the semantic unit \"NUM : count(STATE)\" can not be captured if the hybrid tree is used, whereas with our relaxed hybrid tree representation, such a dependency can still be captured. certain restrictions on the latent structures (h) will need to be imposed. We define in this section the set of all valid latent structures H(n, m) for the (n, m) pair so that some efficient dynamic programming algorithms can be deployed. We introduce our novel relaxed hybrid tree representations which jointly encode both natural language sentences and the tree-structured semantics. A relaxed hybrid tree h defined over (n, m) is a tree whose nodes are (n, m) pairs, where each n is a contiguous sequence of words from n, and each m is a semantic unit (a tree node) from m. For any two nodes h a \u2261 (n a , m a ) and h b \u2261 (n b , m b ) that appear in the relaxed hybrid tree h, if h a is the parent of h b in h, then m a must also be the parent of m b in m, and n a must contain n b . If the lowest common ancestor of h a and h b in h is neither h a nor h b , then n a and n b do not share any common word. Note that words that appear at different positions in n are regarded as different words, regardless of their string forms. Figure 2 (b) shows an example relaxed hybrid tree structure that we consider. Assume we would like to jointly represent both the natural language sentence n \u2261 w 1 w 2 . . . w 10 and its corresponding semantic representation m \u2261 m a (m b (m c , m d )). In the given example, the semantic unit m a maps to the complete sentence, m b maps to the sequence w 4 w 5 . . . w 10 , m c maps to w 6 w 7 , and m d maps to w 9 . Certain words such as w 4 and w 10 that appear directly below the semantic unit m b but do not map to any of m b 's child semantic units are highlighted with parentheses \"()\", indicating they are immediately associated with m b . These words play unique roles in the sub-tree rooted by m b and are expected to be semantically closely related to m b . Note that each word is immediately associated with exactly one semantic unit. As a comparison, we also show an example hybrid tree representation (Lu et al., 2008) in Figure 2 (a) that has similar words-semantics correspondences. Different from our representation, the hybrid tree representation assumes each natural language word only maps to a single semantic unit (which is its immediate parent), and each semantic unit maps to a possibly discontiguous sequence of words. We believe that such a representation is overly restrictive, which might exhibit problems in cases where natural language sentences are highly non-isomorphic to their semantic tree structures. Under our relaxed hybrid tree representations, words that are immediately associated with a particular semantic unit now can also be remotely associated with all its parent semantic units as well. Essentially, our representation allows us to capture certain unbounded dependencies -for any word, as long as it appears below a certain semantic unit (in the relaxed hybrid tree), we can always capture the dependency between the two, regardless of which actual semantic unit that word is immediately associated with. Such an important relaxation allows some longdistance dependencies to be captured, which can potentially alleviate the sentence-semantics nonisomorphism issue reported in several earlier semantic parsing works (Kate and Mooney, 2006; Wong and Mooney, 2007) . To better illustrate the differences, we show a concrete example in Figure 3 , where the correct latent structure showing the correspondences between words and semantic units can not be found with the hybrid tree model. As a result, the hybrid tree model will fail to capture the correct dependency between the words \"how many\" and the semantic unit \"NUM : count(STATE)\". On the other hand, with our relaxed hybrid tree representation, such a dependency can still be captured, since these words will still be (remotely) associated with the semantic unit. Such a relaxed hybrid tree representation, when further constrained with the word association patterns that we will introduce next, allows both the objective function ( 4 ) and the gradients of (5) to be computed through the dynamic programming algorithms to be presented in Section 4. Word Association Patterns As we have mentioned above, in the relaxed hybrid tree structures, each word w under a certain semantic unit m can either appear directly below m only (immediately associated with m), or can also appear in a subtree rooted by one of m's child semantic unit (remotely associated with m). We allow several different ways for word associations and define the allowable patterns for semantic units with different number of arguments in Table 2 . Such patterns are defined so that our model is amendable to dynamic programming algorithms to be discussed in Sec 4. In this table, w refers to a contiguous sequence of natural language words that are immediately associated with the current semantic unit, while X and Y refers to a sequence of natural language words that the first and second child semantic unit will map to, respectively. For example, in Figure 2 (b), the word sequence directly below the semantic unit m a follows the pattern wX (since the word sequence w 1 w 2 w 3 is immediately associated with m a , and the remaining words are remotely associated with m a ), and the word sequence below m b follows wXwYw 2 . The word association patterns are similar to those hybrid patterns used in hybrid trees. One key difference is that we disallow the unary pat-  tern X. The reason is, when computing the partition function in Equation 3, inclusion of pattern X will result in relaxed hybrid trees consisting of an infinite number of nodes. However, this issue does not come up in the original hybrid tree models due to their generative setting, where the training process does not involve such a partition function. Features The features are defined over the (n, m, h) tuples. In practice, we define features at each level of the relaxed hybrid tree structure h. In other words, features are defined over (n, m) tuples where n is a contiguous sequence of natural language words (immediately or remotely) associated with the semantic unit m (recall that h contains both n and m, and each level of h simply consists of a semantic unit and a contiguous sequence of words). Each feature over (n, m) is then further decomposed as a product between two indicator feature functions, defined over the natural language words (n) and semantic unit (m) respectively: \u03c6(n, m) = \u03c6 i (n) \u00d7 \u03c6 o (m). For each \u03c6 i (n) we define two types of features: the local features, which are defined over immediately associated words only, and the span features, which are defined over all (immediately or remotely) associated words to capture long range dependencies. The local features include word unigrams and bigrams, the word association patterns, as well as character-level features 3 which perform implicit morphological analysis. The span features include word unigrams, bigrams, as well as trigrams. Although our model allows certain more sophisticated features to be exploited, such as word POS features, word similarity features based on the WordNet (Pedersen et al., 2004) , we deliberately choose to only include these simple features so as to make a fair comparison with previous works which also did not make use of external resources. For the features defined on m (i.e., \u03c6 o (m)), we include only the string form of m, as well as m's function name as features. Finally, we also define features over m only. Such features are defined over semantic unit pairs such as (m a , m b ) where m a is the parent node of m b as in m. They include: 1) concatenation of the string forms of m a and m b , 2) concatenation of the string form of m a and m b 's type, and 3) concatenation of the function names of m a and m b . Algorithms In this section we describe the efficient algorithms used for learning and decoding. The algorithms are inspired by the inside-outside style algorithms used for the generative hybrid tree models (Lu et al., 2008) , but are different in the following ways: 1) we need to handle features, including long-distance features, 2) we need to additionally handle the computation of the partition function of Equation (3). Learning The training process involves the computation of the objective function (4) as well as the gradient terms (5). The objective function (4) (excluding the regularization term which can be trivially computed) is equivalent to the following: L(\u039b) = i log h\u2208H(n i ,m i ) e \u039b\u2022\u03a6(n i ,m i ,h) \u2212 i log m ,h \u2208H(n i ,m ) e \u039b\u2022\u03a6(n i ,m ,h ) (6) In the first term, h\u2208H(n i ,m i ) e \u039b\u2022\u03a6(n i ,m i ,h) is in fact the sum of the scores (as defined by \u03a6 and \u039b) associated with all such latent structures that contain both m i and n i exactly. The second term is the sum of the scores associated with all the latent structures that contain n i exactly. We focus our discussions on the computation of the first part first. We use m (p) w i . . . w j to denote the combined score of all such latent relaxed hybrid tree structures that contain both the semantic tree rooted by m and the natural language word sequence w i . . . w j that forms the word association pattern p with respect to m. For example, the score of the relaxed hybrid tree in Figure 2 (b) is contained by m a(wX) w 1 . . . w 10 (here p = wX because only w 1 w 2 w 3 are immediately associated with m a ). We give an illustrative example that shows how these scores can be computed efficiently using dynamic programming. Consider the following case when m has at least one child semantic unit: m (wXw) w i . . . w j = m (w) w i \u2297 m (wXw) w i+1 . . . w j + m (w) w i \u2297 m (Xw) w i+1 . . . w j Here the symbol \u2297 means extract and compute, a process that involves 1) extraction of additional features when the two structures on the right-hand side are put together (for example, the local bigram feature \"w i w i+1 \" can be extracted in the above case), and 2) computation of the score for the new structure when the two structures from both sides of \u2297 are combined, based on the scores of these structures and newly extracted features. The above equation holds because for any relaxed hybrid tree contained by the left-hand side, the left-most word w i is always immediately as- w i . . . w j can also be computed based on similar equations. In other words, such terms can be computed from even smaller similar terms in a recursive manner. A bottom-up dynamic programming algorithm is used for computing such terms. When the semantic unit m has two child nodes, similar equations can also be established. Here we give an illustrative example: m (wXwYw) w i . . . w j = j\u22121 k=i m (wX) w i . . . w k \u2297 m (wYw) w k+1 . . . w j Finally, we have the following equation: m w i . . . w j = p m (p) w i . . . w j The left-hand side simply means the combined score for all such relaxed hybrid trees that have (n, m) as the root, where n \u2261 w i . . . w j . Once the computation for a certain (n, m) pair is done, we can move up to process such pairs that involve m's parent node. The above process essentially computes the inside score associated with the (n, m) pair, which gives the sum of the scores of all such (incomplete) relaxed hybrid trees that can be constructed with (n, m) as the root. Similar to (Lu et al., 2008) , we can also define and compute the outside scores for (n, m) (the combined score of such incomplete relaxed hybrid trees that contain (n, m) as one of its leave nodes) in an analogous manner, where the computation of the gradient functions can be efficiently integrated in this process. Computation of the second part of the objective function ( 6 ) involves dynamic programming over a packed forest representation rather than a single tree, which requires an extension to the algorithm described in (Lu et al., 2008) . The resulting algorithm is similar to the one used in (Lu and Ng, 2011) , which has been used for language generation from packed forest representations of typed \u03bb-calculus expressions. Decoding The decoding phase involves finding the optimal semantic tree m * given a new input sentence n: m * = arg max m P (m|n) (7) This in fact is equivalent to finding the following optimal semantic tree m * : m * = arg max m h\u2208H(n,m) e \u039b\u2022\u03a6(n,m,h) (8) Unfortunately, the summation operation inside the arg max prevents us from employing a similar version of the dynamic programming algorithm we developed for learning in Section 4.1. To overcome this difficulty, we instead find the optimal semantic tree using the following equation: m * = arg max m,h\u2208H(n,m) e \u039b\u2022\u03a6(n,m,h) (9) We essentially replace the operation by the max operation inside the arg max. In other words, we first find the best latent relaxed hybrid tree h * that contains the input sentence n, and next we extract the optimal semantic tree m * from h * . This decoding algorithm is similar to the dynamic programming algorithm used for computing the inside score for a given natural language sentence n (i.e., the algorithm for computing the second term of Equation ( 6 )). The difference here is, at each intermediate step, instead of computing the combined score for all possible relaxed hybrid tree structures (i.e., performing sum), we find the single-best relaxed hybrid tree structure (i.e., performing max). Experiments We present evaluations on the standard GeoQuery dataset which is publicly available. This dataset has been used for evaluations in various semantic parsing works (Wong and Mooney, 2006; Kate and Mooney, 2006; Lu et al., 2008; Jones et al., 2012) . It consists of 880 natural language sentences paired with their corresponding formal semantic representations. Each semantic representation is a tree structured representation derived from a Prolog query that can be used to interact with a database of U.S. geography facts for retrieving answers. The original dataset was fully annotated in English, and recently Jones et al. (2012) released a new version of this dataset with three additional language annotations (German, Greek and Thai). For all the experiments, we used the identical experimental setup as described in Jones et al. (2012) . Specifically, we trained on 600 instances, and evaluated on the remaining 280. We note that there exist two different versions of the GeoQuery dataset annotated with completely different semantic representations. Besides the version that we use in this work, which is annotated with tree structured semantic representations, the other version is annotated with lambda calculus expressions (Zettlemoyer and Collins, 2005) . Results obtained from these two versions are not comparable. 4 Like many previous works, we focus on tree structured semantic representations for evaluations in this work since our model is designed for handling the class of semantic representations with recursive tree structures. We used the standard evaluation criteria for judging the correctness of the outputs. Specifically, our system constructs Prolog queries from the output parses, and uses such queries to retrieve answers from the GeoQuery database. 3 : Performance on the benchmark data, using four different languages as inputs. RHT: relaxed hybrid tree (this work). same answers as the gold standard (Jones et al., 2012) . We report accuracy scores -the percentage of inputs with correct answers, and F1 measuresthe harmonic mean of precision (the proportion of correct answers out of inputs with an answer) and recall (the proportion of correct answers out of all inputs). By adopting such an evaluation method we will be able to directly compare our model's performance against those of the previous works. The evaluations were conducted under such a setting in order to make comparisons to previous works. We would like to stress that our model is designed for general-purpose semantic parsing that is not only natural language-independent, but also task-independent. We thus distinguish our work from several previous works in the literature which focused on semantic parsing under other assumptions. Specifically, for example, works such as (Liang et al., 2013; Poon and Domingos, 2009; Clarke et al., 2010) essentially performed semantic parsing under different settings where the goal was to optimize the performance of certain downstream NLP tasks such as answering questions, and different semantic formalisms and languagespecific features were usually involved. For all our experiments, we used the L-BFGS algorithm for learning the feature weights, where feature weights were all initialized to zeros and the regularization hyper-parameter \u03ba was set to 0.01. We set the maximum number of L-BFGS steps to 100. When all the features are considered, our model creates over 2 million features for each language on the dataset (English: 2.1M, Thai: 2.3M, German: 2.7M, Greek: 2.6M). Our model requires (on average) a per-instance learning time of 0.428 seconds and a per-instance decoding time of 0.235 seconds, on an Intel machine with a 2.2 GHz CPU. Our implementation is in Java. Here the per-instance learning time refers to the time spent on computing the instance-level log-likelihood as well as the expected feature counts (needed for the gradients). Table 3 shows the evaluation results of our system as well as those of several other comparable previous works which share the same experimental setup as ours. UBL-S is the system presented in Kwiatkowski et al. (2010) which performs semantic parsing with the CCG based on mapping between graphs, and is the only non-tree based top-performing system. Their system, similar to ours, also uses a discriminative log-linear model where two types of features are defined. WASP is a model based on statistical phrase-based machine translation as we have described earlier. The hybrid tree model (HYBRIDTREE+) performs learning using a generative process which is augmented with an additional discriminative-reranking stage, where certain global features are incorporated (Lu et al., 2008) . The Bayesian tree transducer model (TREETRANS) learns under a Bayesian generative framework, using hyper-parameters manually tuned on the German training data. We can observe from Table 3 that the semantic parser based on relaxed hybrid tree gives competitive performance when all the features (described in Sec 3.4) are used. It significantly outperforms the hybrid tree model that is augmented with a discriminative reranking step. The model reports the best accuracy and F1 scores on English and Thai and best accuracy score on Greek. The scores on German are lower than those of UBL-S and TREETRANS, mainly because the span features appear not to be effective for this language, as we will discuss next. We report in ness vary across different languages. The local features, which capture local dependencies, are of particular importance. Performance on three languages (English, Thai, and Greek) will drop when such features are excluded. Character-level features are very helpful for the three European languages (English, German, and Greek), but appear to be harmful for Thai. This indicates the character-level features that we propose do not perform effective morphological analysis for this Asian language. 5 The span features, which are able to capture certain long-distance dependencies, also play important roles. Specifically, if such features are excluded, our model's performance on three languages (Greek, English, Thai) will drop. Such features do not appear to be helpful for Thai and appear to be harmful for German. Clearly, such long-distance features are not contributing useful information to the model when these two languages are considered. This is especially the case for German, where we believe such features are contributing substantial noisy information to the model. What underlying languagespecific, syntactic properties are generally causing these gaps in the performances? We believe this is an important question that needs to be addressed in future research. As we have mentioned, to make an appropriate comparison with previous works, only simple features are used. We believe that our system's performance can be further improved when additional informative languagespecific features can be extracted from effective language tools and incorporated into our system. Conclusions In this work, we present a new discriminative model for semantic parsing which extends the hy-brid tree model. Such an extension is similar to the extension of the generative syntactic parser based on probabilistic context-free grammars (PCFG) to the feature-based CRF parser (Finkel et al., 2008) , but is slightly more complex due to latent structures. Developed on top of our novel relaxed hybrid tree representations, our model allows certain long-distance dependencies to be captured. We also present efficient algorithms for learning and decoding. Experiments on benchmark data show that our model is competitive to previous works and achieves the state-of-the-art performance across several different languages. Future works include development of efficient algorithms for feature-based semantic parsing with alternative loss functions (Zhou et al., 2013) , development of feature-based language generation models (Lu et al., 2009; Lu and Ng, 2011) and multilingual semantic parsers (Jie and Lu, 2014) , as well as the development of efficient semantic parsing algorithms for optimizing the performance of certain downstream NLP tasks with less supervision (Clarke et al., 2010; Liang et al., 2013) . Being able to efficiently exploit features defined over individual words, our model also opens up the possibility for us to exploit alternative representations of words for learning (Turian et al., 2010) , or to perform joint learning of both distributional and logical semantics (Lewis and Steedman, 2013) . Furthermore, as a general string-to-tree structured prediction model, this work may find applications in other areas within NLP. The system and code can be downloaded from http://statnlp.org/research/sp/. Acknoledgments The author would like to thank the anonymous reviewers for their helpful comments. This work was supported by SUTD grant SRG ISTD 2013 064.",
    "funding": {
        "defense": 0.0,
        "corporate": 0.0,
        "research agency": 0.0,
        "foundation": 1.9361263126072004e-07,
        "none": 1.0
    },
    "reasoning": "Reasoning: The article does not mention any specific funding sources, acknowledgments of funding, or support from defense, corporate, research agencies, foundations, or any other entities. Therefore, based on the provided text, it appears there was no disclosed funding.",
    "abstract": "We propose a novel model for parsing natural language sentences into their formal semantic representations. The model is able to perform integrated lexicon acquisition and semantic parsing, mapping each atomic element in a complete semantic representation to a contiguous word sequence in the input sentence in a recursive manner, where certain overlappings amongst such word sequences are allowed. It defines distributions over the novel relaxed hybrid tree structures which jointly represent both sentences and semantics. Such structures allow tractable dynamic programming algorithms to be developed for efficient learning and decoding. Trained under a discriminative setting, our model is able to incorporate a rich set of features where certain unbounded long-distance dependencies can be captured in a principled manner. We demonstrate through experiments that by exploiting a large collection of simple features, our model is shown to be competitive to previous works and achieves state-of-theart performance on standard benchmark data across four different languages. The system and code can be downloaded from",
    "countries": [
        "Singapore"
    ],
    "languages": [
        "Greek",
        "Thai",
        "German",
        "English"
    ],
    "numcitedby": 13,
    "year": 2014,
    "month": "October",
    "title": "Semantic Parsing with Relaxed Hybrid Trees",
    "values": {
        "building on past work": " Introduction This area of research recently has received a significant amount of attention.  Background Following previous research efforts, we perform semantic parsing under a setting where the semantics for complete sentences are provided as training data, but detailed word-level semantic information is not explicitly given during the training phase. Certain assumptions about the semantics are typically made. One common assumption is that the semantics can be represented as certain recursive structures such as trees, which consist of atomic semantic units as tree nodes. We will provide more details about such tree structured semantic representations in Section 2.1.  Introduction In this work, we propose a novel model for parsing natural language into tree structured semantic representations. Specifically, we propose a novel relaxed hybrid tree representation which jointly encodes both natural language sentences and semantics; such representations can be effectively learned with a latent-variable discriminative model where long-distance dependencies can be captured.  Background The hybrid tree model (Lu et al., 2008) is based on the assumption that there exists an underlying generative process which jointly produces both the sentence and the semantic tree in a top-down recursive manner. The generative process results in a hybrid tree structure which consists of words as leaves and semantic units as nodes. Such a representation allows each semantic unit to map to a possibly discontiguous sequence of words. The model was shown to be effective empirically, but it implicitly assumes that both the sentence and semantics exhibit certain degree of structural similarity that allows the hybrid tree structures to be constructed.  Background Besides these supervised approaches, recently there are also several works that take alternative learning approaches to (mostly task-dependent) semantic parsing. Clarke et al. (2010) proposed a model that learns a semantic parser",
        "novelty": "We propose a novel model for parsing natural language sentences into their formal semantic representations. It defines distributions over the novel relaxed hybrid tree structures which jointly represent both sentences and semantics. Such structures allow tractable dynamic programming algorithms to be developed for efficient learning and decoding. Trained under a discriminative setting, our model is able to incorporate a rich set of features where certain unbounded long-distance dependencies can be captured in a principled manner.",
        "performance": "The model reports the best accuracy and F1 scores on English and Thai and best accuracy score on Greek. Performance on three languages (English, Thai, and Greek) will drop when such features are excluded. The span features, which are able to capture certain long-distance dependencies, also play important roles. Such features do not appear to be helpful for Thai and appear to be harmful for German. The system and code can be downloaded from http://statnlp.org/research/sp/."
    }
}