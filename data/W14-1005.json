{
    "article": "SCFG-based statistical MT models have proven effective for modelling syntactic aspects of translation, but still suffer problems of overgeneration. The production of German verbal complexes is particularly challenging since highly discontiguous constructions must be formed consistently, often from multiple independent rules. We extend a strong SCFG-based string-to-tree model to incorporate a rich feature-structure based representation of German verbal complex types and compare verbal complex production against that of the reference translations, finding a high baseline rate of error. By developing model features that use source-side information to influence the production of verbal complexes we are able to substantially improve the type accuracy as compared to the reference. Introduction Syntax-based models of statistical machine translation (SMT) are becoming increasingly competitive against state-of-the-art phrase-based models, even surpassing them for some language pairs. The incorporation of syntactic structure has proven effective for modelling reordering phenomena and improving the fluency of target output, but these models still suffer from problems of overgeneration. One example is the production of German verbal constructions. This is particularly challenging for SMT models since highly discontiguous constructions must be formed consistently, often from multiple independent rules. Whilst the model's grammar may contain rules in which a complete multi-word verb translation is captured in a single discontiguous rule, in practice many verb translations are incompletely or inconsistently produced. There are many routes by which ill-formed constructions come to be licensed by the model, none of which is easy to address. For instance, Figure 1 shows an example from our training data in which a missing alignment link (between has and ist) allows the extraction of rules that translate has failed to the incomplete fehlgeschlagen. Even with perfect word alignments, the extracted rules may not include sufficient context to ensure the overall grammaticality of a derivation. The extent of this problem will depend partly on the original treebank annotation style, which typically will not have been designed with translation in mind. The problem may be further exacerbated by errors during automatic parsing. In this paper, we address the problem by focusing on the derivation process. We extend a strong SCFG-based string-to-tree model to incorporate a rich feature-structure based representation of German verbal complex types. During decoding, our model composes type values for every clause. When we compare these values against those of the reference translations, we find a high baseline rate of error (either incomplete or mismatching values). By developing model features that use source-side information to influence the production of verbal complexes we are able to substantially improve the type accuracy as compared to the reference. Verbal Complex Structures Adopting the terminology of Gojun and Fraser (2012) , we use the term 'verbal complex' to mean a main verb and any associated auxiliaries within a single clause. Feature Structures We use feature structures to represent the underlying grammatical properties of German verbal complexes. The feature structures serve two main functions: the first is to specify a type for the verbal complex. The types describe clause-level properties and are defined along four dimensions: 1. tense (present, past, perfect, pluperfect, future, future perfect), 2. voice (active, werden-passive, sein-passive), 3. mood (indicative, subjunctive I, subjunctive II), and 4. auxiliary modality (modal, non-modal). The second function is to restrict the choice of individual word forms that are allowed to combine within a given type. For example, a feature structure value for the verbal complex hat . . . gespielt belongs to the perfect, active, indicative, non-modal type. Additionally, it specifies that for this type, the verbal complex comprises exactly two verbs: one is a finite, indicative form of the auxiliary haben or sein, the other is a pastparticiple. The Lexicon Our model uses a lexicon that maps each German verb in the target-side terminal vocabulary to a set of features structures. Each feature structure contains two top-level features: POS, a part-of-speech feature, and VC, a verbal complex feature of the form described above. Since a verbal complex can comprise multiple individual verbs, the lexicon entries include partial VC structures. The full feature structure values are composed through unification during decoding. VP-OC \u2192 rebuilt , wieder aufgebaut The VC values are assigned according to POS value from a small set of hand-written feature structures. Every main verb is assigned VC values from one of three possible groups, selected according to whether the verb is finite, a past-participle, or an infinitive. For the closed class of modal and nonmodal auxiliary verbs, VC values were manually assigned. VP-OC VC = aufgebaut VC aufgebaut POS = VVPP S-TOP \u2192 X 1 have X 2 been X 3 , PP-MO 1 wurde NP-SB 2 VP-OC 3 S-TOP VC = wurde VC S-TOP VC = VP-OC VC wurde POS = VAFIN The Grammar Our baseline translation model is learned from a parallel corpus with automatically-derived word alignments. In the literature, string-to-tree translation models are typically based on either synchronous context-free grammars (SCFGs) (as in Chiang et al. (2007) ) or tree transducers (as in Galley et al. (2004) ). In this work, we use an SCFGbased model but our extensions are applicable in both cases. Following Williams and Koehn (2011) , each rule of our grammar is supplemented with a (possibly-empty) set of PATR-II-style identities (Shieber, 1984) . Figure 2 shows two example rules with identities. The identities should be interpreted as constraints that the feature structures of the corresponding rule elements are compatible under unification. During decoding, this imposes a hard constraint on rule application. Identity Extraction The identities are learned using the following procedure: 1. The syntax of the German parse trees is used to identify verbal complexes and label the participating verb and clause nodes. 2. Grammar rule extraction is extended to generate identities between VC values when an SCFG rule contains two or more nodes from a common verbal complex. 3. POS identities are added for terminals that appear in VC identities. Figure 3 shows a sentence-pair from the training data with the verbal complex highlighted. The rules in Figure 2 were extracted from this sentence-pair. Crucially, in step 2 of the extraction procedure the identities can be added to SCFG rules that cover only part of a verbal complex. For example, the first rule of Figure 2 includes the main verb but not the auxiliary. On application of this rule, the partial VC value is propagated from the main verb to the root. The second rule in Figure 2 identifies the VC value of an auxiliary with the VC value of a VP-OC subderivation (such as the subderivation produced by applying the first rule). Source-side Features Since Och and Ney (2002) , most SMT models have been defined as a log-linear sum of weighted feature functions. In this section, we define two verbal-complex-specific feature functions. In order to do so, we first describe 'clause projection,' a simple source-syntactic restriction on decoding. We then describe our heuristic method of obtaining probability estimates for a target verbal complex value given the source clause. Clause Projection Our feature functions assume that we have an alignment from source-side clauses to target clauses. In order to satisfy this requirement, we adopt a simple restriction that declarative clauses (both main and embedded) on the source-side must be translated as clauses on the target-side. This is clearly an over-simplification from a linguistic perspective but it appears not to harm translation quality in practice. Table 1 shows small gains in BLEU score over our baseline system with this restriction. Clause projection is implemented as follows: 1. The input sentence is parsed and a set of clause spans is extracted according to the 1-best parse. We use the Berkeley parser (Petrov and Klein, 2007) , which is trained on the Penn Treebank and so we base our definition of a declarative clause on the treebank annotation guidelines. 2. We modify the decoder to produce derivations in chart cells only if the cell span is consistent with the set of clause spans (i.e. if source span [i,j] is a clause span then no derivation is built over span [m,n] where i < m \u2264 j and n > j, etc.) 3. We modify the decoder so that grammar rules can only be applied over clause spans if they have a clause label ('S' or 'CS', since the parser we use is trained on the Tiger treebank). Verbal Complex Probabilities When translating a clause, the source-side verbal complex will often provide sufficient information to select a reasonable type for the target verbal complex, or to give preferences to a few candidates. By matching up source-side and target-side verbal complexes we estimate co-occurrence frequencies in the training data. To do this for all pairs in the training data, we would need to align clauses between the source and target training sentences. However, it is not crucial that we identify every last verbal complex and so we simplify the task by restricting training data to sentence pairs in which both source and target sentences are declarative sentences, making the assumption that the main clause of the source sentence aligns with the main clause of the target. We represent source-side verbal complexes with a label that is the string of verbs and particles and their POS tags in the order that they occur in the clause, e.g. plays VBZ, is addressing VBZ VBG. The target-side feature structures are generated by identifying verbal complex nodes in the training data parse trees (as in Section 3.1) and then unifying the corresponding feature structures from the lexicon. Many source verbal complex labels exhibit a strong co-occurrence preference for a particular target type. For example, Table 2 shows the three most frequent feature structure values for the target-side clause when the source label is is closed VBZ VBN. The most frequent value corresponds to a non-modal, sein-passive construction in the present tense and indicative mood. RF F-Structure 0.841 \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 FIN AUX LEMMA sein MOOD indicative TENSE present NON-FIN PP/SP PP LEMMA * \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb 0.045 FIN FULL LEMMA sein NON-FIN none 0.034 \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 FIN AUX LEMMA werden MOOD indicative TENSE present NON-FIN \uf8ee \uf8ef \uf8f0 WPP \uf8ee \uf8ef \uf8f0 PP LEMMA * WERDEN none WORDEN none SEIN none \uf8f9 \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb . . . . . . Feature Functions As with the baseline features, our verbal complexspecific feature functions are evaluated for every rule application r i of the synchronous derivation. Like the language model feature, they are nonlocal features and so cannot be pre-computed. Unlike the baseline features, their value depends on whether the source span that the rule is applied to is a declarative clause or not. Both features are defined in terms of X, the verbal complex feature structure value of the subderivation at rule application r i . The first feature function, f (r i ), uses the source verb label, l, and the probability estimate, P (X|l), learned from the training data: f (r i ) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f3 P (X|l) if r i covers a clause span with verb label l and c l \u2265 c min 1 otherwise The probability estimates are not used for scoring if the number of training observations falls below a threshold, c min . We use a threshold of 10 in experiments. The second feature function, g(r i ), is simpler: it penalizes the absence of a target-side finite verb when translating a source declarative clause: g(r i ) = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 exp(1) if r i covers a clause span and X has no finite verb 1 otherwise Unlike f , which requires the verb label to have been observed a number of times during training, g is applied to all source spans that cover a declarative clause. Dropped finite verbs are a frequent problem in our baseline model and this feature was motivated by an early version of the analysis presented in Section 5.3. Experiments and Analysis In preliminary experiments, we found that changes in translation quality resulting from our verb translation features were difficult to measure using BLEU. In the following experiments, we measure accuracy by comparing verbal complex values against feature structures derived from the reference sentences. Setup Our experiments use the GHKM-based string-totree pipeline implemented in Moses (Koehn et al., 2007; Williams and Koehn, 2012) . We extend a conventional baseline model using the constraints and feature functions described earlier. We extracted a translation grammar using all English-German parallel data from the WMT 2012 translation task (Callison-Burch et al., 2012) , a total of 2.0M sentence pairs. We used all of the WMT 2012 monolingual German data to train a 5-gram language model. The baseline system uses the feature functions described in Williams and Koehn (2012) . The feature weights were tuned on the WMT new-stest2008 development set using MERT (Och, 2003) . We use the newstest2009, newstest2010, and newstest2011 test sets for evaluation. The development and test sets all use a single reference. Main Clause Verb Errors When translating a declarative main clause, the translation should usually also be a declarative main clause -that is, it should usually contain at least a finite verb. From manually inspecting the output it is clear that verb dropping is a common source of translation error in our baseline system. By making the assumption that a declarative main clause should always be translated to a declarative main clause, we can use the absence of a finite verb as a test for translation error. By evaluating identities, our decoder now generates a trace of verbal complex feature structures. We obtain a reference trace by applying the same process of verbal complex identification and feature structure unification to a parse of our reference data. Given these two traces, we compare the presence or absence of main clause finite-verbs in the baseline and reference. Since we do not have alignments between the clause nodes of the test and reference trees, we restrict our analysis to a simpler version of this task: the translation of declarative input sentences that contain only a single clause. To select test sentences, we first parse the source-side of the tuning and test sets. Filtering out sentences that are not declarative or that contain multiple clauses leaves 633, 699, 793, and 953 input sentences for new-stest2008, 2009, 2010, and 2011, respectively. Our baseline system evaluates constraints in order to generate a trace of feature structures but constraint failures are allowed and hypotheses are retained. Our hard constraint system discards all hypotheses for which the constraints fail. The f and g feature functions are not used in these experiments. For all main clause nodes in the output tree, we count the number of feature structure values that contain finite verbs and are complete versus the number that are either incomplete or absent. Since constraint failure results in the production of empty feature structures, incompatible verbal combinations do not contribute to the finite verb total even if a finite verb is produced. We compare the counts of clause nodes with empty feature structures for these two systems against those of the reference set. Table 3 shows total clause counts for the reference, baseline, and hard constraint system (the 'total' columns). For each system, we record how frequently a complete feature structure containing at least a finite verb is present (the F columns) or not (E). As expected, the finite verb counts for the reference translations closely match the counts for the source sentences. The reference sets also contain verb-less clauses (accounting for 4.4% and 7.8% of the total clause counts for the dev and test sets). Verb-less clauses are common in the training data and so it is not surprising to find them in the reference sets. Our baseline and hard constraint systems both fail to produce complete feature structures for a high proportion of test sentences. Table 4 shows the proportion of single-clause declarative source sentences for which the translation trace does not include a complete feature structure. As well as suggesting a high level of baseline failure, these results suggest that using constraints alone is insufficient. Test set Ref. Baseline HC newstest2008 0.0% 13.9% 11.7% newstest2009 0.6% 18.6% 16.0% newstest2010 0.0% 14.5% 12.5% newstest2011 1.4% 17.4% 14.4% Table 4 : Proportion of declarative single-clause sentences for which there is not a complete feature structure for the translation. Ref. is the reference and HC is our hard constraint system. Error Classification In order to verify that the incomplete feature structures indicate genuine translation errors and to understand the types of errors that occur, we manually check 100 sentences from our baseline system and classify the errors. We check the verb constructions of the sentences containing the first 50 failures in newstest2009 and the first 50 failures in newstest2011. Invalid Combination ( 27 ) An ungrammatical combination of auxiliary and main verbs. Example: im Jahr 2007 hatte es bereits um zwei Drittel reduziert worden . Perfect missing aux (25) There is a pastparticiple in sentence-final position, but no auxiliary verb. Example: der Dow Jones etwas sp\u00e4ter wieder bereitgestellt . False positive ( 14 ) Output is OK. In the sample this happens either because the output string is well-formed in terms of verb structure, but the tree is wrong, or because the parse of the source is wrong and the input does not actually contain a verb. No verb (13) The input contains at least one verb that should be translated but the output contains none. Example: der universelle Charakter der Handy auch Nachteile . Invalid sentence structure (13) Verbs are present and make sense, but sentence structure is wrong Example: die rund hunderttausend Menschen in Besitz von ihren eigenen Chipcard Opencard in dieser Zeit , diese Kupon bekommen kann . Inf missing aux (5) There is an infinitive in sentence-final position, but no auxiliary verb or the main verb is erroneously in final position (the output is likely to be ambiguous for this error type). Example: die Preislisten dieser Unternehmen in der Regel nur ausgew\u00e4hlte Personen erreichen . Unknown verb (2) The input verb is untranslated. Example: dann scurried ich auf meinem Platz . Werden-passive missing aux (1) There is a werden-passive non-finite part, but no finite auxiliary verb. Example: die meisten ger\u00e4umigen und luxuri\u00f6sesten Wohnung im ersten Stock f\u00fcr die \u00d6ffentlichkeit ge\u00f6ffnet worden . In our classification, the most common individual error type in the baseline is the ungrammatical combination of verbs, at 27 out of 100. However, there are multiple categories that can be characterized as the absence of a required verb and combined these total 44 out of 100 errors. There are also some false positives and potentially misleading results in which wider syntactic errors result in the failure to produce a feature structure, but the majority are genuine errors. However, this method fails to identify instances where the verbal complex is grammatical but has the wrong features. For that, we compare accuracy against reference values. Feature Structure Accuracy If we had gold-standard feature structures for our reference sets and alignments between test and reference clauses then we could evaluate accuracy by counting the number of matches and reporting precision, recall, and F-measure values for this task. In the absence of gold reference values, we rely on values generated automatically from our reference sets. This requires accepting some level of error from parsing and verb labelling (we perform a manual analysis to estimate the degree of this problem). We also require alignments between  test and reference clauses. Here we make the same simplification as in Section 5.2 and restrict evaluation to single-clause declarative sentences. We test the effect of the f and g features on feature structure accuracy. Their log-linear model weights were tuned by running a line search to optimize the F1 score on a subset of the new-stest2008 dev set containing sentences up to 30 tokens in length (all baseline weights were fixed). For the experiments in which both features are used, we first tune the weight for f and then tune g with the f weight fixed. Table 5 reports feature structure accuracy for the development and test sets. On the test set, the individual f and g features both improve the F1 score. f is effective in terms of both precision and recall, but the g feature degrades precision compared to the baseline. Using both features appears to offer little benefit beyond using f alone. Compared with the baseline or using hard con-straints alone (Table 3 ), the proportion of sentences with incomplete or inconsistent verbal complex values (column E) is substantially reduced by the f and g feature functions. To estimate the false match rate, we manually checked the first 50 sentences from the 2009 test set in which one system was reported to agree with reference and the other not: 37/50 Verb constructions are grammatical. We agree with comparisons against the reference value. 9/50 Verb constructions are grammatical. We agree with the comparison for the test system but not the baseline. 4/50 Verb constructions are ungrammatical or difficult to interpret in both baseline and test. Figure 4 shows some example translations from our system. BLEU Finally, we report BLEU scores for two versions of our dev and test sets: in addition to the full data sets (Table 6 ), we use sub-sets that contain all source sentences up to 30 tokens in length (Table 7). There are two reasons for this: first, we expect shorter sentences to use simpler sentence structure with less coordination and fewer relative and subordinate clauses. All else being equal, we expect to see a greater degree of high-level structural divergence between complex source and target sentence structures than between simple ones. We therefore anticipate that our naive clause projection strategy is more likely to break down on long sentences. Second, we expect the effects on BLEU score to become diluted as sentence length increases, for the simple reason that verbs are likely to account for a smaller proportion of the total number of words (though this effect seems to be small: in a parse of the newstest2009-30 subset, verbs account for 14.2% of tokens; in the full set they account for 13.1%). We find that the change in BLEU is larger for the constrained test sets, but only slightly. 6 Related Work The problem of verbal complex translation in English-to-German is tackled by Gojun and Fraser (2012) in the context of phrase-based SMT. They overcome the reordering limitation of phrase-based SMT by preprocessing the sourceside of the training and test data to move English verbs within clauses into more 'German-like' positions. In contrast, our SCFG-based baseline model does not place any restriction on reordering distance. Arora and Mahesh (2012) address a similar problem in English-Hindi translation. They improve a phrase-based model by merging verbs and associated particles into single tokens, thus simplifying the task of word alignment and phrase-pair extraction. Their approach relies upon the mostlycontiguous nature of English and Hindi verbal complexes. The discontiguity of verbal complexes rules out this approach for translation into German. Our model adopts a similar constraint-based extension of SCFG to that described in Williams and Koehn (2011) . In that work, constraints are used to enforce target-side agreement between nouns and modifiers and between subjects and verbs. Whilst that constraint model operates purely on the targetside, our verbal complex feature functions also take source-side information into account. Conclusion We have presented a model in which a conventional SCFG-based string-to-tree system is extended with a rich feature-structure based representation of German verbal complexes, a grammatical construction that is difficult for an SMT model to produce correctly. Our feature structure representation enabled us to easily identify where our baseline model made errors and provided a means to measure accuracy against the reference translations. By developing feature functions that use source-side information to influence verbal complex formation we were able to improve translation quality, measured both in terms of BLEU score where there were small, consistent gains across the test sets, and in terms of taskspecific accuracy. In future work we intend to explore the use of richer models for predicting target-side verbal complex types. For example, discriminative models that include non-verbal source features. Acknowledgements We would like to thank the anonymous reviewers for their helpful feedback and suggestions. The research leading to these results has received funding from the European Union Seventh Framework Programme (FP7/2007-2013) under grant agreement 287658 (EU-BRIDGE).",
    "abstract": "SCFG-based statistical MT models have proven effective for modelling syntactic aspects of translation, but still suffer problems of overgeneration. The production of German verbal complexes is particularly challenging since highly discontiguous constructions must be formed consistently, often from multiple independent rules. We extend a strong SCFG-based string-to-tree model to incorporate a rich feature-structure based representation of German verbal complex types and compare verbal complex production against that of the reference translations, finding a high baseline rate of error. By developing model features that use source-side information to influence the production of verbal complexes we are able to substantially improve the type accuracy as compared to the reference.",
    "countries": [
        "United Kingdom"
    ],
    "languages": [
        "English",
        "German"
    ],
    "numcitedby": "2",
    "year": "2014",
    "month": "April",
    "title": "Using Feature Structures to Improve Verb Translation in {E}nglish-to-{G}erman Statistical {MT}"
}