{
    "article": "This paper proposes a direct parsing of non-local dependencies in English. To this end, we use probabilistic linear context-free rewriting systems for data-driven parsing, following recent work on parsing German. In order to do so, we first perform a transformation of the Penn Treebank annotation of non-local dependencies into an annotation using crossing branches. The resulting treebank can be used for PLCFRS-based parsing. Our evaluation shows that, compared to PCFG parsing with the same techniques, PLCFRS parsing yields slightly better results. In particular when evaluating only the parsing results concerning long-distance dependencies, the PLCFRS approach with discontinuous constituents is able to recognize about 88% of the dependencies of type *T* and *T*-PRN encoded in the Penn Treebank. Even the evaluation results concerning local dependencies, which can in principle be captured by a PCFG-based model, are better with our PLCFRS model. This demonstrates that by discarding information on non-local dependencies the PCFG model loses important information on syntactic dependencies in general. Introduction Discontinuous constituents as exemplified in (1) are more frequent than generally assumed, even in languages such as English that display a rather rigid word order. In (1), the NP areas of the factory where the crocidolite was used is separated into two non-adjacent parts. (1) is an example from the Penn Treebank (PTB). More generally, all constructions where head-argument or headmodifier dependencies are non-local, such as whmovement, can be seen as instances of discontin-uous constituency. Such instances appear in about 20% of the sentences in the PTB. They constitute a particular challenge for parsing. (1) Areas of the factory were particularly dusty where the crocidolite was used. In the past, data-driven parsing has largely been dominated by Probabilistic Context-Free Grammar (PCFG). This is partly due to the annotation formats of treebanks such as the Penn Treebank (PTB) (Marcus et al., 1994) , which are used as a data source for grammar extraction. Their annotation generally relies on the use of trees without crossing branches, augmented with a mechanism that accounts for non-local dependencies. In the PTB, e.g., labeling conventions and trace nodes are used which establish additional implicit edges in the tree beyond the overt phrase structure. However, given the expressivity restrictions of PCFG, work on data-driven parsing has mostly excluded non-local dependencies. When using treebanks with PTB-like annotation, labeling conventions and trace nodes are often discarded. Some work has however been done towards incorporating non-local information into data-driven parsing. One general way to do this is (nonprojective) dependency parsing where parsers are not grammar-based and the notion of constituents or phrases is not employed, see e.g. McDonald et al. (2005) or Nivre (2009) . Within the domain of grammar-based constituent parsing, we can distinguish three approaches (Nivre, 2006) : 1. Non-local information can be reconstructed in a post-processing step after PCFG parsing (Johnson, 2002; Levy and Manning, 2004; Jijkoun and de Rijke, 2004; Campbell, 2004; Gabbard et al., 2006) . 2. Non-local information can be incorpo- CFG: A \u03b3 LCFRS: \u2022 A \u2022 \u2022 \u03b3 1 \u03b3 2 \u03b3 3 Figure 1: Different domains of locality rated into the PCFG model (Collins, 1999) or into complex labels (Dienes and Dubey, 2003; Hockenmaier, 2003; Cahill et al., 2004) . 3. A formalism can be used which accommodates the direct encoding of non-local information (Plaehn, 2004; Maier and Kallmeyer, 2010; Kallmeyer and Maier, 2010) . This paper pursues the third approach. Our work is based on recent research in using Linear Context-Free Rewriting Systems (LCFRS) (Vijay-Shanker et al., 1987) for data driven parsing. LCFRSs extend CFGs such that nonterminals can span tuples of possibly non-adjacent strings (see Fig. 1 ). This enables them to describe discontinuous constituents and non-projective dependencies (Kuhlmann and Satta, 2009; Maier and Lichte, 2009) . Furthermore, they are able to capture synchronous derivations, something that is empirically attested in treebanks (Kallmeyer et al., 2009) . In order to parse German, a language where discontinuities are particularly frequent, Kallmeyer and Maier (2010) ; Maier and Kallmeyer (2010) use probabilistic LCFRSs (PLCFRSs). As a data source, they use the German NEGRA and TIGER treebanks that annotate discontinuous constituents by using crossing branches. We adapt this approach for German to English, using the PTB. For this, we first need to transform the trace-based annotation of discontinuous constituents into an annotation with crossing branches which requires a careful treatment of the different types of traces that occur in the PTB. Then we extract a PLCFRS from the resulting treebank and we use the PLCFRS parser from Kallmeyer and Maier for our parsing experiments. The paper is structured as follows. Section 2 introduces PLCFRS and the parsing algorithm. The next section explains the transformation of the PTB into an annotation format where nonlocal dependencies are annotated with crossing branches. Section 4 describes further transformations we apply to the resulting treebanks, in particular binarization and category splitting. Finally, section 5 reports the results or our parsing experiments with a detailed evaluation of the way the different types of long-distance dependencies are captured. Section 6 concludes. PLCFRS Parsing PLCFRS LCFRSs are an extension of CFG where the non-terminals can span not only single strings but, instead, tuples of strings (see Fig. 1 ). An LCFRS (Vijay-Shanker et al., 1987 ) is a tuple N, T, V, P, S where a) N is a finite set of non-terminals with a function dim: N \u2192 N; dim(A) is called the fanout of A and determines the dimension of the tuples in the yield of A; b) T and V are disjoint finite sets of terminals and variables; c) S \u2208 N is the start symbol with dim(S) = 1; d) P is a finite set of rules A(\u03b1 1 , . . . , \u03b1 dim(A) ) \u2192 A 1 (X (1) 1 , . . . , X (1) dim(A1) ) \u2022 \u2022 \u2022 A m (X (m) 1 , . . . , X (m) dim(Am) ) for m \u2265 0 where A, A 1 , . . . , A m \u2208 N , X (i) j \u2208 V for 1 \u2264 i \u2264 m, 1 \u2264 j \u2264 dim(A i ) and \u03b1 i \u2208 (T \u222a V ) * for 1 \u2264 i \u2264 dim(A). For all r \u2208 P , it holds that every variable X occurring in r occurs exactly once in the left-hand side (LHS) and exactly once in the right-hand side (RHS). A rewriting rule describes how the yield of the LHS non-terminal can be computed from the yields of the RHS non-terminals. The rules A(ab, cd) \u2192 \u03b5 and A(aXb, cY d) \u2192 A(X, Y ) for instance specify that 1. ab, cd is in the yield of A and 2. one can compute a new tuple in the yield of A from an already existing one by wrapping a and b around the first component and c and d around the second. For every A \u2208 N in a LCFRS G, we define the yield of A, yield(A) as follows: a) For every A( \u03b1) \u2192 \u03b5, \u03b1 \u2208 yield(A); b) For every rule A(\u03b1 1 , . . . , \u03b1 dim(A) ) \u2192 A 1 (X (1) 1 , . . . , X (1) dim(A1) ) \u2022 \u2022 \u2022 A m (X (m) 1 , . . . , X (m) dim(Am) ) and all \u03c4 i \u2208 yield(A i ) for 1 \u2264 i \u2264 m, f (\u03b1 1 ), . . . , f (\u03b1 dim(A) ) \u2208 yield(A) where f is defined as follows: (i) f (t) = t for all t \u2208 T , (ii) f (X (i) j ) = \u03c4 i (j) for all 1 \u2264 i \u2264 m, 1 \u2264 j \u2264 dim(A i ) and (iii) f (xy) = f (x)f (y) for all x, y \u2208 (T \u222a V ) + . f is the composition func- tion of the rule. c) Nothing else is in yield(A). The language is then {w | w \u2208 yield(S)}. The fan-out of an LCFRS G is the maximal fanout of all non-terminals in G. An LCFRS with a fan-out of n is called an n-LCFRS. Furthermore, the RHS length of a rewriting rules r \u2208 P is called the rank of r and the maximal rank of all rules in P is called the rank of G. We call a LCFRS monotone if for every r \u2208 P and every RHS nonterminal A in r and each pair X 1 , X 2 of arguments of A in the RHS of r, X 1 precedes X 2 in the RHS iff X 1 precedes X 2 in the LHS. A probabilistic LCFRS (PLCFRS) (Kato et al., 2006 ) is a tuple N, T, V, P, S, p such that N, T, V, P, S is a LCFRS and p : P \u2192 [0..1] a function such that for all A \u2208 N : \u03a3 A( x)\u2192 \u03a6\u2208P p(A( x) \u2192 \u03a6) = 1. CYK Parsing We use the parser from Kallmeyer and Maier (2010) ; Maier (2010) , Maier and Kallmeyer (2010) which is a probabilistic version of the CYK parser from Seki et al. (1991) , applying techniques of weighted deductive parsing (Nederhof, 2003) . LCFRSs can be binarized (G\u00f3mez-Rodr\u00edguez et al., 2009) and \u03b5-components in the LHS of rules can be removed (Boullier, 1998) . We can therefore assume that all rules are of rank 2 (in section 4.1, we explain our binarization technique) and do not contain \u03b5 components in their LHSs. Furthermore, we assume POS tagging to be done before parsing. POS tags are non-terminals of fan-out 1. The rules are then either of the form A(a) \u2192 \u03b5 with A a POS tag and a \u2208 T or of the form A( \u03b1) \u2192 B( x) or A( \u03b1) \u2192 B( x)C( y) where \u03b1 \u2208 (V + ) dim(A) , i.e., only the rules for POS tags contain terminals in their LHSs. For every w \u2208 T * , we call every pair l, r with 0 \u2264 l \u2264 r \u2264 |w| a range in w. The concatenation of two ranges \u03c1 1 = l 1 , r 1 , \u03c1 2 = l 2 , r 2 is de- fined as follows: if r 1 = l 2 , then \u03c1 1 \u2022 \u03c1 2 = l 1 , r 2 ; otherwise \u03c1 1 \u2022 \u03c1 2 is undefined. For a given rule p : A(\u03b1 1 , . . . , \u03b1 dim(A) ) \u2192 B(X 1 , . . . , X dim(B) )C(Y 1 , . . . , X dim(C) ) we now extend the composition function f to ranges, given an input w: for all vectors of ranges \u03c1 B and \u03c1 C of dimensions dim(B) and dim(C) respectively, f r ( \u03c1 B , \u03c1 C ) = g(\u03b1 1 ), . . . , g(\u03b1 dim(A) ) is defined as follows: g( if there is no z with z : X i ) = \u03c1 B (i) for all 1 \u2264 i \u2264 Scan: 0 : [A, i, i + 1 ] A POS tag of w i+1 Unary: in : [B, \u03c1] in + |log(p)| : [A, \u03c1] p : A( \u03b1) \u2192 B( \u03b1) \u2208 P Binary: in B : [B, \u03c1 B ], in C : [C, \u03c1 C ] in B + in C + log(p) : [A, \u03c1 A ] where p : A( \u03c1 A ) \u2192 B( \u03c1 B )C( \u03c1 C ) is an instantiated rule. Goal: [S, 0, n ] I \u2032 \u2208 C \u222a A then add y : I \u2032 to A else if z : I \u2032 \u2208 A for some z then update weight of I \u2032 in A to max (y, z) Figure 3: Weighted deductive parsing dim(B), g(Y i ) = \u03c1 C (i) for all 1 \u2264 i \u2264 dim(C) and g(xy) = g(x) \u2022 g(y) for all x, y \u2208 V + . p : A(f r ( \u03c1 B , \u03c1 C )) \u2192 B( \u03c1 B )C( \u03c1 C ) is then called an instantiated rule. 1 For a given input w, our items have the form [A, \u03c1] where A \u2208 N , \u03c1 a vector of ranges with | \u03c1| = dim(A). \u03c1 characterizes the span of A. We specify the set of weighted parse items via the deduction rules in Fig. 2 . The parser performs a weighted deductive parsing (Nederhof, 2003) , based on this deduction system. It uses a chart C and an agenda A, both initially empty, and proceeds as in Fig. 3 . Treebank Transformation The PTB annotation guidelines (Bies et al., 1995 , Section 1.1) specify a set of rules that determine where arguments and adjuncts are attached with respect to their head words. For example, subjects are attached at clause level, most other arguments and adjuncts of verbs are attached at VP level, and phrases modifying nouns such as PPs and relative clauses are adjoined at NP level. Knowing these rules, head-argument and head-adjunct dependencies can be read off the trees easily, e.g. for semantic interpretation. Non-local head-argument and head-adjunct dependencies constitute exceptions to these rules. Following the rules would lead to discontinuous constituents with crossing branches, containing the head and the argument or adjunct, but not containing some intervening tokens. Examples of non-locally dependent arguments and adjuncts include wh-moved phrases, fronted phrases, extraposed modifiers, it-extraposition, and right-noderaised phrases (Fig. 4a-d ). Such phrases are attached at locations in the tree that avoid discontinuity, thus the heads on which they depend cannot easily be determined from the tree structure alone. The PTB instead uses the null elements *T*, *ICH*, *EXP* and *RNR* to mark the position where the phrases would be attached according to the general rules and indices in node labels to indicate which null element stands for which phrase (shown by arcs in the tree diagrams). Null elements are embedded in \"placeholder phrases\" of the same category (but without WH prefixes) as the non-locally dependent phrase. This representation of non-local dependencies is not suitable for PCFG parsing since null elements pose a serious combinatorial problem and PCFG has no mechanism for dealing with indexed category labels. Null elements and indices are therefore usually removed before training PCFG parsers, resulting in parse trees that do not contain information on nonlocal dependencies. We use the approach proposed and tested on the German treebanks NEGRA and TIGER in Maier and Kallmeyer (2010) : permit discontinuous constituents, attach non-locally dependent arguments and adjuncts according to the general rules, resulting in a uniform representation for local and nonlocal dependencies, and use PLCFRS for parsing. While NEGRA and TIGER already use such a uniform representation, training and testing data for English can be obtained by removing placeholder phrases with *T*, *ICH*, *EXP* and *RNR* null elements from their locations in the PTB trees and reattaching the coindexed phrases to those locations, removing indices from node labels (Fig. 5 ). Other types of null elements are used to indicate control and other relations with no immediate bearing on non-local head-adjunct and headargument dependencies. We remove these from the treebank along with corresponding indices. Two types of cases require special treatment. First, some arguments and adjuncts are shared between two or more heads, marked by two or more null elements with the same index (Fig. 4(d) ). Since a phrase cannot be attached to more than one location in a tree even with crossing branches, the phrase must either remain in place, where no relation to any head can be immediately read off the tree, or be attached according to the general rules with respect to only one of the heads, leaving the others with no trace of the argument or adjunct. For now, we decided to put consistency in the way arguments and adjuncts are attached first and always attach phrases with multiple heads as depending on the head which is closest (Fig. 5(d) ). The other special case concerns phrases, typically quotations, that surround the matrix phrase containing the head on which they depend. In the PTB annotation, the matrix phrase is embedded into such arguments under a node labeled PRN for parenthesis (Fig. 4 (e)). To avoid cycles after the transformation, such matrix phrases are detached from within the argument and reattached to the node where the argument was originally attached, if any (Fig. 5(e)) . Table 1 gives an overview of the tendency of each type of null element 2 to introduce gaps when so transformed as indicated by gap-degree (Holan et al., 1998; Maier and Lichte, 2009) , i.e. the maximal number of gaps in any constituent of the resulting trees. Most typically, one gap is introduced since there is a single phrase non-adjacent to the rest of the phrase to which it is attached. No gap at all is introduced by the reattachment of most whmoved subjects and *EXP*-type phrases in object position. Gap degrees of 2 are almost exclusively accounted for by surrounding phrases where the VP of the surrounded matrix clause is typically interrupted by two commas and the subject of the matrix clause. On the whole, about 20% of the trees in the transformed PTB contain discontinuities -less than the c. 30% reported by Maier and Lichte (2009) for the German treebanks NEGRA and TIGER, but still a considerable percentage. An LCFRS is extracted from the transformed treebank using the algorithm of Maier and S\u00f8gaard (2008) , simplified using the fact that leaves do not have siblings and their parents are labeled with POS tags: every leaf is represented as a variable. Every internal node n is represented as a term A i (X 11 . . . X 1j 1 , . . . , X i1 . . . X ij i ) where X 11 , . . . , X 1j 1 , . . . , X i1 . . . X ij 1 represent the leaves dominated by n in order, there is an argument boundary between two variables iff the corresponding leaves are non-adjacent, A is the label of n and i is the number of arguments, used to obtain a unique non-terminal A i with fan-out i. A rule \u03b1 \u2192 \u03b2 1 . . . \u03b2 m is extracted for each internal node n such that \u03b1 is the term representing n and \u03b2 1 , . . . , \u03b2 m are the terms representing its children, conventionally ordered by leftmost dominated terminal. For parents of leaves, m is 0, and the single variable in \u03b1 is replaced with the terminal labeling the corresponding leaf. For other nodes, every sequence of variables that occurs as a right-hand side argument is replaced with a single new variable on both sides. Fig. 6 shows an example. Rules are equivalent if equal up to renaming variables. The resulting LCFRS rules are \u03b5-free and they are monotone. The latter means that the order of the arguments of a RHS element is the same as the order of these variables in the LHS. Both properties facilitate parsing. The number of occurrences of the rules are counted and the probabilities of RHSs conditioned on LHSs are then calculated using MLE. In this way, a PLCFRS is obtained. This is a very simple probability model, much like a vanilla PCFG. In the following section, we discuss techniques we used to refine the probability model. Grammar Annotation Binarization Similarly to the transformation of a CFG into Chomsky Normal Form (CNF), we binarize the LCFRS extracted from the treebank. The result is an LCFRS of rank 2. A binarization technique that results in horizontal Markovization of Extracted LCFRS rules: the grammar is proposed and successfully used for parsing NEGRA and TIGER in Kallmeyer and Maier (2010) . However, our experiments have shown that the beneficial effect of this horizontal Markovization technique does not carry over to parsing the PTB, presumably because compared to the two German treebanks, the PTB has a more hierarchical annotation scheme, extracted grammars have rules with shorter RHSs to begin with and can thus profit less from additional factorization; the adverse effect of wrong independence assumptions predominates. We thus use a deterministic binarization technique that does not change the probability model. Specifically, we introduce a unique new non-terminal for each right-hand side longer than 2 and split the rule into two rules, using this new intermediate non-terminal. This is repeated until all right-hand sides are of length 2. The transformation algorithm is inspired by G\u00f3mez-Rodr\u00edguez et al. (2009) and it is also specified in Kallmeyer (2010) . Fig. 7 shows an example. SBARQ 1 (XY ) \u2192 SQ 1 (X).1(Y ) SQ 1 (XY ZU ) \u2192 VP2(X, U )MD1(Y )NP1(Z) VP1(X, Y ) \u2192 WHNP1(X)VB1(Y ) WHNP1(X) \u2192 WP1(X) NP1(X) \u2192 PRP1(X) WP1(What) \u2192 \u03b5 MD1(should) \u2192 \u03b5 PRP1(I) \u2192 \u03b5 VB1(do) \u2192 \u03b5 .1(?) \u2192 \u03b5 SBARQ 1 (XY ) \u2192 SQ 1 (X).1(Y ) SQ 1 (XY Z) \u2192 VP1(X, Z)C1(Y ) C1(XY ) \u2192 MD1(X)NP1(Y ) VP1(X, Y ) \u2192 WHNP1(X)VB1(Y ) WHNP1(X) \u2192 WP1(X) NP1(X) \u2192 PRP1(X) Figure 7 : Binarized grammar equivalent to the grammar in Figure 6 , not showing terminal rules. Note however that the fan-out of the LCFRS can increase because of the binarization. Category Splits Category splitting, i.e. relabeling certain nodes in the training data depending on context, has been used to improve the performance of PCFG parsing (Klein and Manning, 2003) and also PLCFRS parsing (Kallmeyer and Maier, 2010) . Our experiments have shown that a combination of three splits for the PTB annotation improved performance considerably: S nodes are relabeled to SWH if a wh-element is extracted from the sentence. In order to make this split more effective, SBAR nodes that have only one child after transformation to the discontinuous format are removed. VP nodes are relabeled to VPHINF if their head is labeled VB, to VPHTO if their head is labeled TO and to VPHPART if their head is labeled VBN or VBG. S nodes rooting infinitival clauses (head child labeled VPHINF or VPHTO) are relabeled to SINF. Evaluation We EVALB-Style Evaluation Since the structure in Te \u2032 encodes local as well as non-local dependencies, it serves as our primary gold standard. In a first step, we use the standard EVALB metric, generalized to trees with discontinuous constituents as in Maier and Kallmeyer (2010) , to measure how much of the structure in the gold standard is captured by differ-ent parsers. We compare Maier and Kallmeyer's parser trained on Tr \u2032 (resulting in a 3-PLCFRS) with three parsers that do not produce discontinuous structures: the Berkeley parser (Petrov et al., 2006; Petrov and Klein, 2007) trained on Tr using our manual category splits but no automatic splitting/merging/smoothing, the Berkeley parser trained on Tr using its default setting of six iterations of split/merge/smooth, and Maier and Kallmeyer's parser with a grammar extracted from Tr (a 1-PLCFRS, i.e. a PCFG). The upper half of Table 2 shows the results. For comparison, we also evaluated the three context-free parsers on the untransformed context-free test set Te. These figures are given in the lower half of the table. For Maier and Kallmeyer's parser, the number of rules in the grammar before and after binarizing is also given, as well as the number of items created during parsing as an indicator of parsing complexity. Across these experiments, the most crucial factor for parsing accuracy seems to be splitting/merging/smoothing. As the comparison between the two parsing experiments with the Berkeley parser shows, this technique is key to achieving its state-of-the-art results. We plan to transfer this technique to discontinuous constituent parsing in future work. For now, we must compare discontinuous to context-free constituent parsing on a level below the state of the art. Comparison between the two experiments with Maier and Kallmeyer's parser shows that it works with about the same accuracy when trained and tested on discontinuous data as when trained and tested on contextfree data, although parsing complexity is considerably higher in the discontinuous experiment as evidenced by the number of items produced. Note that scores would presumably be lower if sentences with more than 25 tokens were included. Even when trained on the context-free data, both parsers get most of the structure in Te \u2032 right since only a relatively small fraction of constituents is discontinuous. However, for those test sentences that do contain discontinuous constituents (Te \u2032 D ), context-free parsers fare much worse than for sentences that do not (Te \u2032 C ). For Maier and Kallmeyer's parser trained on Tr \u2032 they seem to be only slightly harder to parse. Although its scores for Te \u2032 D with discontinuous parsing are lower than for Te D with context-free parsing, the former may be considered a better parse result than the latter since the Te \u2032 D gold standard con- Dependency Evaluation In order to assess to what degree this is the case, we perform a dependency evaluation (Lin, 1995) , first used for evaluating discontinuous constituent parser output in Maier (2010) . This method requires a conversion of constituent trees to sets of word-word dependencies. We use Lin's dependency conversion method, where each phrase is represented by its lexical head. To determine the head of each phrase, we use the head-finding algorithm of Collins (1999) , ordering the children of each node by leftmost dominated terminal. Under this standard dependency conversion method, the transformation described in Section 3 introduces new word-word (head-argument/headadjunct) dependencies that are relevant to semantic interpretation. Word-word dependencies lost in the transformation are not normally relevant since they result from attachment of phrases outside of the domains of their heads. We therefore choose Te \u2032 as the gold standard against which to evaluate both context-free and discontinuous parsing results. Table 4 shows that discontinuous parsing as compared to context-free parsing boosts the unlabeled attachment score (i.e. recall on word-word dependencies) slightly for local dependencies and considerably for non-local dependencies. The lat- Dependency evaluation also allows a direct comparison with state-of-the-art dependency parsers. In Table 4 we give results for MST-Parser (McDonald and Pereira, 2006) trained on two dependency versions of Tr \u2032 , converted from constituents to dependencies once without dependency labels and once with dependency labels using the method of Hall and Nivre (2008) . It can be seen that MSTParser recognizes a fair percentage of even the difficult *ICH* and *EXP* type dependencies (cf. Section 5.3) and that it has a considerably better overall score. We expect that this gap can be bridged by optimizing Maier and Kallmeyer's parser with techniques successfully used for context-free constituent parsing as outlined above, but this remains to be proven experimentally. The latter suffer from massive attachment ambiguity -attaching the right part of a discontinuous constituent of this type locally as illustrated in Fig. 8 almost always leads to higherscoring parses in the current model. Augmenting it with lexical information as is common in modern PCFG-based parsers could help to better resolve these and other attachment ambiguities. In the present model, including discontinuous annotation of *ICH* and *EXP* type dependencies adds no value to the parser output and is even detrimental since grammar rules typically found with them like NP(X, Y ) \u2192NP(X)SINF(Y ) are used by the parser in many falsely detected discontinuities. We therefore conducted another experiment with Maier and Kallmeyer's parser using the training and test sets Tr \u2032\u2032 and Te \u2032\u2032 . These are like Tr \u2032 and Te \u2032 except that *ICH* and *EXP* type dependencies were not included in the transformation. This makes EVALB scores for the continuous test trees rise slightly and parsing time drop considerably due to the smaller number of discontinuous rules (Table 3 ). However, a higher unlabeled attachment score is not achieved by this (cf. Table 4 ). A Closer Look at the Parses *T* type discontinuities are well recognized presumably due to their strong correlations with patterns like a wh-word followed by a sentence, a sentence followed by another, a sentence interrupted by another, and characteristic punctuation in the case of fronted and discontinuous quotations. Even correctly recognizing deeply embedded attachment of wh-moved phrases as illustrated in Fig. 9 poses no major problem. One of the problems that do exist is the many possible ways that a sentence can be split into two parts as a surrounding quotation, resulting in many required S rules of fan-out 2 and in sparse data. This problem could Conclusion and Future Work This paper pursues an approach of direct parsing of discontinuous constituents. We have applied data-driven PLCFRS parsing to English. To this end, we have first transformed the trace-based Penn Treebank annotation format into a format with crossing branches and explicit discontinuous constituents. The latter can then be used for PLCFRS parsing. Our evaluation has shown that, compared to PCFG parsing with the same techniques, PLCFRS parsing yields slightly better results. In particular when evaluating only the parsing results concerning long-distance dependencies, the PLCFRS approach with discontinuous constituents is able to recognize about 88% of the dependencies of type *T* and *T*-PRN. Even the results concerning local dependencies, which can in principle be captured by a CFG-based model, are better with the PLCFRS model. This demonstrates that by discarding information on non-local dependencies the PCFG model loses important information on syntactic dependencies in general. Our results show that data-driven PLCFRS parsing is a promising and feasible strategy not only for so-called free word order languages such as German but also for English where we obtain competitive parsing results. However, our experiments also reveal some shortcomings of the chosen probabilistic model. A general problem is that some decisions, for instance on PP-attachments, cannot be taken solely based on the syntactic information we have used. This problem occurs independent from the choice of PLCFRS. A careful integration of more lexical information can help to overcome this problem. A shortcoming that is specific to LCFRS is the assumption that the expansions of the same category with different fan-outs (for instance a continuous VP and a discontinuous VP) are independent from each other. This bears two problems. Firstly, since categories of higher fan-out are rather rare, we have a sparse data problem. Secondly, the independence assumption is probably wrong. In order to tackle this problem, we plan to develop models that factor rules into an expansion part and a separating part that introduces gaps. We leave this issue for future work. Acknowledgments We would like to thank Wolfgang Maier for fruitful discussions and help with implementation, and the anonymous reviewers for their valuable suggestions on improving the paper.",
    "abstract": "This paper proposes a direct parsing of non-local dependencies in English. To this end, we use probabilistic linear context-free rewriting systems for data-driven parsing, following recent work on parsing German. In order to do so, we first perform a transformation of the Penn Treebank annotation of non-local dependencies into an annotation using crossing branches. The resulting treebank can be used for PLCFRS-based parsing. Our evaluation shows that, compared to PCFG parsing with the same techniques, PLCFRS parsing yields slightly better results. In particular when evaluating only the parsing results concerning long-distance dependencies, the PLCFRS approach with discontinuous constituents is able to recognize about 88% of the dependencies of type *T* and *T*-PRN encoded in the Penn Treebank. Even the evaluation results concerning local dependencies, which can in principle be captured by a PCFG-based model, are better with our PLCFRS model. This demonstrates that by discarding information on non-local dependencies the PCFG model loses important information on syntactic dependencies in general.",
    "countries": [
        "Germany",
        "Netherlands"
    ],
    "languages": [
        "German",
        "English"
    ],
    "numcitedby": "35",
    "year": "2011",
    "month": "October",
    "title": "{PLCFRS} Parsing of {E}nglish Discontinuous Constituents"
}