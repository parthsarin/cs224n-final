{
    "article": "Research on statistical machine translation has focused on particular translation directions, typically with English as the target language, e.g., from Arabic to English. When we reverse the translation direction, the multiple reference translations turn into multiple possible inputs, which offers both challenges and opportunities. We propose and evaluate several strategies for making use of these multiple inputs: (a) select one of the datasets, (b) select the best input for each sentence, and (c) synthesize an input for each sentence by fusing the available inputs. Surprisingly, we find out that it is best to tune on the hardest available input, not on the one that yields the highest BLEU score. This finding has implications on how to pick good translators and how to select useful data for parameter optimization in SMT. Introduction Nowadays, statistical machine translation (SMT) systems are data-driven, and thus critically depend on the available resources for training, tuning and evaluation. These resources are hard to obtain, which has limited research to a small number of language pairs for which biligual sentence-aligned parallel corpora, called bitexts, are available. What is often not realized is that SMT research has further been restricted to only some translation directions, e.g., those of interest to evaluation campaigns such as NIST and IWSLT or to funding agencies such as DARPA. This is because stable SMT evaluation requires multiple reference translations for the target language. Such multiple references are often available for the English (target) side of the tuning and the evaluation dataset, but not for the source language, e.g., Arabic, Chinese. Reversing the translation direction yields (i) a single reference translation and (ii) multiple versions for each tuning/testing input sentence. There is little we can do about (i), 1 but (ii) offers interesting opportunities for tuning and evaluation. Below we focus on the question of how to make best use of the multiple available inputs at tuning time. We propose and evaluate several strategies for making use of these multiple inputs: (a) select one of the datasets, (b) select the best input for each sentence, and (c) synthesize an input for each sentence by fusing the available inputs. Related Work One relevant line of research is on multi-source translation, which generates a single translation given multiple versions of the input. This line was started by Och and Ney (2001) , who translated the different inputs in isolation and then selected one of them. It has been further extended with various strategies for generating a consensus translation by combining either the inputs (Schroeder et al., 2009) or the outputs (Matusov et al., 2006 ) of the SMT system. In contrast, we assume having multiple sources at tuning but not at testing time. A related line focused on data selection. For training data, this includes filtering (Moore and Lewis, 2010; Foster et al., 2010) , instanceweighting (Axelrod et al., 2011; Matsoukas et al., 2009) and model adaptation (Hildebrand et al., 2005) . For tuning data, Liu et al. (2012) built a separate tuning dataset for each test sentence, which is too costly for real-world translation. To the best of our knowledge, ours is the first attempt to make best use at tuning time of multiple input versions of the same tuning sentence and a single reference translation for it. Previous English-Arabic SMT has used the first input (Al-Haj and Lavie, 2012; Kholy and Habash, 2012) . Method Choosing a dataset We can select one of the input datasets. Select-first. One possible baseline is to select randomly, e.g., the dataset that is listed first. Concat-all. Another baseline is to concatenate all tuning datasets: using each of the available English versions of a given sentence as input, each paired with the only available Arabic reference. Then, there are a number of strategies that select the dataset yielding the highest BLEU score: Backtranslate. We can backtranslate the single target-language reference to English, then evaluate this translation with respect to each of the English inputs, and select the one yielding the highest BLEU score. We can do this using our own system, trained in the opposite, X-English direction; this makes the results potentially more relevant to a system trained and tuned on the same dataset, but in the English-X direction. Another option is to use Google Translate, which would avoid the bias to our datasets. One could argue in favor of either option, and we experiment with both. X-vs-all-but-X. Here we pretend that one of the English inputs is in fact a translation, and we evaluate this \"translation\" with respect to the remaining English datasets. We calculate the BLEU score for each of the English datasets using the remaining English datasets as references, and we select the one with the highest BLEU. This minimizes the risk of selecting an outlier dataset for tuning. Best-on-tuning. Given an English input, we use it to tune the parameters of our SMT system, then we use these learned parameters to translate each of the English inputs, and we evaluate them using BLEU. Then, we average the BLEU scores, where the averaging is over (a) the translations of all English inputs or (b) all but the one used for tuning. The rationale behind (a) is to make all BLEU scores comparable, while that for (b) is to clearly separate tuning from testing, i.e., not to test on the particular dataset that was used for tuning. In either case, we select the dataset that achieved the highest such average. Synthesizing a dataset from full sentences Instead of selecting an entire input dataset, we can synthesize a new dataset by fusing the available inputs. The easiest way is to do selection at the sentence-level: for each tuning reference sentence, we can select one of the available English inputs. We will do the selection with respect to some English reference, e.g., backtranslation of the Arabic reference generated by our own system or by Google translate. Below, we present the similarity measures that we use for the selection. BLEU+1 (B1). BLEU+1 (Lin and Och, 2004 ) is a smoothed version of BLEU (Papineni et al., 2002) used to address sparseness problems with n-gram matches when comparing sentences. BLEU+1 BP smooth (B1-BP). The BLEU+1 approximation of BLEU smooths the n-gram counts but not the brevity penalty, thus destroying the balance between the two; it also assigns a non-zero precision to cases with zero matches. Thus, we experiment with a version of BLEU+1 from (Nakov et al., 2012) that smooths the brevity penalty and also uses a \"grounding\" factor. BLEU+1 Sigmoid LP (B1-SG). Note that the brevity penalty of BLEU/BLEU+1 penalizes shorter but not longer sentences. Thus, we also experiment with a version of BLEU+1 with a symmetric length penalty, which penalizes the squared differences in length using a sigmoid function: LP (s i , r) = 3 \u2212 4 * sig l(s i ) \u2212 l(r) \u03b1 2 where l(s i ) and l(r) are the length of the i-th input and of the reference, respectively, and \u03b1 is a tolerance factor (set to 5 in our experiments). Length Difference (DL). We also try to minimize the difference in length. Minimum BLEU+1 (MIN-B1). Next, instead of maximizing BLEU+1, we can minimize it, i.e., pick the hardest input sentence, and tune the SMT system to perform well on such hard input. Minimum Length (MIN-L). Finally, we can just pick the shortest sentence. Synthesizing a dataset by fusing sentences MEMT. Instead of selecting one of the possible inputs, we can synthesize a new input by mixing different inputs at the sub-sentence level. Here, we use the Multi-Engine Machine Translation system, or MEMT, (Heafield and Lavie, 2010) to merge different input sentences. It merges all input sentences into a lattice and then extracts a new candidate from that lattice using features such as length, language model, and n-gram matches; it tries to maximize BLEU with respect to a given reference: again, a backtranslation of the reference to English using own SMT system or Google Translate. Experiments and Evaluation Experimental Setup We used the phrase-based SMT model (Koehn et al., 2003) , as implemented in the Moses toolkit (Koehn et al., 2007) , to train an SMT system translating from English to Arabic. For tuning and evaluation, we used two multireference datasets, MT04 and MT05, from the NIST 2012 OpenMT Evaluation, 2 each with a single Arabic input and five English reference translations, which we inverted, ending up with five English inputs and one Arabic reference for each one. We trained the English-Arabic system (translation, reordering, and language models) on all training data from NIST 2012 except for UN data. Following Kholy and Habash (2012) , we normalized the Arabic training, development and test data using MADA (Roth et al., 2008) , fixing automatically all wrong instances of alef, ta marbuta and alef maqsura. We segmented the Arabic words by splitting out conjunctions (MADA scheme D1). For English, we converted all words to lowercase. We built our phrase tables using the standard Moses pipeline with max-phrase-length 7 and Kneser-Ney smoothing. We also built a lexicalized reordering model (Koehn et al., 2005) : msd-bidirectional-fe. We used a 5-gram language model trained on the GigaWord v.5 with Kneser-Ney smoothing using KenLM (Heafield, 2011) . For optimization, we used MERT. For evaluation, we used NIST's BLEU scoring tool v13a, which we ran on a desegmented Arabic output, where conjunctions are attached to the following word. In order to ensure stability, we performed three reruns of MERT for each experiment, and we report evaluation results averaged over the three reruns, as suggested by Foster and Kuhn (2009 Table 2 : Tuning and testing on MT04. We tune on the English input in the first column, then we translate all MT04x inputs. We report BLEU and hyp/ref length ratios averaged over (a) all MT04 datasets, and (b) all but the one used for tuning. Table 1 shows the results when tuning on MT04 and testing on MT05. There are several interesting observations we can make. First, the choice of test dataset has a huge impact on the BLEU score: in some cases, more than 11 BLEU points, e.g., compare MT052 to MT053. Second, from the tuning dataset perspective, we can see 0.51-0.78 absolute difference in BLEU between the best (mostly MT040) and the worst choice (mostly MT044). These differences are large enough to justify our interest in tuning input selection. Table 1 also allows us to assess the performance of the two baselines: select-first is optimal, achieving an overall BLEU score of 34.24, while concatall is in the middle (would be third best if ranked with the rest) with a BLEU score of 34.03. Table 2 shows the results when tuning on one MT04 dataset, and testing on all MT04 datasets. The results are averaged (a) over all MT04 datasets and (b) over all but the one used for tuning. In case (a) (see columns 2 and 3), MT044 is selected, which is the worst possible choice. However, in case (b) (see columns 4 and 5), the best score is achieved for MT040, which is the optimal choice, i.e., best-on-tuning yields optimal results when averaging over all but the tuning dataset. Moreover, note that the BLEU scores in column 4 of Table 2 go in strictly decreasing order for MT040, MT041, MT042, MT043, MT044, and they do so also in Table 1 . This suggests that the best-on-tuning strategy is very reliable here. Table 3 : X vs. all-but-X for MT04. BLEU scores and hyp/ref length ratios when testing on each English input, using all the rest as references. Table 3 implements X-vs-all-but-X. It shows the results when tuning on each English input, using all other inputs as references. The highest BLEU score is achieved by MT043, which is the second worst choice. Thus, this is a very poor strategy here; however, below we will see that it is quite reliable if we make a choice based on length ratio. Table 4 shows the results when backtranslating the Arabic reference to English, and then scoring it with respect to each of the English inputs. The backtranslation uses (a) our own system trained to translate in the reverse direction, and (b) Google Translate. We can see that backtranslate performs poor: with (a), it selects MT044, the worst choice, and with (b), it selects MT043, the second worst; however, it works better if we use length ratios. Table 5 shows the results when tuning on datasets synthesized from full sentences (all but the last line) or by fusing sentences (the last line), where we optimize some function with respect to a backtranslation obtained from (a) our own system or (b) Google Translate. We can see that no combination could improve over the best individual system, but the best synthesized dataset yielded a score matching that of the best individual system.  We believe that these results are due to our inability to choose a reliable reference translation: backtranslation generates an automatic translation, which most of the time is arguably worse in quality than the English inputs, which are human, after all. In future work, we plan to try other ways to generate a good reference translation. Tuning on MT05, testing on MT04 Table 6 shows the results when tuning on MT05 and testing on MT04. Once again, the choice of test dataset has a huge impact on the BLEU score: this time up to 7 BLEU points, e.g., compare MT040 to MT044. We further see 0.5-1.5 absolute difference in BLEU between the best (mostly MT051) and the worst choice (mostly MT050). This time, select-first does not work at all: it selects MT050, which is the worst possible choice (while it was best in the reverse, MT04-MT05, translation direction). However, the concat-all strategy performs reasonably well: it would be second best if ranked together with the individual inputs (it was third best in the reverse direction). Table 7 shows that the best-on-tuning strategy once again works quite well, selecting MT051, which is the optimal choice. Note that this time the optimal choice is made regardless of whether the averaging is done over all datasets or over all but the tuning dataset (in the reverse direction, averaging over all made the worst possible choice, while averaging over all but the one used for tuning made an optimal choice). Next, Table 8 shows that X-vs-all-but-X would select MT054, which is in the middle of the possible choices: not the worst, but also not the best (it was second worst in the reverse direction). Table 9 shows that backtranslate does not work well: for both our SMT system and Google Translate, it selects MT053, the second worst choice (it was also second worst in the reverse direction). Table 8 : X vs. all-but-X for MT05. BLEU scores and hyp/ref length ratios when testing on each English input, using all the rest as references. Table 10 shows the results when tuning on synthesized datasets. As before, this does not improve over the best individual system. Again, we can blame this on the bad selection of reference, but there could be also something else: selection strategies that synthesize input datasets based on what is easiest to translate might not be as useful as we have assumed. In the following section, we give some insight on why this might be the case. Discussion So far, we have explored input selection alternatives that make use of BLEU as a central criterion (while we have also experimented with some sentence selection strategies based on length, this was peripheral), and, in many cases, these strategies were very successful.   Below we explore two alternative strategies for best input dataset selection for tuning: (a) looking for the dataset that yields a tuning length ratio that is closest to 1, and (b) choosing the hardest input. We further explore the potential of using perplexity for tuning input selection. Choosing length closest to 1 Above, we have considered the BLEU/BLEU+1 score as the main criterion for input dataset selection. This makes sense since this is the standard evaluation measure, which we are optimizing at test time. However, there are other reasonable criteria that could be considered. For example, recent work has suggested that length is an important factor for parameter optimization in statistical machine translation (Nakov et al., 2012) . Thus, we considered how the above strategies would work when selecting not the dataset yielding the highest BLEU, but that for which the source/reference length ratio is closest to 1. This turned out to work in some but not all cases. When tuning on MT04: Table 2 shows that if looking for the best length instead of the best BLEU, the best-on-tuning strategy would select MT041, which is the second best choice. The same choice would make X-vs-all-but-X (see Table 3 ) and backtranslate when using our system (see Table 4 ). With Google Translate, however, it would make the best choice: MT040. When tuning on MT05: Table 7 shows that best-on-tuning would select MT050, which is the worst choice. The same choice would make X-vsall-but-X (see Table 8 ). Both strategies made the second best choice for MT04. The backtranslate strategy, however, selects MT054, both with our SMT system and with Google Translate; this is the second best choice (see Table 9 ). On MT04, this strategy made an optimal choice. Overall, the length ratio works great for backtranslate (best or second best choice), but for beston-tuning and X-vs-all-but-X results are mixed. Choosing the hardest dataset A closer look at the strategies for backtranslate and X-vs-all-but-X reveals something unexpected: Tables 3, 4 , 8, and 9 show that selecting the input dataset with the lowest BLEU would yield an optimal choice in all these cases. We had assumed that the input that yields the highest BLEU score should be of highest quality, and thus the best to learn from. Instead, a closer inspection has found that the high-BLEU datasets were more literal translations, which were less fluent in English and thus ultimately of lower quality. So, we should really train on the hardest dataset. In fact, this is not very surprising: a student would learn more from hard lessons than from easy ones. Thus, the best strategy to prepare for an exam is to learn hard rather than easy lessons. It is reasonable to expect that hard inputs would have lower perplexity with respect to our language model, i.e., that they would be more similar to the training data, and thus that they should be also closer to the expected test time input. We tested this hypothesis by calculating the perplexity for all input MT04 datasets, and we found for MT040 the perplexity is indeed lower than for MT044. The results are shown in Table 11 , where we show the logarithm of the probability instead of the perplexity because the perplexity was too low. These numbers offer yet another possible explanation about why combining inputs could not improve: it looks like MT040 is much better than the rest, and thus maybe there are simply no enough good translations in the remaining datasets. Conclusion and Future Work We have studied the question of how to select/synthesize a good tuning dataset for SMT in the special case, when we have multiple possible input (English) versions of the same sentence and a single reference (Arabic) translation. We have experimented with a number of strategies, and we have found that it is best to tune on the hardest available input, not on the one that yields the highest BLEU score (i.e., the easiest). We believe that this finding has implications on how we should pick good translators and how we should select useful data for parameter optimization. On the other hand, it might also indicate a problem with BLEU as an evaluation measure. In future work, we plan to test our methods on other Arabic-English datasets that have multiple English references. We further plan experiments with other language pairs, e.g., Chinese-English, which are available from NIST and IWSLT. We also want to study the effect of the tuning dataset selection on evaluation measures other than BLEU, e.g., TER (Snover et al., 2006) and METEOR (Lavie and Denkowski, 2009) . Looking at tuning dataset selection that takes the test data into account is another promising direction for future work. Features from quality estimation (Specia et al., 2010) might be also helpful to determine the best input to tune on. Another related, but different, research direction is about how to best evaluate (as opposed to tune, which we have explored above) an SMT system in case multiple possible versions of the input sentences are available.",
    "funding": {
        "defense": 0.0,
        "corporate": 0.0,
        "research agency": 0.0,
        "foundation": 0.0,
        "none": 1.0
    },
    "reasoning": "Reasoning: The article does not explicitly mention any funding sources, including defense, corporate, research agencies, foundations, or otherwise. Without direct evidence of funding, we cannot assume the involvement of any specific type of funding source.",
    "abstract": "Research on statistical machine translation has focused on particular translation directions, typically with English as the target language, e.g., from Arabic to English. When we reverse the translation direction, the multiple reference translations turn into multiple possible inputs, which offers both challenges and opportunities. We propose and evaluate several strategies for making use of these multiple inputs: (a) select one of the datasets, (b) select the best input for each sentence, and (c) synthesize an input for each sentence by fusing the available inputs. Surprisingly, we find out that it is best to tune on the hardest available input, not on the one that yields the highest BLEU score. This finding has implications on how to pick good translators and how to select useful data for parameter optimization in SMT.",
    "countries": [
        "Qatar"
    ],
    "languages": [
        "Arabic",
        "English"
    ],
    "numcitedby": 4,
    "year": 2013,
    "month": "September",
    "title": "Parameter Optimization for Statistical Machine Translation: It Pays to Learn from Hard Examples"
}