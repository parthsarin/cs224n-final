{
    "article": "Detection of discourse structure is crucial in many text-based applications. This paper presents an original framework for describing textual parallelism which allows us to generalize various discourse phenomena and to propose a unique method to recognize them. With this prospect, we discuss several methods in order to identify the most appropriate one for the problem, and evaluate them based on a manually annotated corpus. Introduction Detection of discourse structure is crucial in many text-based applications such as Information Retrieval, Question-Answering, Text Browsing, etc. Thanks to a discourse structure one can precisely point out an information, provide it a local context, situate it globally, link it to others. The context of our research is to improve automatic discourse analysis. A key feature of the most popular discourse theories (RST (Mann and Thompson, 1987) , SDRT (Asher, 1993) , etc.) is the distinction between two sorts of discourse relations or rhetorical functions: the subordinating and the coordinating relations (some parts of a text play a subordinate role relative to other parts, while some others have equal importance). In this paper, we focus our attention on a discourse feature we assume supporting coordination relations, namely the Textual Parallelism. Based on psycholinguistics studies (Dubey et al., 2005) , our intuition is that similarities concerning the surface, the content and the structure of textual units can be a way for authors to explicit their intention to consider these units with the same rhetorical importance. Parallelism can be encountered in many specific discourse structures such as continuity in information structure (Kruijff-Korbayov\u00e1 and Kruijff, 1996) , frame structures (Charolles, 1997) , VP ellipses (Hobbs and Kehler, 1997), headings (Summers, 1998) , enumerations (Luc et al., 1999) , etc. These phenomena are usually treated mostly independently within individual systems with ad-hoc resource developments. In this work, we argue that, depending on description granularity we can proceed, computing syntagmatic (succession axis of linguistic units) and paradigmatic (substitution axis) similarities between units can allow us to generically handle such discourse structural phenomena. Section 2 introduces the discourse parallelism phenomenon. Section 3 develops three methods we implemented to detect it: a similarity degree measure, a string editing distance (Wagner and Fischer, 1974) and a tree editing distance 1 (Zhang and Shasha, 1989) . Section 4 discusses and evaluates these methods and their relevance. The final section reviews related work. Textual parallelism Our notion of parallelism is based on similarities between syntagmatic and paradigmatic representations of (constituents of) textual units. These similarities concern various dimensions from shallow to deeper description: layout, typography, morphology, lexicon, syntax, and semantics. This account is not limited to the semantic dimension as defined by (Hobbs and Kehler, 1997) who consider text fragments as parallel if the same predicate can be inferred from them with coreferential or similar pairs of arguments. We observe parallelism at various structural levels of text: among heading structures, VP ellipses and others, enumerations of noun phrases in a sentence, enumerations with or without markers such as frame introducers (e.g. \"In France, . . . In Italy, . . . \") or typographical and layout markers. The underlying assumption is that parallelism between some textual units accounts for a rhetorical coordination relation. It means that these units can be regarded as equally important. By describing textual units in a two-tier framework composed of a paradigmatic level and syntagmatic level, we argue that, depending on the description granularity we consider (potentially at the character level for item numbering), we can detect a wide variety of parallelism phenomena. Among parallelism properties, we note that the parallelism of a given number of textual units is based on the parallelism of their constituents. We also note that certain semantic classes of constituents, such as item numbering, are more effective in marking parallelism than others. An example of parallelism The following example is extracted from our corpus (see section 4.1). In this case, we have an enumeration without explicit markers. For the purposes of chaining, each type of link between WordNet synsets is assigned a direction of up, down, or horizontal. Upward links correspond to generalization: for example, an upward link from apple to fruit indicates that fruit is more general than apple. Downward links correspond to specialization: for example, a link from fruit to apple would have a downward direction. Horizontal links are very specific specializations. The parallelism pattern of the first two items is described as follows: [JJ + suff =ward] links correspond to [NN + suff = alization] : for example , X link from Y to Z . This pattern indicates that several item constituents can be concerned by parallelism and that similarities can be observed at the typographic, lexical and syntactic description levels. Tokens (words or punctuation marks) having identical shallow descriptions are written in italics. The X, Y and Z variables stand for matching any nonparallel text areas between contiguous parallel textual units. Some words are parallel based on their syntactic category (\"JJ\" / adjectives, \"NN\" / nouns) or suffix specifications (\"suff\" attribute). The third item is similar to the first two items but with a simpler pattern: JJ links U [NN + suff =alization] W . Parallelism is distinguished by these types of similarities between sentences. Methods Three methods were used in this study. Given a pair of sentences, they all produce a score of similarity between these sentences. We first present the preprocessing to be performed on the texts. Prior processing applied on the texts The texts were automatically cut into sentences. The first two steps hereinafter have been applied for all the methods. The last third was not applied for the tree editing distance (see 3.3). Punctuation marks and syntactic labels were henceforward considered as words. 1. Text homogenization: lemmatization together with a semantic standardization. Lexical chains are built using WordNet relations, then words are replaced by their most representative synonym: Horizontal links are specific specializations. horizontal connection be specific specialization . 2. Syntactic analysis by (Charniak, 1997) 's parser: Wagner & Fischer's string edit distance This method is based on Wagner & Fischer's string edit distance algorithm (Wagner and Fischer, 1974) , applied to sentences viewed as strings of words. It computes a sentence edit distance, using edit operations on these elementary entities. The idea is to use edit operations to transform sentence S 1 into S 2 . Similarly to (Wagner and Fischer, 1974) , we considered three edit operations: 1. replacing word x \u2208 S 1 by y \u2208 S 2 : (x \u2192 y) 2. deleting word x \u2208 S 1 : (x \u2192 \u03bb) 3. inserting word y \u2208 S 2 into S 1 : (\u03bb \u2192 y) By definition, the cost of a sequence of edit operations is the sum of the costs 2 of the elementary operations, and the distance between S 1 and S 2 is the cost of the least cost transformation of S 1 into S 2 . Wagner & Fischer's method provides a simple and effective way (O(|S 1 ||S 2 |)) to compute it. To reduce size effects, we normalized by |S 1 |+|S 2 | 2 . Zhang & Shasha's algorithm Zhang & Shasha's method (Zhang and Shasha, 1989; Dulucq and Tichit, 2003) Keyroots, special subtrees and forests Given a certain node x, L(x) denotes its leftmost leaf descendant. L is an equivalence relation over nodes and keyroots (KR) are by definition the equivalence relation representatives of highest postfix index. Special subtrees (SST) are the subtrees rooted in these keyroots. Consider a tree T postfix indexed (left figure hereinafter) and its three SSTs (right figure). SST(k 1 ) rooted in k 1 is denoted: T [L(k 1 ), L(k 1 ) + 1, . . . , k 1 ]. E.g: SST(3) = T [1, 2, 3] is the subtree containing nodes a, b, d. A forest of SST(k 1 ) is defined as: T [L(k 1 ), L(k 1 ) + 1, . . . , x], where x is a node of SST(k 1 ). E.g: SST(3) has 3 forests : T [1] (node a), T [1, 2] (nodes a and b) and itself. Forests are ordered sequences of subtrees. An idea of how it works The algorithm computes the distance between all pairs of SSTs taken in T 1 and T 2 , rooted in increasingly-indexed keyroots. In the end, the last SSTs being the full trees, we have d(T 1 , T 2 ). In the main routine, an N 1 \u00d7 N 2 array called TREEDIST is progressively filled with values TREEDIST(i, j) equal to the distance between the subtree rooted in T 1 's i th node and the subtree rooted in T 2 's j th node. The bottom right-hand cell of TREEDIST is therefore equal to d(T 1 , T 2 ). Each step of the algorithm determines the edit distance between two SSTs rooted in keyroots (k 1 , k 2 ) \u2208 (T 1 \u00d7 T 2 ). An array FDIST is initialized for this step and contains as many lines and columns as the two given SSTs have nodes. The array is progressively filled with the distances between increasing forests of these SSTs, similarly to Wagner & Fischer's method. The bottom right-hand value of FDIST contains the distance between the SSTs, which is then stored in TREEDIST in the appropriate cell. Calculations in FDIST and TREEDIST rely on the double recurrence formula depicted below: The first formula is used to compute the distance between two forests (a white one and a black one), each of which is composed of several trees. The small circles stand for the nodes of highest postfix index. Distance between two forests is defined as the minimum cost operation between three possibilities: replacing the rightmost white tree by the rightmost black tree, deleting the white node, or inserting the black node. The second formula is analogous to the first one, in the special case where the forests are reduced to a single tree. The distance is defined as the minimum cost operation between: replacing the white node with the black node, deleting the white node, or inserting the black node. It is important to notice that the first formula takes the left context of the considered subtrees into account 3 : ancestor and left sibling orders are preserved. It is not possible to replace the white node with the black node directly, the whole subtree rooted in the white node has to be replaced. The good thing is, the cost of this operation has already been computed and stored in TREEDIST. Let's see why all the computations required at a given step of the recurrence formula have already been calculated. Let two SSTs of T 1 and T 2 be rooted in pos where d(T i ) is the depth T i and f (T i ) is the number of terminal nodes of T i . 3 The 2 nd formula does too, since left context is empty. Our proposal: a degree of similarity This final method computes a degree of similarity between two sentences, considered as lists of syntactic (labels) and lexical (words) constituents. Because some constituents are more likely to indicate parallelism than others (e.g: the list item marker is more pertinent than the determiner \"a\"), a crescent weight function p(x) \u2208 [0, 1] w.r.t. pertinence is assigned to all lexical and syntactic constituents x. A set of special subsentences is then generated: the greatest common divisor of S 1 and S 2 , gcd(S 1 , S 2 ), is defined as the longest list of words common to S 1 and S 2 . Then for each sentence S i , the set of special subsentences is computed using the words of gcd(S 1 , S 2 ) according to their order of appearance in S i . For example, if S 1 = cabcad and S 2 = acbae, gcd(S 1 , S 2 ) = {c, a, b, a}. The set of subsentences for S 1 is {caba, abca} and the set for S 2 is reduced to {acba}. Note that any generated subsentence is exactly the size of gcd(S 1 , S 2 ). For any two subsentences s 1 and s 2 , we define a degree of similarity D(s 1 , s 2 ), inspired from string edit distances: The further a constituent from s 1 is from its symmetric occurrence in s 2 , the more similar the compared subsentences are. Eventually, the degree of similarity between sentences S 1 and S 2 is defined as: D(s1, s2) = n X i=1 \" dmax \u2212 d(xi) dmax \u00d7 p(xi) \u00ab 8 > > > > > > > < > > > > > > > : D(S1, S2) = 2 |S1| + |S2| \u00d7 max s1,s2 D(s1, s2) Example Consider S 1 = cabcad and S 2 = acbae, along with their subsentences s 1 = caba and s 1 = abca for S 1 , and s 2 = acba for S 2 . The degrees of parallelism between s 1 and s 2 , and between s 1 and s 2 are computed. The mapping between the parallel constituents is shown below. For example: D(s1, s2) = 4 X i=1 \" 3 \u2212 d(xi) 3 \u00d7 p(xi) \u00ab = 2/3p(c) + 2/3p(a) + p(b) + p(a) Assume p(b) = p(c) = 1 2 and p(a) = 1. Then D(s 1 , s 2 ) = 2.5 and, similarly D(s 1 , s 2 ) 2.67. Therefore the normalized degree of parallelism is D(S 1 , S 2 ) = 2 5+6 \u00d7 2.67, which is about 0.48. Evaluation This section describes the methodology employed to evaluate performances. Then, after a preliminary study of our corpus, results are presented successively for each method. Finally, the behavior of the methods is analyzed at sentence level. Methodology Our The idea was to compute for each pair a parallelism score indicating the similarity between the sentences. Then the choice of a threshold determined which pairs showed a score high enough to be classified as parallel. Evaluation was based on a manual annotation we proceeded over the texts. In order to reduce computational complexity, we only considered the parallelism occurring between consecutive sentences. For each sentence, we indicated the index of its parallel sentence. We assumed transitivity of parallelism : if S 1 //S 2 and S 2 //S 3 , then S 1 //S 3 . It was thus considered sufficient to indicate the index of S 1 for S 2 and the index of S 2 for S 3 to account for a parallelism between S 1 , S 2 and S 3 . We annotated pairs of sentences where textual parallelism led us to rhetorically coordinate them. The decision was sometimes hard to make. Yet we annotated it each time to get more data and to study the behavior of the methods on these examples, possibly penalizing our applications. In the end, 103 pairs were annotated. We used the notions of precision (correctness) and recall (completeness). Because efforts in im-proving one often result in degrading the other, the F-measure (harmonic mean) combines them into a unique parameter, which simplifies comparisons of results. Let P be the set of the annotated parallelisms and Q the set of the pairs automatically classified in the parallelisms after the use of a threshold. Then the associated precision p, recall r and F-measure f are defined as: p = |P \u2229 Q| |Q| r = |P \u2229 Q| |P | f = 2 1/p + 1/q As we said, the unique task of the implemented methods was to assign parallelism scores to pairs of sentences, which are collected in a list. We manually applied various thresholds to the list and computed their corresponding F-measure. We kept as a performance indicator the best F-measure found. This was performed for each method and on each text, as well as on the texts all gathered together. Preliminary corpus study This paragraph underlines some of the characteristics of the corpus, in particular the distribution of the annotated parallelisms in the texts for adjacent sentences. The following Green and Oakes show significantly more parallelisms than the other texts. Therefore, if we consider a lazy method that would put all pairs in the class of parallelisms, Green and Oakes will yield a priori better results. Precision is indeed directly related to the percentage of parallelisms in the text. In this case, it is exactly this percentage, and it gives us a minimum value of the F-measure our methods should at least reach: A baseline: counting words in common We first present the results of a very simple and thus very fast method. This baseline counts the words sentences S 1 and S 2 have in common, and normalizes the result by |S 1 |+|S 2 | 2 in order to reduce size effects. No syntactic analysis nor lexical homogenization was performed on the texts. Results for this method are summarized in the following table. The last column shows the loss (%) in F-measure after applying a generic threshold (the optimal threshold found when all texts are gathered together) on each text. We first note that results are twice as good as with the lazy approach, with Green and Oakes far above the rest. Yet this is not sufficient for a real application. Furthermore, the optimal threshold is very different from one text to another, which makes the learning of a generic threshold able to detect parallelisms for any text impossible. The only advantage here is the simplicity of the method: no prior treatment was performed on the texts before the search, and the counting itself was very fast. String edit distance We present the results for the 1 st method below: Green and Oakes still yield the best results, but the other texts have almost doubled theirs. Results for Oakes are especially good: an F-measure of 82% guaranties high precision and recall. In addition, the use of a generic threshold on each text had little influence on the value of the F-measure. The greatest loss is for Sand and only corresponds to the adjunction of four pairs of sentences in the class of parallelisms. The selection of a unique generic threshold to predict parallelisms should therefore be possible. Tree edit distance The algorithm was applied using unitary edit costs. Since it did not seem natural to establish mappings between different levels of the sentence, edit operations between two constituents of different nature (e.g: substitution of a lexical by a syntactic element) were forbidden by a prohibitive cost (1000). However, this banning only improved the results shyly, unfortunately. As illustrated in the table above, results are comparable to those previously found. We note an especially good F-measure for Sand: 52%, against 47% for the string edit distance. Optimal thresholds were quite similar from one text to another. Degree of similarity Because of the high complexity of this method, a heuristic was applied. The generation of the subsentences is indeed in C k i n i , k i being the number of occurrences of the constituent x i in gcd, and n i the number of x i in the sentence. We chose to limit the generation to a fixed amount of subsentences. The constituents that have a great C k i n i bring too much complexity: we chose to eliminate their (n i \u2212 k i ) last occurrences and to keep their k i first occurrences only to generate subsequences. An experiment was conducted in order to determine the maximum amount of subsentences that could be generated in a reasonable amount of time without significant performance loss and 30 was a sufficient number. In another experiment, different parallelism weights were assigned to lexical constituents and syntactic labels. The aim was to understand their relative importance for parallelisms detection. Results show that lexical constituents have a significant role, but conclusions are more difficult to draw for syntactic labels. It was decided that, from now on, the lexical weight should be given the maximum value, 1. Finally, we assigned different weights to the syntactic labels. Weights were chosen after counting the occurrences of the labels in the corpus. In fact, we counted for each label the percentage of occurrences that appeared in the gcd of the parallelisms with respect to those appearing in the gcd of the other pairs. Percentages were then rescaled from 0 to 1, in order to emphasize differences between labels. The obtained parallelism values measured the role of the labels in the detection of parallelism. Results for this experiment appear in the table below. The optimal F-measures were comparable to those obtained in 4.4 and the corresponding thresholds were similar from one text to another. This section showed how the three proposed methods outperformed the baseline. Each of them yielded comparable results. The next section presents the results at sentence level, together with a comparison of these three methods. Analysis at sentence level The different methods often agreed but sometimes reacted quite differently. Well retrieved parallelisms Some parallelisms were found by each method with no difficulty: they were given a high degree of parallelism by each method. Typically, such sentences presented a strong lexical and syntactic similarity, as in the example in section 2. Parallelisms hard to find Other parallelisms received very low scores from each method. This happened when the annotated parallelism was lexically and syntactically poor and needed either contextual information or external semantic knowledge to find keywords (e.g: \"first\", \"second\", . . . ), paraphrases or patterns (e.g: \"X:Y\" in the following example (Kan)): Rear: a paragraph in which a link just stopped occurring the paragraph before. No link: any remaining paragraphs. Different methods, different results Eventually, we present some parallelisms that obtained very different scores, depending on the method. First, it seems that a different ordering of the parallel constituents in the sentences alter the performances of the edit distance algorithms (3.2; 3.3). The following example (Green) received a low score with both methods: When we consider AnsV as our dependent variable, the model for the High Web group is still not significant, and there is still a high probability that the coefficient of LI is 0. For our Low Web group, who followed significantly more intra-article links than the High Web group, the model that results is significant and has the following equation: <EQN/>. This is due to the fact that both algorithms do not allow the inversion of two constituents and thus are unable to find all the links from the first sentence to the other. The parallelism measure is robust to inversion. Sometimes, the syntactic parser gave different analyses for the same expression, which made mapping between the sentences containing this expression more difficult, especially for the tree edit distance. The syntactic structure has less importance for the other methods, which are thus more insensitive to an incorrect analysis. Finally, the parallelism measure seems more adapted to a diffuse distribution of the parallel constituents in the sentences, whereas edit distances seem more appropriate when parallel constituents are concentrated in a certain part of the sentences, in similar syntactic structures. The following example (Green) obtained very high scores with the edit distances only: Strong relations are also said to exist between words that have synsets connected by a single horizontal link or words that have synsets connected by a single IS-A or INCLUDES relation. A regular relation is said to exist between two words when there is at least one allowable path between a synset containing the first word and a synset containing the second word in the Word-Net database. Related work Experimental work in psycholinguistics has shown the importance of the parallelism effect in human language processing. Due to some kind of priming (syntactic, phonetic, lexical, etc.) , the comprehension and the production of a parallel utterance is made faster (Dubey et al., 2005) . So far, most of the works were led in order to acquire resources and to build systems to retrieve specific parallelism phenomena. In the field of information structure theories, (Kruijff-Korbayov\u00e1 and Kruijff, 1996) implemented an ad-hoc system to identify thematic continuity (lexical relation between the subject parts of consecutive sentences). (Luc et al., 1999) described and classified markers (lexical clues, layout and typography) occurring in enumeration structures. (Summers, 1998 ) also described the markers required for retrieving heading structures. (Charolles, 1997) was involved in the description of frame introducers. Integration of specialized resources dedicated to parallelism detection could be an improvement to our approach. Let us not forget that our final aim remains the detection of discourse structures. Parallelism should be considered as an additional feature which among other discourse features (e.g. connectors). Regarding the use of parallelism, (Hernandez and Grau, 2005) proposed an algorithm to parse the discourse structure and to select pairs of sentences to compare. Confronted to the problem of determining textual entailment 4 (the fact that the meaning of one expression can be inferred from another) (Kouylekov and Magnini, 2005) applied the (Zhang and Shasha, 1989 )'s algorithm on the dependency trees of pairs of sentences (they did not consider syntactic tags as nodes but only words). They encountered problems similar to ours due to pre-treatment limits. Indeed, the syntactic parser sometimes represents in a different way occurrences of similar expressions, making it harder to apply edit transformations. A drawback concerning the tree-edit distance approach is that it is not able to observe the whole tree, but only the subtree of the processed node. Conclusion Textual parallelism plays an important role among discourse features when detecting discourse structures. So far, only occurrences of this phenomenon have been treated individually and often in an adhoc manner. Our contribution is a unifying framework which can be used for automatic processing with much less specific knowledge than dedicated techniques. In addition, we discussed and evaluated several methods to retrieve them generically. We showed that simple methods such as (Wagner and Fischer, 1974) can compete with more complex approaches, such as our degree of similarity and the (Zhang and Shasha, 1989 )'s algorithm. Among future works, it seems that variations such as the editing cost of transformation for edit distance methods and the weight of parallel units (depending their semantic and syntactic characteristics) can be implemented to enhance performances. Combining methods also seems an interesting track to follow.",
    "abstract": "Detection of discourse structure is crucial in many text-based applications. This paper presents an original framework for describing textual parallelism which allows us to generalize various discourse phenomena and to propose a unique method to recognize them. With this prospect, we discuss several methods in order to identify the most appropriate one for the problem, and evaluate them based on a manually annotated corpus.",
    "countries": [
        "France"
    ],
    "languages": [],
    "numcitedby": "11",
    "year": "2006",
    "month": "April",
    "title": "Recognizing Textual Parallelisms with Edit Distance and Similarity Degree"
}