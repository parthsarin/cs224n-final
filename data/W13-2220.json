{
    "article": "We propose a pre-reordering scheme to improve the quality of machine translation by permuting the words of a source sentence to a target-like order. This is accomplished as a transition-based system that walks on the dependency parse tree of the sentence and emits words in target-like order, driven by a classifier trained on a parallel corpus. Our system is capable of generating arbitrary permutations up to flexible constraints determined by the choice of the classifier algorithm and input features. Introduction The dominant paradigm in statistical machine translation consists mainly of phrase-based system such as Moses (Koehn et.al.,2007) . Different languages, however, often express the same concepts in different idiomatic word orders, and while phrase-based system can deal to some extent with short-distance word swaps that are captured by short segments, they typically perform poorly on long-distance (more than four or five words apart) reordering. In fact, according to (Birch et.al., 2008) , the amount of reordering between two languages is the most predictive feature of phrase-based translation accuracy. A number of approaches to deal with longdistance reordering have been proposed. Since an extuasive search of the permutation space is unfeasible, these approaches typically constrain the search space by leveraging syntactical structure of natural languages. In this work we consider approaches which involve reordering the words of a source sentence in a target-like order as a preprocessing step, before feeding it to a phrase-based decoder which has itself been trained with a reordered training set. These methods also try to leverage syntax, typically by applying hand-coded or automatically induced reordering rules to a constituency or dependency parse of the source sentence. (Galley and Manning, 2008; Xu et.al., 2009; Genzel, 2010; Isozaki et.al., 2010) or by treating reordering as a global optimization problem (Tromble and Eisner, 2009; Visweswariah et.al., 2011) . In order to keep the training and execution processes tractable, these methods impose hard constrains on the class of permutations they can generate. We propose a pre-reordering method based on a walk on the dependency parse tree of the source sentence driven by a classifier trained on a parallel corpus. In principle, our system is capable of generating arbitrary permutations of the source sentence. Practical implementations will necessarily limit the available permutations, but these constraints are not intrinsic to the model, rather they depend on the specific choice of the classifier algorithm, its hyper-parameters and input features. 2 Reordering as a walk on a dependency tree Dependency parse trees Let a sentence be a list of words s \u2261 (w 1 , w 2 , . . . , w n ) and its dependency parse tree be a rooted tree whose nodes are the words of the sentence. An edge of the tree represents a syntactical dependency relation between a head (parent) word and a modifier (child) word. Typical dependency relations include verb-subject, verb-object, noun-adjective, and so on. We assume that in addition to its head h i and dependency relation type d i each word is also annotated with a part-of-speech p i and optionally a lemma l i and a morphology m i (e.g. grammatical case, gender, number, tense). Some definitions require dependency parse trees to be projective, meaning that any complete subtree must correspond to a contiguous span of words in the sentence, however, we don't place such a requirement. In practice, languages with a substantially strict word ordering like English typically have largely projective dependencies, while languages with a more free word ordering like Czech can have substantial non-projectivity. Reordering model Given a sentence s \u2208 S with its dependency parse tree and additional annotations, we incrementally construct a reordered sentence s by emitting its words in a sequence of steps. We model the reordering process as a non-deterministic transition system which traverses the parse tree: Let the state of the system be a tuple x \u2261 (i, r, a, , . . . ) containing at least the index of the current node i (initialized at the root), the list of emitted nodes r (initialized as empty) and the last transition action a (initialized as null). Additional information can be included in the state x, such as the list of the last K nodes that have been visited, the last K actions and a visit count for each node. At each step we choose one of the following actions: \u2022 EM IT : emit the current node. Enabled only if the current node hasn't already been emitted i / \u2208 r (i, r, a, , . . . ) EM IT \u2192 (i, (r | i) , EM IT, , . . . ) \u2022 U P : move to the parent of the current node hi = null, \u2200j a = DOW Nj (i, r, a, , . . . ) U P \u2192 (hi, r, U P, , . . . ) \u2022 DOW N j : move to the child j of the current node. Enabled if the subtree of j (including j) contains nodes that have not been emitted yet. hj = i, a = U P, \u2203k \u2208 subtree(i) : k / \u2208 r (i, r, a, , . . . ) DOW N j \u2192 (j, r, DOW Nj, , . . . ) The pre-conditions on the UP and DOWN actions prevent them from canceling each other, ensuring that progress is made at each step. The additional precondition on DOWN actions ensures that the process always halts at a final state where all the nodes have been emitted. Let T (s) be the set of legal traces of the transition system for sentence s. Each trace \u03c4 \u2208 T (s) defines a permutation s \u03c4 of s as the list of emitted nodes r of its final state. We define the reordering problem as finding the trace \u03c4 * that maximizes a scoring function \u03a6 \u03c4 * \u2261 arg max \u03c4 \u2208T (s) \u03a6 (s, \u03c4 ) (1) Note that since the parse tree is connected, in principle any arbitrary permutation can be generated for a suitable choice of \u03a6, though the maximization problem (1) is NP-hard and APXcomplete in the general case, by trivial reduction from the traveling salesman problem. The intuition behind this model is to leverage the syntactical information provided by the dependency parse tree, as successfully done by (Xu et.al., 2009; Genzel, 2010; Isozaki et.al., 2010) without being strictly constrained by a specific type reordering rules. Trace scores We wish to design a scoring function \u03a6 that captures good reorderings for machine translation and admits an efficient optimization scheme. We chose a function that additively decomposes into local scoring functions, each depending only on a single state of the trace and the following transition action \u03a6 (s, \u03c4 ) \u2261 |\u03c4 |\u22121 t=1 \u03c6 (s, x (\u03c4, t) , x a (\u03c4, t + 1)) (2) We further restrict our choice to a function which is linear w.r.t. a set of elementary local feature functions {f k } \u03c6 (s, x, a) \u2261 |F | k=1 v k f k (s, x, a) (3) where {v k } \u2208 R |F | is a vector of parameters derived from a training procedure. While in principle each feature function could depend on the whole sentence and the whole sequence of nodes emitted so far, in practice we restrict the dependence to a fixed neighborhood of the current node and the last few emitted nodes. This reduces the space of possible permutations. Classifier-driven action selection Even when the permutation space has been restricted by an appropriate choice of the feature functions, computing an exact solution of the optimization problem (1) remains non-trivial, because at each step of the reordering generation process, the set of enabled actions depends in general on nodes emitted at any previous step, and this prevents us from applying typical dynamic programming techniques. Therefore, we need to apply an heuristic procedure. In our experiments, we apply a simple greedy procedure: at each step we choose an action according to the output a two-stage classifier: 1. A three-class one-vs-all logistic classifier chooses an action among EMIT, UP or DOWN based on a vector of features extracted from a fixed neighborhood of the current node i, the last emitted nodes and additional content of the state. 2. If a DOWN action was chosen, then a onevs-one voting scheme is used to choose which child to descend to: For each pair (j, j ) : j < j of children of i, a binary logistic classifier assigns a vote either to j or j . The child that receives most votes is chosen. This is similar to the max-wins approach used in packages such as LIBSVM (Chang and Lin, 2011) to construct a M -class classifier from M (M \u2212 1) /2 binary classifiers, except that we use a single binary classifier acting on a vector of features extracted from the pair of children (j, j ) and the node i, with their respective neighborhoods. We also experimented with different classification schemes, but we found that this one yields the best performance. Note that we are not strictly maximizing a global linear scoring function as as defined by equations ( 2 ) and (3), although this approach is closely related to that framework. This approach is related to transition-based dependency parsing such as (Nivre and Scholz, 2004; Attardi, 2006) or dependency tree revision (Attardi and Ciaramita, 2007) . Training Dataset preparation Following (Al-Onaizan and Papineni, 2006; Tromble and Eisner, 2009; Visweswariah et.al., 2011) , we generate a source-side reference reordering of a parallel training corpus. For each sentence pair, we generate a bidirectional word alignment using GIZA++ (Och and Ney, 2000) and the \"grow-diag-final-and\" heuristic implemented in Moses (Koehn et.al.,2007) , then we assign to each source-side word a integer index corresponding to the position of the leftmost targetside word it is aligned to (attaching unaligned words to the following aligned word) and finally we perform a stable sort of source-side words according to this index. On language pairs where GIZA++ produces substantially accurate alignments (generally all European languages) this scheme generates a target-like reference reordering of the corpus. In order to tune the parameters of the downstream phrase-based translation system and to test the overall translation accuracy, we need two additional small parallel corpora. We don't need a reference reordering for the tuning corpus since it is not used for training the reordering system, however we generate a reference reordering for the test corpus in order to evaluate the accuracy of the reordering system in isolation. We obtain an alignment of this corpus by appending it to the training corpus, and processing it with GIZA++ and the heuristic described above. Reference traces generation and classifier training For each source sentence s in the training set and its reference reordering s , we generate a minimum-length trace \u03c4 of the reordering transition system, and for each state and action pair in it we generate the following training examples: \u2022 For the first-stage classifier we generate a single training examples mapping the local features to an EMIT, UP or DOWN action label \u2022 For the second-stage classifier, if the action is DOW N j , for each pair of children (k, k ) : k < k of the current node i, we generate a positive example if j = k or a negative example if j = k . Both classifiers are trained with the LIBLIN-EAR package (Fan et.al., 2008) , using the L2regularized logistic regression method. The regularization parameter C is chosen by two-fold cross-validation. In practice, subsampling of the training set might be required in order to keep memory usage and training time manageable. Translation system training and testing Once the classifiers have been trained, we run the reordering system on the source side of the whole (non-subsampled) training corpus and the tuning corpus. For instance, if the parallel corpora are German-to-English, after the reordering step we obtain German'-to-English corpora, where German' is German in an English-like word order. These reordered corpora are used to train a standard phrase-based translation system. Finally, the reordering system is applied to source side of the test corpus, which is then translated with the downstream phrase-based system and the resulting translation is compared to the reference translation in order to obtain an accuracy measure. We also evaluate the \"monolingual\" reordering accuracy of upstream reordering system by comparing its output on the source side of the test corpus to the reference reordering obtained from the alignment. Experiments We performed German-to-English and Italian-to-English reordering and translation experiments. Data The German-to-English corpus is Europarl v7 (Koehn, 2005) . We split it in a 1,881,531 sentence pairs training set, a 2,000 sentence pairs development set (used for tuning) and a 2,000 sentence pairs test set. We also used a 3,000 sentence pairs \"challenge\" set of newspaper articles provided by the WMT 2013 translation task organizers. The Italian-to-English corpus has been assembled by merging Europarl v7, JRC-ACQUIS v2.2 (Steinberger et.al., 2006) and bilingual newspaper articles crawled from news websites such as Corriere.it and Asianews.it. It consists of a 3,075,777 sentence pairs training set, a 3,923 sentence pairs development set and a 2,000 sentence pairs test set. The source sides of these corpora have been parsed with Desr (Attardi, 2006) . For both language pairs, we trained a baseline Moses phrasebased translation system with the default configuration (including lexicalized reordering). In order to keep the memory requirements and duration of classifier training manageable, we subsampled each training set to 40,000 sentences, while both the baseline and reordered Moses system are trained on the full training sets. Features After various experiments with feature selection, we settled for the following configuration for both German-to-English and Italian-to-English: (left, right, parent, parent-left, parent-right, grandparent, left-child, right-child) and pairwise combination between syntactical features of these nodes. \u2022 Second stage classifier: stateful features for the current node i and the the children pair (j, j ), lexical and syntactical features for each of the children and pairwise combinations of these features, visit count differences and signed distances between the two children and the current node, syntactical trigram features between all combinations of the two children, the current node, the parent h i and the two last emitted nodes and the two last visited nodes, lexical and syntactical features for the two children left and right neighbors. All features are encoded as binary one-of-n indicator functions. Results For both German-to-English and Italian-to-English experiments, we prepared the data as described above and we trained the classifiers on their subsampled training sets. In order to evaluate the classifiers accuracy in isolation from the rest of the system, we performed two-fold cross vali- We applied the reordering preprocessing system to the source side of the corpora and evaluated the monolingual BLEU and NIST score of the test sets (extracted from Europarl) against their reference reordering computed from the alignment To evaluate translation performance, we trained a Moses phrase-based system on the reordered training and tuning corpora, and evaluated the BLEU and NIST of the (Europarl) test sets. As a baseline, we also trained and evaluated Moses system on the original unreordered corpora. We also applied our baseline and reordered German-to-English systems to the WMT2013 translation task dataset. Discussion Unfortunately we were generally unable to improve the translation scores over the baseline, even though our monolingual BLEU for German-to-English reordering is higher than the score reported by (Tromble and Eisner, 2009) for a comparable dataset. Accuracy on the WMT 2013 set is very low. We attribute this to the fact that it comes form a different domain than the training set. Since classifier training set cross-validation accuracy is high, we speculate that the main problem lies with the training example generation process: training examples are generated only from optimal reordering traces. This means that once the classifiers produce an error and the system strays away from an optimal trace, it may enter in a feature space that is not well-represented in the training set, and thus suffer from unrecoverable performance degradation. Moreover, errors occurring on nodes high in the parse tree may cause incorrect placement of whole spans of words, yielding a poor BLEU score (although a cursory examination of the reordered sentences doesn't reveal this problem to be prevalent). Both these issues could be possibly addressed by switching from a classifier-based system to a structured prediction system, such as averaged structured perceptron (Collins, 2002) or MIRA (Crammer, 2003; McDonald et.al., 2005) . Another possible cause of error is the purely greedy action selection policy. This could be addressed using a search approach such as beam search. We reserve to investigate these approaches in future work.",
    "abstract": "We propose a pre-reordering scheme to improve the quality of machine translation by permuting the words of a source sentence to a target-like order. This is accomplished as a transition-based system that walks on the dependency parse tree of the sentence and emits words in target-like order, driven by a classifier trained on a parallel corpus. Our system is capable of generating arbitrary permutations up to flexible constraints determined by the choice of the classifier algorithm and input features.",
    "countries": [
        "Italy"
    ],
    "languages": [
        "Italian",
        "English",
        "German"
    ],
    "numcitedby": "14",
    "year": "2013",
    "month": "August",
    "title": "Pre-Reordering for Machine Translation Using Transition-Based Walks on Dependency Parse Trees"
}