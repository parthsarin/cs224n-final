{
    "article": "Markov logic is a highly expressive language recently introduced to specify the connectivity of a Markov network using first-order logic. While Markov logic is capable of constructing arbitrary first-order formulae over the data, the complexity of these formulae is often limited in practice because of the size and connectivity of the resulting network. In this paper, we present approximate inference and estimation methods that incrementally instantiate portions of the network as needed to enable firstorder existential and universal quantifiers in Markov logic networks. When applied to the problem of identity uncertainty, this approach results in a conditional probabilistic model that can reason about objects, combining the expressivity of recently introduced BLOG models with the predictive power of conditional training. We validate our algorithms on the tasks of citation matching and author disambiguation. Introduction Markov logic networks (MLNs) combine the probabilistic semantics of graphical models with the expressivity of first-order logic to model relational dependencies (Richardson and Domingos, 2004) . They provide a method to instantiate Markov networks from a set of constants and first-order formulae. While MLNs have the power to specify Markov networks with complex, finely-tuned dependencies, the difficulty of instantiating these networks grows with the complexity of the formulae. In particular, expressions with first-order quantifiers can lead to networks that are large and densely connected, making exact probabilistic inference intractable. Because of this, existing applications of MLNs have not exploited the full richness of expressions available in first-order logic. For example, consider the database of researchers described in Richardson and Domingos (2004) , where predicates include Professor(person), Student(person), AdvisedBy (person, person) , and Published(author, paper). Firstorder formulae include statements such as \"students are not professors\" and \"each student has at most one advisor.\" Consider instead statements such as \"all the students of an advisor publish papers with similar words in the title\" or \"this subset of students belong to the same lab.\" To instantiate an MLN with such predicates requires existential and universal quantifiers, resulting in either a densely connected network, or a network with prohibitively many nodes. (In the latter example, it may be necessary to ground the predicate for each element of the power set of students.) However, as discussed in Section 2, there may be cases where these aggregate predicates increase predictive power. For example, in predicting the value of HaveSameAdvisor(a i . . . a i+k ), it may be useful to know the values of aggregate evidence predicates such as CoauthoredAtLeastTwoPapers(a i . . . a i+k ), which indicates whether there are at least two papers that some combination of authors from a i . . . a i+k have co-authored. Additionally, we can construct predicates such as NumberOfStudents(a i ) to model the number of students a researcher is likely to advise simultaneously. These aggregate predicates are examples of universal and existentially quantified predicates over observed and unobserved values. To enable these sorts of predicates while limiting the complexity of the ground Markov network, we present an algorithm that incrementally expands the set of aggregate predicates during the inference procedure. In this paper, we describe a general algorithm for incremental expansion of predicates in MLNs, then present an implementation of the algorithm applied to the problem of identity uncertainty. Related Work MLNs were designed to subsume various previously proposed statistical relational models. Probabilistic relational models (Friedman et al., 1999) combine descriptive logic with directed graphical models, but are restricted to acyclic graphs. Relational Markov networks (Taskar et al., 2002) use SQL queries to specify the structure of undirected graphical models. Since first-order logic subsumes SQL, MLNs can be viewed as more expressive than relational Markov networks, although existing applications of MLNs have not fully utilized this increased expressivity. Other approaches combining logic programming and log-linear models include stochastic logic programs (Cussens, 2003) and MACCENT (Dehaspe, 1997) , although MLNs can be shown to represent both of these. Viewed as a method to avoid grounding an intractable number of predicates, this paper has similar motivations to recent work in lifted inference (Poole, 2003; de Salvo Braz et al., 2005) , which performs inference directly at the first-order level to avoid instantiating all predicates. Although our model is not an instance of lifted inference, it does attempt to reduce the number of predicates by instantiating them incrementally. Identity uncertainty (also known as record linkage, deduplication, object identification, and co-reference resolution) is the problem of determining whether a set of constants (mentions) refer to the same object (entity). Successful identity resolution enables vision systems to track objects, database systems to deduplicate redundant records, and text processing systems to resolve disparate mentions of people, organizations, and locations. Many probabilistic models of object identification have been proposed in the past 40 years in databases (Fellegi and Sunter, 1969; Winkler, 1993) and natural language processing (McCarthy and Lehnert, 1995; Soon et al., 2001) . With the introduction of statistical relational learning, more sophisticated models of identity uncertainty have been developed that consider the dependencies between related consolidation decisions. Most relevant to this work are the recent relational models of identity uncertainty (Milch et al., 2005; McCallum and Wellner, 2003; Parag and Domingos, 2004) . McCallum and Wellner (2003) present experiments using a conditional random field that factorizes into a product of pairwise decisions about mention pairs (Model 3). These pairwise decisions are made collectively using relational inference; however, as pointed out in Milch et al. (2004) , there are shortcomings to this model that stem from the fact that it does not capture features of objects, only of mention pairs. For example, aggregate features such as \"a researcher is unlikely to publish in more than 2 different fields\" or \"a person is unlikely to be referred to by three different names\" cannot be captured by solely examining pairs of mentions. Additionally, decomposing an object into a set of mention pairs results in \"double-counting\" of attributes, which can skew reasoning about a single object (Milch et al., 2004) . Similar problems apply to the model in Parag and Domingos (2004) . Milch et al. (2005) address these issues by constructing a generative probabilistic model over possible worlds called BLOG, where realizations of objects are typically sampled from a generative process. While BLOG model provides attractive semantics for reasoning about unknown objects, the transition to generatively trained models sacrifices some of the attractive properties of the discriminative model in Mc-Callum and Wellner (2003) and Parag and Domingos (2004) , such as the ability to easily incorporate many overlapping features of the observed mentions. In contrast, generative models are constrained either to assume the independence of these features or to explicitly model their interactions. Object identification can also be seen as an instance of supervised clustering. Daum\u00e9 III and Marcu (2004) and Carbonetto et al. (2005) present similar Bayesian supervised clustering algorithms that use a Dirichlet process to model the number of clusters. As a generative model, it has similar advantages and disadvantages as Milch et al. (2005) , with the added capability of integrating out the uncertainty in the true number of objects. In this paper, we present of identity uncertainty that incorporates the attractive properties of Mc-Callum and Wellner (2003) and Milch et al. (2005) , resulting in a discriminative model to reason about objects. Markov logic networks Let F = {F i } be a set of first order formulae with corresponding real-valued weights w = {w i }. Given a set of constants C = {c i }, define n i (x) to be the number of true groundings of F i realized in a setting of the world given by atomic formulae x. A Markov logic network (MLN) (Richardson and Domingos, 2004 ) defines a joint probability distribution over possible worlds x. In this paper, we will work with discriminative MLNs (Singla and Domingos, 2005) , which define the conditional distribution over a set of query atoms y given a set of evidence atoms x. Using the normalizing constant Z x , the conditional distribution is given by P (Y = y|X = x) = 1 Z x exp \uf8eb \uf8ed |Fy| i=1 w i n i (x, y) \uf8f6 \uf8f8 (1) where F y \u2286 F is the set of clauses for which at least one grounding contains a query atom, and n i (x, y) is the number of true groundings of the ith clause containing evidence atom x and query atom y. Inference Complexity in Ground Markov Networks The set of predicates and constants in Markov logic define the structure of a Markov network, called a ground Markov network. In discriminative Markov logic networks, this resulting network is a conditional Markov network (also known as a conditional random field (Lafferty et al., 2001) ). From Equation 1 , the formulae F y specify the structure of the corresponding Markov network as follows: Each grounding of a predicate specified in F y has a corresponding node in the Markov network; and an edge connects two nodes in the network if and only if their corresponding predicates co-occur in a grounding of a formula F y . Thus, the complexity of the formulae in F y will determine the complexity of the resulting Markov network, and therefore the complexity of inference. When F y contains complex first-order quantifiers, the resulting Markov network may contain a prohibitively large number of nodes. For example, let the set of constants C be the set of authors {a i }, papers {p i }, and conferences {c i } from a research publication database. Predicates may include AuthorOf(a i , p j ), AdvisorOf(a i , a j ), and ProgramCommittee(a i , c j ). Each grounding of a predicate corresponds to a random variable in the corresponding Markov network. It is important to notice how query predicates and evidence predicates differ in their impact on inference complexity. Grounded evidence predicates result in observed random variables that can be highly connected without resulting in an increase in inference complexity. For example, consider the binary evidence predicate HaveSameLastName(a i . . . a i+k ). This aggregate predicate reflects information about a subset of (k \u2212 i + 1) constants. The value of this predicate is dependent on the values of HaveSameLastName(a i , a i+1 ), HaveSameLastName(a i , a i+2 ), etc. However, since all of the corresponding variables are observed, inference does not need to ensure their consistency or model their interaction. In contrast, complex query predicates can make inference more difficult. Consider the query predicate HaveSameAdvisor(a i . . . a i+k ). Here, the related predicates HaveSameAdvisor(a i , a i+1 ), HaveSameAdvisor(a i , a i+2 ), etc., all correspond to unobserved binary random variables that the model must predict. To ensure their consistency, the resulting Markov network must contain dependency edges between each of these variables, resulting in a densely connected network. Since inference in general in Markov networks scales exponentially with the size of the largest clique, inference in the grounded network quickly becomes intractable. One solution is to limit the expressivity of the predicates. In the previous example, we can decompose the predicate HaveSameAdvisor(a i . . . a i+k ) into its (k \u2212 i + 1) 2 corresponding pairwise predicates, such as HaveSameAdvisor(a i , a i+1 ). Answering an aggregate query about the advisors of a group of students can be handled by a conjunction of these pairwise predicates. However, as discussed in Sections 1 and 2, we would like to reason about objects, not just pairs of mentions, because this enables richer evidence predicates. For example, the evidence predicates AtLeastTwoCoauthoredPapers(a i . . . a i+k ) and NumberOfStudents(a i ) can be highly predictive of the query predicate HaveSameAdvisor(a i . . . a i+k ). Below, we describe a discriminative MLN for identity uncertainty that is able to reason at the object level. Identity uncertainty Typically, MLNs make a unique names assumption, requiring that different constants refer to distinct objects. In the publications database example, each author constant a i is a string representation of one author mention found in the text of a citation. The unique names assumption assumes that each a i refers to a distinct author in the real-world. This simplifies the network structure at the risk of weak or fallacious predictions (e.g., AdvisorOf(a i , a j ) is erroneous if a i and a j actually refer to the same author). The identity uncertainty problem is the task of removing the unique names assumption by determining which constants refer to the same real-world objects. Richardson and Domingos (2004) address this concern by creating the predicate Equals(c i , c j ) between each pair of constants. While this retains the coherence of the model, the restriction to pairwise predicates can be a drawback if there exist informative features over sets of constants. In particular, by only capturing features of pairs of constants, this solution cannot model the compatibility of object attributes, only of constant attributes (Section 2). Instead, we desire a conditional model that allows predicates to be defined over a set of constants. One approach is to introduce constants that represent objects, and connect them to their mentions by predicates such as IsMentionOf(c i , c j ). In addition to computational issues, this approach also somewhat problematically requires choosing the number of objects. (See Richardson and Domingos (2004) for a brief discussion.) Instead, we propose instantiating aggregate predicates over sets of constants, such that a setting of these predicates implicitly determines the number of objects. This approach allows us to model attributes over entire objects, rather than only pairs of constants. In the following sections, we describe aggregate predicates in more detail, as well as the approximations necessary to implement them efficiently. Aggregate predicates Aggregate predicates are predicates that take as arguments an arbitrary number of constants. For example, the HaveSameAdvisor(a i . . . a i+k ) predicate in the previous section is an example of an aggregate predicate over k \u2212 i + 1 constants. Let I C = {1 . . . N } be the set of indices into the set of constants C, with power set P(I C ). For any subset d \u2208 P(I C ), an aggregate predicate A(d) defines a property over the subset of constants d. Note that aggregate predicates can be translated into first-order formulae. For example, HaveSameAdvisor(a i . . . a i+k ) can be re-written as \u2200(a x , a y ) \u2208 {a i . . . a i+k } SameAdvisor(a x , a y ). By using aggregate predicates we make explicit the fact that we are modeling the attributes at the object level. We distinguish between aggregate query predicates, which represent unobserved aggregate variables, and aggregate evidence predicates, which represent observed aggregate variables. Note that using aggregate query predicates can complicate inference, since they represent a collection of fully connected hidden variables. The main point of this paper is that although these aggregate query predicates are specifiable in MLNs, they have not been utilized be-cause of the resulting inference complexity. We show that the gains made possible by these predicates often outweigh the approximations required for inference. As discussed in Section 3.1, for each aggregate query predicates A(d), it is critical that the model predict consistent values for every related subset of d. Enforcing this consistency requires introducing dependency edges between aggregate query predicates that share arguments. In general, this can be a difficult problem. Here, we focus on the special case for identity uncertainty where the main query predicate under consideration is AreEqual(d). The aggregate query predicate AreEqual(d) is true if and only if all constants d i \u2208 d refer to the same object. Since each subset of constants corresponds to a candidate object, a (consistent) setting of all the AreEqual predicates results in a solution to the object identification problem. The number of objects is chosen based on the optimal grounding of each of these aggregate predicates, and therefore does not require a prior over the number of objects. That is, once all the AreEqual predicates are set, they determine a clustering with a fixed number of objects. The number of objects is not modeled or set directly, but is implied by the result of MAP inference. (However, a posterior over the number of objects could be modeled discriminatively in an MLN (Richardson and Domingos, 2004) .) This formulation also allows us to compute aggregate evidence predicates over objects to help predict the values of each AreEqual predicate. For example, NumberFirstNames(d) returns the number of different first names used to refer to the object referenced by constants d. In this way, we can model aggregate features of an object, capturing the compatibility among its attributes. For a given C, there are |P(I C )| possible groundings of the AreEqual query predicates. Naively implemented, such an approach would require enumerating all subsets of constants, ultimately resulting in an unwieldy network. An equivalent way to state the problem is that using N -ary predicates results in a Markov network with one node for each grounding of the predicate. Since in the general case there is one grounding for each subset of C, the size of the corresponding Markov network will be exponential in |C|. See Figure 1 for an example instantiation of an MLN with three constants (a, b, c) and one AreEqual predicate. In this paper, we provide algorithms to perform approximate inference and parameter estimation by incrementally instantiating these predicates as needed. MAP Inference Maximum a posteriori (MAP) inference seeks the solution to y * = argmax y P (Y = y|X = x) where y * is the setting of all the query predicates F y (e.g. AreEqual) with the maximal conditional density. In large, densely connected Markov networks, a common approximate inference technique is loopy belief propagation (i.e. the max-product algorithm applied to a cyclic graph). However, the use of aggregate predicates makes it intractable even to instantiate the entire network, making max-product an inappropriate solution. Instead, we employ an incremental inference technique that grounds aggregate query predicates in an agglomerative fashion based on the model's current MAP estimates. This algorithm can be viewed as a greedy agglomerative search for a local optimum of P (Y |X), and has connections to recent work on correlational clustering (Bansal et al., 2004) and graph partitioning for MAP estimation (Boykov et al., 2001) . First, note that finding the MAP estimate does not require computing Z x , since we are only interested in the relative values of each configuration, and Z x is fixed for a given x. Thus, at iteration t, we compute an unnormalized score for y t (the current setting of the query predicates) given the evidence predicates x as follows: S(y t , x) = exp \uf8eb \uf8ed |F t | i=0 w i n i (x, y t ) \uf8f6 \uf8f8 where F t \u2286 F y is the set of aggregate predicates representing a partial solution to the object identification task for constants C, specified by y t . Algorithm 1 Approximate MAP Inference Algorithm 1: Given initial predicates F 0 2: while ScoreIsIncreased do 3: F * i \u21d0 FindMostLikelyPredicate(F t ) 4: F * i \u21d0 true 5: F t \u21d0 ExpandPredicates(F * i , F t ) 6: end while Algorithm 1 outlines a high-level description of the approximate MAP inference algorithm. The algorithm first initializes the set of query predicated F 0 such that all AreEqual predicates are restricted to pairs of constants, i.e. AreEqual(c i , c j ) \u2200(i, j). This is equivalent to a Markov network containing one unobserved random variable for each pair of constants, where each variable indicates whether a pair of constants refer to the same object. Initially, each AreEqual predicate is assumed false. In line 3, the procedure FindMostLike-lyPredicate iterates through each query predicate in F t , setting each to true in turn and calculating its impact on the scoring function. The procedure returns the predicate F * i such that setting F * i to True results in the greatest increase in the scoring function S(y t , x). Let (c * i . . . c * j ) be the set of constants \"merged\" by setting their AreEqual predicate to true. The ExpandPredicates procedure creates new predicates AreEqual(c * i . . . c * j , c k . . . c l ) corresponding to all the potential predicates created by merging the constants c * i . . . c * j with any of the other previously merged constants. For example, after the first iteration, a pair of constants (c * i , c * j ) are merged. The set of predicates are expanded to include AreEqual(c * i , c * j , c k ) \u2200c k , reflecting all possible additional references to the proposed object referenced by c * i , c * j . This algorithm continues until there is no predicate that can be set to true that increases the score function. In this way, the final setting of F y is a local maximum of the score function. As in other search algorithms, we can employ look-ahead to reduce the greediness of the search (i.e., consider multiple merges simultaneously), although we do not include look-ahead in experiments reported here. It is important to note that each expansion of the aggregate query predicates F y has a corresponding set of aggregate evidence predicates. These evidence predicates characterize the compatibility of the attributes of each hypothesized object. Pruning The space required for the above algorithm scales \u2126(|C| 2 ), since in the initialization step we must ground a predicate for each pair of constants. We use the canopy method of McCallum et al. (2000) , which thresholds a \"cheap\" similarity metric to prune unnecessary comparisons. This pruning can be done at subsequent stages of inference to restrict which predicates variables will be introduced. Additionally, we must ensure that predicate settings at time t do not contradict settings at t \u2212 1 (e.g. if F t (a, b, c) = 1, then F t+1 (a, b) = 1). By greedily setting unobserved nodes to their MAP estimates, the inference algorithm ignores inconsistent settings and removes them from the search space. Parameter estimation Given a fully labeled training set D of constants annotated with their referent objects, we would like to estimate the value of w that maximizes the likelihood of D. That is, w * = argmax w P w (y|x). When the data are few, we can explicitly instantiate all AreEqual(d) predicates, setting their corresponding nodes to the values implied by D. The likelihood is given by Equation 1 , where the normal- izer is Z x = y exp |F y | i=1 w i n i (x, y ) . Although this sum over y to calculate Z x is exponential in |y|, many inconsistent settings can be pruned as discussed in Section 3.4.1. In general, however, instantiating the entire set of predicates denoted by y and calculating Z x is intractable. Existing methods for MLN parameter estimation include pseudo-likelihood and voted perceptron (Richardson and Domingos, 2004; Singla and Domingos, 2005) . We instead follow the recent success in piecewise training for complex undirected graphical models (Sutton and McCallum, 2005) by making the following two approximations. First, we avoid calculating the global normalizer Z x by calculating local normalizers, which sum only over the two values for each aggregate query predicate grounded in the training data. We therefore maximize the sum of local probabilities for each query predicate given the evidence predicates. This approximation can be viewed as constructing a log-linear binary classifier to predict whether an isolated set of constants refer to the same object. Input features include arbitrary first-order features over the input constants, and the output is a binary variable. The parameters of this classifier correspond to the w weights in the MLN. This simplification results in a convex optimization problem, which we solve using gradient descent with L-BFGS, a second-order optimization method (Liu and Nocedal, 1989) . The second approximation addresses the fact that all query predicates from the training set cannot be instantiated. We instead sample a subset F S \u2208 F y and maximize the likelihood of this subset. The sampling is not strictly uniform, but is instead obtained by collecting the predicates created while performing object identification using a weak method (e.g. string comparisons). More explicitly, predicates are sampled from the training data by performing greedy agglomerative clustering on the training mentions, using a scoring function that computes the similarity between two nodes by string edit distance. The goal of this clustering is not to exactly reproduce the training clusters, but to generate correct and incorrect clusters that have similar characteristics (size, homogeneity) to what will be present in the testing data. Experiments We perform experiments on two object identification tasks: citation matching and author disambiguation. Citation matching is the task of determining whether two research paper citation strings refer to the same paper. We use the Citeseer corpus (Lawrence et al., 1999) , containing approximately 1500 citations, 900 of which are unique. The citations are manually labeled with cluster identifiers, and the strings are segmented into fields such as author, title, etc. The citation data is split into four disjoint categories by topic, and the results presented are obtained by training on three categories and testing on the fourth. Using first-order logic, we create a number of aggregate predicates such as AllTitlesMatch, Al-lAuthorsMatch, AllJournalsMatch, etc., as well as their existential counterparts, ThereExist-sTitleMatch, etc. We also include count predicates, which indicate the number of these matches in a set of constants. Additionally, we add edit distance predicates, which calculate approximate matches 1 between title fields, etc., for each pair of citations in a set of citations. Aggregate features are used for these, such as \"there exists a pair of citations in this cluster which have titles that are less than 30% similar\" and \"the minimum edit distance between titles in a cluster is greater than 50%.\" We evaluate using pairwise precision, recall, and F1, which measure the system's ability to predict whether each pair of constants refer to the same object or not. Table 1 shows the advantage of our proposed model (Objects) over a model that only considers pairwise predicates of the same features (Pairs). Note that Pairs is a strong baseline that performs collective inference of citation matching decisions, but is restricted to use only IsEqual(c i , c j ) predicates over pairs of citations. Thus, the performance difference is due to the ability to model firstorder features of the data. Author disambiguation is the task of deciding whether two strings refer to the same author. To increase the task complexity, we collect citations from the Web containing different authors with matching last names and first initials. Thus, simply performing a string match on the author's name would be insufficient in many cases. We searched for three common last name / first initial combinations (Miller, D; Li, W; Smith, B). From this set, we collected 400 citations referring to 56 unique authors. For these experiments, we train on two subsets and test on the third. We generate aggregate predicates similar to those used for citation matching. Additionally, we include features indicating the overlap of tokens from the titles and indicating whether there exists a pair of authors in this cluster that have different middle names. This last feature exemplifies the sort of reasoning enabled by aggregate predicates: For example, consider a pairwise predicate that indicates whether two authors have the same middle name. Very often, middle name information is unavailable, so the name \"Miller, A.\" may have high similarity to both \"Miller, A. B.\" and \"Miller, A. C.\". However, it is unlikely that the same person has two different middle names, and our model learns a weight for this feature. Table 2 demonstrates the advantage of this method. Overall, Objects achieves F 1 scores superior to Pairs on 5 of the 7 datasets. These results indicate the potential advantages of using complex first-order quantifiers in MLNs. The cases in which Pairs outperforms Objects are likely due to the fact that the approximate inference used in Objects is greedy. Increasing the robustness of inference is a topic of future research. Conclusions and Future Work We have presented an algorithm that enables practical inference in MLNs containing first-order existential and universal quantifiers, and have demonstrated the advantages of this approach on two real-world datasets. Future work will investigate efficient ways to improve the approximations made during inference, for example by reducing its greediness by revising the MAP estimates made at previous iterations. Although the optimal number of objects is chosen implicitly by the inference algorithm, there may be reasons to explicitly model this number. For example, if there exist global features of the data that suggest there are many objects, then the inference algorithm should be less inclined to merge constants. Additionally, the data may exhibit \"preferential attachment\" such that the probability of a constant being added to an existing object is proportional to the number of constants that refer to that object. Future work will examine the feasibility of adding aggregate query predicates to represent these values. More subtly, one may also want to directly model the size of the object population. For example, given a database of authors, we may want to estimate not only how many distinct authors exist in the database, but also how many distinct authors exist outside of the database, as discussed in Milch et al. (2005) . Discriminatively-trained models cannot easily reason about objects for which they have no observations; so a generative/discriminative hybrid model may be required to properly estimate this value. Finally, while the inference algorithm we describe is evaluated only on the object uncertainty task, we would like to extend it to perform inference over arbitrary query predicates. Acknowledgments We would like to thank the reviewers, and Pallika Kanani for helpful discussions. This work was supported in part by the Center for Intelligent Information Retrieval, in part by U.S. Government contract #NBCH040171 through a subcontract with BBNT Solutions LLC, in part by The Central Intelligence Agency, the National Security Agency and National Science Foundation under NSF grant #IIS-0326249, and in part by the Defense Advanced Research Projects Agency (DARPA), through the Department of the Interior, NBC, Acquisition Services Division, under contract number NBCHD030010. Any opinions, findings and conclusions or recommendations expressed in this material are the author(s)' and do not necessarily reflect those of the sponsor.",
    "funding": {
        "defense": 1.0,
        "corporate": 1.0,
        "research agency": 1.0,
        "foundation": 0.0,
        "none": 0.0
    },
    "reasoning": "Reasoning: The acknowledgments section of the article mentions support from the Center for Intelligent Information Retrieval, U.S. Government contract #NBCH040171 through a subcontract with BBNT Solutions LLC, The Central Intelligence Agency, the National Security Agency, National Science Foundation under NSF grant #IIS-0326249, and the Defense Advanced Research Projects Agency (DARPA), through the Department of the Interior, NBC, Acquisition Services Division, under contract number NBCHD030010. This indicates funding from defense (CIA, NSA, DARPA), corporate (BBNT Solutions LLC), and research agency (National Science Foundation)."
}