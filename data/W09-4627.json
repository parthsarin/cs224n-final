{
    "article": "A polyadic dynamic logic is introduced in which a model-theoretic version of nonlocal multicomponent tree-adjoining grammar can be formulated. It is shown to have a low polynomial time model checking procedure. This means that treebanks for nonlocal MCTAG, incl. all weaker extensions of TAG, can be efficiently corrected and queried. Our result is extended to HPSG treebanks (with some qualifications). The model checking procedures can also be used in heuristics-based parsing. * The model checking procedure described in this paper uses constructs from a model checking procedure introduced in joint work with Martin Lange. Thanks also to Laura Kallmeyer, Timm Lichte and Wolfgang Maier for introducing me to various extensions of tree-adjoining grammar, incl. nonlocal MCTAG. Introduction First order logics and monadic second order logics have been used to query standard treebanks of context-free derivation structures (Kepser, 2004) . The model checking problems for both logics are known to be PSPACE-complete (Blackburn et al., 2001) , however. Moreover, treebanks are now being constructed that replace context-free derivation structures with context-sensitive ones, incl. The Prague Dependency Treebank (Haji\u010dov\u00e1 et al., 2001) , The Danish Dependency Treebank (Buch-Kromann, 2007) , The LinGO Redwoods Treebank (English) (Oepen et al., 2002) , and Bul-TreeBank (Simov et al., 2004) . Maier and S\u00f8gaard (2008) show that even German standard treebanks such as TIGER and NeGra contain mildly context-sensitive derivation structures. The dependency treebanks also use mildly context-sensitive derivation structures (Kuhlmann and M\u00f6hle, 2007) ; the frequency of non-contextfree structures in these treebanks is estimated in Nivre (2006) and is similar to the frequency of such strucures in TIGER and NeGra (Maier and S\u00f8gaard, 2008) . The HPSG treebanks (Redwoods and BulTreeBank) also contain context-sensitive derivation structures (and beyond) . The obvious question to ask now is: Are there less complex logics that can be used to correct and query contextsensitive treebanks? This paper introduces a polyadic modal logic called decharge logic. Its model checking problem can be solved in low polynomial time; a model checking algorithm is spelled out. It is shown that decharge logic captures context-sensitive nonlocal multicomponent tree-adjoining grammars (MC-TAGs) (Becker et al., 1991) in the following sense: For each non-local MCTAG G, there exists a decharge logic D such that \u03c9 \u2208 L(G) iff \u2203M.M |= D \u03c9, i.e. if a string is recognized by the grammar G it is satisfiable in the corresponding logic. D is thus a model-theoretic characterization of G. Nonlocal MCTAG is context-sensitive, but not mildly context-sensitive (Rambow and Satta, 1992) , and its fixed and universal recognition problems are NP-complete. Head-driven phrase structure grammar (HPSG) (Pollard and Sag, 1994 ) is strictly more expressive, i.e. it is possible to reconstruct nonlocal MCTAGs in the HPSG formalism (S\u00f8gaard, 2007) . In other words, every nonlocal MCTAG is, formally, a HPSG. This doesn't tell us much, since, formally, most things are HPSGs: most formalizations of HPSG are Turing complete (Hegner, 1996) . Even the model checking problem of the standard logical formalization of HPSG -known as relational speciate reentrant logic (RSRL) (Richter, 2004) -is undecidable (S\u00f8gaard, 2007) . HPSG is captured in the above sense (with some qualifications) by an extended version of decharge logic whose model checking problem remains low polynomial time solvable (S\u00f8gaard and Lange, 2009) . Note on style: Knowledge of tree-adjoining grammar and HPSG is assumed for brevity. Instead a more detailed introduction is given to the concepts from modal logic used in decharge logic. See Joshi and Schabes (1997) for a recent introduction to tree-adjoining grammar. Since the paper covers some ground, proofs are only presented as informal proof sketches. In general, the point of the paper is to present decharge logic and its extension and to argue that these logics may be relevant for natural language processing. The technical results are sketched, but only informally. No motivation is provided for the move to context-sensitive formalisms itself. The point is simply: if you want to use contextsensitive treebanks and query them, decharge logic has better computational properties than the other logics proposed in the literature for linguistic theories such as nonlocal MCTAG and HPSG. The model checking algorithms can also be used in heuristics-based parsing. Since neither nonlocal MCTAG nor HPSG has efficient parsing procedures, real-life parsing will typically be heuristicsbased. A derivation structure is guessed (though not in a completely arbitrary fashion), rather than derived, and model checking can be used to check if the derivation structure satisfies whatever linguistic principles not guaranteed by the heuristics. Decharge logic Modal and dynamic logic The logics covered in this brief introduction are all modal extensions of propositional logic. Propositional logic is the classic logic over propositional variables and Boolean connectives. Basic modal logic extends propositional logic with monadic operators 3 i , 3 j , . . ., or in a notational variant i , j , . . ., known as \"diamonds\" and their duals known as \"boxes\" (written 2 i , 2 j , . . . or [i], [j], . . .). See Blackburn et al. (2001) for an introduction. The monadic operators introduce binary relations. The diamonds intuitively mean \"there is a relation from the current state to a state for which it holds that\". For example, the formula i p means that there is a relation (indexed by i) from the current state to a state in the denotation of p. The relation indeces are called labels (Labels), and the propositional variables are called atoms (Atoms). The syntax of basic modal logic over a signature Labels, Atoms is: \u03c6, \u03c8 . = p | \u03c6 \u2227 \u03c8 | \u00ac\u03c6 | a \u03c6 where a \u2208 Labels and p \u2208 Atoms. [a]\u03c6 . = \u00ac a \u00ac\u03c6 for all a \u2208 Labels. Semantics is defined in terms of satisfaction definitions over Kripke models (henceforth, models) M = W, {R a \u2208 a \u2208 Labels}, V where W is a finite set of states (or worlds), R a \u2286 W \u00d7 W, and V : Atoms \u2192 2 W a valuation function. The satisfaction definitions are as follows: M, w |= p iff w \u2208 V(p) M, w |= \u03c6 \u2227 \u03c8 iff M, w |= \u03c6 & M, w |= \u03c8 M, w |= \u00ac\u03c6 iff M, w |= \u03c6 M, w |= a \u03c6 iff \u2203w \u2032 .Ra(w, w \u2032 ) & M, w \u2032 |= \u03c6 \u2032 Example 2.1. The model 0 : p, \u00acq 1 : p, \u00acq 2 : \u00acp, \u00acq 3 : \u00acp, q with all edges in R a , except (2, 3) \u2208 R b , satisfies the formulas (i) b \u22a4 \u2192 b q, since all edges in R b lead to states in the denotation of q, and (ii) \u00ac[a]\u00acq, since not all edges in R a lead to states in the complement of the denotation of q. Clearly, basic modal logic is not powerful enough to capture HPSG, since modal logic has the tree model property (Blackburn et al., 2001) , i.e. if there exists a model that satisfies \u03c6 it is possible to unravel this model into a tree. Since reentrancies are used discriminatively in HPSG, it is clear that any logic that has the tree model property is too weak to capture HPSG. The reason that basic modal logic is too weak to capture nonlocal MCTAG is more subtle. Basic modal logic is invariant under generated substructures (Blackburn et al., 2001) , i.e. if \u03c6 is true in all states of a model it is also true in all states of a submodel (by the tree model property also a subtree) generated in one of those states. Since set saturation, used in both nonlocal MCTAG and HPSG, relies on an \"upwards query\", i.e. if a set (labeled by some FEATURE in the case of HPSG) is introduced in a state w, then w must be dominated by a state with an empty set (labeled by some FEATURE in the case of HPSG), it is clear that any logic that is invariant under generated substructures is too weak to capture nonlocal MCTAG (and HPSG). Verifying context-sensitive treebanks and heuristic parses in polynomial time Propositional dynamic logic (PDL) is an extension of modal logic in which it is possible to do up-and downwards indeterministic queries such as \"somewhere down/up the model it holds that\". The syntax of PDL over a signature Labels, Atoms not only defines a set of formulas, but also a set of programs Programs. Diamonds and boxes can now be indexed by programs rather than just labels, and relations are induced over models: \u03c6, \u03c8 . = p | \u03c6 \u2227 \u03c8 | \u00ac\u03c6 | \u03b1 \u03c6 \u03b1, \u03b2 . = \u01eb | a | \u03b1; \u03b2 | \u03b1 * | \u03b1 \u222a \u03b2 | \u03b1 \u22121 | \u03c6 ? where a \u2208 Labels and p \u2208 Atoms. The satisfaction definitions are the same as for basic modal logic, except the last clause is generalized to programs: M, w |= a \u03c6 iff \u2203w \u2032 .Ra(w, w \u2032 ) & M, w \u2032 |= \u03c6 \u2032 Each program \u03b1, as already mentioned, induces a relation R \u03b1 over a model with states W that is inductively defined: R\u01eb . = {(w, w) | s \u2208 W} R \u03b1;\u03b2 . = {(w, w \u2032 ) | \u2203(w, v) \u2208 R\u03b1 & (v, w \u2032 ) \u2208 R \u03b2 } R\u03b1 * . = S k R \u03b1 k w. R \u03b1 0 = R\u01eb& R \u03b1 k+1 = R \u03b1;\u03b1 k R \u03b1\u222a\u03b2 . = R\u03b1 \u222a R \u03b2 R \u03b1 \u22121 . = {(w, v) | (v, w) \u2208 R\u03b1} R \u03c6? . = {(w, w) | M, w |= \u03c6} Intuitively, \u01eb is the empty transition, \u03b1; \u03b2 is composition, \u03b1 * is Kleene closure, \u03b1 \u222a \u03b2 is union, \u03b1 \u22121 is converse and \u03c6? is a test. Example 2.2. The model 0 : \u00acp, \u00acq 1 : p, \u00acq 2 : \u00acp, \u00acq 3 : p, q with all edges in R a satisfies the formulas (i) \u00ac[a * ]p, since 0 / \u2208 V(p), and (ii) a q, since any state dominates a state in the denotation of q. Note that PDL is not invariant under generated substructures. The formula (a * ) \u22121 p, for example, is true in the model: 0 : p 1 : \u00acp 2 : \u00acp 3 : \u00acp with all edges in R a , but not in any of its proper generated submodels. PDL still has the tree model property and is thus not adequate for HPSG (nor as a stand-alone logic for non-local MCTAG). A slight extension of PDL, namely PDL with intersection, has been proposed for simpler unificationbased formalisms and basic tree-adjoining grammar (Keller, 1993; Blackburn and Spaan, 1993) . The extension simply adds a clause \u03b1 \u2229 \u03b2 to the syntax of programs with semantics: R \u03b1\u2229\u03b2 . = R \u03b1 \u2229 R \u03b2 PDL with intersection does not have the tree model property, since, for example, a \u2229 b \u22a4 is not satisfied by any tree-like model. The model checking problem for PDL with intersection can be solved in linear time (Lange, 2006) . Consequently, querying simpler unification-based treebanks and treebanks based on tree-adjoining grammar can be done in time linear in the size of structures and in the length of queries. PDL with intersection is not powerful enough to capture the kind of set saturation found in nonlocal MCTAG and HPSG in an intuitive way. 1 Decharge logic is an extension of PDL with intersection specially designed for this purpose. The standard logic for HPSG, which is adequate for nonlocal MCTAG too by the general inclusion result (S\u00f8gaard, 2007) , as already mentioned has an undecidable model checking problem. So the main result of this paper is that decharge logic is adequate for nonlocal MCTAG and (with some qualifications) HPSG and has a low polynomial time model checking procedure. Decharge logic Decharge logic is a polyadic extension of deterministic PDL with intersection in the following sense. Our signatures are as usual. Our models, however, differ a bit from ordinary Kripke models. Definition 2.3 (Semi-deterministic polyadic Kripke models). A semi-deterministic polyadic Kripke model (SPKM) is a tuple M = W, {R a | a \u2208 Labels}, V such that W is a set of worlds or states. Let R \u2020 = {(s 1 , ..., s n ) | \u2200i = 1, . . . , n.\u2200j = i + 1, . . . , n.s i = s j } be the relation consisting of all tuples of worlds without multiple occurrences. Furthermore, for each a \u2208 Labels, R a \u2286 R \u2020 is a polyadic relation over W. All atomic programs are required to be deterministic, i.e. whenever {(s, t 1 , . . . , t n ), (s, u 1 , . . . , u m )} \u2286 R a for some a \u2208 Labels then n = m and t i = u i for all i = 1, . . . , n. Finally V : W \u2192 2 Atoms interprets propositional variables in worlds. Note that labels are not associated with a particular arity. Relations may contain tuples of different lengths, since they will be used to encode set values in nonlocal MCTAG and HPSG. Definition 2.4 (Syntax of decharge logic). Formulas (\u03c6, \u03c8) and programs (\u03b1 i ) of decharge logic over the signature Labels, Atoms are defined as: \u03c6, \u03c8 . = p | \u03c6 \u2227 \u03c8 | \u00ac\u03c6 | \u03b1 (\u03c61, . . . , \u03c6n) \u03b11, \u03b12 . = \u01eb | a | \u03b11; a | \u03b2 * 1 | \u03b11 \u222a \u03b12 | \u03b11 \u2229 \u03b12 | \u2296(\u03b3, a, \u03b13) \u03b21, \u03b22 . = \u01eb | a | \u03b21 \u222a \u03b22 \u03b3i . = \u01eb | a | \u03b3i; a where a \u2208 Labels and p \u2208 Atoms. \u2296 is called the decharge operator. The semantics of the PDL operators are as usual, but over SPKMs, and the relation induced by the decharge operator is defined as follows: R \u2296(\u03b1 1 ,\u03b1 2 ,\u03b1 3 ) . = {(w, v1, . . . , vj\u22121, vj+1, . . . , vn) | \u2203(w, w \u2032 ) \u2208 R\u03b1 1 , \u2203(w \u2032 , v1, . . . , vn) \u2208 R\u03b1 2 , \u2203(w, vj ) \u2208 R\u03b1 3 } \u2296 is a complement operator that nondeterministically removes an element from a list. Intuitively, \u03b1 1 is a pointer to somewhere in the structure, \u03b1 2 is the set value at the node that is pointed out, and \u03b1 3 the place where we put the element that has been removed. \u2229 can then be used to place the new set. Model checking There exists a model checking procedure for decharge logic whose worst-case complexity is in O(|\u03c6| 2 \u00d7 |W| 4 ) where \u03c6 is the input formula and W the world set of the SPKM. The proof goes as follows: Let M be a SPKM with world set W and \u03c6 a decharge logic formula. First find all subformulas of the form \u03b1 \u03c8 in \u03c6. This can be done in time O(|\u03c6|). Then for each subformula compute the relation R \u03b1 over M . This can be done in time O(|\u03b1| \u00d7 |W| 4 ) by Lemma 5.4 in S\u00f8gaard and Lange (2009) . Add R \u03b1 to M under a new atomic program name a \u03b1 in time O(|W| 2 ) (the bound on the size of the new relations). Let M \u2032 be the resulting SPKM, and let \u03c6 \u2032 result from \u03c6 by replacing every \u03b1 \u03c6 with a \u03b1 \u03c6 in a bottom-up fashion. Now M, w |= \u03c6 iff M \u2032 , w |= \u03c6 \u2032 , and M \u2032 , w |= \u03c6 \u2032 is an instance of the model checking problem of ordinary polyadic modal logic (Blackburn et al., 2001) known to be solvable in time (Lange, 2006) . Overall this gives an upper bound of O(|\u03c6| 2 \u00d7 |W| 4 ) on the time needed to perform model checking for decharge logic. O = (|M \u2032 | \u00d7 |\u03c6 \u2032 |) Extended decharge logic Decharge logic is not rich enough to cover all the basic constructs in HPSG (Pollard and Sag, 1994) . Extended decharge logic bridges this gap (in part) without changing the worst-case complexity of the model checking problem. Formulas (\u03c6, \u03c8) and programs (\u03b1 i ) of extended decharge logic over a signature Labels, Atoms are defined as follows: \u03c6, \u03c8 . = p | \u03c6 \u2227 \u03c8 | \u00ac\u03c6 | \u03b1 (\u03c61, . . . , \u03c6n) \u03b11, \u03b12 . = \u01eb | a | \u03b11; a | \u03b2 * 1 | \u03b11 \u222a \u03b12 | \u03b11 \u2229 \u03b12 | \u03b11 \u2293 \u03b12 | app(\u03b31, \u03b32, \u03b33, \u03b34) | \u2296(\u03b31, a, \u03b11) \u03b21, \u03b22 . = \u01eb | a | \u03b21 \u222a \u03b22 \u03b3i . = \u01eb | a | \u03b3i; a where a \u2208 Labels and p \u2208 Atoms. Note that two new operators are introduced, namely \u2293 and app. R \u03b1\u2293\u03b2 is defined as {(w, w \u2032 ) | \u2203(w, v 1 , . . . , v n ) \u2208 R \u03b1 and \u2203(w, u 1 , . . . , u m ) \u2208 R \u03b2 , \u2203i, j.w \u2032 = v i = u j }, while R app(\u03b1 1 ,\u03b1 2 ,\u03b1 3 ,\u03b1 4 ) is defined as {(x, \u02331 , . . . , \u0233m , z1 , . . . , zn ) \u2208 R \u2020 | \u2200i, j.\u2203x \u2032 , x \u2032\u2032 .(x \u2032 , \u0233i ) \u2208 R \u03b1 2 , (x \u2032\u2032 , zj ) \u2208 R \u03b1 4 , (x, . . . x \u2032 . . .) \u2208 R \u03b1 1 , (x, . . . x \u2032\u2032 . . .) \u2208 R \u03b1 3 , (x, \u02331 , . . . , \u0233m , z1 , . . . , zn ) \u2208 R \u2020 }. Intuitively, the append operator (app) works this way: \u03b1 1 and \u03b1 3 are pointers to nodes in a feature structure. The operator then takes the arguments of \u03b1 2 and \u03b1 4 at the nodes to which the pointers lead, and conjoins them. In a sense, this gives us a virtual list value, a list value that is nowhere in the derivation structure; the notion of virtual lists and sets is similar to the notion of a chain in Richter (2004) , albeit a very restricted one. The intersection operator is used to place this virtual list value somewhere in the structure. In extended decharge logic, lists are used as canonical representations of sets. The even richer logic in S\u00f8gaard and Lange (2009) represents all linearizations of sets in models, but has a PSPACEcomplete model checking procedure. The low polynomial time model checking procedure can be extended to this extension of decharge logic, as shown in Theorem 5.5 in S\u00f8gaard and Lange (2009) . Consequently, the new operators do not add to asymptotic complexity. Verifying context-sensitive treebanks and heuristic parses in polynomial time Nonlocal multicomponent tree-adjoining grammar Multicomponent tree-adjoining grammar (MC-TAG) (Becker et al., 1991) is an extension of treeadjoining grammar in which adjunction is simultaneous adjunction of all trees in a finite set (of fixed size) of auxiliary trees rather than just adjunction of a single tree. Tree-local and set-local MCTAG impose further restrictions on adjunction, while nonlocal MCTAG imposes no further restrictions. MCTAG was primarily invented to implement analyses of scrambling in languages such as German (Becker et al., 1991) and Korean (Kallmeyer and Yoon, 2004) . A recent alternative to MCTAG uses tree tuples rather than sets (TT-MCTAG) (Lichte, 2007) , also motivated by scrambling phenomena. The key idea in all these analyses is to factorize the verb and its complements into different auxiliary trees that can then be permuted in derivation. For each verb with its complements a new tree set is adjoined. Computational complexity and generative capacity Rambow and Satta (1992) present a proof that the fixed recognition problem of nonlocal MC-TAG is NP-hard, generalized to a few restricted variants in Champollion (2007) , while S\u00f8gaard et al. (2007) present a (weaker) proof of the NPhardness of the universal recognition problem that is generalized to all variants of MCTAG. It follows from the linear upper bound on the size of derivation structures that the universal recognition problem can also be solved in nondeterministic linear space, which also implies that nonlocal multicomponent tree-adjoining languages can be recognized by linear bounded automata. Since any language that can be represented by a linear bounded automaton is context-sensitive (Landweber, 1963) , it holds that nonlocal MCTAG is context-sensitive. It also follows from the result obtained in this paper, namely that model checking can be done in low polynomial time, that the universal recognition problem is in NP and thereby NP-complete. It is possible to nondeterministically guess a derivation structure linear in the length of the input string and verify it in low polynomial time. On the other hand it is easy to prove that nonlocal MCTAG is not mildly context-sensitive; see also Rambow and Satta (1992) This grammar generates the MIX language which according to Marsh's conjecture is not even an indexed language. Tree-local MCTAG, on the other hand, is weakly (but not strongly) equivalent to tree-adjoining grammar and thus mildly context-sensitive. Model-theoretic characterization A model-theoretic version of nonlocal MCTAG in which a grammar is a set of axioms in decharge logic, and the language is the set of strings whose logical descriptions are satisfiable in conjunction with the grammar, is briefly sketched. The first step of the reconstruction of nonlocal MCTAG in logical terms is similar to the modeltheoretic characterization of tree-adjoining grammar in Keller (1993) . Consider the translation of a case of adjunction in below, presented in Figure 1 in the more readable AVM notation known from HPSG and also used in Keller (1993) , Blackburn and Spaan (1993) and Richter (2004) , i.e. AVMs can, if we ignore the issue of underspecification for now, be seen as deterministic Kripke models (Blackburn and Spaan, 1993) . The idea behind the translation is that we duplicate trees. So we have an initial constituent structure embedded under IDTRS that adjunction can modify; if no adjunction takes place, the IDTRS and DTRS tree structures are unified. The axiomatization of TAG is such that every node in a model must be either a terminal node, an adjunction site or IDTRS and DTRS must be unified. See Keller (1993) for details. S r r r NP Bill VP 4 4 V knows NP Moira + VP r r r V knows S l l D D NP Bill VP * =\u21d2 S 3 3 3 3 NP Bill VP 3 3 3 3 V knows S r The trick is now to introduce an additional feature TSET to encode sets of auxiliary trees. The decharge operator \u2296 is used to nondeterministically remove auxiliary trees from these sets one at a time in derivation. Saturation is ensured by the converse operator, as already described above. 4 Head-driven phrase structure grammar HPSG (Pollard and Sag, 1994 ) is a popular, but very complex deep grammar theory or, perhaps more adequately, a complex deep grammar architecture. Its earliest version was unification-based, but this is no longer the case. It is, unlike nonlocal MCTAG, supposed to be model-theoretic. Consequently, logical formalizations already exist. Conventionally, an HPSG grammar is defined as a tuple Types, \u2291 , Principles , where Types, \u2291 is the inheritance hierarchy, a finite bounded complete partial order, and Principles is a set of linguistic principles. The linguistic principles correspond intuitively to generative rules, but are con-straints over a set of legitimate derivation structures. The inheritance hierarchy is formally simple and can be reconstructed in propositional logic (Moens et al., 1989) . Consequently, the tricky part is the linguistic principles. The main challenges are set saturation, covered in extended decharge logic by the decharge operator, and union of sets. Note that set union cannot be expressed by the decharge operator. Example 4.1. An example of a linguistic principle in HPSG that uses set union is the Nonlocal Feature Principle (Pollard and Sag, 1994) : For each nonlocal feature, the INHER-ITED value on the mother is the union of the INHERITED values on the daughters minus the TO-BIND value on the head daughter. In Pollard and Sag (1994) , there are three nonlocal features on INHERITED, SLASH,QUE,REL. Reape (1994) formalizes an earlier version of HPSG in terms of a quantified hybrid logic L ++ . L ++ is an extension of propositional logic with nary modalities, nominals and quantification over nominals. Nominals are a subset of the set of propositional variables that only denote singleton subsets in a model. Quantification is similar to first order logic. L ++ is a polyadic version of H(\u2203). Set union is implemented in a first order theory of sets. The model checking problem is obviously PSPACE-hard. Related formalizations Verifying context-sensitive treebanks and heuristic parses in polynomial time (Hegner, 1996) defined a decidable extension of the Sch\u00f6nfinkel-Bernays class as a formalization of HPSG. In this logic, quantifiers or variables are typed relative to the inheritance hierarchy, and prefixes of the form \u2200 t \u2203 t are allowed iff t, t \u2032 are incompatible types.The logic is clearly more expressive than the Sch\u00f6nfinkel-Bernays class, but it does not capture strong welltypedness (Carpenter, 1992) . Consider, for instance, the HPSG-style strong welltypedness condition on phrases: \u2200x.hd-phr(x) \u2192 \u2203y.head-dtr(x, y) saying that a headed phrase has a head daughter. The trouble is that a head daughter can itself be a headed phrase, so this condition cannot be expressed in the logic of (Hegner, 1996) . In general, no decidable standard prefix-vocabulary class of first order logic characterizes the deterministic, connected and strongly welltyped structures used in HPSG (S\u00f8gaard, 2007) . The logic proposed in Richter (2004) , RSRL, is an extension of description logic with global quantification similar to what can be obtained in PDL with intersection by (a 1 \u222a . . . \u222a a n ) * with Labels = {a 1 , . . . , a n }, i.e. the master modality. RSRL is much more complex than PDL with intersection, though. In fact its model checking problem is known to be undecidable. Sets are still decomposed as in the first order theory of sets. The relevant complexity results (and proofs thereof) for L ++ and RSRL are presented in S\u00f8gaard (2007) . PSPACE-hardness of model checking L ++ and RSRL can be proven by reduction of Geography (Garey and Johnson, 1979) , the undecidability of satisfiability by the tiling problem, and the undecidability of model checking RSRL can be proven by the Post correspondence problem. The main difference between decharge logic and L ++ and RSRL is that sets are first class citizens in decharge logic, i.e. sets of tuples denoted by relations of variable arity. This complicates the logical machinery in some respects, but means that first order machinery that leads to PSPACEcomplete model checking, can be avoided. Model-theoretic characterization Here is possible formalization of the Nonlocal Feature Principle in Example 4.1 in extended decharge logic in the feature geometry in Pollard and Sag (1994) See S\u00f8gaard and Lange (2009) for more examples. Our qualifications, mentioned multiple times in the above, are also made precise in S\u00f8gaard and Lange (2009) . There are a few somewhat controversial HPSG principles, i.e. the Trace Principle and the Binding Theory, that do not seem to be definable in extended decharge logic. Conclusion This paper introduced a polyadic dynamic logic called decharge logic and an extension thereof to provide query languages for context-sensitive treebanks, e.g. treebanks with non-projective dependency structures, incl. the Prague Dependency Treebank and the Danish Dependency Treebank, the LinGO Redwoods Treebank and the BulTree-Bank. Common query tools for treebanks include Cor-pusSearch, ICECUP III (Wallis and Nelson, 2000) and TGrep2, but as pointed out by Kepser (2004) the query languages used in these tools are not even expressive enough to perform arbitrary queries on context-free derivations. They are, according to Kepser (2004) , all subsumed by the existential fragment of first order logic. Other more expressive logics that have been introduced to characterize context-sensitive grammar formalisms (Reape, 1994; Richter, 2004) have model checking procedures with exponential runtime. It was shown that decharge logic and its extension have low polynomial time model checking procedures. The two logics thus make querying contextsensitive treebanks feasible. Using decharge logics for querying treebanks is similar to using more common query tools. Say the following is a sentence in a treebank in TGrep2 input format: (i) matches all nodes labeled by NP that dominate a node labeled by NN (2 nodes); (ii) matches all nodes labeled by NP that immediately dominate a node labeled by NN (1 node); and (iii) matches all nodes labeled by NP that do not immediately dominate a node labeled by NN (1 node). The queries correspond to the following formulas in decharge logic: The query tools thus essentially model check the derivation structure wrt. some formula \u03c6 and output the set of nodes (states) that satisfy \u03c6. Decharge logic and its extension can also be used to verify heuristic parses.",
    "abstract": "A polyadic dynamic logic is introduced in which a model-theoretic version of nonlocal multicomponent tree-adjoining grammar can be formulated. It is shown to have a low polynomial time model checking procedure. This means that treebanks for nonlocal MCTAG, incl. all weaker extensions of TAG, can be efficiently corrected and queried. Our result is extended to HPSG treebanks (with some qualifications). The model checking procedures can also be used in heuristics-based parsing. * The model checking procedure described in this paper uses constructs from a model checking procedure introduced in joint work with Martin Lange. Thanks also to Laura Kallmeyer, Timm Lichte and Wolfgang Maier for introducing me to various extensions of tree-adjoining grammar, incl. nonlocal MCTAG.",
    "countries": [
        "Denmark"
    ],
    "languages": [
        "German",
        "Korean",
        "Danish"
    ],
    "numcitedby": "1",
    "year": "2009",
    "month": "May",
    "title": "Verifying context-sensitive treebanks and heuristic parses in polynomial time"
}