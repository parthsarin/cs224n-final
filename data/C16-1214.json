{
    "article": "Multiword Expressions (MWEs) are crucial lexico-semantic units in any language. However, most work on MWEs has been focused on standard monolingual corpora. In this work, we examine MWE usage on Twitter -an inherently multilingual medium with an extremely short average text length that is often replete with grammatical errors. In this work we present a new graph based, language agnostic method for automatically extracting MWEs from tweets. We show how our method outperforms standard Association Measures. We also present a novel unsupervised evaluation technique to ascertain the accuracy of MWE extraction. Introduction Apart from being just a social media platform, Twitter has emerged as an authoritative source of breaking news and subsequent discussions (Kwak et al., 2010; Hu et al., 2012) . Most \"global\" news stories, from terrorist attacks, political news, sports events to celebrity updates, not only trend on Twitter within minutes of the actual event but often in multiple languages. One challenge thus, in understanding the full story is being able to process all languages involved. One way to do this could be by partitioning data into the constituent languages (Bergsma et al., 2012) as there exist several sophisticated tools for Twitter (Pak and Paroubek, 2010; Ritter et al., 2012; Owoputi et al., 2013; Kong et al., 2014) designed specifically for various languages (Avontuur et al., 2012; Abdul-Mageed et al., 2012; Rehbein, 2013) . However, such an approach might not be able to process all languages. Further, it faces an added disadvantage of ignoring valuable semantic, temporal and cross-lingual relationships between the tweets. In fact these relationships could instead be utilized to not only better understand the underlying story but also generate resources for resource poor languages in question. Thus, as a cursory step in understanding such hashtags, our work focuses on extracting multiword expressions (MWEs) from Twitter data streams. MWEs are great starting points from two perspectives: (a) they are statistically \"idiosyncratic\" (Sag et al., 2002) and thus, require no prior knowledge of the text or the corresponding language for extraction and (b) form a considerable portion of the vocabulary for a given language (Fellbaum, 1998) . Furthermore, their importance for a variety of NLP tasks like POS tagging (Shigeto et al., 2013) , deep parsing (Nivre and Nilsson, 2004) , sentiment analysis (Moreno-Ortiz et al., 2013) , translation (Ren et al., 2009; Carpuat and Diab, 2010) etc \u02d9. cannot be overstated. Also, as we explore in Section 4, MWE usage on Twitter shows some unique characteristics stemming from the nature of the medium like acronym usage, temporal sensitivity, etc. and thus, motivating a stronger need to develop MWE extraction techniques specific to such data streams. However, most work (Van de Cruys and Moir\u00f3n, 2007; Ramisch et al., 2010; Sinha, 2011) on automatic MWE extraction has either relied on (a) the knowledge of POS patterns that constitute MWEs and the availability of POS annotated corpora, or (b) enumeration of all possible n-grams and ranking them using Association Measures (AMs) (Pedersen et al., 2011) . A third branch of work also exists that instead uses parallel corpora (Da Silva et al., 1999) and exploits distributional dissimilarity between words  to extract phrases. However, we do not consider this approach further given the target domain and only mention it here for completeness. However, as outlined above, the very nature of our problem invalidates the first line of approach. It is impractical to build corresponding systems (namely POS taggers, POS patterns and candidate extraction) for every applicable language. As far as the second approach is concerned, it is usually effective over time invariant datasets where one time enumeration of all n-grams would suffice. However, our setting would require frequent regeneration of N-grams as the corpus increases over time. Hence, we would like to find methods that do not require enumerating all N-grams and can yet find statistically significant phrases. An added challenge, as we discuss in Section 2, when working with multilingual data is that of evaluation. Thus, we must also find ways to evaluate the extracted MWEs that involves minimal manual intervention. Thus, the primary objectives of this work can be enumerated as: \u2022 Propose a new graph based method for MWE extraction that can circumvent the challenges of Twitter language usage, temporal nature of Hashtags and possible enumeration of all N-grams. \u2022 Propose an automatic evaluation technique for the extracted MWEs \u2022 Additionally, analyze the variance in extracted MWEs across different variables The rest of the paper is organized as follows. Starting with Section 2, we first discuss the problem setting in a little more detail and then present our method in Section 3. We show why a word graph based method can overcome the enumerated problems -multilingualism, lack of grammar and relatively free word ordering to name a few. Then in Section 4, we describe our novel evaluation technique and also compare the performance of our method against different AMs. Finally, we conclude by discussing the scope of future work and conclusions from our results in Section 5. Related Work In this section, we consider the problem of extracting MWEs from a text corpus and evaluating the accuracy and nature of the extracted MWEs. As discussed in Section 1, nuanced extraction techniques rely on POS annotated corpora at the very least. Firstly, the lack of POS taggers for all applicable languages would reduce the size of the workable dataset. For example, some resource poor languages like Malay, Indonesian etc \u02d9. have very little work in the said regard (Adriani and Van Rijsbergen, 2000; Rais et al., 2011) . Secondly, as shown by (Derczynski et al., 2013) , POS taggers trained on longer documents perform poorly on tweets. Further the extraction patterns vary widely (Kunchukuttan and Damani, 2008; Green et al., 2011; Tsvetkov and Wintner, 2014) based on the underlying language and thus, making it computationally intractable. Finally, as shown by (Solorio et al., 2014) , it is much harder to detect the individual languages within code switched short text documents. Further, there is even lack of availability of standard annotated corpora beyond a handful of languages (Solorio and Liu, 2008; Vyas et al., 2014) for code switched text and thus, almost little to no research even exists in extracting MWEs from such text. Thus, at the very least we need to look at techniques that do not rely on POS tags. As far as candidate evaluation is concerned, most techniques discussed thus far focus on evaluating the efficacy of the POS extraction patterns. Hence, a common technique (Pearce, 2002; Ramisch et al., 2012) involves measuring recall against standard corpora. Note that such methods assume that an exhaustive language specific list of MWEs is available. However, since our task is primarily concerned with MWE \"discovery\", such standard lexicons may not be used. A common alternative involves manual evaluation. However, our initial efforts at manual evaluation proved to be tedious primarily due to unfamiliarity with some of the languages. This prompted us to develop an automatic evaluation technique that we present in Section 4.2 that uses the Twitter Search API. However, this raises a related yet contrary question on MWE classification. For the extracted MWEs to be useful for downstream processing, some nomenclature must be developed. Some of the earliest work in MWE extraction and classification was done by Sag et al. (2002) . They initially introduced a structural classification for MWEs that relies on the differences in compositionality and fixedness between the different MWEs. Later work by Schneider et al. (2014) on MWE usage in social media uses two classification schemes. One, that deals with compositionality and classifies MWEs as either strong or weak based on their opaqueness and a second, detailed syntactic classification that relies on POS tags. In a multilingual scenario however, it is much easier to determine POS tags for a foreign phrase than to judge the compositionality or opaqueness of the MWE itself. Thus, in continuation with the list provided by Schneider et al. (2014) that deals specifically with social media, we adopted an abridged version 1 as depicted in Table 1 . The table lists the tag type, the POS tags used and some extracted examples. Note that this scheme is used only for the purpose of classification and not utilized for MWE evaluation. For languages other than English, we determine membership by examining the translation of the given foreign language phrase. We largely use this nomenclature for analysis as presented in Section 4. Having thus presented an overview of related work, we now turn our attention to our main algorithm. 3 System description & algorithms Constructing Word Graphs Thus, so far we have established that the nature and size of tweets are an hindrance for the standard tokenization process. However, using word graphs would circumvent both problems. On one hand, they would allow us to capture co-occurrence and statistical information within the graph structure but at the same time allow relaxed word ordering. Thus, given a set of tweets for a hashtag, which we will refer to as a dataset, we could construct a single graph G = (V, E) from all tweets as follows. The vertices V represent the set of all unique tokens that occur within the dataset and two vertices share an edge if they co-occur within a tweet. The edge weight is set to the co-occurrence probability of the participating vertices and each vertex is annotated with the occurrence probability of the underlying token. The token set is obtained by simple whitespace tokenization followed by lowercasing and removing all mentions, URLs, emojis/emoticons and # prefixes. For such a graph, we further contend that the tokens represented by a pair of vertices constitute a MWE if (a) the said tokens frequently co-occur but (b) rarely occur with other tokens. This could be ascertained by using the edge weights and examining the vertex neighborhoods of the said vertices. To that end, we looked at similar problems in other domains and found the method as presented by Londhe et al. (2014) for Product title matching to be promising. The authors essentially demonstrate how word graphs for product titles can be utilized to detect equivalences using a community detection algorithm viz. CDAM (Community Detection for Approximate Matching). We thus implemented equivalent algorithms, collectively called GRePE (Graph Reduction for Phrase Extraction) in our problem setting which we now present. Extracting MWE candidates A block diagram of our system components is shown in Figure 1 . Overall, the two main system components are the Indexer and the Graph Reducer. The Indexer ingests a given dataset to convert it into e (V 1 ), N e (V 2 ) 3: for Vertex v in {V 1 , V 2 } do 4: Find v in N(v) such that p(v, v ) is largest 5: Define N \u03b7 (v) as all vertices x with p(x, v) \u2265 \u03b7 \u00d7 p(v, v ) 6: Initialize N e (v) = N \u03b7 (v) 7: Let v o = V \\ v , N \u03b7 (v) := N(v) \\ N \u03b7 (v), C(v) = N \u03b7 (v) \u2229 v o 8: Let S v = getW JC(N(v), N(v o )) 9: end for 10: for Each element c in C 1 do 11: Let S c = getW JC((N(1) \\ c), N(2)) 12: if w c = p(V 1 , c) + |S c \u2212 S 1 | \u2265 \u03b7 1 then 13: Add c to N e 1 14: end if 15: end for 16: Repeat above for C 2 17: Return N e (V 1 ), N e (V 2 ) a Word Graph and a corresponding Positional Index. The Graph Reducer then iterates over the graph, detects MWEs and merges constituent nodes. The following subsections present more details. Before we describe the graph reduction algorithms, we introduce some notation as follows: 1. i th vertex is denoted as V i 2. The neighborhood of a vertex V , i.e. a set of vertices up to a depth of k, is denoted as N k (V ) 3. Immediate neighborhood of a vertex V i.e. N 1 (V ) is denoted simply as N(V ) 4. p(V ) and p(V i , V j ) represent the prior and joint probabilities respectively The process of graph reduction occurs in three phases : (a) Context determination (b) Local graph reduction and (c) Candidate pruning. Phases (a) and (b) operate on a neighborhood of a pair of vertices. The third phase however iterates over the graph and determines which vertex pairs to examine as we explain below. Context Determination We first determine a context (i.e. a set of vertices) for comparison. The basic idea of the algorithm is to define a context by using only valuable vertices in a given neighborhood. The inherent value is established in two ways : (a) the edge weight as compared to the maximum edge weight and (b) the contribution of the said vertex to the similarity / dissimilarity between the vertices being compared. We present Algorithm 1 that determines this context (or \"cross-enriched\" neighborhood). 2 Algorithm 2 LOCAL GRAPH REDUCTION 1: Input: The sets : C(i, j), U(i) and U(j) 2: Output: MWE candidates M 3: Initialize M \u2190 \u2205 4: Let the set U := U(i) \u222a U(j), |U| = k 5: Let A = zeros(k, k) 6: Construct adjacency matrix where A(x, y) = p(U x , U y ) + C(i,j) c p(c, U y ) 7: for All x,y within the same partition do M \u2190 \u2205 6: for < V i , V j > in V d do 7: N e (V i ), N e (V j ) = crossEnrich(V i , V j , \u03b7) 8: compute C(i, j), U i , U j 9: M \u2190 reduce(C(i, j), U i , U j ) 10: end for 11: M \u2190 f ilter(M, \u03b6, \u03ba) 12: for Group g in M do 13: M op \u2190 expandP hrase(g, idx) 14: end for 15: Return M op , G For a given vertices V i and V j , this algorithm effectively partitions their joint neighborhood into four disjoint sets: 1. Common vertices, C(i, j) := N e (V i ) \u2229 N e (V j ) 2. Uncommon vertices of i, U(i) := N e (V i ) \\ C(i, j) 3. Uncommon vertices of j, U(j) := N e (V j ) \\ C(i, j) 4. Ignored vertices, i,j k N(V k ) \\ N e (V k ) We only care about the common (C) and uncommon (U) vertices which act as inputs to the next phase. Local Graph Reduction In the next phase, we consider the sub-graph created by these three sets and perform local graph reductions as outlined in Algorithm 2. Essentially, we represent the local graph as a compressed adjacency matrix. For a given cell, A(x, y), the weight in the matrix is set to the edge weight between vertices x and y plus the sum of weights from all common vertices to y. We then reduce the graph by either deleting Candidate Pruning & Phrase Expansion In the final phase as illustrated in Algorithm 3, we output the final list of MWEs using a two step process. We first iterate over the graph that in turn calls Algorithm 1 and Algorithm 2. Next, we eliminate false positives based on two parameters : word rarity (\u03b6) and co-occurrence (\u03ba). The former eliminates candidates that are composed of frequently occurring words, i.e. typical stopwords whilst the latter ensures a lower bound on the number of co-occurrences of the words that constitute the candidates. Finally, we use the positional index to reorder and expand the phrases as needed before outputting the final result. A note about graph iteration is pertinent here. For a pair of vertices V i and V j input to the algorithms, it can be observed that the actual merge occurs on the vertices within the neighborhood of V i , V j and not on the vertices themselves. Thus, in order to cover as much graph as quickly as possible, the easiest strategy is to pick V i , V j in decreasing order of degree. Note that this also guarantees iteration in O(V) time. Finally, although our method does seem similar to enumerating all n-grams and using some AM, we contend that this method can differentiate between nuances of usage due to the pairwise or cross-vertex iteration. In a typical n-gram approach, such contextual information is lost whereas in our method, it is equivalent to evaluating the n-grams in a limited context and is hence, more powerful. We now present details of parameter estimation and a short discussion on parameter sensitivity. Parameter estimation As we saw in Section 3.2, we use the following parameters: \u2022 Enrichment parameter \u03b7 : Determines which vertices in the current neighborhood will be considered \u2022 Word rarity parameter \u03b6 : Determines the level of rarity for a vertex to be considered \u2022 Co-occurrence parameter \u03ba : Determines the co-occurrence probability for an edge to be considered We used the MH370 dataset (refer Table 2 3 ) to find the optimum values of these parameters except for the Enrichment parameter (\u03b7) as described below. We obtained the value of \u03b7 by evaluating the effect of varying \u03b7 on a set of vertices and the neighboring vertices retained. We found a value of 0.6 to be a reasonable balance between over-pruning and retaining most vertices. Refer Figure 2 that demonstrates that a value of \u03b7 = 0.6 does seem to have a large discriminatory power. For estimating \u03b6 and \u03ba, we first used Algorithm 3 in a parameter-less mode (i.e. without filtering) and obtained all potential MWE candidates. For all such candidates, we established if the phrase indeed is a Datasets and data collection As outlined in Section 1, our primary focus lies in extracting and analyzing MWEs from short text documents, namely tweets. Given the diverse nature of users, languages employed and topics discussed on Twitter 6 , we wanted to achieve as broad coverage as possible. For over two weeks 7 , we collected tweets for selected trending topics at different times of day. The choice of the selected topics was based on volumes as reported by Twitter plus the perceived global reach of the topic itself. However, for the final analysis we only used a subset of our crawled data as any sets with less than 2000 unique tweets were discarded. Although Twitter provides its own language identification, we used langid (Lui and Baldwin, 2012) for our use to allow generalization to other data sources (like Facebook) later. A summary of the datasets is provided in Table 2 that captures the language and vocabulary spread for each hashtag. Note that the volume of tweets notwithstanding, each HashTag has tweets in at least 30 different languages, the average tweet length is only about 10 words and the word frequency distribution has a significant long-tail with about 40% of the words occuring just once. Automatic Evaluation As outlined in Section 2, we evaluate our system on precision as against recall and compare the system generated MWEs with those generated by standard AMs. Since we are computing Average Precision, the metric value is sensitive to the size of the result set considered. Given that our system produces limited number of MWEs, we restrict the output of compared AMs to be equal to the number of MWEs generated by our system. In order to ascertain if a generated phrase is indeed a MWE, we performed two levels of evaluation. At the first level we use the Twitter Search API 8 as follows. For every candidate W = (w 1 , w 2 ), we execute three queries while restricting each query to top 25 unique results 9 : (a) w 1 w 2 (which is equivalent to w 1 AND w 2 ) (b) the phrase \"w 1 w 2 \" (c) concatenation w 1 w 2 . Each result set is then converted to a corresponding numeric score as below 1. DistanceScore = Average normalized token distance between tokens w 1 and w 2 While the latter two scores approximate the probability of the phrase occurring either as separate words or concatenated together, the first score is a proxy for how frequently do the constituent words appear next to each other (as in a phrase) versus co-occurring in a tweet. Additionally, we add a fourth parameter, an integer stopword score [0, 2] that acts as a regularization parameter to penalize phrases that contain stopwords which are bound to return a large number of results. We present some examples to illustrate the need for all four values in Table 3 . We trained a simple multinomial logistic regression classifier on the MH370 dataset on manually evaluated MWE candidates with a 70% true label precision. As second layer of screening, we assign one of the 15 POS labels as listed in Table 1 and double check that the extracted candidates are in fact MWEs. Note that we translate phrases from languages other than English into English before assigning the POS tags. We admit this is slightly lossy but we view at as a way to project all MWEs in the same token space for simplicity. Thus, for each dataset, we compute the Average Precision by using the true class labels obtained as explained above. We present the results in Table 4 along with Mean Average Precision (MAP). We additionally compare the overlap between our method and the different AMs in Table 5a as well as splits by POS tag type in Table 5b . These tables show that although the different AMs do not necessarily generate the same candidate list (except LogLikelihood and T-score), the comparable POS split percentages indicate inherent bias within the dataset. Discussion of results We must take a moment to explain and examine the results. Although, it may not seem that our method is a vast improvement over other AMs when looking at the MAP, it must be noted that we do not produce \"ranked\" results as such and only candidates. We used a fixed ordering based upon the co-occurrence probability of phrases and a better ranking mechanism may exist but was not explored. The performance of the AMs is also bound to suffer when the full result sets are used. Further, except for the Presiden-tObama dataset, our method places within top 3 where it is not the best performing method. Comparing against Table 2 , the method seems to suffer for predominantly English datasets (low OOV% -Pride, Pres-identObama etc) but better for multilingual datasets (Brexit, PokemonGO). Thus, we could in principle augment our method with either AMs or existing POS based approaches for English to further improve performance. However, it can be concluded that overall the method returns a small and fairly precise set of MWEs as compared to AMs and enumerating all bigrams. Future Work and Conclusions In summary, we can enumerate our contributions as (a) we presented a language agnostic method for extracting MWEs from Twitter (b) we explored the performance of different AMs in a similar setting and (c) we showed a method for automatic evaluation of extracted MWEs. As an extension to this work, we would like to further analyze our results and study the effect of Twitter and social media specific features We would also like to explore if the extracted MWEs can be utilized for other downstream tasks like generating summaries or automatic bilingual tweet alignment. We believe such work would help in developing resources for resource poor languages as well as aid in better understanding and modeling language usage on social media.",
    "abstract": "Multiword Expressions (MWEs) are crucial lexico-semantic units in any language. However, most work on MWEs has been focused on standard monolingual corpora. In this work, we examine MWE usage on Twitter -an inherently multilingual medium with an extremely short average text length that is often replete with grammatical errors. In this work we present a new graph based, language agnostic method for automatically extracting MWEs from tweets. We show how our method outperforms standard Association Measures. We also present a novel unsupervised evaluation technique to ascertain the accuracy of MWE extraction.",
    "countries": [
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "3",
    "year": "2016",
    "month": "December",
    "title": "Time-Independent and Language-Independent Extraction of Multiword Expressions From {T}witter"
}