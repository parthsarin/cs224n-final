{
    "article": "We present a method for constructing, maintaining and consulting a database of proper nouns. We describe noun phrases composed of a proper noun and/or a description of a human occupation. They are formalized by finite state transducers (FST) and large coverage dictionaries and are applied to a corpus of newspapers. We take into account synonymy and hyperonymy. This first stage of our parsing procedure has a high degree of accuracy. We show how we can handle requests such as: 'Find all newspaper articles in a general corpus mentioning the French prime minister', or 'How is Mr. X referred to in the corpus; what have been his different occupations through out the period over which our corpus extends?' In the first case, non trivial occurrences of noun phrases are located, that is phrases not containing words present in the request~ but either synonyms, or proper nouns relevant to request. The results of the search is far better than than those obtained by a key-word based engine. Most answers are correct: except some cases of homonymy (where a human reader would also fail without more context). Also, the treatment of people having several different occupations is not fully resolved. We have built for French, a library of about one thousand such FSTs., and English FSTs arc under construction. The same method can be used to locate and propose new proper nouns, simply by replacing given proper names in the same FSTs by variables. Introduction Information Retrieval in full texts is one of the challenges of the next years. Web engines attempt to select among the millions of existing Web Sites, those corresponding to some input request. Newspaper archives is another exam-ple: there are several gigabytes of news on electronic support, and the size is increasing every day. Different approaches have been proposed to retrieve precise information in a large database of natural texts: 1. Key-words algorithms (e.g. Yahoo): cooccurrences of tile different words of the request are searched for in one same document. Generally, slight variations of spelling are allowed to take into account grammatical endings and typing errors. 2. Exact pattern algorithms (e.g. OED): sequences containing occurrences described by a regular expression oll characters are located. 3. Statistical algorithms (e.g. LiveTopic): they offer to the user documents containing words of the request and also words that are statistically and semantically close with respect of clustering or factorial analysis. The first method is the simplest one: it generally provides results with an important noise (documents containing homographs of the words of the request, not in relation with the request, or documents containing words that have a form very close to that of the request, but with a different meaning). The second method yields excellent results, to the extent that the pattern of the request is sufficiently complex, and thus allows specification of synonymous forms. Also, the different grammatical endings can be described precisely. The drawback of such precision is the difficulty to build and handle complex requests. The third approach can provide good results for a very simple request. But., as any statistical method, it needs documents of a huge size, and thus, cannot take into account words occurring a limited number of times in the database, which is the case of roughly one word out of two, according Zipf's law 1 (Zipf, 1932) . We are particularly interested in finding noun phrases containing or referring to proper nouns, in order to answer the following requests: 1. Who is John Major? 2. Find all document re/erring to John Major. 3. Find all people, who have been French ministers o~ culture. , 1993) is available to directly construct FSTs. In theory, such FSTs are more powerful than traditional FSTQ. In figure 1 , the transducer recognizes the sequences a, b, ca, cb. To each of these input sequences, it associates an output noted val(input). Here, val(a) = {ab}, val(b) = {b}, 2 If a sub-automaton refers to a parent automaton, we will be able to express context dependent words such as a'*b n . val(c) is not defined as c is not recognized by the automaton, val(ca) = {d}, and val(cb) = {b}. We define an ordering relation on the set of recognized sequences by a transducer T, that is: x <_T Y \u00a2:~ Veeval(x), eEval(y). In our example, b --<T a and b =7-cb with derived equality relation. We construct our transducer describing occupations in such a way that with this ordering 3 relation: -Two sequences x, y are synonyms if and only if x =7-Y -The sequence y is an hyponym of x (i.e. y is a x) if and only if x --<T Y. The transducer in figure 2 describes 4 different sequences referring to the word minister. Sub-parts of the transducers Country and Nationality are given in figure 3 and 4 . By construction, all the sequences recognized are grammatically correct. For example, the variant of minister of European affairs: minister for European affairs is recognized, but not Chinese French minister for agriculture. The output of the transducer is compatible with our definition of order: \u2022 val(France's culture minister) =7-{French, minister, Culture} =7-val(culture minister of France) >7-val(French minister) \u2022 'chancellor of the Exchequer'=T 'finance minister' \u2022 'prime minister~ T'minister' i.e. a prime minister is a minister but 'deputy minister~7-'minister' i.e. a deputy minister is not a minister. Reciprocally, given an output, it easy to find all paths corresponding to this output (by inverting the inputs and the outputs in the transducer). This will be very useful to fornmlate answers to requests, or to translate noun phrases: the ':natural language\" sequences corresponding to the set {minister, French} are : \"French minister\" or \"minister of France\". We will note val-i({minister, French}) = {'french minister', 'minister of France'}. Full Name description The full name description is based oll the same methodology (cf. figure 5 ), except that the boxes containing <PN : F\u00b1rstName> and <PN:SurName> represent words of the proper nouns dictionaries. The output of this transducer is computed in a different way: the output is the surname, the firstname if available, and the gender implied either by the firstname, or by the short title: Mr., Sir, princess, etc .... Handling requests: a dynamic dictionary In order to instantly obtain answers for all requests, we build an incremental index of all matches described by the FST library. At this stage, the program proposes new possible proper nouns not yet listed, they complete the dictionary. Our index has the following property: when an FST is modified, it is not the whole library which is recompiled, but only the FSTs affected by the modification. We now describe this stage and show how the program consults the index and the FST library to construct the answer. Constructing the database In (Senellart, 1998) , a fast algorithm that parses regular expressions on full inverted text is presented. We use such an algorithm for locating occurrences of the FSTs in the text. For each FST, and for each of its occurrences in the text, we compute the position, the length, and the FST associated output of the occurrence. This type of index is compressed in tile same way entries of the full inverted text are. This choice of structure has the following features: 1. There is no difference of parsing between a 'grey (autonomous) box' and a 'norreal one'. Once sub-transducers have been compiled, they behave like normal words. Thus, the parsing algorithms are exactly the same. 2. A makefile including dependencies between the different graphs is built, and modifications of one graph triggers the re-compilation of the graphs directly or indirectly dependent. . This structure is incrementah adding new texts to the database is easy, we only need to index them and to merge the previous index with the new one by. a trivial pointer operation. A description of a whole noun phrase is given made by the graph of figure 6. We use a second structure: a dynamic proper noun dictionary ~ that relies on the indexes of Occupation.graph and FullName.graph. T) is called 'dynamic' dictionary, because the information associated to the entries depend on the locations in the text we are looking for. The algorithm that constructs T) is the following: 1. For each recognized occurrence we associate O1 which is the output of Full-Name.graph and the output 02 of the Occupation.graph (see section 4 for examples). 2. If O1 is not empty., find O1 in :D: that is, find the last e in T) such that O1 <__7-e. -If there is none, create one : i.e. associate this FullName with the occupation 02 and with the current location in the text. -If there exists one, and its occupation is compatible with 02 then add the current location to this entry. Or else, create a new entry for O1 (eventually completed by the information from e) with its new occupation 02, and pointing to the current location in the text. A detailed run of this algorithm is given in section 4. Consulting the database Given a request of type 1: Who is P. We first apply tile NounPhrases.graph to P. If P is not recognized, the research fails. It it is recognized, we obtain two outputs O1 and 02 as previously mentioned. For this type of request O1 cannot be empty. So we look in T) for the entries that match O1 (there can be several, often when the first name is not given, or given by its initial). Then, we print the different occupations associated to these entries. Given a request of type 2: the result is just an extension of the previous case: once we have found the entries in T~, we print all positions associated in the text. Given a request of type 3, the method is different: we begin by applying the Noun-Phrases.graph to P. In this case, O1 is empty. Then we look up the entries of 2), and check if at some location of the text, its occupation is compatible with the occupation of the request. Examples of use Consider the following chronological extract of French newspaper : I-M. Jack Lan K, minlstre de i'dducation nationale et de la culture, 2-ChafE& le 7 avril 1992 par M. Lan K de rdfldchlr aux conditions de 3-M. Jack Lank a lanc4 dimanche soir ~I la t&Idvision l'idde d'impliquer 4-Commentant Faction du mlnlstre de la culture, le premier adjolnt 5-En d4finltive l'idde de M. Lan K apparaTt comme un r~ve ! 6-Le directeur de l'American Ballet Theater, Kevin McKenzle : 7-M. Lan K pr~sente son pro jet de r~forme des lycdes prdvoyant 8-Tous, soutenez la |oi Lan K, par distraction, de temps en temps, ici 9-M. Jack Lan K, maire de Blols, a omclellement d~posd sa I0-Sortants : Michel Fromet, suppldant de Jack LanK, se repr~sente 11-De son cotd. Carl Lan K, secr~talre gdn@ra] du Front national, a 12-et Jack Lan K, anclen mlnlstre de ['dducatlon natlonale et de la culture, 13-l'ancien ministre, Jack LanK, et son successeur, Jacques Toubon, 14-Jack Lang, malre de Blois et anclen minlstre, 15-..., le nouveau ministre de l'4ducation nationale, Jacques Woubo., -At the beginning 7) is empty. -We read the sentence h 01 = {m, Jack, Lang}, 02 = {minister, education, culture}. There is no entry in 7) corresponding to 01, thus we create in 7) the following entry : SurName=LanE, FirstName=Jack, Gender=m, (Line 1 Occupation=minis%or,education,culture) -We read the sentence 2:O1 ---{m, Lang}. 01 matches the only entry in 7), and moreover as 02 is empty: it also matches the entry. Thus we add the line 2, as a reference to this first entry. SurName=Lan E , FirstName=Jack, Gender=m, (Line 1,20ccupation~inister,education.culture) -At the end of the processing, 7) equals to: SurName=LanK, FirstName=Jack, Gender--m, (Line 1,2,3,4,5,70ccnpation=nlinister,educatlon,cu]ture) (Line 9,12.13.14 Occupation----mayor,Blols) SurName=Fromet, FirstName=Mi chel, Gender=m, (Line 10 Occupation=minister.deputy,education,culture) SurName=LanK, FirstName=Carl, G ender--m, (Line I10\u00a2cupation=head-party,F~) SurName=Toubon, FirstName=Jacques, Gender=m, (Line 13,15 Occupation----mlnlster,education) Now if we search all parts of the text mentioning the minister of culture, we apply NounPhrases.graph to this request and we find O1 = {}, O2 = {minister, culture}. The only entries in 7) matching 02 correspond to the lines 1,2,3,4,5,7,13,15. This was expected, lines referring to the homonym of Jack Lang have not be considered, nor line referring Jack Lang designated as the mayor of Blois. 5 Remaining errors Some cases are difficult to solve, as we can see in the sentence: In China, the first minister has .... The first phrase of the sentence: In China is an adverbial, and could be located everywhere in the sentence. It could even be implicit, that is, implied by the rest of the text. In such a case, a human reader will need the context, to identify the person designated. We are not able, to extract the information we need, thus the result is not false, but imprecise. Another situation leads to wrong results: when one same person has several occupations, and is designated sometimes by one, sometimes by another. To resolve such a case, we must represent the set of occupations that axe compatible. This is a rather large project ell the 'semantics' of occupation. Finally, as we can see if figure 6 , a determiner and an adjective can be found between the Fullname part, and the Occupation part. In most case, it is something 'this', or 'tile', or 'the wellknown', or 'our great', and can be easily described by a FST. But in very exceptional case, we can find also complex sequences between the Fullname part, and the Occupation part. For example: 'M. X, who is since 1976, the prime minister of ...'. In this case, it is not possible, in tile current state of the developpment of out FST library, to provide a complete description. 6 Building the dictionaries and the database The results of our approach is in proportion tile size of the database we use. We show that using variables in FSTs, and the bootstrapping method, this constraint is not as huge it seems. One can start with a minimal database and improve tile database, when testing it on a new corpus. Suppose for example, that the database is empty (we only have general purpose dictionaries). We ask the system to find all occurrences of the word 'minister', the result has the following form of concordance.\" The Israeli foreign minister. $himon Peres. said the intern the Russian foreign minister. Indrei V. gozyrev, was likely Berlusconi as prime minister, but ty issue ought to be the \u00a2oturi, as the Creek minister of culture, thought up the ide fir:~ deputy prime minister, Oleg Soskove~s; Moscow has pl On this small sample, we see that it is interesting to search the different occurrences of \"(<A>+<N>) <minister>\" and we obtain the list: prime, foreign, Greek, finance, trade, interior, Cambodian, ... We separate automatically in this list, words with uppercase first letter and lowercase words. This provide a first draft for a Nationality dictionary (on a 1Mo corpus, we obtain 234 entries (only with this simple rule). The list is then manually checked to extract noise as 'Trade minister of ...'. We then sort the lowercase adjective and begin to construct the minister graph. We find directly 23 words in the subgraph \"SpecialityMinisterLeft\", plus the special compounds \"prime minister\" and \"chief minister\". We then apply this graph to the corpus and attempt to extend occurrences to the left and to the right. We notice that we can find a name of country with an \"'s\"just to the left of the occupation, and thus we catch potential names of country with the following request: \"[A-Z][a-z]*'s :MinisterOccupation\", where [A-Z] [a-z] * is any word beginning with an uppercase letter. This is an example of variable in the automaton. Pursuing this text-based method and starting from scratch, in roughly 10 minutes, we build a first version of the dictionaries: Country (87 entries) and Nationality (255 entries), Firstname (50 entries), Surname (47 entries), plus a first version of the Minis-terOccupation and the FullName FSTs... The graphical tools and the real-time parsing algorithms we use are crucial in this construction. Remark that the strict domain of proper noun cannot be bounded: when we describe occupations in companies, we must catch the company names. When we describe the medical occupation, we are lead to catch the hospital names... Very quickly the coverage of the database enlarges, and dictionaries of names of companies, of towns must be constructed. Concerning the French, in a newspaper corpus, one word out of twenty is included in a occupation sequence: i.e. one sentence out of two in our corpus contained such noun phrase. Conclusion In conclusion, we have developed this system first for the French language, with very good results. It partially solves the problem of Information Retrieval for this precise domain. In fact the \"occupation\" domain is not closed: is a \"thief\" an occupation ? To avoid such difficulties, and in order to reach a good coverage of the domain, we have described essentially institutional occupations. We know full well that if we want to be precise, a very deep semantic description should be done: for example, it is not sure that we can say a \"prime minister\" of France is comparable with a \"prime minister\" of UK ? One of strength of the described system is that it enables us to gather information present in different locations of the corpus, which improves punctual descriptions. Another interest of having such representations for different languages is a possibly automatic translation for such noun phrases. The output of the source language will be used in the target language of FSTs to identify paths having the same output, hence the same meaning. We are working to adapt the representation to other languages, such as English and the challenge is not only to repeat the same work on another language, but to keep the same output for two synonyms in French and English, which is not easy, because some occupations are totally specific to a language. Our method is totally text-based, and the appropriate tools allow us to enrich the database progressively. We strongly believe that the complete description of such noun phrases is needed (for all needs: IR, translation, syntactic analysis...), and our interactive method which is quite efficient to this aim. Dictionnaires dlectroniques et analyse automatique de textes. Masson. Zipf. 1932",
    "abstract": "We present a method for constructing, maintaining and consulting a database of proper nouns. We describe noun phrases composed of a proper noun and/or a description of a human occupation. They are formalized by finite state transducers (FST) and large coverage dictionaries and are applied to a corpus of newspapers. We take into account synonymy and hyperonymy. This first stage of our parsing procedure has a high degree of accuracy. We show how we can handle requests such as: 'Find all newspaper articles in a general corpus mentioning the French prime minister', or 'How is Mr. X referred to in the corpus; what have been his different occupations through out the period over which our corpus extends?' In the first case, non trivial occurrences of noun phrases are located, that is phrases not containing words present in the request~ but either synonyms, or proper nouns relevant to request. The results of the search is far better than than those obtained by a key-word based engine. Most answers are correct: except some cases of homonymy (where a human reader would also fail without more context). Also, the treatment of people having several different occupations is not fully resolved. We have built for French, a library of about one thousand such FSTs., and English FSTs arc under construction. The same method can be used to locate and propose new proper nouns, simply by replacing given proper names in the same FSTs by variables.",
    "countries": [
        "France"
    ],
    "languages": [
        "Russian",
        "English",
        "French"
    ],
    "numcitedby": "19",
    "year": "1998",
    "month": "August",
    "title": "Locating Noun Phrases with Finite State Transducers"
}