{
    "article": "End-to-end models on data-to-text learn the mapping of data and text from the aligned pairs in the dataset. However, these alignments are not always obtained reliably, especially for the time-series data, for which real time comments are given to some situation and there might be a delay in the comment delivery time compared to the actual event time. To handle this issue of possible noisy alignments in the dataset, we propose a neural network model with multitimestep data and a copy mechanism, which allows the models to learn the correspondences between data and text from the dataset with noisier alignments. We focus on generating market comments in Japanese that are delivered each time an event occurs in the market. The core idea of our approach is to utilize multitimestep data, which is not only the latest market price data when the comment is delivered, but also the data obtained at several timesteps earlier. On top of this, we employ a copy mechanism that is suitable for referring to the content of data records in the market price data. We confirm the superiority of our proposal by two evaluation metrics and show the accuracy improvement of the sentence generation using the time series data by our proposed method. Introduction In recent time, various industries such as finance, pharmaceuticals and telecommunications have increased opportunities to treat large-scale data. Hence, there is an increasing demand to automatically generate a text from large and complex data. In recent studies, neural network-based models have achieved significant progress on the data-to-text which is a text generation task from input data (Puzikov and Gurevych, 2018; Liu et al., 2018; Iso et al., 2019) . One important issue in constructing a dataset for data-to-text is to obtain the correct alignment between data and text. It is not very problematic when there is a clear correspondence between data and text, for example, when the text is manually provided by an annotator for each input, including E2E NLG Challenge dataset (Puzikov and Gurevych, 2018) . However, this is often not a trivial problem in the wild, in particular for the application of real-time text generation, such as sequential comment generation on sports games (Taniguchi et al., 2019) and stock markets (Murakami et al., 2017) , for which we can only obtain a loose alignment of data and text. This problem has been taken into account in a classical task (Chen and Mooney, 2008) , but has been overlooked in the recent neural-based models cited above. In Murakami et al. (2017) , for example, they constructed a dataset for market comment generation in Japanese from a chart of stock price trends and its market reports, wherein the alignments between data and texts sometimes deviate. Figure 1 presents examples of data which are a five-minute chart of Nikkei 225 (Nikkei Stock Average) and comments describing the chart trends. All of the (I) to (III) comments are about an event at \"9:00 am, 29th of January\". However, since there is often a delay in comment delivery time for an event (e.g., (II) and (I II)), if a different movement occurs during this time period, the expressions in comment may not exactly reflect the movement at the delivery time. The word \"rebound\" indicates a downward and then upward movement on three points (the closing prices of the last two days and the latest price). This is valid for the prices at (I) and (II), but does not hold at (III) because the latest price (17039.22 yen) is lower than the last closing price (17041.45 yen). In addition, the expression \"gains 88 yen\" is only valid at the opening time (I) and is not valid at (II). To deal with these inconsistencies, the models have to be aware of these possible mismatch of data and text due to the delay, but a simple encoder-decoder-based Figure 1 : Nikkei 225 and market comments about an event at 9:00 am, 29th of January model of Murakami et al. (2017) , which does not tell the difference between the event and delivery times, may perform an undesirable generalization between data and text. In this study, we extend Murakami et al. (2017) 's model with a new architecture to solve the problem due to the noisy alignments. The presented architecture is a multi-timestep architecture, which employs multiple input vectors to compensate the lack of information about the actual event time, treating it as a hidden variable and learning the correspondences from the ambiguous data. Our model employs a copy mechanism to generate a price value in a text, in which an attention weight to the time can be regarded as an induced alignment between the text and actual event time. The experimental results reveal that our proposed model outperforms the existing model in terms of the correctness of market price movement expressions, in addition to the BLEU scores. Generating Market Comments In this section, we explain the model proposed by Murakami et al. (2017) , which be used as a base model. They proposed a model for generating a market comment, which is a news headline about the movement of the Nikkei 225, from the timeseries of the stock price of the Nikkei 225. Their model is based on the encoder-decoder (Sutskever et al., 2014) . Murakami et al. (2017) use both a long-term vector x long and a short-term vector x short . To capture the long-term price movement, they use a vector consisting of the closing prices of the preceding trading days represented as x long = ( long, 1 , long, 2 , . . . , long, ). Similarly, to capture the short-term price movement, they use a vector consisting of the prices of previous timesteps on the five-minute chart, starting from the comment delivery time (e.g., 10:00 am), represented as x short = ( short, 1 , short, 2 , . . . , short, ). Each of these vectors undergoes the following two preprocessing steps : Base Model std = \u2212 , ( 1 ) norm = 2 \u00d7 move \u2212 ( \u00af max + \u00af min ) \u00af max \u2212 \u00af min , (2) where is the -th element of x. and are the mean and the standard deviation of the values in the training data, respectively. move is defined to be \u2212 , where is the closing price of the previous trading day. \u00af max and \u00af min are the maximum and the minimum of move , respectively. Equation ( 1 ) is a standardization method and Equation (2) is a normalization method for moving reference. By applying these preprocessings to x long and x short , we obtain x std long ,x norm long , x std short , and x norm short . In the encoding step, these vectors are passed to multi-layer perceptrons (MLPs) to obtain the vectors h std long , h norm long , h std short , and h norm short . These are then concatenated as h long = [h std long ; h norm long ] and h short = [h std short ; h norm short ]. These vectors are combined to obtain the hidden state m of the encoder: m = W [h long ; h short ] + b . (3) In the decoding step, Murakami et al. (2017) set the initial hidden state s 0 of the decoder as m above, and use LSTM cells (Hochreiter and Schmidhuber, 1997) . They further use additional vectors called time embeddings t. To obtain t, time is discretized into intervals of one hour (e.g., 9:00 am to 10:00 am), and an embedding is obtained for each interval; 9:10 am and 9:30 am are associated with the same embedding. The time embedding of the interval, wherein the delivery time of the comment falls into is used as an additional input in each step of LSTM: s = LSTM( [t ; w \u22121 ], s \u22121 ). (4) As in the standard LSTM decoder, this output is fed into a linear layer, followed by a softmax layer to calculate the next word probability. Generalization Tags for Estimation of Arithmetic Operations Market comments often mention numerical values including the market prices themselves and the values obtained through arithmetic operations such as difference and rounding. To allow the model to generate numerical values with such computation during decoding, Murakami et al. (2017) introduce generalization tags (Table 1 ), which specify which operation should be performed to obtain a value. In Murakami et al. (2017) , for simplicity, the input value to these operations is fixed as the short,1 , the first (latest) price at the delivery time, which is converted to and in Table 1 (see caption). However, this simplification ignores the possible mismatch of the delivery and event times (Section 1). We extend this method with a variant of a copy mechanism (Section 3.2), in which the event time is Murakami et al. (2017) used MLPs, convolutional neural networks (CNNs) and long short-term memory networks (LSTMs). We use MLPs in the encoder for our baseline model because the differences of the performance were small in their experiment. Tag Arithmetic operation <operation1> Return <operation2> Round down to the nearest 10 <operation3> Round down to the nearest 100 <operation4> Round up to the nearest 10 <operation5> Round up to the nearest 100 <operation6> Return as it is <operation7> Round down to the nearest 100 <operation8> Round down to the nearest 1,000 <operation9> Round down to the nearest 10,000 <operation10> Round up to the nearest 100 <operation11> Round up to the nearest 1,000 <operation12> Round up to the nearest 10,000 Table 1 : Generalization tags and corresponding arithmetic operations. is defined as the latest price, and is defined as the difference between and the closing price of the previous trading day. softly predicted with attention and each numerical value is generated on demand during decoding with an operation in Table 1 . 3 Multi-timesteps for Time-series Data Murakami et al. (2017) 's model put an assumption that the event and delivery times are identical. This assumption simplifies the task and thus Murakami et al. (2017) propose a model with a basic encoderdecoder architecture. However, due to the time gap between the actual event time and delivery time, this assumption is not realistic. We extend the Murakami et al. (2017) 's model with a multi-timestep architecture, aiming at solving that problem occurred by the noisy alignments. Figure 2 presents our model architecture. To compensating the lack of information caused by the time gap mentioned above, we extend the encoder with additional input vectors. Each additional vector corresponds to x short starting from preceding timesteps instead of the delivery time. This allows us to treat the actual event time as a latent variable. On top of this, we introduce a copy mechanism with attention in the decoder, which facilitates learning correspondences between data and text from the noisy training data. Encoder with Multi-timesteps For long-term stock prices, we use a long-term vector x long following Murakami et al. (2017) . For short-term stock prices, instead of x short alone, we use x short-0step ,. . . , x short-step which we abbreviate as x 0 ,. . . , x for brevity. Each x is a short-term vector consisting of the stock prices of timesteps, which, instead of starting from the comment delivery time, starts from the time steps prior to the delivery time. When the delivery time is 10:00 am, for example, since we use the five-minute chart, our short-term vectors comprise of + 1 vectors corresponding to the vectors starting from 10:00 am, 9:55 am, 9:50 am, and so on. We note that each interval of five minutes is not simply associated with one value, but rather with four different values: open (the price at the very beginning of the interval), low (the lowest price in the interval), high (the highest price in the interval), and close (the price at the last of the interval). We encode these as four different vectors x open , x low , x high , and x close . Thus, there are in total 4( + 1) \u2212 1 vectors for short-term prices. In the following, we use \u02dc \u2208 [0, 4( + 1)) as an index for these vectors. Each of the input vectors undergoes the preprocessing methods as Murakami et al. (2017) . For long-term vectors, we obtain x std long and x norm long in the same way. Similarity, for each \u02dc , we obtain x std \u02dc and x norm \u02dc from x \u02dc . Given these, each MLP emits the corresponding hidden states h long and h \u02dc . Murakami et al. (2017) use only the close prices. We use four values instead since prices could largely move even in a single interval. Following Equation (3), we also obtain the encoder hidden state m with h long and h short . The vector h short depends on a sequence of h \u02dc to which an encoder maps the input data. It is computed as a weighted sum of h \u02dc as follows: h short = 4( +1)\u22121 \u02dc =0 \u02dc h \u02dc . (5) The weight \u02dc of each h \u02dc is computed by: \u02dc = exp( \u02dc )/ 4( +1)\u22121 =0 exp( ). (6) e = ( 0 , \u2022 \u2022 \u2022 , 4( +1)\u22121 ) is obtained by MLP [t ; a ; f 0 ; h 0 ; . . . ; f 4( +1)\u22121 ; h 4( +1)\u22121 ] . (7) \u02dc scores the importance of x \u02dc , based on the hidden states h \u02dc , time embedding vector t (Section 2.1), and additional two kinds of vectors, five-minute time embedding vectors f \u02dc and article-type embedding vector a. f \u02dc is an embedding to identify \u02dc , which maps from the starting time and the kind of price (e.g., open) to a vector. a is a vector obtained whether the comment is regular or irregular. The motivation to use these vectors is that an important x \u02dc is primarily determined by either the price history (encoded by h \u02dc ), or the delivery time (encoded by f \u02dc ), depending on the article type. For instance, when the delivery time is the same as the market opening time, that is, 9:00 am, and the comment is a regular comment, then the comment usually mentions the price at 9:00 am (e.g., \"The opening price is 15,430 yen.\"). In this case, the important x \u02dc is primarily determined by the time encoded by f \u02dc ; that is, for regular comments, the event times are rather fixed regardless of the variations in delivery times. On the other hand, even if the delivery time is the same as the market opening time, when the comment is irregular, the comment mentions some distinguished price movement (e.g. \"The price is over 100 yen higher than the last closing price.\") rather than the mere price at 9:00 am. In this case, the important x \u02dc would be determined by the price history itself. We expect these additional vectors to provide a useful inductive bias for a model to learn those distinctions. Decoder with Copy Mechanism We adapt a copy mechanism (Gu et al., 2016) in our decoder to generate numerical values by attending to the input. Recall that in the current task, the values in the output text usually do not appear in the input data (Section 2.2); rather, they can be obtained by applying an arithmetic operation to the certain value in the data. We generate a numerical value by an extension of a copy mechanism, wherein a value is generated by applying one of the operations in Table 1 to a data point \u02dc ,1 , which is the first value (latest price) of x \u02dc . Denoting an arithmetic operation as \u2208 { 1 , \u2022 \u2022 \u2022 , 12 }, the value is identified by a pair ( , \u02dc ). We reduce the generation of numerical values to identification of these pairs, followed by the execution of an operation. We wish to obtain a probability distribution on numerical values that are determined by ( , \u02dc ). One consideration for obtaining this is that there can be multiple pairs of ( , \u02dc ) that result in the same value. For example, for an input \u02dc ,1 = = 3200, 6 7 , and 10 all result in the same value (3200). In practice, we obtain a probability to generate a numerical value by a weighted sum of scores for ( , \u02dc ), for which ( \u02dc ,1 ) = holds, according to the obtained weights \u02dc in the encoder, which we regard as attention. (\u2022) denotes execution of operation to the input. We note that unlike the standard copy mechanism, we use the fixed attention weights \u02dc throughout the decoder. This is because, in a headline comment, which is our target, the event to be mentioned would not change throughout a single piece of text. In other words, the important x \u02dc would not change throughout a comment. Our model generates all numerical values in the text with this copy mechanism. To do this, we exclude numerical values from the vocabulary of the model. To switch the copy mode and noncopy mode, we add a special token \"<PRICE>\", which is inserted before every numerical value in the training data and indicates that the next token is a price value. Utilizing \"<PRICE>\", we define each conditional probability of generating target word at time as: ( | < , m) = ( | < , m), ( \u22121 = \"<PRICE>\") ( | < , m), (otherwise) (8) where ( |\u2022) and ( |\u2022) are obtained by the generation mode and the copy mode, respectively. This method is inspired by Pointer-generator network introduced by See et al. (2017) . These two probabilities are defined as: ( |\u2022) = [softmax(W v + b )] (9) ( |\u2022) = \u02dc , : ( \u02dc ,1 )= ( \u02dc , ) (10) ( \u02dc , ) = \u02dc \u2022 [softmax(W c + b )] . (11) v and c are both obtained from the output of decoder LSTM, s , at each step : s = LSTM( [t ; w \u22121 ; q \u22121 ], s \u22121 ) (12) v = W \u210e s + b \u210e (13) c = MLP(s ). ( 14 ) t is the time embedding defined in Section 2.1. Comparing to Equation (4), we add q to the input to the LSTM. Each element of q is ( \u02dc , ). We add this vector to properly propagate the information about an applied arithmetic operation, which may not be kept directly in s . Experiments Datasets We used a five-minute chart of the Experimental Settings All MLPs in the model are three layers with hidden dimension of 256. The decoder LSTM is a single layer with hidden dimensions of 256. For the length of short-and long-term vectors, we set = 7 for x long and = 62 for x \u02dc , following Murakami et al. (2017) , changing the range of by setting \u2208 [0, 6]. The embedding sizes of a word, five-minute tag f \u02dc , article-tag a, and time tag t are 128, 80, 64, and 64, respectively. We trained the models for 150 epochs with the mini-batch size of 100, using Adam (Kingma and Ba, 2015) optimizer with the initial learning rate 1 \u00d7 10 \u22124 , and saved the parameters every epoch, selecting the model with the highest BLEU score on the validation dataset. Evaluation Metrics We conduct two types of evaluation: one is BLEU (Papineni et al., 2002) to measure the matching degree between the market comments written by humans as references and the output comments generated by the models, and the other is a new evaluation metric that we created. The new metric uses the matching between the market price movement in the data and the movement expressions in the comments. Using (x , w , w ), which are the -th sample of the input data, the market comment written by humans, and the output comment generated by the models, we define the following https://hosted.datascope.reuters.com/ DataScope/ variables: (w) = \uf8f1 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f3 (w \u2208 rise ) (w \u2208 fall ) ( \u210e ) (x) = \uf8f1 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f3 (Latest move > 0) (Latest move < 0) ( \u210e ) C = { | (w ) = (x )} C = { | (w ) = (x )} D = { | (w ) \u2260 (x )} D = { | (w ) \u2260 (x )} where rise is {\u7d9a\u4f38 (continuous rise), \u53cd\u767a (rebound), \u4e0a\u3052 (up / rise)}, fall is {\u7d9a\u843d (continuous fall), \u53cd\u843d (fall back), \u4e0b\u3052 (down/fall)}, move is the same as move shown in Section 2.1, defined as \u2212 , where is the closing price of the previous trading day. Using the above variables, we obtain the following metrics: Concord = |C \u2229 C | |C | Concord = |C \u2229 C | |C | Diff = |D \u2229 D | |D | Diff = |D \u2229 D | |D | . These metrics can be seen as a proxy for the model's ability to attend to an intermediate (not latest) step according to the movement in the data. To know the frequency of these concordances and differences in the data, we count them in the training and valid dataset, which we summarize in Table 2 . We evaluate the BLEU scores for both validation and test sets, while we performed the correspondence evaluation, which will be described below, only for the validation set. We train models with six different seeds for each setting and report the macro averages on them. Results Table 3 summarizes the BLEU scores on the validation and test sets, and Table 4 presents the correspondence evaluation on the validation set. According to the experimental results provided in Table 3 , our models mostly outperformed the baseline, especially when used with the copy mechanism. For the test set, our models always outperformed the baseline. In particular, = 2 with the copy mechanism achieved the highest score, 7.68 points improvement on the BLEU score compared to the baseline (see the bold font in Table 3 ). Conversely, the result shows that just adding attention to the encoder (+Attention), keeping the decoder the same as the baseline, is not helpful. It shows that simply applying the attention mechanism does not enable the model to obtain the correspondence between data and text correctly, while the copy mechanism certainly helps to obtain the correspondence. In a comparison among the models using = 6, increasing the number of steps does not necessarily contribute to improving the BLEU score. Furthermore, Table 4 indicates that most of our models outperformed the baseline. However, in the same tendency as the BLEU score evaluation, this result further reveals that increasing the number of steps is not necessarily an important factor in improving the score. Figure 3 depicts distributions regarding the time gap between the comment delivery time and the event occurrence time. When we use = 5, we can cover 89.05% in training data and 94.07% in validation set of their time gap data (i.e., sum of an Irregular value and 0 to 5 of Regular values in Figure 3 ). Alternatively, using more x \u02dc would add more noise, therefore, they would be related to the transactions. According to Table 3 , Table 4 and Figure 3 , using = 3 or = 4, covered around 80% are considered as the best choice in this dataset. Table 5 provides examples of the generated comments where our model generated the correct movement expression while the baseline generated an incorrect expression (see, the bold font in Table 5 ). Moreover, the method with copy mentioned the cor-Figure 3 : Data distribution regarding the time gap between the comment delivery time and the event occurrence time. First, we classified a human-written market comment in the dataset into two types, whether it was a regular comment (Regular) or not (Irregular) using the expressions specific to regular comments. In the case of a regular comment, it is classified by the time gap between that event occurrence time and the comment delivery time in five-minute increments, for example, 0 = from 0 min to 5 min gap, 1 = from 5 min to 10 min gap. rect numerical value, while the baseline generated an incorrect numerical value. However, there is another problem with the fluency. For instance, at the expression of \"in the higher yen range\", the numerical value should be a round number, e.g., round to the nearest 100, 1,000, or 10,000. However, the model with the copy mechanism generates a specific number (see, the underline font in Table 5 ) Related Work The task of generating text describing input data, which is called data-to-text, has been worked on various domains, for instance weather forecasts (Belz, 2007; Angeli et al., 2010) , healthcare (Portet et al., 2009; Banaee et al., 2013) , and sports (Liang et al., 2009) . Traditionally, data-to-text is divided into two sub-problems (Kukich, 1983; Goldberg et al., 1994) : content selection, which is about \"what to say\", and surface realization, which is about \"how to say\". Moreover, Reiter and Dale (1997) divides three modules, adding micro planning between the above sub-problems. In the early stage of this task, surface realization is often realized using templates (van Deemter et al., 2005) or statistically learned models with hand-crafted features (Belz, 2008; Konstas and Lapata, 2012) . In recent times, various industries such as finance, pharmaceuticals, and telecommunications have been increased providing opportunities to treat various types of large-scale data, so that they are interested in automatically learning a correspondence relationship from data to text and generating a description of this relationship. Therefore, recent works have focused on generating text from data with neural networks, that can solve the above sub-tasks in one through. Especially the models, which utilize an encoder-decoder model (Sutskever et al., 2014) have proven to be useful (Mei et al., 2016; Lebret et al., 2016) . While text generation by neural network can describe the text fluently, they do not describe the exact entities or numbers. Therefore, a copy mechanism (Vinyals et al., 2015; Gu et al., 2016) , which provides a way to directly copy words from the input, has been utilized. By these neural networks, the works such as conditional language generation based on tables (Yang et al., 2017) , short biographies generation from Wikipedia tables (Lebret et al., 2016; Chisholm et al., 2017; Sha et al., 2018; Liu et al., 2018) and sports scoreboards (Wiseman et al., 2017; Li and Wan, 2018; Puduppully et al., 2019) are well performed. Contrastingly, they can only generate the superficial contents that appear in their input table, and cannot generate contents that require arithmetic operations. However, Joulin and Mikolov (2015) and Neelakantan et al. (2016) indicate that current neural models have difficulties in learning arithmetic operations such as addition and comparisons by neural program inductions. Thus, there have been some methods to prepare the numerical values with arithmetic operations in advance. Murakami et al. (2017) post-process the price by extending the copy mechanism and replacing numerical values with defined arithmetic operations after generation. Nie et al. (2018) utilizes information from pre-computed operations on raw data to consider incorporating the facts that can be inferred from the input data to guide the generation process. Our model prepares numerical values with defined arithmetic operations as Murakami et al. (2017) for copy and that copy target is guided by encoded input. Conclusion In this paper, we have proposed an encoder-decoder model with multi-timestep data and a copy mechanism for generating the market comment from data with the noisy alignments. Both BLEU scores and our proposal evaluation showed the accuracy of sentence generation with time-series data has been improved by our proposed method, especially utilizing a copy mechanism. Acknowledgements This paper is based on results obtained from projects commissioned by the New Energy and Industrial Technology Development Organization (NEDO) JPNP20006 and JPNP15009, and JSPS KAKENHI Grant Number JP20H04217."
}