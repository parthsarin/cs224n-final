{
    "article": "This paper describes how to construct a finite-state machine (FSM) approximating a 'unification-based' grammar using a left-corner grammar transform. The approximation is presented as a series of grammar transforms, and is exact for leftqinear and rightlinear CFGs, and for trees up to a user-specified depth of center-embedding. 1 Introduction This paper describes a method for approximating grammm's with finite-state machines. Unlike the method derived from the LR(k) parsing algorithm described in Pereira and Wright (1991) , these methods use grammar transformations based on the left-corner grammar transform (Rosenkrantz and Lewis II, 1970; Aho and Ulhnan, 1972) . One advantage of the left, corner methods is that they generalize straightforwardly to complex feature \"unification based\" grammars, unlike the LR(k) based at> proach. For example, the implementation described here translates a DCG version of the example grammar given by Pereira and Wright (1991) directly into a FSM without constructing an approximating CFG. Left-corner based techniques are natural for this kind of application because (with the simple optimization described below) they can parse pure leftbranching or pure right-branching structures with a stack depth of one (two if terminals are pushed and popped from the stack). Higher stack depth occurs with center-embedded structures, which humans find difficult to comprehend. This suggests that we may get a finite-state approximation to human performance by simply imposing a stack depth bound. We provide a simple tree-geometric description of the configurations that cause an increase ill a left corner parser's stack depth below. The rest of this paper is structured as follows. The remainder of this section outlines the \"grammar transform\" approach, summarizes the top-down t)arsing algorithm and discusses how finite state approximations of top-down parsers can be construtted. The fact that this approximation is not exact for left linear grammars (which define finite-state languages) motivates a finite-state approxinlation based on the left-corner parsing algorithm (which is presented as a grammar transform in section 2). In its standard form the approximation based on the left-corner parsing algorithm suffers from the complementary problem to the toi)-down approximation: it is not exact for right-linear grmnmars, but tile \"optimized\" variants presented in section 3 overcome this deficiency, resulting in finite-state CFG approximations which m'e exact for leftqinear and right-linear grmnmars. Section 4 discusses how these techniques can be combined in an implementation. Parsing strategies as grammar transformations The parsing algorithms discussed here are presented as grammar trans/ormatioTzs, i.e., functions T that map a context-free grammar G into another contextfi'ee grammar T(G). The transforms have the property that a top-down parse using the transformed grammar is isomorphic to some other kind of parse using tile original grammar. Thus grammar transforms provide a simple, compact way of describing various parsing algorithms, as a top-down parser using T(G) behaves identically to the kind of parser we want to study using G. Mappings from trees to trees Tile transtbrmations presented here can also be understood as isomorphisms fi'om the set of parse trees of the source grammar G to parse trees of the transformed grammar which preserve terminal strings. Tiros it is convenient to explain the transforms in terms of their effect on parse trees. We call a parse tree with respect to tile source grammar G an analysis tree, in order to distinguish it from parse trees with respect to some transform of G. Tile analysis tree t in Figure 1 will be used as an example throughout this paper. The analysis tree t used as a running example below, and its left-corner transforms \u00a3Ci(t). Note that the phonological forms are treated here as annotations on the nodes drawn above them, rather than independent nodes. That is, DET (annotated with the) is a terminal node. 1.3 Top-down parsers and parse trees The \"predictive\" or \"top-down\" recognition algorithm is one of the simplest CFG recognition algorithms. Given a CFG G = (N,T,P,S), a (topdown) stack state is a sequence of terminals and nonterminals. Let Q = (N U T)* be the set of stack states for G. The start state qo E Q is the sequence S, and the final state qs E Q is the empty sequence ~. The state transition function 5 : Q \u00d7 (TU {~}) ~ 2 Q maps a state and a terminal or epsilon into a set of states. It is the smallest function 3 that satisfies the following conditions: \"TE6(a'y,a):aET, TE (NUT)*. /~'y E 5(A'y, e) : A E N, \"), E (N U T)*, A -~/3 E P. A string w is accepted by the top-down recognition algorithm if q/ E ~*(qo,w), where 5* is the reflexive transitive closure of ($ with respect to epsilon moves. Extending this top-down parsing algorithm to a 'unification-based' grammar is straight-forward, and described in many textbooks, such as Pereira and Shieber (1987) . It is easy to read off the stack states of a topdown parser constructing a parse tree from the tree itself. For any node X in the tree, the stack contents of a top-down parser just before the construction of X consists of (the label of) X followed by the sequence of labels on the right siblings of the nodes encountered on the path from X back to the root. It is easy to check that a top-down parser requires a stack of depth 3 to construct the tree t depicted in Figure 1 . 1.4 Finlte-state approximations We obtain a finite-state approximation to a topdown parser by restricting attention to only a finite number of possible stack states. The system implemented here imposes a stack depth restriction, i.e., the transition function is modified so that there are no transitions to any stack state whose size is larger than some user-specified limit. 1 This restriction ensures that there is only a finite number of possible stack states, and hence that the top down parser is an finite-state machine. The resulting finite-state machine accepts a subset of the language generated by the original grammar. The situation becomes more complicated when we move to 'unification-based' grammars, since there may be an unbounded number of different categories appearing in the accessible stack states. In the system implemented here we used restriction (Shieber, 1985) on the stack states to restrict attention to a finite number of distinct stack states for any given stack depth. Since the restriction operation maps a stack state to a more general one, it produces a finite-state approximation which accepts a superset of the language generated by the original unification grammar. Thus for general constraint-based grammars the language accepted by our finite-state apt)roximation is not guaranteed to be either a superset or a subset of the language generated by the input grammar. 2 The left-corner transform While conceptually simple, the top-down parsing algorithm presented in the last section suffers from a number of drawbacks for a finite-state approximation. For example, the number of distinct accessible stack states is unbounded if the grammar is left-recursive, yet left-linear grammars always generate regular languages. This section presents the standard left-corner grammar transformation (Rosenkrantz and Lewis II, 1970; Aho and Ullman, 1972) ; these references should be consulted for proofs of correctness. This transform serves as the basis for the fllrther transforms described in the next ,;ection; tliese transforms have the property that the output grammar induces a finite number of distinct accessible stack states if their input is a left-rccursive left-linear grammar. Given an input grammar G with nonterminals N and terminals T, these transforms \u00a3Ci produce grammars with an enlarged set of nonterminals N' = N U (N x (N U T)). The new \"pair\" categories in N x (N U T) are written A-X, where A is a nonterminal of G and X is either a terminal or nonterminal of G. It turns out that if A =~; X 7 then A-X =~)c,((~) % i.e., a non-terminal A-X in the trmlsformed grammar derives the diffeT~nce between A and X in the original grammar, and the notation is meant to be suggestive of this. The l@-corne.r transform of a CFG G = (N, T, P, S) is a grammar /2dr (G) = (N', T, PI, S), where 1~ contains all productions of the form (1.a-1.c). This paper assumes that N n T = (~, as is standard. To save space we assume that P does not contain any epsilon productions (but it is straightforward to deal with them). A -+ aA--a: A c N,a E T. (1.a) A -X -+ flA-B : A E N,B -4 Xfl C P. (1.b) A-A -+ ~ : A e N. (1.c) Informally, the productions (1.a) start the leftcorner recognition of A by recognizing a ternfinal a as a possible left-corner of A. The actual leftcorner recognition is performed by the productions (1.b), which extend the left-corner from X to its parent B by recognizing fl; these productions are used repeatedly to construct increasingly larger leftcorners. Finally, the productions (1.c) terminate the recognition of A when this left-corner construction process has constructed an A. The left-corner transform preserves the number of parses of a string, so it defines an isomorphism from analysis trees (i.e., parse trees with respect to (J) to parse trees with respect to \u00a3Ct (G). If t is a parse tree with respect to G then (abusing notation) \u00a3Ct (t) is the corresponding parse tree with respect to \u00a361(G). Figure 1 shows the etfect of this mapping on a simple tree. The transformed tree is considerably more complex: it has double the number of nodes of the original tree. In a top-down parse of the tree \u00a3C1(t) in Figure 1 the maximum stack depth is 3, which occurs at the recognition of the terminals ran and fast. Filtering useless categories In general tile grammar produced by the transform \u00a3C1(G) contains a large number of useless nontcr-minals, i.e., non-terminals which can never appear in any complete derivation, even if the grammar G is flflly pruned (i.e., contains no useless productions). While \u00a3C1(G) can be pruned using standard algorithms, given the observation about the relationship between the pair non-terminals in \u00a3Cl (G) and nonterminals in G, it, is clear that certain productions can be discarded immediately as useless. Define the h:ft-corncr relation < C (N U T) x N as follows: X < A iff 3fl. A ~ X fl E P, Let <* be the reflexive and transitive closure of <. It is easy to show that a category A-X is useless in \u00a3C1(G) (i.e., derives no sequence of terminals) unless X <* A. Thus we can restrict the productions in (1.a-l.c) without affecting the language (strongly) generated to those that; only contain pair categories A-X where X m* A. Unification grammars One of the main advantages of left-corner parsing algorithms over LR(k) based parsing algorithms is that they extend straight-forwardly to complex feature based \"unification\" grammars. The transformation/2C1 itself can be encoded in several lines of Prolog (Matsumoto et al., 1983; Pereira and Shieber, 1987) . This contrasts with the LR(k) methods. In LR(k) parsing a single LR state may correspond to sew~ral items or dotted rules, so it is not cleat\" how the feature \"unification\" constraints should be associated with transitions from LR state to LR state (see Nakazawa (1995) for one proposal), in contrast, extending the techniques described here to complex feature based \"unification\" grammar is straight-forward. The main complication is the filter on useless nonterminals and productions just discussed. Generalizing the left-corner closure filter on pair categories to complex feature \"unification\" grammars in an efficient way is complicated, and is the primary difficulty in using left-corner methods with complex feature based grammars, vail Noord (1997) provides a detailed discussion of methods for using such a \"left-corner filter\" in unification-grammar parsing, and the methods he discusses are used in the implementation described below. Extended left-corner transforms This section presents some simple extensions to the basic left-corner transform presented abow~'. The 'tail-recursion' optimization permits bounded-stack parsing of both left, and right linear constructions. Further manipulation of this transform puts it into a form in which we can identify precisely the tree configurations in the original grammar which cause the stack size of a left-corner parser to increase. These observations motivate the special binarization methods described in the next section, which minimize stack depth in grammars that contain productions of length no greater than two. A tail-recursion optimization If G is a left-linear grammar, a top-down parser using Z:C1 (G) can recognize any string generated by (7 with a constant-bounded stack size. However, the corresponding operation with right-linear grammars requires a stack of size proportional to the length of the string, since the stack fills with paired categories A-A for each non-left-corner nonterminal in the analysis tree. The 'tail recursion' or 'composition' optimization (Abney and Johnson, 1991; Resnik, 1992) permits right-branching structures to be parsed with bounded stack depth. It is the result of epsilon removal applied to the output of \u00a3C1, and can be described in terms of resolution or partial evaluation of the transformed grammar with respect to productions (1.c). In effect, the schema (1.b) is split into two cases, depending on whether or not the rightmost nonterminal A-B is expanded by the epsilon rules produced by schema (1.c). This expansion yields a grammar \u00a3C2(G) = (N', T, P2, S), where P2 contains all productions of the form (2.a-2.c). (In these schemata A,B E N; a E T; X E N U T and \u00a2t E (NUT)*).  (2.c) Figure 1 shows the effect, of the transform \u00a3C2 on the example tree. The maximum stack depth required for this tree is 2. When this 'tail recursion' optimization is applied, pair categories in the transformed grammar encode proper left-corner relationships between nodes in the analysis tree. This lets us strengthen the 'useless category' filter described above as follows. Let ~+ be the transitive closure of the left-corner relation ,~ defined above. It is easy to show that a category A-X is useless in \u00a3C2(G) (i.e., derives no sequence of terminals) unless X <+ A. Thus we can restrict the productions in (2.a-2.b) without affecting the language (strongly) generated to just those that only contain pair categories A-X where X ,~+ A. The special ease of binary productions We can get a better idea of the properties of transformation \u00a3C2 if we investigate the special case where the productions of (7 are unary or binary. In this situation, transformation \u00a362(G) can be more explicitly written as \u00a3C3((7) = (N',T, P3,S), where P3 contains all instances of the production schemata (3.a-3.e). (In these schemata, a E T; A, B E N and X,Y E NUT). a A-X ~ a C aA-B (4.f) Figure 2 : The highly distinctive \"zig-zag\" or \"lightning bolt\" configuration of nodes in the analysis tree characteristic of the use of production schema (4.f) in transform \u00a3C4. This is the only configuration which causes an increase in stack depth in a topdown parser using a grammar transformed with \u00a3C4.       The transform also simplifies the specification of finite-state machine approximations. Because all terminals are introduced as the left-most symbols in their productions, there is no need for terminal symbols to at)t)em on the parser's stack, saving an epsilon transition associated with a stack push and an immediately following stack pop with respect to the standard left-corner algorithm. Productions (4.a) and (4.d-4.g) can t)e understood as transitions over a terminal a that replace the top stack element with a sequence of other elements, while the other productions can be interpreted as epsilon transitions that manipulate the stack contents accordingly. Note that the right hand sides of all of these productions except for schema (4.f) are right-linear. Thus instances of this schema are the only productions that can incre~e the stack size in a top-down parse with /2(24(G), and the stack depth required to parse an analysis tree is the maximum number of \"zig-zag\" patterns in the l)ath in the analysis tree from any terminal node to the root. Figure 2 sketches the configuration of nodes in the analysis trees in which instances of schemata (4.f) would l)e used in a parse using /;C4(G). This highly distinctive \"zig-zag\" or \"lightning bolt\" pattern does not occur at all in the example tree t in Figure 1 , so the maximmn required stack depth is 2. (Recall that in a traditional top-down parser terminals are pushed onto the stack and poI)ped later, so initialization productions (4.a) cause two symbols to t)e pushed onto the stack). It follows that this tinite state approximation is exact for left-linear and right-linear CFGs. Indeed, analysis trees that consist simply of a left>branching subtree followed by a right-l)ranching subtree, such as the example tree t, m:e transformed into strictly right-branching trees by 12(-:4. Implementation This section provides further details of the finitestate apt)roximator implemented in this research. The apt)roximator is written in Sicstus l'rolog. It takes a user-specifier Definite Clause Grammar G (without Prolog annotations) as intmt, which it binarizes and then applie.s transform 12(24 to. The implementation annotates each transition with the production it corresponds to (represented as a pair of a \u00a3(24 schema number and a production number fl'om G), so the finite-state approximation actually defines a transducer which transduces a lexical input to a sequence of productions which specify a parse of that input with respect to EC4 (G). A following program inverts the tree transform 12C4, returning a corresponding parse tree with respect to G. This parse tree can be checked by performing complete unifications with respe(:t to the ()riginal grammar productions if so desired, q_'hus the finite-state approximation provides an eflMent way of determining if an analysis of a given input string with respect to a unification grammar G exists, and if so, it can be used to suggest such analyses. Conclusion This paper surveyed the issues arising in tile construction of finite-state approximations of left-corner parsers. The different kinds of parsers were presented as grammar transforms, which let us abstract away from the algorithmic details of parsing algorithms themselves. It; derived the various forms of the left-corner parsing algorithms in terms of grammar transfbrmations fi'om the original left-corner grmmnar transform.",
    "abstract": "This paper describes how to construct a finite-state machine (FSM) approximating a 'unification-based' grammar using a left-corner grammar transform. The approximation is presented as a series of grammar transforms, and is exact for leftqinear and rightlinear CFGs, and for trees up to a user-specified depth of center-embedding. 1",
    "countries": [
        "United States"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "11",
    "year": "1998",
    "month": "",
    "title": "Finite-state Approximation of Constraint-based Grammars using Left-corner Grammar Transforms"
}