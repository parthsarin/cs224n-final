{
    "article": "String transformation, which maps a source string s into its desirable form t * , is related to various applications including stemming, lemmatization, and spelling correction. The essential and important step for string transformation is to generate candidates to which the given string s is likely to be transformed. This paper presents a discriminative approach for generating candidate strings. We use substring substitution rules as features and score them using an L 1 -regularized logistic regression model. We also propose a procedure to generate negative instances that affect the decision boundary of the model. The advantage of this approach is that candidate strings can be enumerated by an efficient algorithm because the processes of string transformation are tractable in the model. We demonstrate the remarkable performance of the proposed method in normalizing inflected words and spelling variations. Introduction String transformation maps a source string s into its destination string t * . In the broad sense, string transformation can include labeling tasks such as partof-speech tagging and shallow parsing (Brill, 1995) . However, this study addresses string transformation in its narrow sense, in which a part of a source string is rewritten with a substring. Typical applications of this task include stemming, lemmatization, spelling correction (Brill and Moore, 2000; Wilbur et al., 2006; Carlson and Fette, 2007) , OCR error correction (Kolak and Resnik, 2002) , approximate string matching (Navarro, 2001) , and duplicate record detection (Bilenko and Mooney, 2003) . Recent studies have formalized the task in the discriminative framework (Ahmad and Kondrak, 2005; Li et al., 2006; Chen et al., 2007) , t * = argmax t\u2208gen(s) P (t|s). (1) Here, the candidate generator gen(s) enumerates candidates of destination (correct) strings, and the scorer P (t|s) denotes the conditional probability of the string t for the given s. The scorer was modeled by a noisy-channel model (Shannon, 1948; Brill and Moore, 2000; Ahmad and Kondrak, 2005) and maximum entropy framework (Berger et al., 1996; Li et al., 2006; Chen et al., 2007) . The candidate generator gen(s) also affects the accuracy of the string transformation. Previous studies of spelling correction mostly defined gen(s), gen(s) = {t | dist(s, t) < \u03b4}. (2) Here, the function dist(s, t) denotes the weighted Levenshtein distance (Levenshtein, 1966) between strings s and t. Furthermore, the threshold \u03b4 requires the distance between the source string s and a candidate string t to be less than \u03b4. The choice of dist(s, t) and \u03b4 involves a tradeoff between the precision, recall, and training/tagging speed of the scorer. A less restrictive design of these factors broadens the search space, but it also increases the number of confusing candidates, amount of feature space, and computational cost for the scorer. Moreover, the choice is highly dependent on the target task. It might be sufficient for a spelling correction program to gather candidates from known words, but a stemmer must handle unseen words appropriately. The number of candidates can be huge when we consider transformations from and to unseen strings. This paper addresses these challenges by exploring the discriminative training of candidate generators. More specifically, we build a binary classifier that, when given a source string s, decides whether a candidate t should be included in the candidate set or not. This approach appears straightforward, but it must resolve two practical issues. First, the task of the classifier is not only to make a binary decision for the two strings s and t, but also to enumerate a set of positive strings for the string s, gen(s) = {t | predict(s, t) = 1}. (3) In other words, an efficient algorithm is necessary to find a set of strings with which the classifier predict(s, t) yields positive labels for the string s. Another issue arises when we prepare a training set. A discriminative model requires a training set in which each instance (pair of strings) is annotated with a positive or negative label. Even though some existing resources (e.g., inflection table and query log) are available for positive instances, such resources rarely contain negative instances. Therefore, we must generate negative instances that are effective for discriminative training. To address the first issue, we design features that express transformations from a source string s to its destination string t. Feature selection and weighting are performed using an L 1 -regularized logistic regression model, which can find a sparse solution to the classification model. We also present an algorithm that utilizes the feature weights to enumerate candidates of destination strings efficiently. We deal with the second issue by generating negative instances from unlabeled instances. We describe a procedure to choose negative instances that affect the decision boundary of the classifier. This paper is organized as follows. Section 2 formalizes the task of the candidate generator as a binary classification modeled by logistic regression. Features for the classifier are designed using the rules of substring substitution. Therefore, we can obtain, efficiently, candidates of destination strings and negative instances for training. Section 3 reports the remarkable performance of the proposed method in various applications including lemmatization, spelling normalization, and noun derivation. We briefly review previous work in Section 4, and conclude this paper in Section 5. Candidate generator Candidate classification model In this section, we first introduce a binary classifier that yields a label y \u2208 {0, 1} indicating whether a candidate t should be included in the candidate set (1) or not (0), given a source string s. We express the conditional probability P (y|s, t) using a logistic regression model, P (1|s, t) = 1 1 + exp (\u2212\u039b T F (s, t)) , (4) P (0|s, t) = 1 \u2212 P (1|s, t). (5) In these equations, F = {f 1 , ..., f K } denotes a vector of the Boolean feature functions; K is the number of feature functions; and \u039b = {\u03bb 1 , ..., \u03bb K } presents a weight vector of the feature functions. We obtain the following decision rule to choose the most probable label y * for a given pair s, t , y * = argmax y\u2208{0,1} P (y|s, t) = 1 \u039b T F (s, t) > 0 0 (otherwise) . (6) Finally, given a source string s, the generator function gen(s) is defined to collect all strings to which the classifier assigns positive labels: gen(s) = {t | P (1|s, t) > P (0|s, t)} = {t | \u039b T F (s, t) > 0}. (7) Substitution rules as features The binary classifier can include any arbitrary feature. This is exemplified by the Levenshtein distance and distributional similarity (Lee, 1999) between two strings s and t. These features can improve the classification accuracy, but it is unrealistic to compute these features for every possible string, as in equation 7. For that reason, we specifically examine substitution rules, with which the process (1) (2) (3) Figure 1 : Generating substitution rules. of transforming a source string s into its destination form t is tractable. In this study, we assume that every string has a prefix '\u02c6' and postfix '$', which indicate the head and tail of a string. A substitution rule r = (\u03b1, \u03b2) replaces every occurrence of the substring \u03b1 in a source string into the substring \u03b2. Assuming that a string s can be transformed into another string t with a single substitution operation, substitution rules express the different portion between strings s and t. Equation 8 defines a binary feature function with a substitution rule between two strings s and t, f k (s, t) = 1 (rule r k can convert s into t) 0 (otherwise) . (8) We allow multiple substitution rules for a given pair of strings. For instance, substitution rules ('a', ''), ('na', 'n'), ('ae', 'e'), ('nae', 'ne'), etc. form feature functions that yield 1 for strings s = '\u02c6anaemia$' and t = '\u02c6anemia$'. Equation 6 produces a decision based on the sum of feature weights, or scores of substitution rules, representing the different portions between s and t. Substitution rules for the given two strings s and t are obtained as follows. Let l denote the longest common prefix between strings s and t, and r the longest common postfix. We define c s as the substring in s that is not covered by the longest common prefix l and postfix r, and define c t for t analogously. In other words, strings s and t are divided into three regions, lc s r and lc t r, respectively. For strings s = '\u02c6anaemia$' and t = '\u02c6anemia$' in Figure 1 (2), we obtain c s = 'a' and c t = '' because l = '\u02c6an' and r = 'emia$'. Because substrings c s and c t express different portions between strings s and t, we obtain the mini-mum substitution rule (c s , c t ), which can convert the string s into t by replacing substrings c s in s with c t ; the minimum substitution rule for the same example is ('a', ''). However, replacing letters 'a' in '\u02c6anaemia$' into empty letters does not produce the correct string '\u02c6anemia$' but '\u02c6nemi$'. Furthermore, the rule might be inappropriate for expressing string transformation because it always removes the letter 'a' from every string. Therefore, we also obtain expanded substitution rules, which insert postfixes of l to the head of minimum substitution rules, and/or append prefixes of r to the rules. For example, we find an expanded substitution rule ('na', 'n'), by inserting a postfix of l = '\u02c6an' to the head of the minimum substitution rule ('a', ''); similarly, we obtain an expanded substitution rule ('ae', 'e'), by appending a prefix of r = 'emia$' to the tail of the rule ('a', ''). Figure 1 displays examples of substitution rules (the right side) for three pairs of strings (the left side). Letters in blue, green, and red respectively represent the longest common prefixes, longest common postfixes, and different portions. In this study, we expand substitution rules such that the number of letters in rules is does not pass a threshold \u03b8 1 . Parameter estimation Given a training set that consists of N instances, D = (s (1) , t (1) , y (1) ), ..., (s (N ) , t (N ) , y (N ) ) , we optimize the feature weights in the logistic regression model by maximizing the log-likelihood of the conditional probability distribution, L \u039b = N i=1 log P (y (i) |s (i) , t (i) ). (9) The partial derivative of the log-likelihood with respect to a feature weight \u03bb k is given as equation 10, \u2202L \u039b \u2202\u03bb k = N i=1 y (i) \u2212 P (1|s (i) , t (i) ) f k (s (i) , t (i) ). (10) The maximum likelihood estimation (MLE) is known to suffer from overfitting the training set. The common approach for addressing this issue is to use the maximum a posteriori (MAP) estimation, introducing a regularization term of the feature weights \u039b, i.e., a penalty on large feature weights. In addition, the generation algorithm of substitution rules might produce inappropriate rules that transform a string incorrectly, or overly specific rules that are used scarcely. Removing unnecessary substitution rules not only speeds up the classifier but also the algorithm for candidate generation, as presented in Section 2.4. In recent years, L 1 regularization has received increasing attention because it produces a sparse solution of feature weights in which numerous feature weights are zero (Tibshirani, 1996; Ng, 2004) . Therefore, we regularize the log-likelihood with the L 1 norm of the weight vector \u039b and define the final form the objective function to be minimized as E \u039b = \u2212L \u039b + |\u039b| \u03c3 . (11) Here, \u03c3 is a parameter to control the effect of L 1 regularization; the smaller the value we set to \u03c3, the more features the MAP estimation assigns zero weights to: it removes a number of features from the model. Equation 11 is minimized using the Orthant-Wise Limited-memory Quasi-Newton (OW-LQN) method (Andrew and Gao, 2007) because the second term of equation 11 is not differentiable at \u03bb k = 0. Candidate generation The advantage of our feature design is that we can enumerate strings to which the classifier is likely to assign positive labels. We start by observing the necessary condition for t in equation 7, \u039b T F (s, t) > 0 \u21d2 \u2203k : f k (s, t) = 1 \u2227 \u03bb k > 0. ( 12 ) The classifier might assign a positive label to strings s and t when at least one feature function whose weight is positive can transform s to t. Let R + be a set of substitution rules to which MAP estimation has assigned positive feature weights. Because each feature corresponds to a substitution rule, we can obtain gen(s) for a given string s by application of every substitution rule r \u2208 R + , gen(s) = {r(s) | r \u2208 R + \u2227 \u039b T F (s, r(s)) > 0}. ( 13 ) Input: s = (s 1 , ..., s l ): an input string s (series of letters) Input: D: a trie dictionary containing positive features Output: T : gen(s) Algorithm 1: A pseudo-code for gen(s). T = {}; 1 U = {}; 2 foreach i \u2208 (1, ..., |s|) do 3 F \u2190 D.prefix search(s, i); 4 foreach f \u2208 F do 5 if f / \u2208 U then 6 t \u2190 f . Here, r(s) presents the string to which the substitution rule r transforms the source string s. We can compute gen(s) with a small computational cost if the MAP estimation with L 1 regularization reduces the number of active features. Algorithm 1 represents a pseudo-code for obtaining gen(s). To search for positive substitution rules efficiently, the code stores a set of rules in a trie structure. In line 4, the code obtains a set of positive substitution rules F that can rewrite substrings starting at offset #i in the source string s. For each rule f \u2208 F , we obtain a candidate string t by application of the substitution rule f to the source string s (line 7). The candidate string t is qualified to be included in gen(s) when the classifier assigns a positive label to strings s and t (lines 8 and 9). Lines 6 and 11 prevent the algorithm from repeating evaluation of the same substitution rule. Generating negative instances The parameter estimation requires a training set D in which each instance (pair of strings) is annotated with a positive or negative label. Negative instances (counter examples) are essential for penalizing inappropriate substitution rules, e.g. ('a', ''). Even though some existing resources (e.g. verb inflection table) are available for positive instances, such resources rarely contain negative instances. A common approach for handling this situation is to assume that every pair of strings in a resource Input: D + = [(s 1 , t 1 ), ..., (s l , t l )]: positive instances Input: V : a suffix array of all strings (vocabulary) Output: D \u2212 : negative instances Output: R: substitution rules (features) Algorithm 2: Generating negative instances. is a negative instance; however, negative instances amount to ca. V (V \u2212 1)/2, where V represents the total number of strings. Moreover, substitution rules expressing negative instances are innumerable and sparse because the different portions are peculiar to individual negative instances. For instance, the minimum substitution rule for unrelated words anaemia and around is ('naemia', 'round'), but the rule cannot be too specific to generalize the conditions for other negative instances. D \u2212 = []; 1 R = {}; 2 foreach d \u2208 D + do 3 foreach In this study, we generate negative instances so that they can penalize inappropriate rules and settle the decision boundary of the classifier. This strategy is summarized as follows. We consider every pair of strings as candidates for negative instances. We obtain substitution rules for the pair using the same algorithm as that described in Section 2.2 if a string pair is not included in the dictionary (i.e., not in positive instances). The pair is used as a negative instance only when any substitution rule generated from the pair also exists in the substitution rules generated from positive instances. Algorithm 2 presents the pseudo-code that implements the strategy for generating negative instances efficiently. First, we presume that we have positive instances D + = [(s 1 , t 1 ), ..., (s l , t l )] and unlabeled strings V . For example, positive instance D + represent orthographic variants, and unlabeled strings V include all possible words (vocabulary). We insert the vocabulary into a suffix array, which is used to locate every occurrence of substrings in V . The algorithm first generates substitution rules R only from positive instances D + (lines 3 to 7). For each substitution rule r \u2208 R, we enumerate known strings S that contain the source substring r.src (line 9). We apply the substitution rule to each string s \u2208 S and obtain its destination string t (line 11). If the pair of strings s, t is not included in D + (line 12), and if the destination string t is known (line 13), the substitution rule r might associate incorrect strings s and t, which do not exist in D + . Therefore, we insert the pair to the negative set D \u2212 (line 14). Evaluation Experiments We evaluated the candidate generator using three different tasks: normalization of orthographic variants, noun derivation, and lemmatization. The datasets for these tasks were obtained from the UMLS SPECIALIST Lexicon 2 , a large lexicon that includes both commonly occurring English words and biomedical vocabulary. Table 1 displays the list of tables in the SPECIALIST Lexicon that were used in our experiments. We prepared three datasets, Orthography, Derivation, and Inflection. The Orthography dataset includes spelling variants (e.g., color and colour) in the LRSPL table. We chose entries as positive instances in which spelling variants are caused by (case-insensitive) alphanumeric changes 3 . The Derivation dataset was built directly from the LRNOM table, which includes noun derivations such as abandon \u2192 abandonment. The LRAGR table includes base forms and their inflectional variants of nouns (singular and plural forms), verbs (infinitive, third singular, past, past participle forms, etc), and adjectives/adverbs (positive, comparative, and superlative forms). For the Inflection dataset, we extracted the entries in which inflectional forms differ from their base forms 4 , e.g., study \u2192 studies. For each dataset, we applied the algorithm described in Section 2.5 to generate substitution rules and negative instances. Table 2 shows the number of positive instances (# +), negative instances (# -), and substitution rules (# Rules). We evaluated the performance of the proposed method in two different goals of the tasks: classification (Section 3.2) and normalization (Section 3.3). Experiment 1: Candidate classification In this experiment, we measured the performance of the classification task in which pairs of strings were assigned with positive or negative labels. We trained and evaluated the proposed method by performing ten-fold cross validation on each dataset 5 . Eight baseline systems were prepared for comparison: Levenshtein distance (LD), normalized Levenshtein distance (NLD), Dice coefficient on letter bigrams (DICE) (Adamson and Boreham, 1974) , Longest Common Substring Ratio (LCSR) (Melamed, 1999) , Longest Common Prefix Ratio (PREFIX) (Kondrak, 2005 ), Porter's stemmer (Porter, 1980) , Morpha (Minnen et al., 2001) , and CST's lemmatiser (Dalianis and Jonge-3 LRSPL table includes trivial spelling variants that can be handled using simple character/string operations. For example, the table contains spelling variants related to case sensitivity (e.g., deg and Deg) and symbols (e.g., Feb and Feb.). 4 LRAGR table also provides agreement information even when word forms do not change. For example, the table contains an entry indicating that the first-singular present form of the verb study is study, which might be readily apparent to English speakers. 5 We determined the regularization parameter \u03c3 = 5 experimentally. Refer to Figure 2 for the performance change. jan, 2006) 6 . The five systems LD, NLD, DICE, LCSR, and PREFIX employ corresponding metrics of string distance or similarity. Each system assigns a positive label to a given pair of strings s, t if the distance/similarity of strings s and t is smaller/larger than the threshold \u03b4 (refer to equation 2 for distance metrics). The threshold of each system was chosen so that the system achieves the best F1 score. The remaining three systems assign a positive label only if the system transforms the strings s and t into the identical string. For example, a pair of two words studies and study is classified as positive by Porter's stemmer, which yields the identical stem studi for these words. We trained CST's lemmatiser for each dataset to obtain flex patterns that are used for normalizing word inflections. To examine the performance of the L 1regularized logistic regression as a discriminative model, we also built two classifiers based on the Support Vector Machine (SVM). These SVM classifiers were implemented by the SVM perf 7 on a linear kernel 8 . An SVM classifier employs the same feature set (substitution rules) as the proposed method so that we can directly compare the L 1regularized logistic regression and the linear-kernel SVM. Another SVM classifier incorporates the five string metrics; this system can be considered as our reproduction of the discriminative string similarity proposed by Bergsma and Kondrak (2007) . Table 3 reports the precision (P), recall (R), and F1 score (F1) based on the number of correct decisions for positive instances. The proposed method outperformed the baseline systems, achieving 0.919, 0.888, and 0.984 of F1 scores, respectively. Porter's stemmer worked on the Inflection set, but not on the Orthography set, which is beyond the scope of the stemming algorithms. CST's lemmatizer suffered from low recall on the Inflection set because it removed suffixes of base forms, e.g., (cloning, clone) \u2192 (clone, clo). Morpha and CST's lemma- (Porter, 1980) . 084 .074 .079 .197 .846 .320 .926 .839 .881 Morpha (Minnen et al., 2001) .009 .007 .008 .012 .022 .016 .979 .836 .902 CST's lemmatiser (Dalianis et al. 2006) .119 .008 .016 .383 .682 .491 .821 .176 Levenshtein distance (\u03b4 = 1) did not work for the Derivation set because noun derivations often append two or more letters (e.g., happy \u2192 happiness). No string similarity/distance metrics yielded satisfactory results. Some metrics obtained the best F1 scores with extreme thresholds only to classify every instance as positive. These results imply the difficulty of the string metrics for the tasks. The L 1 -regularized logistic regression was comparable to the SVM with linear kernel in this experiment. However, the presented model presents the advantage that it can reduce the number of active features (features with non-zero weights assigned); the L 1 regularization can remove 74%, 48%, and 82% of substitution rules in each dataset. The performance improvements by incorporating string metrics as features were very subtle (less than 0.7%). What is worse, the distance/similarity metrics do not specifically derive destination strings to which the classifier is likely to assign positive labels. Therefore, we can no longer use the efficient algorithm as a candidate generator (in Section 2.4) with these features. Table 4 demonstrates the ability of our approach to obtain effective features; the table shows the top 10 features with high weights assigned for the Orthography data. An interesting aspect of the proposed method is that the process of the orthographic variants is interpretable through the feature weights. Figure 2 shows plots of the F1 scores (y-axis) for the Inflection data when we change the number of active features (x-axis) by controlling the regularization parameter \u03c3 from 0.001 to 100. The larger the value we set for \u03c3, the better the classifier performs, generally, with more active features. In extreme cases, the number of active features drops to 97 with \u03c3 = 0.01; nonetheless, the classifier still achieves 0.961 of the F1 score. The result suggests that a small set of substitution rules can accommodate most cases of inflectional variations. Experiment 2: String transformation The second experiment examined the performance of the string normalization tasks formalized in equation 1. In this task, a system was given a string s and was required to yield either its transformed form t * (s = t * ) or the string s itself when the transformation is unnecessary for s. . 078 .012 .021 .233 .016 .029 .435 .682 .531 .830 .587 .688 CST's lemmatiser .135 .160 .146 .378 .732 .499 .367 .762 .495 .584 .589 .587 Proposed method .859 .823 .841 .979 .981 .980 .973 .979 .976 .837 .816 .827 by the maximum entropy framework. Features for the maximum entropy model consist of: substitution rules between strings s and t, letter bigrams and trigrams in s, and letter bigrams and trigrams in t. We prepared four datasets, Derivation, Inflection, and XTAG morphology. Each dataset is a list of string pairs s, t that indicate the transformation of the string s into t. A source string s is identical to its destination string t when string s should not be changed. These instances correspond to the case where string s has already been lemmatized. For each string pair (s, t) in LR-SPL 9 , LRNOM, and LRAGR tables, we generated two instances s, t and t, t . Consequently, a system is expected to leave the string t unchanged. We also used XTAG morphology 10 to perform a crossdomain evaluation of the lemmatizer trained on the Inflection dataset 11 . The entries in XTAG morphol-9 We define that s precedes t in dictionary order. 10 XTAG morphology database 1.5: ftp://ftp.cis.upenn.edu/pub/xtag/morph-1. 5/morph-1.5.tar.gz 11 We found that XTAG morphology contains numerous in-ogy that also appear in the Inflection dataset were 39,130 out of 317,322 (12.3 %). We evaluated the proposed method and CST's lemmatizer by performing ten-fold cross validation. Table 5 reports the performance based on the number of correct transformations. The proposed method again outperformed the baseline systems with a wide margin. It is noteworthy that the proposed method can accommodate morphological inflections in the XTAG morphology corpus with no manual tuning or adaptation. Although we introduced no assumptions about target tasks (e.g. a known vocabulary), the average number of positive substitution rules relevant to source strings was as small as 23.9 (in XTAG morphology data). Therefore, the candidate generator performed 23.9 substitution operations for a given string. It applied the decision rules (equation 7) 21.3 times, and generated 1.67 candidate strings per source string. The experimental results described herein demonstrated that the candidate generator was modeled successfully by the discriminative framework. Related work The task of string transformation has a long history in natural language processing and information retrieval. As described in Section 1, this task is related closely to various applications. Therefore, we specifically examine several prior studies that are relevant to this paper in terms of technical aspects. Some researchers have reported the effectiveness of the discriminative framework of string similarity. MaCallum et al. (2005) proposed a method to train the costs of edit operations using Conditional Random Fields (CRFs). Bergsma and Kondrak (2007) correct comparative and superlative adjectives, e.g., unpopular \u2192 unpopularer \u2192 unpopularest and refundable \u2192 refundabler \u2192 refundablest. Therefore, we removed inflection entries for comparative and superlative adjectives from the dataset. presented an alignment-based discriminative string similarity. They extracted features from substring pairs that are consistent to a character-based alignment of two strings. Aramaki et al. (2008) also used features that express the different segments of the two strings. However, these studies are not suited for a candidate generator because the processes of string transformations are intractable in their discriminative models. Dalianis and Jongejan (2006) presented a lemmatiser based on suffix rules. Although they proposed a method to obtain suffix rules from a training data, the method did not use counter-examples (negatives) for reducing incorrect string transformations. Tsuruoka et al. (2008) proposed a scoring method for discovering a list of normalization rules for dictionary look-ups. However, their objective was to transform given strings, so that strings (e.g., studies and study) referring to the same concept in the dictionary are mapped into the same string (e.g., stud); in contrast, this study maps strings into their destination strings that were specified by the training data. Conclusion We have presented a discriminative approach for generating candidates for string transformation. Unlike conventional spelling-correction tasks, this study did not assume a fixed set of destination strings (e.g. correct words), but could even generate unseen candidate strings. We used an L 1 -regularized logistic regression model with substring-substitution features so that candidate strings for a given string can be enumerated using the efficient algorithm. The results of experiments described herein showed remarkable improvements and usefulness of the proposed approach in three tasks: normalization of orthographic variants, noun derivation, and lemmatization. The method presented in this paper allows only one region of change in string transformation. A natural extension of this study is to handle multiple regions of changes for morphologically rich languages (e.g. German) and to handle changes at the phrase/term level (e.g., \"estrogen receptor\" and \"receptor of oestrogen\"). Another direction would be to incorporate the methodologies for semisupervised machine learning to accommodate situa-tions in which positive instances and/or unlabeled strings are insufficient. Acknowledgments This work was partially supported by Grants-in-Aid for Scientific Research on Priority Areas (MEXT, Japan), and for Solution-Oriented Research for Science and Technology (JST, Japan).",
    "abstract": "String transformation, which maps a source string s into its desirable form t * , is related to various applications including stemming, lemmatization, and spelling correction. The essential and important step for string transformation is to generate candidates to which the given string s is likely to be transformed. This paper presents a discriminative approach for generating candidate strings. We use substring substitution rules as features and score them using an L 1 -regularized logistic regression model. We also propose a procedure to generate negative instances that affect the decision boundary of the model. The advantage of this approach is that candidate strings can be enumerated by an efficient algorithm because the processes of string transformation are tractable in the model. We demonstrate the remarkable performance of the proposed method in normalizing inflected words and spelling variations.",
    "countries": [
        "Japan",
        "United Kingdom"
    ],
    "languages": [
        "English",
        "German"
    ],
    "numcitedby": "42",
    "year": "2008",
    "month": "October",
    "title": "A Discriminative Candidate Generator for String Transformations"
}