{
    "article": "When constructing models that learn from noisy labels produced by multiple annotators, it is important to accurately estimate the reliability of annotators. Annotators may provide labels of inconsistent quality due to their varying expertise and reliability in a domain. Previous studies have mostly focused on estimating each annotator's overall reliability on the entire annotation task. However, in practice, the reliability of an annotator may depend on each specific instance. Only a limited number of studies have investigated modelling perinstance reliability and these only considered binary labels. In this paper, we propose an unsupervised model which can handle both binary and multi-class labels. It can automatically estimate the per-instance reliability of each annotator and the correct label for each instance. We specify our model as a probabilistic model which incorporates neural networks to model the dependency between latent variables and instances. For evaluation, the proposed method is applied to both synthetic and real data, including two labelling tasks: text classification and textual entailment. Experimental results demonstrate our novel method can not only accurately estimate the reliability of annotators across different instances, but also achieve superior performance in predicting the correct labels and detecting the least reliable annotators compared to stateof-the-art baselines. 1 Introduction In many natural language processing (NLP) applications, the performance of supervised machine learning models depends on the quality of the corpus used to train the model. Traditionally, labels are collected from multiple annotators/experts 1 Code is available at https://github.com/ createmomo/instance-level-reliability who are assumed to provide reliable labels. However, in reality, these experts may have varying levels of expertise depending on the domains, and thus may disagree on labelling in certain cases (Aroyo and Welty, 2013) . A rapid and costeffective alternative is to obtain labels through crowdsourcing (Snow et al., 2008; Poesio et al., 2013 Poesio et al., , 2017)) . In crowdsourcing, each instance is presented to multiple expert or non-expert annotators for labelling. However, labels collected in this manner could be noisy, since some annotators could produce a significant number of incorrect labels. This may be due to differing levels of expertise, lack of financial incentive and interest (Poesio et al., 2017) , as well as the tedious and repetitive nature of the annotation task (Raykar et al., 2010; Bonald and Combes, 2017) . Thus, in order to ensure the accuracy of the labelling and the quality of the corpus, it is crucial to estimate the reliability of the annotators automatically without human intervention. Previous studies have mostly focused on evaluating the annotators' overall reliability (Gurevych and Kim, 2013; Sheshadri and Lease, 2013; Poesio et al., 2017) . Measuring the reliability on a per-instance basis is however useful as we may expect certain annotators to have more expertise in one domain than another, and as a consequence certain annotation decisions will be more difficult than others. This resolves a potential issue of models that only assign an overall reliability to each annotator, where such a model would determine an annotator with expertise in a single domain to be unreliable for the model, even though the annotations are reliable within the annotator's domain of expertise. Estimating per-instance reliability is also helpful for unreliable annotator detection and task allocation in crowdsourcing, where the cost of labelling data is reduced using proactive learn-ing strategies for pairing instances with the most cost-effective annotators (Donmez and Carbonell, 2008; Li et al., 2017) . Although reliability estimation has been studied for a long time, only a limited number of studies have examined how to model the reliability of each annotator on a perinstance basis. Additionally, these in turn have only considered binary labels (Yan et al., 2010 (Yan et al., , 2014;; Wang and Bi, 2017) , and cannot be extended to multi-class classification in a straightforward manner. In order to handle both binary and multi-class labels, our approach extends one of the most popular probabilistic models for label aggregation, proposed by Hovy et al. (2013) . One challenge of extending the model is the definition of the label and reliability probability distributions on a perinstance basis. Our approach introduces a classifier which predicts the correct label of an instance, and a reliability estimator, providing the probability that an annotator will label a given instance correctly. The approach allows us to simultaneously estimate the per-instance reliability of the annotators and the correct labels, allowing the two processes to inform each other. Another challenge is to select appropriate training methods to learn a model with high and stable performance. We investigate training our model using the EM algorithm and cross entropy. For evaluation, we apply our method to six datasets including both synthetic and real-world datasets (see Section 4.1). In addition, we also investigate the effect on the performance when using different text representation methods and text classification models (see Section 4.2). Our contributions are as follows: firstly, we propose a novel probabilistic model for the simultaneous estimation of per-instance annotator reliability and the correct labels for natural language labelling tasks. Secondly, our work is the first to propose a model for modelling per-instance reliability for both binary and multi-class classification tasks. Thirdly, we show experimentally how our method can be applied to different domains and tasks by evaluating it on both synthetic and realworld datasets. We demonstrate that our method is able to capture the reliability of each annotator on a per-instance basis, and that this in turn helps improve the performance when predicting the underlying label for each instance and detecting the least reliable annotators. Related Work Modelling Annotator Reliability Probabilistic graphical models have been widely used for inferring the overall reliability of annotators in the absence of ground truth labels. Approaches include modelling a single overall reliability score for each annotator (Whitehill et al., 2009; Welinder et al., 2010; Karger et al., 2011; Liu et al., 2012; Demartini et al., 2012; Hovy et al., 2013; Rodrigues et al., 2014; Li et al., 2014a,b) , estimating the reliability of each annotator on a per-category basis (Dawid and Skene, 1979; Zhou et al., 2012; Kim and Ghahramani, 2012; Zhang et al., 2014) , and estimating the sensitivity and specificity for each annotator in binary classification tasks (Raykar et al., 2010) . Fewer attempts have been made to model the per-instance reliability of annotators, focusing mainly on medical image classification. One approach is that by Yan et al. (2010; 2014) who use logistic regression to predict the per-instance reliability of annotators. Wang and Bi (2017) used a modified support vector machine (SVM; Cortes and Vapnik 1995) loss, modelling the per-instance reliability as the distance from the given instance to a separation boundary. True Label Prediction in Crowdsourcing True label prediction in crowdsourcing is the aggregation of labels produced by different annotators to infer the correct label of each instance. Majority voting assigns to each instance the most commonly occurring label among the annotators, which can result in a high agreement between the predicted label and the ground truth for some NLP tasks (Snow et al., 2008) . Dawid and Skene (1979), Whitehill et al. (2009 ), Raykar et al. (2010) , Welinder et al. (2010) , Liu et al. (2012) , Zhou et al. (2012) , Kim and Ghahramani (2012) , Hovy et al. (2013) , Yan et al. (2010; 2014) , Li et al. (2014b) and Zhang et al. (2014) investigated binary or multi-class label prediction using probabilistic graphical models. Karger et al. (2011) , Wang and Bi (2017) , and Bonald and Combes (2017) formalised the label prediction as an optimisation problem. Rodrigues et al. (2014) and Nguyen et al. (2017) investigated how to aggregate sequence labels using probabilistic graphical models. a ij t i r ij M N Figure 1: Graphical model. for i = 1 to N ti \u223c Categorical(ft(xi)) for j = 1 to M rij \u223c Bernoulli(fr(xi, j)) aij \u223c Uniform(T ) rij = 0 \u03b4t i rij = 1 Figure 2: Generative process for our method. f t is the classifier, returning a probability distribution over predicted labels, and f r is the reliability estimator, returning the probability that the annotator is accurate for the instance. Uniform(T ) is a uniform distribution over the categories in T . \u03b4 ti is the deterministic distribution that only takes on the value t i . 3 Methodology Model In the description of our model we let N be the number of training instances, M the number of annotators, x i the ith training instance, t i its true underlying label, T the set of values t i can take on, r ij whether annotator j is reliable for the ith instance, and a ij the label that annotator j gave the ith instance. Below we describe the components of the model in more detail. Probabilistic Model: Our model is inspired by the method proposed by Hovy et al. (2013) , and it shares the same graphical representation (see Figure 1 ). The distributions of the model, however, are defined differently, as can be seen in Figure 2 , due to the inclusion of a classifier and a reliability estimator. We assume that the underlying label t i depends only on the corresponding instance, while the reliability r ij depends on the instance and the identity of the annotator. If r ij = 0, then the annotator j is unreliable for instance x i , and a label is chosen randomly from among the available categories. Otherwise, the annotation a ij is set to be the correct label. Classifier: The classifier f t (x i ) provides the predicted probabilities of an instance belonging to each category, p(t i | x i ). t i is the underlying label for instance x i , the ith instance, and takes a value in the set of categories T . Note that there is no restriction on what classifier is used, other than that it can be trained using expectation maximisation. The inclusion of a classifier directly in the model means that it can be trained while taking into account the uncertainty of the data and predictions, as opposed to first making a hard assignment of a label for each instance and training the classifier post-hoc. Reliability Estimator: The reliability estimator f r (x i , j) predicts the probability of annotator j producing the correct label for instance x i , p(r ij | x i ). r ij is a binary variable, with 1 and 0 representing annotator j being reliable and unreliable for instance x i , respectively. The reliability estimator is modelled as a feed-forward neural network, where j is encoded as a one-hot vector. The exact representation of x i depends on the model used for the classifier. If the classifier is a neural network, the output of the last hidden layer is used; otherwise, the original feature vector is used. Learning Pre-training As the number of parameters in our model is much larger than that of previous studies (Yan et al., 2010 (Yan et al., , 2014;; Wang and Bi, 2017) due to the introduction of both a classifier and a reliability estimator, the model is much harder to train from scratch. Therefore, before we start training the model, we first pre-train the classifier using labels predicted by a simpler method as targets, using e.g. majority voting or the method proposed by Dawid and Skene (1979) . Although these labels may be noisy, we have observed empirically that a better initialisation strategy does result in better performance (see Section 5). For the reliability estimator, for each instance x i we compare each annotation a ij to the labels predicted in the previous step. If a ij is the same as the predicted label, we take the corresponding r ij to be 1, and 0 otherwise. We then pretrain the reliability estimator f r to predict these values for r. EM Training We first consider training our model using expectation maximisation (EM; Dempster et al. 1977) . This involves maximising the expectation of the complete log likelihood of the model with respect to the posterior of the latent variables in the model. For the posterior of the model, we fix the parameters of the model and denote them \u03b8 (k) at iteration k of the algorithm. We only maximise the expectation with respect to the parameters \u03b8 of the complete log likelihood. The expectation is calculated as: Q(\u03b8 | \u03b8 (k) ) = E[log p(a, t, r | x, \u03b8)] = N i=1 E [log p(ti | xi, \u03b8)] + N i=1 M j=1 E [log p(rij | xi, \u03b8)] + N i=1 M j=1 E [log p(aij | ti, rij, xi, \u03b8)] , (1) where each expectation is calculated with respect to the posterior p(t, r | a, x, \u03b8 (k) ). E Step: For the E step we compute the posterior with fixed parameters \u03b8 (k) , \u03c0 ij (t, r) = p(t i = t, r ij = r | a i , x i ), as: \u03c0ij(t, r) = p(ti = t, rij = r | ai, xi) \u221d p(ti = t | xi)p(rij = r | xi) \u2022 p(aij | ti = t, rij = r, xi) \u2022 j =j \u03b3 (k) ij (t) (2) \u03b3 k ij (t) = r \u2208{0,1} p(rij = r | xi) \u2022 p(aij | ti = t, rij = r , xi) , (3) where we drop the dependency on \u03b8 (k) for brevity. Note that \u03c0 ij (t, r) = 0 when r = 1 and a ij = t. We can then compute the marginalised posteriors, needed for Equation (1), as follows: p(ti = t | ai, xi) = r\u2208{0,1} \u03c0 i1 (t, r) (4) p(rij = r | ai, xi) = t\u2208T \u03c0 ij (t, r), (5) where the posterior p(t i , r i1 | a i , x i ) of the model is chosen arbitrarily to marginalise over to get the posterior for t i . M Step: Using the posterior calculated in the E step we can compute the expectation of the complete log likelihood, Q(\u03b8 | \u03b8 (k) ), and calculate its gradient with respect to the parameters \u03b8. We then use gradient ascent to update the classifier and reliability estimator jointly. Algorithm 1 Training procedure Input: a, the annotations x, the instances L, the number of inner iterations m, the training mode: 0 for expectation maximisation, 1 for cross entropy (training alternatingly), 2 for cross entropy (training jointly) 1: Pre-train \u03b8 = {\u03b8t, \u03b8r} (Section 3.2) 2: k \u2190 0 3: while stopping criteria not met do 4: k \u2190 k + 1 5: Calculate \u03c0ij (t, r) (Equation ( 2 )) E step 6: if m = 0 then M step 7: for l = 1 to L 8: \u03b8 \u2190 \u03b8 + \u03b1\u2207 \u03b8 Q(\u03b8 | \u03b8 (k) ) 9: end for 10: else if m = 1 then 11: for l = 1 to L 12: \u03b8r \u2190 \u03b8r \u2212 \u03b1\u2207 \u03b8r L(\u03b8r | \u03b8 (k) ) 13: end for 14: for l = 1 to L 15: \u03b8t \u2190 \u03b8t \u2212 \u03b1\u2207 \u03b8 t L(\u03b8t | \u03b8 (k) ) 16: end for 17: else 18: for l = 1 to L 19: \u03b8 \u2190 \u03b8 \u2212 \u03b1\u2207 \u03b8 L(\u03b8 | \u03b8 (k) ) 20: end for 21: end if 22: end while Cross Entropy Training As an alternative training procedure, we also consider training the model using cross entropy. As with expectation maximisation, we first calculate the posterior \u03c0 ij (t, r) using the fixed parameters \u03b8 (k) . The networks f t and f r are then trained to minimise the cross entropy between the priors p(t i | x i ) and p(r ij | x i ), and the corresponding posteriors p(t i | a i , x i ) and p(r ij | a i , x i ). The networks can be trained in an alternating fashion, with f r being trained while f t is kept fixed, and the other way around. Denoting the parameters of f t as \u03b8 t and f r as \u03b8 r , the loss functions for the respective networks then become L(\u03b8t | \u03b8 (k) ) = \u2212 1 N i,t,r \u03c0i1(t, r) log p(ti | xi) L(\u03b8r | \u03b8 (k) ) = \u2212 1 N M i,j,t,r \u03c0ij(t, r) log p(rij | xi) (6) Alternatively, they can be trained jointly by minimising the total cross entropy. L(\u03b8 | \u03b8 (k) ) = L(\u03b8t | \u03b8 (k) ) + L(\u03b8r | \u03b8 (k) ) (7) The training algorithm is summarised in Algorithm 1. The algorithm is run until either a maximum number of iterations is reached, or the objective function stops improving. Text Classification: For text classification we use the datasets Question Classification (Li and Roth, 2002) , which contains short questions along with the type of answer expected, and Sentence Classification (Chambers, 2013) , which consists of sentences selected from medical publications. Examples of instance/class pairs for the text classification datasets include \"Where is the Orinoco?\" (class: \"location\") for the Question Classification dataset, and \"New types of potent force clamps are discovered.\" (class: \"author's own work\") for the Sentence Classification dataset. For these datasets that do not include crowd annotations, we synthesise annotations by simulating different annotators as follows: 1) Narrow Expert: has expertise in a single domain (i.e. class). For the instances of this class, the annotator will always provide the correct label. For other classes, a correct label will be provided with a probability of 0.65; otherwise, a random label will be selected with uniform probability; 2) Broad Expert: has expertise in every domain and only makes mistakes with a probability of 0.05; 3) Random Annotator: selects labels at random; 4) Adversarial Annotator: deliberately provides incorrect labels with a probability of 0.8. For each of the datasets, we generated annotations using one narrow expert per class, one broad expert, one random annotator and one adversarial annotator, for a total of |T | + 3 annotators, where |T | is the number of classes in the dataset. In order to evaluate the generality of our model, we also apply it to another task in which we have 5 annotators with different overall reliabilities for the text classification tasks. They produce incor- rect labels with probabilities 0.1, 0.3, 0.5, 0.7, 0.9 respectively. Real-World Crowdsourcing Annotators Recognising Textual Entailment: Finally, we evaluate our model on a real-world dataset for the recognising textual entailment (RTE) task (Snow et al., 2008) . Given a text pair, the annotator decides whether the hypothesis sentence can be inferred from the text fragment. The dataset includes both ground truth and crowdsourced labels from 164 annotators. Table 1 shows the number of instances of each class 2 in the above-mentioned datasets. Experimental and Model Settings Our model was implemented using the Chainer deep learning framework 3 (Tokui et al., 2015) . Classifier: As shown in Table 2 , in each experiment the output of the classifier is generated by a feed-forward neural network (FNN). Each FNN consists of an input layer, two hidden layers and a softmax output layer. The number of hidden units in each layer is listed in the third column of the table. The ReLU activation function (Nair and Hinton, 2010) was applied after each hidden layer. The output size of all the Long Short-Term Memory (LSTM; Hochreiter and Schmidhuber, 1997) layers in our experiments is 100. For the 2-dimensional classification task, each instance is simply represented using its position in 2-dimensional space. For the text classification tasks, we investigated 3 methods of representing the sentences: bag-of-words (BoW) weighted by Term Frequency-Inverse Document Frequency (TFIDF), an average word embedding (Avg.) and the output at the last step of an LSTM layer (Embed.\u2192LSTM). For the embedding we use word2vec embeddings pre-trained on Google News (Mikolov et al., 2013) for the question classification and RTE tasks, and a pre-trained embedding (Pyysalo et al., 2013) trained on a combination of English Wikipedia, PubMed and PMC texts for the sentence classification task. For the RTE task, we implemented two classifiers. For the first one, each instance (i.e. a sentence pair) was represented as a concatenation of the average word embedding for each sentence (Cat. Avg.). We also implemented Bowman et al. (2015) , which runs each sentence through an LSTM, concatenates the outputs, and then feeds the concatenated output to an FNN with tanh activations. Reliability Estimator: We model the reliability estimator as an FNN. Its structure is the same as the classifier, albeit with different sizes of the two hidden layers. For the experiments listed in Table 2, the number of units of each hidden layer in the FNN are 5, 100, 25, 25, 50, and 100 respectively. The input to the estimator is the concatenation of the instance x i (i.e. its original feature vector or the output of the last hidden layer of the classifier) and a one-hot vector representing the annotator identity. Learning Settings: For every experiment we use the Adam (Kingma and Ba, 2015) optimiser with a weight decay rate 0.001, a gradient clipping of 5.0, \u03b1 = 0.001, \u03b2 1 = 0.9 and \u03b2 2 = 0.999. We pre-train the classifier and reliability estimator for 200 epochs, using both majority voting and the model proposed by Dawid and Skene (1979) . The maximum number of outer iterations is set to 500 and 20 for EM training and cross entropy training respectively. The number of inner iterations is 50 in both cases. True Label Prediction and Reliability Estimation: After training, for each instance x i we take its underlying label to be the most probable label according to the posterior of t i (see Equation (4)). We compared our predicted labels to the following state-of-the-art baselines: Majority Voting (MV), DS (Dawid and Skene, 1979), GLAD (Whitehill et al., 2009) , LFC (Raykar et al., 2010) , CUBAM (Welinder et al., 2010) , Yan et al. (2010) , KOS (Karger et al., 2011) , VI (Liu et al., 2012) , BCC (Kim and Ghahramani, 2012) , MINIMAX (Zhou et al., 2012) , MACE (Hovy et al., 2013) , CATD (Li et al., 2014a) , PM (Li et al., 2014b) and EM-MV and Opt (Zhang et al., 2014) . Note that CUBAM, Yan et al. (2010) , KOS and VI are only suitable for aggregating binary labels, and Yan et al. ( 2010 ) is the state-of-the-art method that models per-instance reliability. We take the reliability of annotator j on instance x i to be the posterior probability that r ij is 1 (see Equation (5)). Results and Analysis We measure the inter-annotator agreement (IAA) of each dataset. Fleiss's kappa (Fleiss et al., 2013) , denoted by \u03ba, is measured for the 2-dimensional and text classification datasets, and Krippendorff's alpha (Krippendorff, 1970) is calculated for the RTE dataset 4 . We find that the IAA values indicate slight agreement among annotators for all datasets. Our experiments using different settings are shown as follows: our model is denoted by O, with M and D denoting the model pre-trained using MV and DS respectively. E denotes training using expectation maximisation, while C denotes cross entropy training. AL and JT denote cross entropy training done alternatingly and jointly, respectively. In the rest of this section, Tables 3 to 7 and Tables 8 to 10 present the results on the synthetic datasets and RTE dataset respectively. For the synthetic datasets, in Tables 3 to 6 , we first consider a scenario where we have multiple narrow experts (N), one broad expert (B), one random annotator (R) and one adversarial annotator (A). In Table 7 , we further consider a scenario with 5 annotators, 2-Dimensional Datasets moon circle 3-class \u03ba = 0.029 \u03ba = 0.029 \u03ba = 0.153 MV 84.6 84.6 89.0 DS (Dawid and Skene, 1979) 97.8 97.9 99.4 GLAD (Whitehill et al., 2009) 97.9 97.9 93.7 LFC (Raykar et al., 2010) 97.9 97.9 99.4 CUBAM (Welinder et al., 2010) 97.9 97.9 -Yan et al. (Yan et al., 2010) 84.1 84.1 -KOS (Karger et al., 2011) 96.7 96.7 -VI (Liu et al., 2012) 97.9 97.9 -BCC (Kim and Ghahramani, 2012) 97.9 97.9 99.4 MINIMAX (Zhou et al., 2012) 97.9 97.9 99.2 MACE (Hovy et al., 2013) 97.8 97.9 97.0 CATD (Li et al., 2014a) 94.5 94.5 94.3 PM (Li et al., 2014b) 94.5 94.5 94.3 EM-MV (Zhang et al., 2014) 97.9 97.9 96.3 EM-Opt (Zhang et al., 2014) 72 Table 3 : F1 scores of predicted labels on the 2dimensional datasets when using the output of the last hidden layer of the classifier to represent an instance for the reliability estimator. each of differing reliability, as explained in Section 4.1. Table 3 shows that our method performs well on the 2-dimensional datasets, obtaining higher label prediction F1 scores than the baselines. We omit the analysis of the true label prediction and reliability estimation results on these datasets as all models performed similarly, choosing instead to focus the discussion on the results for the NLP tasks. Classifier and Reliability Estimator In order to explore the separate performance contribution of classifier and reliability estimator, we compare the performance of our model to a classifier pre-trained using DS labels, as well as a variant of our model without the reliability estimator, i.e. setting all the annotators have the same reliability on all the instances. As shown in Tables 4, 7 and 8, the pre-trained classifier performed worse than some aggregation methods. This indicates that the noise in the labels predicted by DS has an adverse effect on the training of the classifier. The much lower performance of the model with the reliability estimator removes hints at the importance of modelling per-annotator reliability to ensure accurate predictions. (Whitehill et al., 2009) 87.1 87.1 79.9 79.9 LFC (Raykar et al., 2010) 98.2 98.2 97.0 97.0 BCC (Kim and Ghahramani, 2012) 98.3 98.3 98.1 98.1 MINIMAX (Zhou et al., 2012) 28.2 28.2 50.9 50.9 MACE (Hovy et al., 2013) 91.6 91.6 63.6 63.6 CATD (Li et al., 2014a) 91.1 91.1 92.2 92.2 PM (Li et al., 2014b) 91.1 91.1 92.2 92.2 EM-MV (Zhang et al., 2014) 88.3 88.3 66.9 66.9 EM-Opt (Zhang et al., 2014) 13.5 13.5 Instance Representation for Reliability Estimator For the representation of the instance x i as it is fed to the reliability estimator, we compared the performance of using the original feature vector of x i to using the last hidden layer output of the classifier (which we refer to as the \"full model\"). We found that using the hidden layer representation can not only improve the label prediction performance (see Tables 4, 7 and 8 ), but also sped up the training compared to using the feature vector directly. The hidden layer representation allows us to reduce the number of parameters in the model, by sharing parameters with the classifier. Full Model on Synthetic Datasets Based on the results of the full model in Table 4 , we can conclude that per-instance reliability modelling is beneficial to the label prediction task, and using the average pre-trained embedding can result in slightly better performance. It is worth noting that the method used to pre-train the model had a noticeable effect on its performance, with better F1 scores being obtained when using DS pretraining. In the following experiments we only consider models pre-trained using the DS algorithm. In order to investigate whether our method can successfully capture per-instance annotator reliability, for each annotator, we counted the number of correctly labelled instances and calculated the average reliability for each class among the top 100 instances with the highest per-instance reliability as shown in Table 5 and 6 5 . The cells with grey background colour indicate which domain, or class, the annotator has expertise in. It can be seen that all annotators obtain high accuracy on these instances. In general our method also captured the varying expertise of each narrow annotator, estimating their reliability on instances belonging to the corresponding classes as particularly high. For these experiments in Table 7 , we also investigated the performance when using two different classification models. As seen in this table, both of them outperformed all baselines significantly. Full Model on RTE Dataset Table 8 presents the label prediction performance on the RTE dataset. As not every annotator has provided labels for every instance in this dataset, for both the EM and cross entropy training we simply omitted missing instance/annotator pairs when calculating the loss functions. As seen in the table, most of the baselines obtained high performance as the textual entailment recognition task is easy for non-expert annotators. However, our full model still achieved better prediction performance 5 We omit the results for the sentence classification task for lack of space, as we consider the results on the question classification dataset to be representative. (Dawid and Skene, 1979) 90.1 90.1 83.9 83.9 GLAD (Whitehill et al., 2009) 80.9 80.9 71.8 71.8 LFC (Raykar et al., 2010) 88.3 88.3 80.3 80.3 BCC (Kim and Ghahramani, 2012) 90.4 90.4 85.6 85.6 MINIMAX (Zhou et al., 2012) 30.4 30.4 44.0 44.0 MACE (Hovy et al., 2013) 84.6 84.6 62.4 62.4 CATD (Li et al., 2014a) 85.2 85.2 80.5 80.5 PM (Li et al., 2014b) 85.2 85.2 80.5 80.5 EM-MV (Zhang et al., 2014) 75.4 75.4 56.6 56.6 EM-Opt (Zhang et al., 2014) 19 (Dawid and Skene, 1979) 92.6 GLAD (Whitehill et al., 2009) 92.4 LFC (Raykar et al., 2010) 92.5 CUBAM (Welinder et al., 2010) 92.6 Yan et al. (Yan et al., 2010) 90.4 KOS (Karger et al., 2011) 63.2 VI (Liu et al., 2012) 92.5 BCC (Kim and Ghahramani, 2012) 92.3 MINIMAX (Zhou et al., 2012) 92.4 MACE (Hovy et al., 2013) 92.4 CATD (Li et al., 2014a) 92.3 PM (Li et al., 2014b) 92.0 EM-MV (Zhang et al., 2014) 92.5 EM-Opt (Zhang et al., 2014) 92 than all of the baseline methods. We also investigated the effectiveness of our model for removing noisy labels. We compare our model to the five best-performing baselines (DS, LFC, CUBAM, VI and EM-MV in Table 8 ). Each of these models are trained on the RTE dataset, after which the least reliable annotation for each instance is removed. We use the per-instance reliability for our model, the global reliability score of each annotator for LFC, CUBAM and VI, and the per-category annotator reliability for DS and EM-MV as the measure of the reliability of each annotation. For each of these models, we then retrain the models in Table 8 using the denoised dataset; the difference in performance can be seen in Table 9. We can see that using per-instance reliability results in the largest improvement, while only considering the annotators' overall reliability may cause a reduction in performance. In order to analyse the per-instance reliability of the human annotators, for each annotator we rank the instances according to the annotator's perinstance reliability. We look at the top 15 and bottom 15 instances, then count how many of them were correctly labelled (Cor. Labels) as well as the average reliability on these instances (Avg. Reliability). Table 10 shows the results of five annotators 6 . It can be seen that each annotator has considerably different reliabilities across instances. Training Stability Pre-training: As discussed in Section 3.2, the predicted labels produced by a simpler method are used for pre-training. Although these labels are not perfect, we assume that our method can still learn some useful information from them for a better starting point than random parameter initialisation. EM and Cross Entropy Training: From Tables 3, 4, 7 and 8, it can be seen that, in most cases, using cross entropy achieved much better and more stable performance than the models learned using EM training. We also noticed that the objective function would improve when using cross entropy training, and tended to converge faster in our experiments-generally within just a few epochs. Therefore, we recommend to use this training method in practice. Early Stopping: When using both EM and cross entropy training, we found that even if the objective function improved between iterations, the label prediction performance would eventually start to decrease. It is worth to investigate the reason for this phenomenon. To counteract this issue we used early stopping, where training is halted when the objective function does not improve more than 0.001 between iterations. Another option is to reduce the maximum number of outer iterations, e.g. to 20. Conclusion and Future Work We propose a novel probabilistic model which learns from noisy labels produced by multiple annotators for NLP crowdsourcing tasks by incorporating a classifier and a reliability estimator. Our work constitutes the first effort to model the perinstance reliability of annotators for both binary and multi-class NLP labelling tasks. We investigate two methods of training our model using the EM algorithm and cross entropy. Experimental results on 6 datasets including synthetic and real datasets demonstrate that our method can not only capture the per-instance reliability of each annotator, but also obtain better label prediction and the least reliable annotator detection performance compared to state-of-the-art baselines. For future work, we plan to apply our model to other NLP tasks such as relation extraction and named entity recognition. We also plan to investigate the use of variational inference (Jordan et al., 1999) as a means of training our model. Using variational inference might improve the stability and performance of our model. Acknowledgement We would like to thank the anonymous reviewers and Paul Thompson for their valuable comments. Discussions with Austin J. Brockmeier have been insightful. The work is funded by School of Computer Science Kilburn Overseas Fees Bursary from University of Manchester.",
    "funding": {
        "defense": 0.0,
        "corporate": 0.0,
        "research agency": 1.9361263126072004e-07,
        "foundation": 1.9361263126072004e-07,
        "none": 0.9992902042242858
    },
    "reasoning": "Reasoning: The article explicitly mentions that the work is funded by the School of Computer Science Kilburn Overseas Fees Bursary from the University of Manchester. There is no mention of funding from defense, corporate entities, research agencies, or foundations. The University of Manchester is an educational institution, and while it may receive various forms of funding, the specific bursary mentioned does not fall under defense, corporate, research agency, or foundation categories as defined."
}