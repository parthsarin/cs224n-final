{
    "article": "Sequence labeling models like conditional random fields have been successfully applied in a variety of NLP tasks. However, as the size of label set and dataset grows, the learning speed of batch algorithms like L-BFGS quickly becomes computationally unacceptable. Several online learning methods have been proposed in large scale setting, yet little effort has been made to compare the performance of these algorithms. Comparison is often carried out on a few datasets with fine tuned parameters for specific algorithm. In this paper, we investigate and compare several online learning algorithms for sequence labeling with datasets varying in scale, feature design and label set. We find that Dual Coordinate Ascent (DCA) is robust across datasets even without careful tuning of parameter. Furthermore, a recently proposed variant of Stochastic Gradient Descent (SGD), Adaptive online gradient Descent based on feature Frequency information (ADF), has very fast training speed compared with plain SGD, but fails to converge under certain conditions. Finally, We propose a simple modification of ADF, which bears comparable convergence speed with ADF, and is consistently better than plain SGD. Introduction Sequence labeling models have been widely used in a variety of NLP tasks, such as word segmentation, part-of-speech tagging, chunking, and named entity recognition. Various sequence labeling models have been proposed, like hidden Markov models (HMM) (Rabiner, 1989) , structured perceptron (Collins, 2002) , conditional random fields (CRFs) (Lafferty et al., 2001) and SVM-HMM (Tsochantaridis et al., 2006) . In recent years, discriminative models gain significant popularity over generative models on these tasks, and achieve state-of-the-art performance on most above tasks. Their strength and flexibility come from their ability to incorporate arbitrary declarative features. CRFs is one of such discriminative models for sequence labeling built upon maximum entropy principle. The learning algorithms of CRFs can be divided into batch methods and online methods. Batch methods update parameters by estimating gradient over the entire training data, while online methods estimate noisy gradient with a small portion of the training data, and update parameters frequently. Among all the batch methods, L-BFGS is the most widely used and outperforms others by a substantial margin (Malouf et al., 2002) ; Conjugate-gradient (CG) method with proper preconditioner can converge as fast as L-BFGS (Sha and Pereira, 2003) . However, discriminative models for typical sequence labeling tasks are very large and may involve hundreds of thousands of features, rendering even fastest batch learning methods very slow and impractical for large scale datasets. Several online learning algorithms have been proposed to speed the training process of structured prediction problems, such as Passive-Aggressive (PA) algorithm (Crammer et al., 2006) , Dual Coordinate Ascent (DCA) (Martins et al., 2010) and Stochastic Gradient Descent (SGD). SGD is known for its performance in the back propagation training of neural network. It also shows extremely good performance on machine learning tasks such as SVM (Bordes et al., 2009) , CRFs (Vishwanathan et al., 2006) , and Markov Logic Networks (Poon and Vanderwende, 2010) . It may reach optimal performance even before it sees the whole training data on large datasets (Bottou and Bousquet, 2008) . SGD takes typically 5-10 iterations to converge when training a multiclass Maximum Entropy (ME) model, while it takes over 50 iterations when training CRFs, much slower than training its unstructured counterpart, multiclass ME. We show how simple feature frequency adaptive strategy may help accelerate training of CRFs within 10 iterations. Despite recent progresses in online learning algorithms, little effort has been made to compare these algorithms thoroughly. In this paper, we focus on several online learning algorithms for sequence labeling. More specifically, we investigate PA, DCA, SGD and SGD's variant ADF (Sun et al., 2012) . We perform comparison on several standard datasets with diverse settings of feature design and label set. We make it as close as possible to real application scenarios whenever resources are available. Experiment reveals distinct behavior of these algorithms under different settings. Our contributions are threefold. First, we make a fair and extensive comparison of state-ofthe-art online learners for sequence labeling and characterize the strength of each algorithm. Second, we confirm the effectiveness of ADF on most datasets despite its lack of theoretical convergence guarantee for now; inspired by ADF, we propose Modified ADF (MADF), which guarantees convergence and converges as fast as ADF. Finally, we explore the use of Tongyici Cilin (Extended) as a semantic lexicon in Chinese named entity recognition, which remains unexplored for this task in previous work. The remaining of this paper is organized as follows: in Section 2, we describe in detail the online learning algorithms, and propose MADF; in Section 3 we evaluate performance of these algorithms, and present novel usage of Tongyici Cilin (Extended) in Experiment 2; we review related work in Section 4; finally we conclude. Online Learning Algorithms for Sequence Labeling A sequence labeling task is defined as follows: given an observation sequence x = {x 1 , x 2 , . . . , x n }, output its corresponding label sequence y = { y 1 , y 2 , . . . , y n }, one label for each x i . The output space is |Y | n where Y is the label set that each individual y i takes values from, and n is the length of y. In discriminative sequence labeling models, feature functions are used to describe interdependency between observed and hidden variables. Under first order Markov assumption, the feature function can be divided into transition features \u03c6(x, y i , y i+1 ) and emission features \u03c6(x, y i ). These can be combined to \u03c6(x, y). Dynamic programming technique like viterbi decoding is often employed during inference: \u0177 = arg max y \u03b8 T \u03c6(x, y) (1) where \u03b8 are model parameters. Next we will describe how to estimate parameters \u03b8 with different online algorithms. Passive-aggressive algorithm (PA) Passive-Aggressive (PA) algorithm (Crammer et al., 2006 ) is a family of margin based online learning algorithms. This algorithm updates the parameter to satisfy the constraint imposed by the current example (aggressively), and does nothing if the current example is correctly classified (passively). Equation 2 defines the objective function for PA algorithm (referred by the author as PA-I): \u03b8 (t+1) = arg min \u03b8 1 2 \u03b8 \u2212 \u03b8 (t) 2 + C\u03be s.t. l( \u0177, y) < \u03be and \u03be \u2265 0 (2) where \u03be is a non-negative slack variable that copes with wrongly labeled data; C controls the aggressiveness of parameter updating, and is a trade-off between convergence speed and model quality. The update rule of parameter is as follows: \u03b8 (t+1) = \u03b8 (t) \u2212 \u03b7(\u03c6(x (t) , \u0177(t) ) \u2212 \u03c6(x (t) , y (t) )) (3) where \u03b7 = min C, \u03b8 T (\u03c6(x (t) , \u0177(t) ) \u2212 \u03c6(x (t) , y (t) )) + l(y (t) , \u0177(t) ) \u03c6(x (t) , \u0177(t) ) \u2212 \u03c6(x (t) , y (t) ) 2 (4) and \u0177(t) = arg max y \u03b8 T (\u03c6(x (t) , y) \u2212 \u03c6(x (t) , y (t) )) + l(y (t) , y) where l(y (t) , \u0177(t) ) is the penalty we incur if our prediction is \u0177(t) and the true label is y (t) . \u0177(t) can be solved with cost augmented decoding, which can be efficiently accomplished if l(y (t) , \u0177(t) ) decomposes the same way as the feature vector function (Smith, 2011) . This is referred to as a max-loss update in (Crammer et al., 2006) . When applied to sequence labeling PA is a special case of the general algorithm where output y is a label sequence. Hamming loss (Eq. 6) is often used. However, other loss can also fit when one faces with task specific needs (Song et al., 2012 ) (Mohit et al., 2012) . l(\u0177, y) = H amming(\u0177, y) = n i=1 \u03b4 y i = \u0177i ( \u0177i , y i ) (6) 2.2 Dual coordinate ascent (DCA) (Martins et al., 2010) present a general framework for online learning of structured classifiers. It bears some resemblance to the PA algorithm in that it shares the passive-aggressive property of PA. This algorithm applies to a wide class of loss functions; CRFs, SVM, structured perceptron can all be deemed as its special cases. Furthermore, learning rate is automatically determined for each instance, hence pesky learning rate tuning is no longer needed. The learning objective is the sum of loss on datasets plus a regularization term: min \u03b8 \u2208 d \u03bbR(\u03b8 ) + 1 m m t=1 L(\u03b8 ; x (t) , y (t) ) (7) The update rule 8 is very similar to the PA algorithm in large margin setting (Eq. 3), if we divide Equation 7 by \u03bb, replace 1 \u03bbm with C, and set \u2207L = \u03c6(x (t) , \u0177(t) ) \u2212 \u03c6(x (t) , y (t) ) . The update rule for DCA is: \u03b8 (t+1) = \u03b8 (t) \u2212 \u03b7 t \u2207L(\u03b8 ; x (t) , y (t) ) (8) where \u03b7 (t) = min 1 \u03bbm , L(\u03b8 (t) ; x (t) , y (t) ) \u2207L(\u03b8 (t) ; x (t) , y (t) ) 2 (9) As for sequence labeling problem, CRFs is derived by setting the loss function to the negative log-loss with no cost function, i.e. L CRF = \u2212 log P(y t |x t ). The loss function of CRFs is just a special case of the general loss function L. CRFs with SGD learning and its variants Linear chain conditional random fields (CRFs) (Lafferty et al., 2001 ) is widely used model for sequence labeling. It predicts the output sequence y by its conditional probability P(y|x): P(y|x) = 1 Z(x) exp \u03b8 T \u03c6(x, y) (10) where Z(x) = y exp \u03b8 T \u03c6(x, y) is normalization term which ensures that the probability sums to 1. The training objective is to maximize the likelihood on the training data (often accompanies a prior over parameters to get max-a-posterior estimation), which is equivalent to minimizing a negative log loss over all data points plus a regularizer: L = m i=1 \u2212 log P(y|x) + \u03bbm \u03b8 2 (11) Here we multiply the regularizer by m to keep it consistent with Equation 7 . This way \u03bb has the same meaning as in Equation 7 . Minimizing this objective gives the gradient for one instance in online setting: t) , y (t) ) = E P(y|x;\u03b8 (t) ) \u03c6(x (t) , y (t) ) \u2212 \u03c6(x (t) , y (t) ) + \u03bb\u03b8 (12) where the expectation of feature vector given current example x (t) is taken over all possible sequences of y, and can be efficiently computed using forward-backward algorithm. \u2202 \u2202 \u03b8 L(\u03b8 ; x ( Generally regularizer is added to avoid overfitting. Various regularizers have been proposed. L 2 regularizer, R(\u03b8 ) = \u03bb 2 \u03b8 2 2 , which is used by various CRF based tools, often leads to superior performance and can be numerically optimized. L 1 regularizer, R(\u03b8 ) = \u03c3 \u03b8 1 , known as Lasso, encourages sparse parameter. Elastic net, a linear interpolation of L 1 and L 2 regularizer, is used by (Lavergne et al., 2010) to regularize CRFs, and performs as good as L 2 regularizer, while still retaining compact model. SGD and its variants Stochastic gradient descent (SGD) is known for its fast convergence on machine learning tasks (Bottou and Bousquet, 2008) (Vishwanathan et al., 2006 ) (Shalev-Shwartz et al., 2007) . Every time the algorithm randomly draws one sample (or small batch of samples in mini-batch setting), and performs update according to the gradient of this sample. In general, SGD has the following simple update rule: \u03b8 (t+1) = \u03b8 (t) \u2212 \u03b7 (t) B\u2207L (13) where \u03b7 (t) is a scalar learning rate, B is a matrix; B = I for a plain SGD and B \u2248 H \u22121 for second order SGD. Despite its ease of implementation, it's generally hard to tune and schedule the learning rate properly. (Murata, 1998) shows that with a 1/t-annealing learning rate it can be asymptotically as effective as batch learning in terms of generalization error. (Bottou and Bousquet, 2008) further shows that utilizing second order information by setting \u03b7B = 1 t H \u22121 , optimal asymptotic convergence rate is achieved. With \u03b7 = 1/t and fixed B, convergence is guaranteed based on the theory of stochastic approximation (Murata, 1998) . Various ways of approximating the inverse of Hessian have been proposed (Hsu et al., 2009 ) (Vishwanathan et al., 2006) . But these methods are much slower than plain SGD in terms of execution time of one pass over the entire dataset, so the speed up is very limited. Full approximation of H \u22121 is quite expensive , so low rank approximation and diagonal approximation (Bordes et al., 2009 ) is very appealing. The next two algorithms is closely related to diagonal rescaling. ADF In ADF, instead of a single global learning rate in plain SGD, each dimension of parameters has its own learning rate. The learning rate decays periodically according to its associated feature frequency, with high frequency decaying faster. This adaptive strategy is based on the intuition that frequent observed features are more adequately trained so smaller learning rates are needed. The author shows its high convergence speed compared with plain SGD in Chinese word segmentation task. The method works well in most of our experiments, except for a few datasets. As we observed in our experiments in several other sequence labeling tasks, despite its speed of convergence and of reduction in training set error rate, it might fail to generalize well to testset and its parameters fluctuate a lot with different random shuffling of data. Moreover, it is not clear how to tune the upper bound and lower bound of the decay factor. In fact, ADF can be seen as diagonal approximation of the inverse of Hessian with exponential decrease learning rate based on frequency adaptive information. Unfortunately, this decrease in learning rate does not have theoretically convergence guarantee for now, although it works well in practice. (Murata, 1998) shows that SGD with 1/t-annealing learning rate guarantees convergence. Modified ADF (MADF) Second order SGD (2SGD) uses an approximation of inverse of Hessian by setting \u03b7B = 1 t H \u22121 in order to achieve the optimal learning rate. Inspired by ADF and current theory foundation of 2SGD, we propose to use feature frequency information to approximate H \u22121 , while still keeping a \u03b7 = 1/t annealing factor, so convergence is guaranteed (Eq. 14). Our method works as follows: at the beginning of the algorithm, we compute the diagonal scaling matrices B using Equation 15 , which is of the same size as the parameter vector. For each dimension of \u03b8 , we use a separate learning rate 1 t B ii . \u03b8 (t+1) = \u03b8 (t) \u2212 1 t B\u2207L(\u03b8 ) (14) B ii = 1 \u03b2 + (\u03b1 \u2212 \u03b2) \u00d7 #\u03c6(x, y) #t okens where a = 1 \u03b1 b = 1 \u03b2 (15) where a and b serve as lower and upper bounds of diagonal scaling element B ii . We keep B constant during the training process. #\u03c6(x, y)/#t okens is the relative feature frequency associated with i-th dimension. There are two main differences of our method compared with ADF. The first is how the frequency is counted. In ADF, frequency is counted as y \u03c6(x, y) per sentence and is the same for each predicate x with different y. Our method counts \u03c6(x, y) per token in the training set and use separate learning rate for predicate x with different y. Another difference is that we keep an annealing learning rate \u03b7 (t) = 1/t with fixed diagonal scaling matrix B, while ADF can be seen as exponential decaying B with constant \u03b7. It is difficult to set the upper and lower bounds of scaling factor B ii . One solution is to grid search a and b with held-out dataset. In this paper, we find it works surprisingly well by setting a = 0.001 and b = 1 on almost all datasets. It is easy to interpret our method in the view of input rescaling. In the back propagation learning of neutral network, mapping a too large input to a relatively small output would result in a small learning rate in order to ensure stable convergence, leading to slow convergence speed 1 . (LeCun et al., 1998) suggest simply to normalize the input to combat this problem. Furthermore, input scaling is closely related to diagonal approximation of the inverse of Hessian (Bordes et al., 2009) . However, scaling input feature value in sparse dataset is not realistic. Our idea is that in batch setting, the update of parameters associated with frequent features tend to be larger than those associated with rare features, so we scale the learning rate by the inverse of its associated relative feature frequency. We show in Section 3 how this simple adaptive learning rate can significantly speedup the learning process while still is equipped with convergence guarantee. It runs as fast as plain SGD in terms of per iteration execution time, without the penalty of approximating the inverse of Hessian. The speedup is attributed to a proper estimation of initial learning rate, especially on datasets with more skewed feature frequency distribution. Evaluation and Analysis Implementation There are several implementation issues on how to obtain good performance with different algorithms. Weight averaging: averaged perceptron, PA and DCA can get much better performance by weight averaging. We only have to maintain two weight vectors \u03b8 (t) and \u03b8 (t) ; each time we perform update \u03b8 (t+1) = \u03b8 (t) \u2212 \u2207L and \u03b8 (t+1) = \u03b8 (t) \u2212 t\u2207L. Finally the average weight is obtained by \u03b8 = T t=0 \u03b8 (t) = \u03b8 (T ) \u2212 \u03b8 (T ) /T . Randomize data: if we have to pass the dataset multiple times, it's better to randomize the dataset. This can get better performance on all online algorithms in our experiments, not only SGD variants. Regularization with L 2 : In NLP tasks, the feature vector is typically sparse. The gradient \u2207L (see Eq. 12) consists of two parts, one corresponds with the loss and the other with the regularizer. The first part is often sparse and can be efficiently carried out. The update of the regularizer part is dense and quite expensive if done for every sample. There are two methods that can combat this problem. (Shalev-Shwartz et al., 2007) propose to represent the weight vector \u03b8 by the product of one scaling factor and one vector. We can see the reason by a simple rearrangement of the formula \u03b8 (t+1) = \u03b8 (t) \u2212 \u03b7(\u2207l + \u03bb\u03b8 (t) ) = (1 \u2212 \u03b7\u03bb)\u03b8 (t) \u2212 \u03b7\u2207l. The first term can be done efficiently with a scalar product. (Bordes et al., 2009) propose in SVMSGD2 another method in which the regularizer term is treated as a special example and updated periodically. The method works on both first order and second order SGD. We will use this method in our experiment if not particularly mentioned. Initial learning rate for SGD: The initial learning rate of SGD plays a critical role in the whole process of learning. It is chosen by heuristic method. We can sample a subset of the training data, run SGD algorithm for one pass over the subset and pick the learning rate with smallest training objective value as the initial guess of learning rate. This method is generally helpful for all SGD variants. We use this setting for all variants of SGD. Datasets settings We compare the performance on several sequence labeling tasks, namely Chinese word segmentation, Chinese named entity recognition, CoNLL 2000 chunking, CoNLL 2003 NER, and Chinese part-of-speech tagging. The datasets vary across tasks in label set size and feature design. We inject as much knowledge as possible to mimic real application scenarios. For under-resourced tasks, we simply use token based n-gram features. Table 2 gives a brief view of features used. Table 4 shows the statistics after feature generation. Tasks Type Features Chinese word segmentation basic character unigram w \u22122 , w \u22121 , w 0 , w 1 , w 2 , character bigram w \u22122 w \u22121 , w \u22121 w 0 , w 0 w 1 , w 1 w 2 , whether w j and w j+1 are identical and whether w j and w j+2 are identical in windows of 2 characters on the left and 2 characters on the right; unigram/bigram dictionary features as described in (Sun et al., 2012) extended accessor variety and mutual information (Sun and Xu, 2011 This categorized lexicon is quite similar to word cluster features in (Ratinov and Roth, 2009) , but is more precise. However, to our certain knowledge, this resource remains unexplored in previous Chinese NER tasks. Words in Chinese do not have space like in English. In Chinese NER task, texts are given without word boundaries, so segmentation is an essential preprocessing step. But this will bring segmentation error to the system, especially most named entities are out-ofvocabulary words. On the other hand, if we perform inference at character level directly, we quickly loss the meaning of words . We propose two simple strategies to alleviate these problems: first, while still performing inference at character level, we do forward maximum matching and backward maximum matching to provide basic word boundary features; second, word meaning is injected with the category of the matching word in Tongyici Cilin. The class of a word also serves as a mechanism of word cluster, which holds similar words together. Hence Tongyici Cilin serves as both word clusters and a lexicon when performing maximum matching. Finally, we use entity list extracted from Baidu Baike as additional entity list features. The datasets we use are SigHan 08 Chinese NER dataset and one month of People Daily. As our main concern is to build a resource rich feature design for Chinese named entity recognition, we do not make further comparison with other algorithms. Other approaches typically use complex model combinations, which are not directly comparable to our single model based method. 3. CoNLL English NER and Chunking (Ratinov and Roth, 2009 ) perform an extensive study on NER and extract valuable resources, which can be readily incorporated into any existing NER system. We use the word class hierarchy and gazetteer lists from their package 4 . We do not use other features for simplicity. Word class features are derived from brown clustering algorithm and intended for bridging the gap of unseen text . The brown algorithm hierarchically clusters the words, and paths with different lengths to the root represent different levels of abstraction. Gazetteers are dictionaries of named entities and injected to the system to provide world knowledge. We use these two features as described in (Ratinov and Roth, 2009) . For English chunking task, we use the template provided with CRF++ 5 , this template is also used in the benchmark of CRFSGD 6 . Chinese part-of-speech(POS) tagging The setting follows the baseline of (Sun and Uszkoreit, 2012 ). As we do not have access to the more complex features, we just use this baseline, which performs reasonably good on a different datasets. Experiments As for plain SGD, we replicate CRFSGD implementation for fair comparison. For all variants of SGD, we use the regularizer proposed by (Bordes et al., 2009) . All learning rates are searched by subsampling, except for PA and DCA, which do not need to specify learning rates. For ADF, we use the same setting as (Sun et al., 2012) . We run SGD for 50 iterations and other online methods for 30 iterations. This setting is suffice for most algorithms to reach a stable state. Also note PA and DCA need to specify an aggressive parameter C, which controls how aggressively the parameter perform updates. PA seems to be very sensitive to this parameter, and the algorithm leads to bad results if C is not properly set. The algorithm converges fast with a larger C, but may not provide good generalization performance. In our experiment, we set C = 0.01 for PA, which is a trade-off between convergence speed and an accurate model. DCA is not very sensitive to this parameter so we set C to 1. For every task we also plot the final performance of CRF++ and Wapiti 7 at the beginning of iterations. We do not plot the learning curves because they use different learning methods (Wapiti does contain online learners but needs to switch to L-BFGS to fine tune the model parameter, so we only report results of L-BFGS learner). For POS tagging we do not plot the results of CRF++, because CRF++ will run for weeks. CRF++ uses L-BFGS for parameter estimation, and we use default stop condition. Wapiti (Lavergne et al., 2010) uses elastic net regularizer, and does feature selection automatically while training. The resulting model is compact and small, and still retains performance comparable to L 2 -regularizer. We use the default setting of regularizer weights and a stop condition that error rate of development set does not further decrease in window of size 10. For other variants of SGD, PSA (Hsu et al., 2009) and SMD (Vishwanathan et al., 2006) are out of our consideration because they are typically more than 10 times slower than plain SGD in execution time of one pass over the dataset, despite their theoretical appealing one pass over the data. We tried averaged SGD (ASGD) (Xu, 2011) on two of our datasets, but it did not perform so well even if we tried several switch time between SGD and ASGD. For Chinese word segmentation, we evaluate F-score using the script for SigHan 2005 bakeoff. For all NER and chunking tasks, we report phrase based F-score with the script provided by CoNLL. For POS tagging, we report token based accuracy. Results are listed in Table 5 . Discussion Differences across datasets: For well resourced tasks, i.e. CWS pku(e), NER People Daily(e), CoNLL 2003 English NER(e) (4,7,9 in figure 1 ), SGD and its variants give better performance than PA and DCA, with faster convergence speed; while PA and DCA give very robust performance on under-resourced tasks despite the presence of only simple token based features, partly attribute to their weight averaging mechanism. Another observation is that small or under-resourced datasets often make the learning curve of SGD and its variants fluctuate a lot. For simple datasets with only token based features, e.g. 6,10,11,12, PA and DCA performs relatively good or even better than other methods. PA is a margin based method and may generalize well to unseen data under such circumstances. Moreover, PA and DCA all use weight averaging for better generalization, which proves useful under simple feature set. In other cases, DCA performs as good as other training methods and converges as fast as SGD, but are always more stable. This may ease the selection of stopping criterion, as a non-stable learning curve may stop accidentally at a bad point. (Lavergne et al., 2010) suggest it is good practice to use a separate development set to determine a stop criterion, but this set is not always available. Note also that the aggressiveness parameter C for PA is critical for a reasonably good performance, as in chunking (8) and English NER (9) tasks, PA gets very poor results. Effect of \u03b7 0 : As we observe in our experiments, the high convergence speed is largely determined by a good choice of initial learning rate. For plain SGD, high frequency features cause the initial estimate of learning rate to decrease, resulting in a low convergence speed. In datasets 4, 5, 6, 7, 9, 10 , the initial estimations of \u03b7 0 in MADF are several times larger than that in SGD, which explains the convergence speed differences. (note the feature frequency in table 4 and convergence speed difference of SGD and MADF in figure 1 .) In datasets with feature frequency not so skewed, SGD converges as fast as ADF and MADF. ADF and MADF always converge faster than plain SGD and often achieve top performance within 10 iterations. ADF is more stable than MADF because of its fast decay of learning rate. But this effect comes at the price that ADF cannot reach top performance on some datasets. For instance, in the CWS PKU (4), Chinese NER People Daily (7) and English NER tasks (9), ADF reaches an F-score 0.1% to 0.3% lower than MADF; SGD can also performs better than ADF on these datasets after 100 iterations which I do not plot. Batch learning method (i.e. CRF++) rarely gives the best generalization performance. This implies that expensive batch optimization methods are not necessary for large learning tasks. Online methods will suffice. One exception is CITYU CWS task, in which CRF++ performs better than all online methods. We find the problem is how a feature fires when it is false. Both CRF++ and Wapiti treat it as a feature \"F\" and we omit it when we fire this feature. After adding this the F-score on testset goes up from 94.1% to 94.4% for SGD and MADF, 95.5% for ADF, comparable to CRF++. However, on a different dataset CWS PKU, adding this \"F\" feature decreases F-score by 0.1%, still higher than CRF++ by 0.3%. Summary: PA is competitive with properly chosen aggressiveness parameter on under-resourced tasks. DCA converges as fast as SGD and is more stable, and is often as good as or even better than SGD variants. ADF and MADF are consistently faster than plain SGD and often reach reasonably good performance after a mere 10 passes over the datasets. ADF sometimes gets suboptimal results and losses the opportunity to further refine the parameters because of a too fast decay of learning rate; while MADF has convergence guarantee but may have a little more fluctuation in small datasets. Finally, online methods are generally several dozens times faster and get better performance than batch method. Related Work In many NLP related tasks, the data distribution is skewed, and generally only a small number of features are fired in each example, resulting in a sparse distribution. Skewed feature frequency can affect speed of SGD algorithms, resulting in a conservative small initial guess of learning rate, which slows down the convergence speed. (Sun et al., 2012) utilize feature frequency information to speed up training of CRF model. It is simple and fast compared with other Hessian approximation methods. The sparse distribution can greatly accelerate training speed of models through clever regularization as described in (Vishwanathan et al., 2006) (Bordes et al., 2009) , or through sparse forward-backward decoding (Lavergne et al., 2010) . Stochastic gradient descent (SGD) is well known for its performance on machine learning tasks (Bottou and Bousquet, 2008) . Its recent successes in learning CRFs (Vishwanathan et al., 2006) and SVM (Shalev-Shwartz et al., 2007) show its advantage over batch learning algorithms in both convergence speed and generalization performance. It is particularly suitable in a large scale setting, and may achieve top performance even before seeing the whole dataset. Various methods based on SGD have been proposed to accelerate training of CRFs. Several variants of SGD aim at theoretically one pass over the training data to get optimal performance (Hsu et al., 2009) . The core idea of these methods is approximating the inverse of Hessian in order to accelerate training (and is why they are called second order SGD). However, the approximation is expensive and much slower than a plain SGD in terms of per iteration running time. (Xu, 2011) proposes averaged SGD (ASGD) that is as fast as SGD and converges within several iterations. However, in several datasets we tested, the testset performance is below standard SGD even after we tried several switch time of SGD and ASGD. Besides the regularizer mentioned above, group Lasso has recently been proposed to regularize a structured classifier (Martins et al., 2011) . The author encodes prior structural knowledge of the feature space by grouping different features into M groups and using separate regularizer weight for each group. The resulting model is compact and avoids the problem of overfitting with large number of free parameters. Conclusion We investigate several online learning algorithms for sequence labeling and empirically show how each algorithm performs on datasets with distinct feature design and label set. This will ease the selection of algorithms in similar tasks in future. Our experiments show that most online algorithms outperform batch method (CRF++) at both speed and generalization performance. We can gain further speedup by adopting simple strategy as ADF and MADF do. We propose our own algorithm inspired by ADF, which is a variant of SGD. We confirm the effectiveness of ADF on several datasets. While ADF works in most situations, sometimes it leads to suboptimal solutions. Our algorithm performs consistently better than SGD, and converges as fast as ADF. These simple frequency adaptive methods can greatly accelerate training speed under skewed feature frequency distribution. As many NLP tasks involve the cycle of training the model and refining features then retraining the model, fast training methods are particularly useful, especially on large dataset with a large label set. It is also interesting to see how these two simple frequency adaptive approaches help in other structured learning problems in future. Acknowledgments (Grant No. 20090001110047 )",
    "abstract": "Sequence labeling models like conditional random fields have been successfully applied in a variety of NLP tasks. However, as the size of label set and dataset grows, the learning speed of batch algorithms like L-BFGS quickly becomes computationally unacceptable. Several online learning methods have been proposed in large scale setting, yet little effort has been made to compare the performance of these algorithms. Comparison is often carried out on a few datasets with fine tuned parameters for specific algorithm. In this paper, we investigate and compare several online learning algorithms for sequence labeling with datasets varying in scale, feature design and label set. We find that Dual Coordinate Ascent (DCA) is robust across datasets even without careful tuning of parameter. Furthermore, a recently proposed variant of Stochastic Gradient Descent (SGD), Adaptive online gradient Descent based on feature Frequency information (ADF), has very fast training speed compared with plain SGD, but fails to converge under certain conditions. Finally, We propose a simple modification of ADF, which bears comparable convergence speed with ADF, and is consistently better than plain SGD.",
    "countries": [
        "China"
    ],
    "languages": [
        "English",
        "Chinese"
    ],
    "numcitedby": "2",
    "year": "2012",
    "month": "December",
    "title": "A Comparison and Improvement of Online Learning Algorithms for Sequence Labeling"
}