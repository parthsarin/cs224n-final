{
    "article": "We present a corrective model for recovering non-projective dependency structures from trees generated by state-of-theart constituency-based parsers. The continuity constraint of these constituencybased parsers makes it impossible for them to posit non-projective dependency trees. Analysis of the types of dependency errors made by these parsers on a Czech corpus show that the correct governor is likely to be found within a local neighborhood of the governor proposed by the parser. Our model, based on a MaxEnt classifier, improves overall dependency accuracy by .7% (a 4.5% reduction in error) with over 50% accuracy for non-projective structures. Introduction Statistical parsing models have been shown to be successful in recovering labeled constituencies (Collins, 2003; Charniak and Johnson, 2005; Roark and Collins, 2004) and have also been shown to be adequate in recovering dependency relationships (Collins et al., 1999; Levy and Manning, 2004; Dubey and Keller, 2003) . The most successful models are based on lexicalized probabilistic context free grammars (PCFGs) induced from constituencybased treebanks. The linear-precedence constraint of these grammars restricts the types of dependency structures that can be encoded in such trees. 1 A shortcoming of the constituency-based paradigm for parsing is that it is inherently incapable of representing non-projective dependencies trees (we define non-projectivity in the following section). This is particularly problematic when parsing free wordorder languages, such as Czech, due to the frequency of sentences with non-projective constructions. In this work, we explore a corrective model which recovers non-projective dependency structures by training a classifier to select correct dependency pairs from a set of candidates based on parses generated by a constituency-based parser. We chose to use this model due to the observations that the dependency errors made by the parsers are generally local errors. For the nodes with incorrect dependency links in the parser output, the correct governor of a node is often found within a local context of the proposed governor. By considering alternative dependencies based on local deviations of the parser output we constrain the set of candidate governors for each node during the corrective procedure. We examine two state-of-the-art constituencybased parsers in this work: the Collins Czech parser (1999) and a version of the Charniak parser (2001) that was modified to parse Czech. Alternative efforts to recover dependency structure from English are based on reconstructing the movement traces encoded in constituency trees (Collins, 2003; Levy and Manning, 2004; Johnson, 2002; Dubey and Keller, 2003) . In fact, the fea- tures we use in the current model are similar to those proposed by Levy and Manning (2004) . However, the approach we propose discards the constituency structure prior to the modeling phase; we model corrective transformations of dependency trees. The technique proposed in this paper is similar to that of recent parser reranking approaches (Collins, 2000; Charniak and Johnson, 2005) ; however, while reranking approaches allow a parser to generate a likely candidate set according to a generative model, we consider a set of candidates based on local perturbations of the single most likely tree generated. The primary reason for such an approach is that we allow dependency structures which would never be hypothesized by the parser. Specifically, we allow for non-projective dependencies. The corrective algorithm proposed in this paper shares the motivation of the transformation-based learning work (Brill, 1995) . We do consider local transformations of the dependency trees; however, the technique presented here is based on a generative model that maximizes the likelihood of good dependents. We consider a finite set of local perturbations of the tree and use a fixed model to select the best tree by independently choosing optimal dependency links. In the remainder of the paper we provide a definition of a dependency tree and the motivation for using such trees as well as a description of the particular dataset that we use in our experiments, the Prague Dependency Treebank (PDT). In Section 3 we describe the techniques used to adapt constituencybased parsers to train from and generate dependency trees. Section 4 describes corrective modeling as used in this work and Section 4.2 describes the par-ticular features with which we have experimented. Section 5 presents the results of a set of experiments we performed on data from the PDT. Syntactic Dependency Trees and the Prague Dependency Treebank A dependency tree is a set of nodes \u03a9 = {w 0 , w 1 , . . . , w k } where w 0 is the imaginary root node 2 and a set of dependency links G = {g 1 , . . . , g k } where g i is an index into \u03a9 representing the governor of w i . In other words g 3 = 1 indicates that the governor of w 3 is w 1 . Finally, every node has exactly one governor except for w 0 , which has no governor (the tree constraints). 3 The index of the nodes represents the surface order of the nodes in the sequence (i.e., w i precedes w j in the sentence if i < j). A tree is projective if for every three nodes: w a , w b , and w c where a < b < c; if w a is governed by w c then w b is transitively governed by w c or if w c is governed by w a then w b is transitively governed by w a . 4 Figure 1 shows examples of projective and non-projective trees. The rightmost tree, which is non-projective, contains a subtree consisting of w a and w c but not w b ; however, w b occurs between w a and w c in the linear ordering of the nodes. Projectivity in a dependency tree is akin to the continuity constraint in a constituency tree; such a constraint is implicitly imposed by trees generated from context free grammars (CFGs). Strict word-order languages, such as English, exhibit non-projective dependency structures in a relatively constrained set of syntactic configurations (e.g., right-node raising). Traditionally, these movements are encoded in syntactic analyses as traces. In languages with free word-order, such as Czech, constituency-based representations are overly constrained (Sgall et al., 1986) . Syntactic dependency trees encode syntactic subordination relationships allowing the structure to be non-specific about the underlying deep representation. The relationship between a node and its subordinates expresses a sense of syntactic (functional) entailment. In this work we explore the dependency structures encoded in the Prague Dependency Treebank (Haji\u010d, 1998; B\u00f6hmov\u00e1 et al., 2002) . The PDT 1.0 analytical layer is a set of Czech syntactic dependency trees; the nodes of which contain the word forms, morphological features, and syntactic annotations. These trees were annotated by hand and are intended as an intermediate stage in the annotation of the Tectogrammatical Representation (TR), a deep-syntactic or syntacto-semantic theory of language (Sgall et al., 1986) . All current automatic techniques for generating TR structures are based on syntactic dependency parsing. When evaluating the correctness of dependency trees, we only consider the structural relationships between the words of the sentence (unlabeled dependencies). However, the model we propose contains features that are considered part of the dependency rather than the nodes in isolation (e.g., agreement features). We do not propose a model for correctly labeling dependency structures in this work. Constituency Parsing for Dependency Trees A pragmatic justification for using constituencybased parsers in order to predict dependency structures is that currently the best Czech dependencytree parser is a constituency-based parser (Collins et al., 1999; Zeman, 2004) . In fact both Charniak's and Collins' generative probabilistic models con-tain lexical dependency features. 5 From a generative modeling perspective, we use the constraints imposed by constituents (i.e., projectivity) to enable the encapsulation of syntactic substructures. This directly leads to efficient parsing algorithms such as the CKY algorithm and related agenda-based parsing algorithms (Manning and Sch\u00fctze, 1999). Additionally, this allows for the efficient computation of the scores for the dynamic-programming state variables (i.e., the inside and outside probabilities) that are used in efficient statistical parsers. The computational complexity advantages of dynamic programming techniques along with efficient search techniques (Caraballo and Charniak, 1998; Klein and Manning, 2003) allow for richer predictive models which include local contextual information. In an attempt to extend a constituency-based parsing model to train on dependency trees, Collins transforms the PDT dependency trees into constituency trees (Collins et al., 1999) . In order to accomplish this task, he first normalizes the trees to remove non-projectivities. Then, he creates artificial constituents based on the parts-of-speech of the words associated with each dependency node. The mapping from dependency tree to constituency tree is not one-to-one. Collins describes a heuristic for choosing trees that work well with his parsing model. Training a Constituency-based Parser We consider two approaches to creating projective trees from dependency trees exhibiting nonprojectivities. The first is based on word-reordering and is the model that was used with the Collins parser. This algorithm identifies non-projective structures and deterministically reorders the words of the sentence to create projective trees. An alternative method, used by Charniak in the adaptation of his parser for Czech 6 and used by Nivre and Nilsson (2005) , alters the dependency links by raising the governor to a higher node in the tree whenever a non-projectivity is observed. The trees are then transformed into Penn Treebank style constituencies using the technique described in (Collins et al., 1999) . Both of these techniques have advantages and disadvantages which we briefly outline here: Reordering The dependency structure is preserved, but the training procedure will learn statistics for structures over word-strings that may not be part of the language. The parser, however, may be capable of constructing parses for any string of words if a smoothed grammar is being used. Governor-Raising The dependency structure is corrupted leading the parser to incorporate arbitrary dependency statistics into the model. However, the parser is trained on true sentences, the words of which are in the correct linear order. We expect the parser to predict similar incorrect dependencies when sentences similar to the training data are observed. Although the results presented in (Collins et al., 1999) used the reordering technique, we have experimented with his parser using the governor-raising technique and observe an increase in dependency accuracy. For the remainder of the paper, we assume the governor-raising technique. The process of generating dependency trees from parsed constituency trees is relatively straight-forward. Both the Collins and Charniak parsers provide head-word annotation on each constituent. This is precisely the information that we encode in an unlabeled dependency tree, so the dependency structure can simply be extracted from the parsed constituency trees. Furthermore, the constituency labels can be used to identify the dependency labels; however, we do not attempt to identify correct dependency labels in this work. Constituency-based errors We now discuss a quantitative measure for the types of dependency errors made by constituency-based parsing techniques. For node w i and the correct governor w g * i the distance between the two nodes in the hypothesized dependency tree is: dist(w i , w g * i ) = \u23a7 \u23aa \u23a8 \u23aa \u23a9 d(w i , w g * i ) iff w g * i is ancestor of w i d(w i , w g * i ) iff w g * i is sibling/cousin of w i \u2212d(w i , w g * i ) iff w g * i is descendant of w i Ancestor, sibling, cousin, and descendant have the standard interpretation in the context of a tree. The dependency distance d(w i , w g * i ) is the minimum number of dependency links traversed on the undirected path from w i to w g * i in the hypothesized dependency tree. The definition of the dist function makes a distinction between paths through the parent of w i (positive values) and paths through chil-CORRECT(W ) 1 Parse sentence W using the constituency-based parser 2 Generate a dependency structure from the constituency tree 3 for w i \u2208 W 4 do for w c \u2208 N (w g h i ) // Local neighborhood of proposed governor 5 do l(c) \u2190 P (g * i = c|w i , N (w g h i ) ) dren of w i (negative values). We found that a vast majority of the correct governors were actually hypothesized as siblings or grandparents (a dist values of 2) -an extreme local error. 6 g i \u2190 arg max c l(c) // Figure 2 shows a histogram of the fraction of nodes whose correct governor was within a particular dist in the hypothesized tree. A dist of 1 indicates the correct governor was selected by the parser; in these graphs, the density at dist = 1 (on the x axis) shows the baseline dependency accuracy of each parser. Note that if we repaired only the nodes that are within a dist of 2 (grandparents and siblings), we can recover more than 50% of the incorrect dependency links (a raw accuracy improvement of up to 9%). We believe this distribution to be indirectly caused by the governor raising projectivization routine. In the cases where non-projective structures can be repaired by raising the node's governor to its parent, the correct governor becomes a sibling of the node. Corrective Modeling The error analysis of the previous section suggests that by looking only at a local neighborhood of the proposed governor in the hypothesized trees, we can correct many of the incorrect dependencies. This fact motivates the corrective modeling procedure employed here. Table 1 presents the pseudo-code for the corrective procedure. The set g h contains the indices of governors as predicted by the parser. The set of governors predicted by the corrective procedure is denoted as g . The procedure independently corrects each node of the parsed trees meaning that there is potential for inconsistent governor relationships to exist in the proposed set; specifically, the result-ing dependency graph may have cycles. We employ a greedy search to remove cycles when they are present in the output graph. The final line of the algorithm picks the governor in which we are most confident. We use the correctgovernor classification likelihood, P (g * i = j|w i , N (w g h i )) , as a measure of the confidence that w c is the correct governor of w i where the parser had proposed w g h i as the governor. In effect, we create a decision list using the most likely decision if we can (i.e., there are no cycles). If the dependency graph resulting from the most likely decisions does not result in a tree, we use the decision lists to greedily select the tree for which the product of the independent decisions is maximal. Training the corrective model requires pairs of dependency trees; each pair contains a manuallyannotated tree (i.e., the gold standard tree) and a tree generated by the parser. This data is trivially transformed into per-node samples. For each node w i in the tree, there are |N (w g h i )| samples; one for each governor candidate in the local neighborhood. One advantage to the type of corrective algorithm presented here is that it is completely disconnected from the parser used to generate the tree hypotheses. This means that the original parser need not be statistical or even constituency based. What is critical for this technique to work is that the distribution of dependency errors be relatively local as is the case with the errors made by the Charniak and Collins parsers. This can be determined via data analysis using the dist metric. Determining the size of the local neighborhood is data dependent. If subordinate nodes are considered as candidate governors, then a more robust cycle removal technique is be required. MaxEnt Estimation We have chosen a MaxEnt model to estimate the governor distributions, P (g * i = j|w i , N (w g h i )). In the next section we outline the feature set with which we have experimented, noting that the features are selected based on linguistic intuition (specifically for Czech). We choose not to factor the feature vector as it is not clear what constitutes a reasonable factorization of these features. For this reason we use the MaxEnt estimator which provides us with the flexibility to incorporate interdependent features independently while still optimizing for likelihood. The maximum entropy principle states that we wish to find an estimate of p(y|x) \u2208 C that maximizes the entropy over a sample set X for some set of observations Y , where x \u2208 X is an observation and y \u2208 Y is a outcome label assigned to that observation, H(p) \u2261 \u2212 x\u2208X,y\u2208Y p(x)p(y|x) log p(y|x) The set C is the candidate set of distributions from which we wish to select p(y|x). We define this set as the p(y|x) that meets a feature-based expectation constraint. Specifically, we want the expected count of a feature, f (x, y), to be equivalent under the distribution p(y|x) and under the observed distribution p(y|x). y ) is a feature of our model with which we capture correlations between observations and outcomes. In the following section, we describe a set of features with which we have experimented to determine when a word is likely to be the correct governor of another word. x\u2208X,y\u2208Y p(x)p(y|x)f i (x, y) = x\u2208X,y\u2208Y p(x)p(y|x)f i (x, y) f i (x, We incorporate the expected feature-count constraints into the maximum entropy objective using Lagrange multipliers (additionally, constraints are added to ensure the distributions p(y|x) are consistent probability distributions): H(p) + i \u03b1 i x\u2208X,y\u2208Y p(x)p(y|x)f i (x, y) \u2212p(x)p(y|x)f i (x, y) + \u03b3 y\u2208Y p(y|x) \u2212 1 Holding the \u03b1 i 's constant, we compute the unconstrained maximum of the above Lagrangian form: p \u03b1 (y|x) = 1 Z \u03b1 (x) exp( i \u03b1 i f i (x, y)) Z \u03b1 (x) = y\u2208Y exp( i \u03b1 i f i (x, y)) giving us the log-linear form of the distributions p(y|x) in C (Z is a normalization constant). Finally, we compute the \u03b1 i 's that maximize the objective function: \u2212 x\u2208X p(x) log Z \u03b1 (x) + i \u03b1 i p(x, y)f i (x, y) A number of algorithms have been proposed to efficiently compute the optimization described in this derivation. For a more detailed introduction to maximum entropy estimation see (Berger et al., 1996) . Proposed Model Given the above formulation of the MaxEnt estimation procedure, we define features over pairs of observations and outcomes. In our case, the observations are simply w i , w c , and N (w g h i ) and the outcome is a binary variable indicating whether c = g * i (i.e., w c is the correct governor). In order to limit the dimensionality of the feature space, we consider feature functions over the outcome, the current node w i , the candidate governor node w c and the node proposed as the governor by the parser w g h i . Table 2 describes the general classes of features used. We write F i to indicate the form of the current child node, F c for the form of the candidate, and F g as the form of the governor proposed by the parser. A combined feature is denoted as L i T c and indicates we observed a particular lemma for the current node with a particular tag of the candidate. In all models, we include features containing the form, the lemma, the morphological tag, and the ParserGov feature. We have experimented with different sets of feature combinations. Each combination set is intended to capture some intuitive linguistic correlation. For example, the feature component L i T c will fire if a particular child's lemma L i is observed with a particular candidate's morphological tag T c . This feature is intended to capture phenomena surrounding particles; for example, in Czech, the governor of the reflexive particle se will likely be a verb. Related Work Recent work by Nivre and Nilsson introduces a technique where the projectivization transformation is encoded in the non-terminals of constituents during parsing (Nivre and Nilsson, 2005) . This allows for a deterministic procedure that undoes the projectivization in the generated parse trees, creating non-projective structures. This technique could be incorporated into a statistical parsing framework, however we believe the sparsity of such nonprojective configurations may be problematic when using smoothed backed-off grammars. We suspect that the deterministic procedure employed by Nivre and Nilsson enables their parser to greedily consider non-projective constructions when possible. This may also explain the relatively low overall performance of their parser. A primary difference between the Nivre and Nilsson approach and what we propose in this paper is that of determining the projectivization procedure. While we exploit particular side-effects of the projectivization procedure, we do not assume any particular algorithm. Additionally, we consider trans-formations for all dependency errors where their technique explicitly addresses non-projectivity errors. We mentioned above that our approach appears to be similar to that of reranking for statistical parsing (Collins, 2000; Charniak and Johnson, 2005) . While it is true that we are improving upon the output of the automatic parser, we are not considering multiple alternate parses. Instead, we consider a complete set of alternate trees that are minimal perturbations of the best tree generated by the parser. In the context of dependency parsing, we do this in order to generate structures that constituency-based parsers are incapable of generating (i.e., non-projectivities). Recent work by Smith and Eisner (2005) on contrastive estimation suggests similar techniques to generate local neighborhoods of a parse; however, the purpose in their work is to define an approximation to the partition function for log-linear estimation (i.e., the normalization factor in a MaxEnt model). Empirical Results In this section we report results from experiments on the PDT Czech dataset. Approximately 1.9% of the words' dependencies are non-projective in version 1.0 of this corpus and these occur in 23.2% of the sentences (Haji\u010dov\u00e1 et al., 2004) . We used the standard training, development, and evaluation datasets defined in the PDT documentation for all experiments. 7  MaxEnt estimator using the L-BFGS optimization algorithms and Gaussian smoothing. 8  Table 4 presents results on development data for the correction model with different feature sets. The features of the Simple model are the form (F), lemma (L), and morphological tag (M) for the each node, the parser-proposed governor node, and the candidate node; this model also contains the Parser-Gov feature. In the table's following rows, we show the results for the simple model augmented with feature sets of the categories described in Table 2 . Table 3 provides a short description of each of the models. As we believe the Simple model provides the minimum information needed to perform this task, Collins trees via a 20-fold Jackknife training procedure. 8 Using held-out development data, we determined a Gaussian prior parameter setting of 4 worked best. The optimal number of training iterations was chosen on held-out data for each experiment. This was generally in the order of a couple hundred iterations of L-BFGS. The MaxEnt modeling implementation can be found at http://homepages.inf.ed.ac. uk/s0450736/maxent_toolkit.html. we experimented with the feature-classes as additions to it. The final row of Table 4 contains results for the model which includes all features from all other models. We define NonP Accuracy as the accuracy for the nodes which were non-projective in the original trees. Although both the Charniak and the Collins parser can never produce non-projective trees, the baseline NonP accuracy is greater than zero. This is due to the parser making mistakes in the tree such that the originally non-projective node's dependency is projective. Alternatively, we report the Non-Projective Precision and Recall for our experiment suite in Table 5 . Here the numerator of the precision is the number of nodes that are non-projective in the correct tree and end up in a non-projective configuration; however, this new configuration may be based on incorrect dependencies. Recall is the obvious counterpart to precision. These values correspond to the NonP 6 shows the results of the full model run on the evaluation data for the Collins and Charniak parse trees. It appears that the Charniak parser fares better on the evaluation data than does the Collins parser. However, the corrective model is still successful at recovering non-projective structures. Overall, we see a significant improvement in the dependency accuracy. We have performed a review of the errors that the corrective process makes and observed that the model does a poor job dealing with punctuation. This is shown in Table 7 along with other types of nodes on which we performed well and poorly, respectively. Collins (1999) ric for constituency-based parsing explicitly ignores punctuation in determining the correct boundaries of constituents (Harrison et al., 1991) and so should the dependency evaluation. However, the reported results include punctuation for comparative purposes. Finally, we show in Table 8 a coarse analysis of the corrective performance of our model. We are repair-ing more dependencies than we are corrupting. Conclusion We have presented a Maximum Entropy-based corrective model for dependency parsing. The goal is to recover non-projective dependency structures that are lost when using state-of-the-art constituencybased parsers; we show that our technique recovers over 50% of these dependencies. Our algorithm provides a simple framework for corrective modeling of dependency trees, making no prior assumptions about the trees. However, in the current model, we focus on trees with local errors. Overall, our technique improves dependency parsing and provides the necessary mechanism to recover non-projective structures.",
    "abstract": "We present a corrective model for recovering non-projective dependency structures from trees generated by state-of-theart constituency-based parsers. The continuity constraint of these constituencybased parsers makes it impossible for them to posit non-projective dependency trees. Analysis of the types of dependency errors made by these parsers on a Czech corpus show that the correct governor is likely to be found within a local neighborhood of the governor proposed by the parser. Our model, based on a MaxEnt classifier, improves overall dependency accuracy by .7% (a 4.5% reduction in error) with over 50% accuracy for non-projective structures.",
    "countries": [
        "Czech Republic",
        "United States"
    ],
    "languages": [
        "Czech",
        "English"
    ],
    "numcitedby": "56",
    "year": "2005",
    "month": "October",
    "title": "Corrective Modeling for Non-Projective Dependency Parsing"
}