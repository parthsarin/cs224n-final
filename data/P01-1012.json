{
    "article": "We address the issue of on-line detection of communication problems in spoken dialogue systems. The usefulness is investigated of the sequence of system question types and the word graphs corresponding to the respective user utterances. By applying both ruleinduction and memory-based learning techniques to data obtained with a Dutch train time-table information system, the current paper demonstrates that the aforementioned features indeed lead to a method for problem detection that performs significantly above baseline. The results are interesting from a dialogue perspective since they employ features that are present in the majority of spoken dialogue systems and can be obtained with little or no computational overhead. The results are interesting from a machine learning perspective, since they show that the rule-based method performs significantly better than the memory-based method, because the former is better capable of representing interactions between features. Introduction Given the state of the art of current language and speech technology, communication problems are unavoidable in present-day spoken dialogue systems. The main source of these problems lies in the imperfections of automatic speech recognition, but also incorrect interpretations by the natural language understanding module or wrong default assumptions by the dialogue manager are likely to lead to confusion. If a spoken dialogue system had the ability to detect communication problems on-line and with high accuracy, it might be able to correct certain errors or it could interact with the user to solve them. For instance, in the case of communication problems, it would be beneficial to change from a relatively natural dialogue strategy to a more constrained one in order to resolve the problems (see e.g., Litman and Pan 2000) . Similarly, it has been shown that users switch to a 'marked', hyperarticulate speaking style after problems (e.g., Soltau and Waibel 1998) , which itself is an important source of recognition errors. This might be solved by using two recognizers in parallel, one trained on normal speech and one on hyperarticulate speech. If there are communication problems, then the system could decide to focus on the recognition results delivered by the engine trained on hyperarticulate speech. For such approaches to work, however, it is essential that the spoken dialogue system is able to automatically detect communication problems with a high accuracy. In this paper, we investigate the usefulness for problem detection of the word graph and the history of system question types. These features are present in many spoken dialogue systems and do not require additional computation, which makes this a very cheap method to detect problems. We shall see that on the basis of the previous and the current word graph and the six most recent system question types, communication problems can be detected with an accuracy of 91%, which is a significant improvement over the relevant baseline. This shows that spoken dialogue systems may use these features to better predict whether the ongoing dialogue is problematic. In addition, the current work is interesting from a machine learning perspective. We apply two machine learning techniques: the memory-based IB1-IG algorithm (Aha et al. 1991 , Daelemans et al. 1997 ) and the RIPPER rule induction algorithm (Cohen 1996) . As we shall see, some interesting differences between the two approaches arise. Related work Recently there has been an increased interest in developing automatic methods to detect problematic dialogue situations using machine learning techniques. For instance, Litman et al. (1999) and Walker et al. (2000a) use RIPPER (Cohen 1996) to classify problematic and unproblematic dialogues. Following up on this, Walker et al. (2000b) aim at detecting problems at the utterance level, based on data obtained with AT&Ts How May I Help You (HMIHY) system (Gorin et al. 1997 ). Walker and co-workers apply RIPPER to 43 features which are automatically generated by three modules of the HMIHY system, namely the speech recognizer (ASR), the natural language understanding module (NLU) and the dialogue manager (DM). The best result is obtained using all features: communication problems are detected with an accuracy of 86%, a precision of 83% and a recall of 75%. It should be noted that the NLU features play first fiddle among the set of all features. In fact, using only the NLU features performs comparable to using all features. Walker et al. (2000b) also briefly compare the performance of RIPPER with some other machine learning approaches, and show that it performs comparable to a memory-based (instance-based) learning algorithm (IB, see Aha et al. 1991) . The results which Walker and co-workers describe show that it is possible to automatically detect communication problems in the HMIHY system, using machine learning techniques. Their approach also raises a number of interesting followup questions, some concerned with problem detection, others with the use of machine learning techniques. (1) Walker et al. train their classifier on a large set of features, and show that the set of features produced by the NLU module are the most important ones. However, this leaves an important general question unanswered, namely which particular features contribute to what extent? (2) Moreover, the set of features which the NLU module produces appear to be rather specific to the HMIHY system and indicate things like the percentage of the input covered by the relevant grammar fragment, the presence or absence of context shifts, and the semantic diversity of subsequent utterances. Many current day spoken dialogue systems do not have such a sophisticated NLU module, and consequently it is unlikely that they have access to these kinds of features. In sum, it is uncertain whether other spoken dialogue systems can benefit from the findings described by Walker et al. (2000b) The current paper uses a similar methodology for on-line problem detection as Walker et al. (2000b) , but (1) we take a bottom-up approach, focussing on a small number of features and investigating their usefulness on a per-feature basis and ( 2 ) the features which we study are automatically available in the majority of current spoken dialogue system: the sequence of system question types and the word graphs corresponding to the respective user utterances. A word graph is a lattice of word hypotheses, and we conjecture that various features which have been shown to cue communication problems (prosodic, linguistic and ASR features, see e.g., Hirschberg et al. 1999 , Krahmer et al. 1999 and Swerts et al. 2000) have correlates in the word graph. The sequence of system question types is taken to model the dialogue history. Finally, (3) to gain further insight into the adequacy of various machine learn-ing techniques for problem detection we use both RIPPER and the memory-based IB1-IG algorithm. Approach Data and Labeling The corpus we used consisted of 3739 question-answer pairs, taken from 444 complete dialogues. The dialogues consist of users interacting with a Dutch spoken dialogue system which provides information about train time tables. The system prompts the user for unknown slots, such as departure station, arrival station, date, etc., in a series of questions. The system uses a combination of implicit and explicit verification strategies. The data were annotated with a highly limited set of labels. In particular, the kind of system question and whether the reply of the user gave rise to communication problems or not. The latter feature is the one to be predicted. The following labels are used for the system questions. O open questions (\"From where to where do you want to travel?\") I implicit verification (\"When do you want to travel from Tilburg to Schiphol Airport?\") E explicit verification (\"So you want to travel from Tilburg to Schiphol Airport?\") Y yes/no question (\"Do you want me to repeat the connection?\") M Meta-questions (\"Can you please correct me?\") The difference between an explicit verification and a yes/no question is that the former but not the latter is aimed at checking whether what the system understood or assumed corresponds with what the user wants. If the current system question is a repetition of the previous question it asked, this is indicated by the suffix R. A question only counts as a repetition when it has the same contents as the previous system question. Of the user inputs, we only labeled whether they gave rise to a communication problem or not. A communication problem arises when the value which the system assigns to a particular slot (departure station, date, etc.) does not coincide with the value given for that particular slot by the user in his or her most recent contribution to the dialogue or when the system makes an incorrect default assumption (e.g., the dialogue manager assumes that the date slot should be filled with the current date, i.e., that the user wants to travel today). Communication problems are generally easy to label since the spoken dialogue system under consideration here always provides direct feedback (via verification questions) about what it believes the user intends. Consider the following exchange. U: I want to go to Amsterdam. S: So you want to go to Rotterdam? As soon as the user hears the explicit verification question of the system, it will be clear that his or her last turn was misunderstood. The problemfeature was labeled by two of the authors to avoid labeling errors. Differences between the two annotators were infrequent and could always easily be resolved. Baselines Of the 3739 user utterances 1564 gave rise to communication problems (an error rate of 41.8%). The majority class is thus formed by the unproblematic user utterances, which form 58.2% of all user utterances. This suggests that the baseline for predicting communication problems is obtained by always predicting that there are no communication problems. This strategy has an accuracy of 58.2%, and a recall of 0% (all problems are missed).T he precision is not defined,\u00a9 and consequently neither is the \u00a8. This baseline is misleading, however, when we are interested in predicting whether the previous user utterance gave rise to communication problems. There are cases when the dialogue system is itself clearly aware of communication problems. This is in particular the case when the system repeats the question (labeled with the suffix R) or when it asks a metaquestion (M). In the corpus under investigation here this happens 1024 times. It would not be For definitions of accuracy, precision and recall see e.g., Manning and Sch\u00fctze (1999:268-269) . Since 0 cases are selected, one would have to divide by 0 to determine precision for this baseline. Throughout this paper we use the ! #\" measure (van Rijsbergen 1979:174) to combine precision and recall in a single measure. By setting $ equal to 1, precision and recall are given an equal weight, and the measure simplifies to % '& ) ( 10 32 4& 65 7( ) very illuminating to develop an automatic error detector which detects only those problems that the system was already aware of. Therefore we take the following as our base-line strategy for predicting whether the previous user utterance gave rise to problems, henceforth referred to as the system-knows-baseline: if the Q(@ ) is repetition or meta-question, then predict user utterance @ -1 caused problems, else predict user utterance @ -1 caused no problems. This 'strategy' predicts problems with an accuracy of 85.6% (1024 of the 1564 problems are detected, thus 540 of 3739 decisions are wrong), a precision of 100% (of 1024 predicted problems 1024 were indeed problematic), a recall of 65.5% (1024 of the 1564 problems are predicted to be problematic) and thus an A B \u00a8of 79.1. This is a sharp baseline, but for predicting whether the previous user utterance caused problems or not the system-knows-baseline is much more informative and relevant than the majority-classbaseline. Table 1 summarizes the baselines. Feature representations Question-answer pairs were represented as feature vectors (or patterns) of the following form. Six features were reserved for the history of system questions asked so far in the current dialogue (6Q). Of course, if the system only asked 3 questions so far, only 3 types of system questions are stored in memory and the remaining three features for system question are not assigned a value. The representation of the user's answer is derived from the word graph produced by the ASR module. It should be kept in mind that in general the word graph is much more complex than the recognized string. The latter typically is the most plausible path (e.g., on the basis of acoustic confidence scores) in the word graph, which itself may contain many other paths. Different systems determine the plausibility of paths in the word graph in different ways. Here, for the sake of generality, we abstract over such differences and simply represent a word graph as a Bag of Words (BoW), collecting all words that occur in one of the paths, irrespective of the associated acoustic confidence score. A lexicon was derived of all the words and phrases that occurred in the corpus. Each word graph is represented as a sequence of bits, where the C -th bit is set to 1 if the C -th word in the pre-derived lexicon occurred at least once in the word graph corresponding to the current user utterance and 0 otherwise. Finally, for each user utterance, a feature is reserved for indicating whether it gave rise to communication problems or not. This latter feature is the one to be predicted. There are basically two approaches for detecting communication problems. One is to try to decide on the basis of the current user utterance whether it will be recognized and interpreted correctly or not. The other approach uses the current user utterance to determine whether the processing of the previous user utterance gave rise to communication problems. This approach is based on the assumption that users give feedback on communication problems when they notice that the system misunderstood their previous input. In this study, eight prediction tasks have been defined: the first three are concerned with predicting whether the current user input will cause problems, and naturally, for these three tasks, the majority-class-baseline is the relevant one; the last five tasks are concerned with predicting whether the previous user utterance caused problems, and for these the sharp, system-knows-baseline is the appropriate one. The eight tasks are: (1) predict on the basis of the (representation of the) current word graph BoW @ whether the current user utterance (at time @ ) will cause a communication problem, (2) predict on the basis of the six most recent system question types up to @ (6Q @ ), whether the current user utterance will cause a communication problem, (3) predict on the basis of both BoW @ and 6Q @ , whether the current user utterance will cause a problem, (4) predict on the basis of the current word graph BoW @ , whether the previous user utterance, uttered at time @ -1, caused a problem, (5) predict on the basis of the six most recent system questions, whether the previous user utterance caused a problem, (6) predict on the basis of BoW @ and 6Q @ , whether the previous user utterance caused a problem, (7) predict on the basis of the two most recent word graphs, BoW @ -1 and BoW @ , whether the previous user utterance caused a problem, and finally (8) predict on the basis of the two most recent word graphs, BoW @ -1 and BoW @ , and the six most recent system question types 6Q @ , whether the previous user utterance caused a problem. Learning techniques For the experiments we used the rule-induction algorithm RIPPER (Cohen 1996) and the memory-based IB1-IG algorithm (Aha et al. 1991 , Daelemans et al. 1997 ).D RIPPER is a fast rule induction algorithm. It starts with splitting the training set in two. On the basis of one half, it induces rules in a straightforward way (roughly, by trying to maximize coverage for each rule), with potential overfitting. When the induced rules classify instances in the other half below a certain threshold, they are not stored. Rules are induced per class. By default the ordering is from low-frequency classes to high frequency ones, leaving the most frequent class as the default rule, which is generally beneficial for the size of the rule set. The memory-based IB1-IG algorithm is one of the primary memory-based learning algorithms. Memory-based learning techniques can be characterized by the fact that they store a representation of a set of training data in memory, and classify new instances by looking for the most similar instances in memory. The most basic distance function between two features is the overlap metric in (1), where E GF IH QP SR 6T is the distance between patterns H and R (both consisting of U features) and V is the distance between the features. If H is the test-case, the E measure determines which group W of cases R in memory is the most similar to H . The most frequent value for the relevant X We used the TiMBL software package, version 3 (Daelemans et al. 2000) to run the IB1-IG experiments. category in W is the predicted value for H . Usually, W is set to 1. Since some features are more important than others, a weighting function Y a`is used. Here Y a`is the gain ratio measure. In sum, the weighted distance between vectors H and R of length U is determined by the following equation, where V !F cb d\u00e8P Sf gT gives a point-wise distance between features which is 1 if b d\u00ech p f `and 0 otherwise. E GF IH qP SR rT p s t ` \u00a8V uF cb v\u00a4P Sf \u1e81T (1) Both learning techniques were used for the same 8 prediction tasks, and received exactly the same feature vectors as input. All experiments were performed using ten-fold cross-validation, which yields errors margins in the predictions. Results First we look at the results obtained with the IB1-IG algorithm (see Table 2 ). Consider the problem of predicting whether the current user utterance will cause problems. Either looking at the current word graph (BoW @ ), at the six most recent system questions (6Q @ ) or at both, leads to a significant improvement with respect to the majorityclass-baseline.x The best results are obtained with only the system question types (although the difference with the results for the other two tasks is not significant): a 63.7% accuracy and an \u00f6f 58.3. However, even though this is a significant improvement over the majority-class-baseline, the accuracy is improved with only 5.5%.y Next consider the problem of predicting whether the previous user utterance caused communication problems (these are the five remaining tasks). The best result is obtained by taking the two most recent word graphs and the six most recent system question types as input. This yields an accuracy of 88.1%, which is a significant improvement with respect to the All checks for significance were performed with a onetailed test. As an aside, we performed one experiment with the words in the actual, transcribed user utterance at time instead of BoW , where the task is to predict whether the current user utterance would cause a communication problem. This resulted in an accuracy of 64.2% (with a standard deviation of 1.1%). This is not significantly better than the result obtained with the BoW. problem @ -1 82.49 2.0 85.69 3.8 69.69 3.7 76.69 3.5 BoW @ + 6Q @ problem @ -1 87.39 1.1 85.59 2.8 83.99 1.3 84.79 1.3 BoW @ -1 + BoW @ problem @ -1 73.59 1.7 69.89 3.8 64.69 2.3 67.09 2.3 BoW @ -1 + BoW @ + 6Q @ problem @ -1 88. BoW @ -1 + BoW @ problem @ -1 76.79 2.6 \u00a2 74.79 3.6 66.09 5.7 69.99 3.8 BoW @ -1 + BoW @ + 6Q @ problem @ -1 91.19 1.1 \u00a3 \u00a2 92.69 2.0 85.79 2.9 89.09 1.5 Table 3 : RIPPER results (accuracy, precision, recall, and A B \u00a8, with standard deviations) on the eight prediction tasks. : this accuracy significantly improves the majority-class-baseline ( B ). : this accuracy significantly improves the system-knows-baseline ( B ). : this accuracy result is significantly better than the IB1-IG result given in Table 2 for this particular task, with .05. \u00a2 : this accuracy result is significantly better than the IB1-IG result given in Table 2 for this particular task, with .001. \u00a6 : this accuracy result is significantly better than the IB1-IG result given in Table 2 for this particular task, with q .01. sharp, system-knows-baseline. In addition, the A B \u00a8of 84.8 is nearly 6 points higher than that of the relevant, majority-class baseline. The results obtained with RIPPER are shown in Table 3 . On the problem of predicting whether the current user utterance will cause a problem, RIPPER obtains the best results by taking as input both the current word graph and the types of the six most recent system questions, predicting problems with an accuracy of 66.0%. This is a significant improvement over the majority-class-baseline, but the result is not significantly better than that obtained with either the word graph or the system questions in isolation. Interestingly, the result is significantly better than the results for IB1-IG on the same task. On the problem of predicting whether the previous user utterance caused a problem, RIPPER obtains the best results by taking all features into account (that is: the two most recent bags of words and the six system questions). This results in a 91.1% accuracy, which is a significant improvement over the sharp system-knows-baseline. This implies that 38% of the communication problems which were not detected by the dialogue system d Notice that RIPPER sometimes performs below the system-knows-baseline, even though the relevant feature (in particular the type of the last system question) is present. Inspection of the RIPPER rules obtained by training only on 6Q reveals that RIPPER learns a slightly suboptimal rule set, thereby misclassifying 10 instances on average. Figure 1 : RIPPER rule set for predicting whether user utterance @ -1 caused communication problems on the basis of the Bags of Words for @ and @ -1, and the six most recent system questions. Based on the entire data set. The question features are defined in section 2. The word \"naar\" is Dutch for to, \"om\" for at, \"uur\" for hour, \"van\" for from, \"vanuit\" is slightly archaic variant of \"van\" (from), \"ik\" is Dutch for I, \"nee\" for no, \"niet\" for not and \"wil\", finally, for want. The (U /i ) numbers at the end of each line indicate how many correct (U ) and incorrect (i ) decisions were taken using this particular if ...then ...statement. under investigation could be classified correctly using features which were already present in the system (word graphs and system question types). Moreover, the \u00a8is 89, which is 10 points higher than the B \u00a8associated with the systemknows baseline strategy. Notice also that this RIP-PER result is significantly better than the IB1-IG results for the same task. To gain insight into the rules learned by RIP-PER for the last task, we applied RIPPER to the complete data set. The rules induced are displayed in Figure 1 . RIPPER's first rule is concerned with repeated questions (compare with the system-knows-baseline). One important property of many other rules is that they explicitly combine pieces of information from the three main sources of information (the system questions, the current word graph and the previous word graph). Moreover, it is interesting to note that the words which crop up in the RIPPER rules are primarily function words. Another noteworthy feature of the RIPPER rules is that they reflect certain properties which have been claimed to cue communication problems. For instance, Krahmer et al. (1999) , in their descriptive analysis of dialogue problems, found that repeated material is often an indication of problems, as is the use of a marked vocabulary. The rules 2, 3 and 7 are examples of the former cue, while the occurrence of the somewhat archaic \"vanuit\" instead of the ordinary \"van\" is an example of the latter. Discussion In this study we have looked at automatic methods for problem detection using simple features which are available in the vast majority of spoken dialogue systems, and require little or no computational overhead. We have investigated two approaches to problem detection. The first approach is aimed at testing whether a user utterance, captured in a noisyj word graph, and/or the recent history of system utterances, would be predictive of whether the utterance itself would be misrecognised. The results, which basically represents a signal quality test, show that problematic cases could be discerned with an accuracy of about 65%. Although this is somewhat above the baseline of 58% decision accuracy when no problems would be predicted, signalling recognition problems with word graph features and previous system question types as predictors is a hard task. As other studies suggest (e.g., Hirschberg et al. 1999) , confidence scores and acoustic/prosodic features could be of help. The second approach tested whether the word graph for the current user utterance and/or the recent history of system question types could be employed to predict whether the previous user k In the sense that it is not a perfect image of the users input. utterance caused communication problems. The underlying assumption is that users will signal problems as soon as they become aware of them through the feedback provided by the system. Thus, in a sense, this second approach represents a noisy channel filtering task: the current utterance has to be decoded as signalling a problem or not. As the results show, this task can be performed at a surprisingly high level: about 91% decision accuracy (which is an error reduction of 38%), with an A B \u00a8of the problem category of 89. This result can only be obtained using a combination of features; neither the word graph features in isolation nor the system question types in isolation offer enough predictive power to reach above the sharp baseline of 86% accuracy and an A B \u00a8on the problem category of 79. Keeping information sources isolated or combining them directly influences the relative performances of the memory-based IB1-IG algorithm versus the RIPPER rule induction algorithm. When features are of the same type, accuracies of the memory-based and the ruleinduction systems do not differ significantly (with one exception). In contrast, when features from different sources (e.g., words in the word graph and question type features) are combined, RIPPER profits more than IB1-IG does, causing RIPPER to perform significantly more accurately. The feature independence assumption of memory-based learning appears to be the harming cause: by its definition, IB1-IG does not give extra weight to apparently relevant interactions of feature values from different sources. In contrast, in nine out of the twelve rules that RIPPER produces, word graph features and system questions type features are explicitly integrated as joint left-hand side conditions. The current results show that for on-line detection of communication problems at the utterance level it is already beneficial to pay attention only to the lexical information in the word graph and the sequence of system question types, features which are present in most spoken dialogue system and which can be obtained with little or no computational overhead. An approach to automatic problem detection is potentially very useful for spoken dialogue systems, since it gives a quantitative criterion for, for instance, changing the dia-logue strategy (initiative, verification) or speech recognition engine (from one trained on normal speech to one trained on hyperarticulate speech).",
    "abstract": "We address the issue of on-line detection of communication problems in spoken dialogue systems. The usefulness is investigated of the sequence of system question types and the word graphs corresponding to the respective user utterances. By applying both ruleinduction and memory-based learning techniques to data obtained with a Dutch train time-table information system, the current paper demonstrates that the aforementioned features indeed lead to a method for problem detection that performs significantly above baseline. The results are interesting from a dialogue perspective since they employ features that are present in the majority of spoken dialogue systems and can be obtained with little or no computational overhead. The results are interesting from a machine learning perspective, since they show that the rule-based method performs significantly better than the memory-based method, because the former is better capable of representing interactions between features.",
    "countries": [
        "Netherlands"
    ],
    "languages": [
        "Dutch"
    ],
    "numcitedby": "35",
    "year": "2001",
    "month": "July",
    "title": "Detecting Problematic Turns in Human-Machine Interactions: Rule-induction Versus Memory-based Learning Approaches"
}