{
    "article": "The paper introduces an LR-based algorithm for efficient phrase structure parsing of morphologically rich languages. The algorithm generalizes lexicalized parsing (Collins, 2003) by allowing a structured representation of the lexical items. Together with a discriminative weighting component (Collins, 2002) , we show that this representation allows us to achieve state of the art accurracy results on a morphologically rich language such as French while achieving more efficient parsing times than the state of the art parsers on the French data set. A comparison with English, a lexically poor language, is also provided. Introduction The paper provides a phrase structure parsing algorithm inspired by LR (Knuth, 1965) , GLR (Tomita, 1988) and the recent developments of (Huang and Sagae, 2010) for dependency grammar. The parsing algorithm comes with a discriminative weighting framework inspired by (Collins, 2002) . Although discriminative phrase structure parsing has been shown to be challenging when it comes to efficiency issues (Turian and Melamed, 2006; Finkel et al., 2008) , we use here several approximations that make the framework not only tractable but also efficient and accurate on a lexically rich language such as French. Despite the successes of dependency grammar, we are interested in phrase structure grammar since it naturally allows to support compositional semantic representations as recently highlighted by (Socher et al., 2012) . It remains that most phrase structure parsers have been designed in priority for modelling lexically poor languages such as English or Chinese (Collins, 2003; Charniak, 2000; Zhu et al., 2013) . Although highly accurate multilingual parsers exist (Petrov et al., 2006) , they remain relatively both slow for wide coverage purposes and their inner formal structure is not designed to handle naturally morphological information. We assume that parsing lexically rich languages benefits from taking into account the structured morphological information that can be extracted from lexical forms. Using French as a case study we show that we can reach both parsing efficiency with an approximative inference method and we can get a state of the art accurracy by generalizing lexicalized parsing to handle feature structure-based word representations. Our proposal also differs theoretically from related ones (Sagae and Lavie, 2006; Zhang and Clark, 2011; Zhu et al., 2013) by explicitly using an LR automaton. The explicit introduction of the LR automaton allows us to establish a formal difference between shift reduce phrase structure parsing and shift reduce dependency parsing. It further provides some insights on the nature of the grammar underlying many contemporary parsers. The paper is organized as follows. First, section 2, we set up a formal framework for describing weighted phrase structure parsing as a 2-LCFG (Nederhof and Satta, 2010) . Observing that the tree structures are actually constrained in practice we formulate in section 3 an LR automaton construction method for treebank grammars suitable for encoding these constraints. We then provide in section 4 a description of the algorithm and its components. Section 5 give an extension to 2-LCFG suitable for parsing morphologically rich languages and meeting common practical requirements. The whole framework is then evaluated in section 6 on French and English allowing to better identify its properties with respects to the state of the art. Grammatical representation The first step we consider is the grammar actually used for parsing and how it is generated. We suppose here a bilexical context free grammar or 2-LCFG (Nederhof and Satta, 2010) . A 2-LCFG is a CFG whose rules are of the form given in Figure 1 (left). Symbols of the form x and h denote terminal symbols while symbols of the form A[h] or A[x] denote lexicalized non terminals. A, B, C are non lexicalized non terminals and h denotes a head. A 2-LCFG rule is typically of the form N P [cat] \u2192 D[a] N [cat] . For practical robust parsing, 2-LCFG are grammars with a very large number of rules generated dynamically at runtime (Section 4). Most of the static grammatical preprocessing involved for the generation of an LR automaton only applies to the underlying delexicalized 2-CFG by ignoring lexical annotation symbols. The first step towards robust parsing thus requires to generate a grammar suitable for this purpose. In our case, the grammar is a treebank grammar and since most treebanks do encode trees with variable branching arities we must transform it to match the 2-LCFG required pattern. The first step amounts to apply an order 0 head markovization (Collins, 2003) which is followed by a reduction of unary rules. Both transformations guarantee that the trees do follow strictly a Chomsky Normal Form (CNF). Trees in CNF have two properties of interest. First, one can show by induction that they can be generated with a constant number of derivation steps \u03b7 for a sentence of length n : \u03b7 = 2n\u22121. This property is in principle critical for the comparison of weighted parsing hypotheses (Section 5) and explains why we use 2-LCFG as a grammatical representation in the first place. Second, the binarization (markovization) procedure also introduces temporary symbols we consider to be different from other non terminal symbols. These temporary symbols are further constraining the tree structure. Using ':' to denote a temporary symbol in Figure 1 (right), we observe for instance that the root of a tree cannot be temporary and two siblings cannot be temporaries either. By contrast, arc standard dependency parsers such as the one of (Huang and Sagae, 2010) do verify the first property while the second property is irrelevant in that case. A[h] \u2192 B[h] C[x] A[h] \u2192 B[x] C[h] A[h] \u2192 h LR automaton construction We use an LR automaton to enforce the parser to generate parse trees satisfying the above mentioned structural constraints. Although, other proposals such as (Sagae and Lavie, 2006) apparently returns a failure when the parser generates invalid trees and (Zhu et al., 2013) apparently handles the problem with local constraints preventing the parser to generate invalid configurations, we use here an LR(0) automaton to ensure that the parser globally enforces these constraints. This seemed to us theoretically justified, easier to generalize (Section 6) and easier to implement. As such, a traditional LR(0) parser (Knuth, 1965) is not suited for parsing natural language: it aims to statically eliminate ambiguity from the grammar. Here, following (Tomita, 1985) the LR tables are built without trying to resolve conflicts. Instead the conflicts are kept and determinism is brought by a weighting component. The use of LR(0) tables aims to ensure that the parser actually generates valid parse derivations. In this case, the generation of the derivations requires to constrain the underlying 2-CFG grammar with respects to temporary symbols. This being said, building an LR(0) automaton for robust treebank grammars raise two issues. The first is inductive, a grammar read off from a treebank is not guaranteed to be robust and to generalize to other text, since a treebank remains a finite sample of language. The second is practical : traditional LR(0) compilation methods involve the determinisation of the LR NFA which is exponential in the number n of states of this NFA. In case of very large ambiguous treebank grammars n is very large and the compilation becomes intractable (Briscoe and Carroll, 1993) . These two observations lead us to design this automata by the following construction. First, let \u03a3 be the set of non terminal symbols read off from the treebank, T be the set of temporaries introduced by binarization and N the set of non temporary symbols such that \u03a3 = N \u222a T and N \u2229 T = \u2205. Second we note W the set of terminal symbols extracted from the treebank and A \u2208 N the unique axiom of this grammar. We then partition \u03a3 with the following set of equivalence classes: [a] = {A}, [t] = T and [n] = \u03a3 \u2212 (T \u222a A). For convenience we also note [w] = W . Given these equivalence classes, we define the matrix grammar G m = \u03a3 m , [w], [a], R m (where \u03a3 m = {[a], [n], [t]}). The rules R m of G m are then designed to enforce the above mentioned tree well formedness constraints. Some possible such rules are given in Table 1 using ID/LP notation (Gazdar et al., 1985) .In other words, an immediate dominance rule of the form a \u2192 b , c is expanded as two rules a \u2192 b c and a \u2192 c b. Such a grammar allows to enforce the above-mentioned constraints, it is also small and it is robust : L(G m ) = [w]+. We can then very easily build a deterministic LR(0 (Aho et al., 2006) . From this automaton we can then efficiently generate an expanded automaton (Sagae and Lavie, 2006) . In short S denotes the shift action, RU (X) denotes an unary reduction by terminal X, RL(X) denotes a binary reduction by terminal X with left symbol marked as head, and RR(X) denotes a binary reduction by terminal X with right symbol marked as head. By contrast with a classical LR action set, we extract the actions RL(X) and RR(X) from a state q \u2208 Q if we have an LR item of the form X \u2192 A B\u2022 without requiring that X \u2192 B A\u2022 \u2208 q. This simplification, mirrorring that of (Sagae and Lavie, 2006) , reduces the number of actions, eases learning and makes parsing more efficient. This being said, the matrix grammar G m given in Table 1 is not the only one possible (see also section 6). A valid rule set must enforce tree well formedness constraints by building upon a partition of \u03a3 in equivalence classes. On the other hand the action set A defined here implies that for every rule R \u2208 R m of the form [a] \u2192 [n] , [t] [n] \u2192 [n] , [t] [t] \u2192 [n] , [t] [a] \u2192 [n] , [n] [n] \u2192 [n] , [n] [t] \u2192 [n] , [n] [a] \u2192 [w] [n] \u2192 [w] ) automaton A m = \u03a3 m \u222a {[w]}, Q, i, F, E m with classical methods A exp = {\u03a3 \u222a W }, Q, i, F, E where E = {(q, a, q ) | (q, [x], q ) \u2208 E m , \u2200a \u2208 [x]}. In order to read off the LR(0) table from A exp , we consider the set of actions A def = {RL(X)|X \u2208 \u03a3} \u222a {RR(X)|X \u2208 \u03a3} \u222a {RU (X)|X \u2208 \u03a3} \u222a {S} first introduced by [x] \u2192 [y] [z] there is a rule R \u2208 R m of the form [x] \u2192 [z] [y]. That is why we formulate the rules R m with ID/LP notation and this also means that we cannot express any word ordering constraint with this grammar. This last property is actually shared by many robust parsers. Discriminative LR-based parsing The LR tables being built by preserving conflicts, determinism is achieved by a weighting component derived from the global perceptron described by (Collins, 2002) . We start by describing the weighted parsing procedure before turning our attention to the weight estimation problem. We assume that an LR(0) The algorithm relies on two data structures: a stack S and a queue. The stack S = . . . |s 2 |s 1 |s 0 has s 0 for topmost element. A node s i = \u03c3, \u03c4 in the stack is a couple where \u03c3 is an LR state number and \u03c4 = (s i .c t [s i .w t ] s i .c l [s i .w l ] s i .c r [s i .w r ]) encodes a local tree of depth 1. s i .c t , s i .c l , s i .c r denote the root left child and right child categories of tree and s i .w t , s i .w l , s i .w r denote the root, the left child and right child terminals of this tree such that a node s i .c \u2022 [s i .w \u2022 ] denotes a non terminal 2-LCFG symbol at node s i in the stack. The queue is static and initially filled up with the sequence of tokens to be parsed: ITEM j, S : w INIT 1, \u03c3 i , : 0 GOAL n + 1, \u03c3 e , \u03c4 : w SHIFT j,S | s 0 = \u03c3,_ :w j+1,S | s 0 | GOTO(t j ,\u03c3), (t j [t j ] _ _) : w+F (S, j,S ) RL(X) j,S | s 2 = \u03c3 2 ,_ :w 2 | s 1 = \u03c3 1 ,(s 1 .ct[s 1 .wt] _ _) :w 1 | s 0 = \u03c3 0 ,(s 0 .ct[s 0 .wt] _ _) :w 0 j,S | s 2 | GOTO(X,\u03c3 2 ),(X[s 1 .wt] s 1 .ct[s 1 .wt] s 0 .ct[s 0 .wt]) :w 0 +F (RL(X), j,S ) RR(X) j,S | s 2 = \u03c3 2 ,_ :w 2 | s 1 = \u03c3 1 ,(s 1 .ct[s 1 .wt] _ _) :w 1 | s 0 = \u03c3 0 ,(s 0 .ct[s 0 .wt] _ _) :w 0 j,S | s 2 | GOTO(X,\u03c3 2 ),(X[s 0 .wt] s 1 .ct[s 1 .wt] s 0 .ct[s 0 .wt]) :w 0 +F (RR(X), j,S ) RU(X) j,S | s 1 = \u03c3 1 ,(s 1 .ct[s 1 .wt] _ _) | s 0 = \u03c3 0 ,(s 0 .ct[s 0 .wt] _ _) :w 0 j,S | s 1 | GOTO(X,\u03c3 1 ),(X[s 0 .wt] s 0 .ct[s 0 .wt]) :w 0 +F (RU (X), j,S ) GR j,S | s 1 = \u03c3 1 ,(s 1 .ct[s 1 .wt] _ _) | s 0 = \u03c3 0 ,(s 0 .ct[s 0 .wt] _ _) :w 0 j,S | s 1 | GOTO(GR,\u03c3 1 ),(s 0 .ct[s 0 .wt] _ _) :w 0 +F (GR, j,S ) (Rule introduced in section 5) Figure 2 : Actions as inference rules in extended deductive notation T = t 1 . . . t n . Parsing is performed by generating sequentially configurations C i = j, S where S is a stack and j the index of the first element of the queue. Given an initial configuration C 0 = 1, \u03c3 i , , a derivation step C i\u22121 a i\u22121 \u21d2 C i generates a new configuration C i = j , S provided a configuration C i\u22121 = j, S | \u03c3, \u03c4 by applying the action a i\u22121 \u2208 ACTION(\u03c3, t j ). A k\u2212step derivation sequence C 0\u21d2k is a sequence of derivation steps such that C 0 a 0 \u21d2 . . . a k\u22121 \u21d2 C k . A derivation sequence is finished when the configuration C 3n\u22121 = n + 1, \u03c3, \u03c4 is generated 1 . If \u03c3 = \u03c3 e then the derivation is a success, otherwise it is a failure. A derivation is also finished when ACTION(\u03c3, t j ) = \u2205 for a configuration C k = \u03c3, t j which is another case of failure. The actions detailed in Figure 2 using extended deductive notation are responsible for modifying the stack and updating LR states. The shift action, SHIFT, thus pushes onto the stack a local tree rooted by the category of the next token in the queue. The reduce left RL(X) and the reduce right RR(X) actions pop the top two elements from the stack and push a new element of category X[w] on top of it. The two actions differ only by the way the head w is assigned: RL(X) chooses w to be X's left child head word while RR(X) sets w to be X's right child head word. RU (X) is an unary reduction action that pops the stack top and pushes a new top element with category X whose head is its unique child head. By design of the automaton we ensure that RU (X) can only be applied after a shift reduction took place. In order to achieve disambiguation, a derivation sequence C 0\u21d2k = C 0 a 0 \u21d2 . . . a k\u22121 \u21d2 C k is also weighted by a function of the form: W (C 0\u21d2k ) = w \u2022 \u03a6 g (C 0\u21d2k ) = k\u22121 i=0 w \u2022 \u03a6(a i , C i ) that is the weight of a derivation sequence is given by an inner product that the parser approximates as a sum of inner products local to each derivation step. w \u2208 R d is a d-dimensional vector of weights and each \u03a6(a i , C i ) \u2208 {0, 1} d is a d-dimensional vector of feature functions in which every \u03c6 i has signature \u03c6 i (a, \u03ba, j). The values a and j denote an action and the current index of the head of the queue in T while \u03ba is a kernel vector similar to the one defined by (Huang and Sagae, 2010) . It summarizes information accessible from the stack for the purpose of feature function evaluation. Figure 3 illustrates the actual kernel vector used in this paper: together with j, the index of the first element in the queue, the kernel vector \u03ba is the set of values accessible to feature functions \u03c6 i (a, \u03ba, j) in the stack. As can be seen the stack stores local trees with instanciated 2-LCFG nodes labelled with the notation introduced in section 4. Since the score of a derivation is a sum of independent terms, the (prefix) weight w = W (C 0\u21d2k ) of a derivation sequence can be computed at each derivation step. This allows to store the (prefix) weight of this sequence on configurations such that a configuration has the extended form C k = j, S : w in the weighted case. We make explicit the actual prefix weight computation in Figure 2 by using the following abbreviation: For a given input sequence T , the parser is naturally non deterministic. Non determinism is introduced by the ACTION function which returns a set a \u2208 2 A of possible actions given the current configuration. In the nondeterministic case, we thus derive from a given derivation sequence F (a i , C i ) = w \u2022 \u03a6(a i , C i ). s0.ct[s0.wt] s0.cr[s0.wr] s0.c l [s0.w l ] s1.ct[s1.wt] s1.cr[s1.wr] s1.c l [s1.w l ] s2.ct[s2.wt] C 0\u21d2k\u22121 a set \u03b4(C 0\u21d2k\u22121 ) of k\u2212steps derivation sequences. If we let GEN k\u22121 (T ) be the set of derivation sequences at step k \u2212 1, the set of derivation sequences at step k is GEN k (T ) = C 0\u21d2k\u22121 \u2208GEN k\u22121 (T ) \u03b4(C 0\u21d2k\u22121 ). In this context, achieving deterministic parsing amounts to solve the following optimization problem: \u0108 = argmax C 0\u21d23n\u22121 \u2208GEN 3n\u22121 (T ) W (C 0\u21d23n\u22121 ) (1) Since in the worst case, the size of GEN k (T ) is |A| k , the search space has exponential size. Like (Zhu et al., 2013) , we use in this paper a beam search approximation. A beam GEN K k (T ) is a subset of size K of GEN k (T ). Provided a beam GEN K k\u22121 (T ) we build GEN K k (T ) with the fol- lowing recurrence: GEN K k (T ) = K-argmax C 0\u21d2k \u2208\u2206(GEN K k\u22121 (T )) W (C 0\u21d2k ) where \u2206(GEN K k\u22121 (T )) = C 0\u21d2k\u22121 \u2208GEN K k\u22121 (T ) \u03b4(C 0\u21d2k\u22121 ) , Using a beam aims to reduce complexity to O(K|A|(3n \u2212 1)) \u2248 O(n) and makes inference computationally tractable in practice. On the other hand it makes inference incomplete (the parser may fail to find a solution even if it exists) and does not guarantee the solution to be optimal. In other words, Equation 1 is replaced by an approximation: C = argmax C 0\u21d23n\u22121 \u2208GEN K 3n\u22121 (T ) W (C 0\u21d23n\u22121 ) (2) The weight estimation procedure is performed by the averaged percetron algorithm (Collins, 2002) . As pointed out by (Huang et al., 2012) using a beam introduces an approximation that can also harm the convergence of the learning procedure since we provide at each training iteration the approximative solution given by equation 2 instead of the exact solution to equation 1 expected in theory by the perceptron algorithm. To overcome the problem we perform updates on subderivation sequences. Let C (r) 0\u21d2k be a subderivation sequence at step k and let C (0) 0\u21d2k = argmax C 0\u21d2k \u2208GEN K k (T ) W (C 0\u21d2k ) be the best subderivation in the beam at step k. In this context the perceptron update has the form: w \u2190 w + \u03a6 g (C (r) 0\u21d2k ) \u2212 \u03a6 g (C (0) 0\u21d2k ) . We tested two methods for choosing k satisfying the weaker convergence criterions established by (Huang et al., 2012) : C (0) 0\u21d2k = C (r) 0\u21d2k and W (C (0) 0\u21d2k ) > W (C (r) 0\u21d2k ). If we let V = {k | C (0) 0\u21d2k = C (r) 0\u21d2k , W (C (0) 0\u21d2k ) > W (C (r) 0\u21d2k )}, then the early update method amounts to choose k = min k\u2208V k and the max violation update method amounts to choose k = argmax k\u2208V W (C (0) 0\u21d2k ) \u2212 W (C (r) 0\u21d2k ). Generalisations This section introduces two extensions to the algorithm meeting practical motivations: grammar relaxation and extended word representations. In practical cases, it may be convenient to interface the parser with a morphological tagger. In this case terminal symbols t 1 . . . t n are part of speech tags. Since grammar transformations introduced in section 2 can potentially modify the tagset and since enforcing a strict Chomsky normal form in this case makes little sense, we allow the trees to have structures such as the one given in Figure 4 . This kind of structure licences the following new patterns of 2-CFG rules: A \u2192 B t and A \u2192 t B where t denotes a terminal symbol (in this case a tag). These new rule patterns modify a property of 2-LCFG on which we relied so far, \u03b7 is now variable : n \u2212 1 \u2264 \u03b7 \u2264 2n \u2212 1. We observe that longer derivation sequences tend to have an higher weight. Indeed weights increase linearly with the length of the derivation sequence as illustrated in Figure 5 where the weights are averaged out of measurements made over the parses on the French development set described in Section 6. qq q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q q 0 10 20 Although weights can in principle be positive or negative, this apparently counter-intuitive behaviour is caused by the beam which keeps for further steps only the highest weighted configurations. To further study the behaviour of variable length sequences, we define two variants of the parser: first the 'naive' variant modifies the termination condition. Let S = {C 0\u21d2k |C k = n+1, \u03c3 e , \u03c4 , 2n\u22121 \u2264 k \u2264 3n\u22121}. In this context, equation 2 is reframed as: C = argmax C 0\u21d2k \u2208S W (C 0\u21d2k ) . A second version, called the 'synchronized version' introduces an additional inference rule called the Ghost Reduction and referred as GR in Figure 2 . A slight modification of the LR automaton construction, designed to trigger either an unary reduction action or a Ghost reduction after a shift allow us to enforce the property that \u03b7 = 3n \u2212 1 in this case too. The ghost reduction is designed to both make the parser 'wait' one step during derivation in case it chooses not to perform an unary reduction after shift and also to avoid modifying the content of the stack. The second extension allows terminals to be not only lexical tokens or part-of-speech tags but arbitrary tuples \u03c9. This allows to encode words with an arbitrary set of additional structured features such as their lemmas, gender, number, case, semantic representation. The exact nature of these additional features depends on the capacity of a parsing preprocessor to actually supply them. In this context the non terminal symbols of the 2-LCFG have thus the form A[\u03c9]. The fields of the tuples are then made accessible to feature functions. This extension is motivated by the hypothesis that parsing morphologically rich languages will benefit significantly from structured word representations, for instance allowing the parser to take advantage of morphology. We are now in position to describe the feature templates used by the parser (Figure 6 ). Before the dot s i and q i denote respectively the address in the stack and in the queue of the adressed node. t, l, r denote the top, left and right nodes of the local trees in the stack. After the dot w c , w f denote a category and a word form, while c is a constituent category. w m denote the mood of a verb and w X an refined category dubbed subcat in the French Treebank (Abeill\u00e9 et al., 2003) : these subcategories refine crude tags by encoding information such as the definiteness of a determiner, subtypes of adjectives etc. gen, num, agr s0t.wc & s0t.c s0t.w f & s1t.w f s0t.c & s1t.c & s2t.c s0t.c & q2.wc & q3.wc Agreement s0t.w f & s0t.c s0t.w f & s1t.c s0t.w f & s1t.c & s2t.c s0t.c & q2.w f & q3.wc s0tc & e(s0t.agr, s1t.agr) & s1t.c s1t.wc & s1t.c s0t.c & s1t.w f s0t.c & s1t.w f & q0.wc s0t.c & q2.wc & q3.w f s0tc & e(s0t.num, s1t.num) & s1t.c s1t.w f & s1t.c s0t.c & s1t.c s0t.c & s1t.c & s2t.w f s0t.c & s0r.c & s1t.c s0tc & e(s0t. Experiments The following experiments aim to identify the contribution of the components of the parser both to parsing accurracy and to parsing speed. Experiments are carried mainly on French. A final set of tests is also carried out on English in order to highlight the generality of the framework and to ease comparisons with other proposals. Protocol The experiments use the French SPMRL dataset (Seddah et al., 2013) which is newer and larger than datasets previously used for parsing French (Crabb\u00e9 and Candito, 2008) . It instanciates the full French Treebank described in (Abeill\u00e9 et al., 2003) and will surely become the new standard data set for parsing French in the next few years. We use this data set as is, with two scenarios: one with gold standard tags and the second with tags predicted by a 97.35% accurate tagger (Seddah et al., 2013) . The French data is head annotated with head rules provided by (Arun and Keller, 2005) . Additionally, compound word structures are systematically left headed. For English, we use the Penn Treebank with standard split: section 02-21 for training, section 22 for development and section 23 for test. The predicted scenario uses the MELT tagger (Denis and Sagot, 2012) with an accurracy of 97.1%. The head annotations have been inferred by aligning the phrase structure treebank with its dependency conversion described by (de Marneffe et al., 2006) . We use a C++ implementation of the algorithm described above for running the experiments. Scores reported for the Berkeley parser (Petrov et al., 2006) use the runs described by (Seddah et al., 2013) . F-score is measured with the classical evalb and times are measured on the same machine (MacOSX 2.4Ghz) and do not take into account input/output times for both parsers. Each experiment modifies a single experimental variable by contrast with a default parser configuration. The default parser configuration sets the beam size to K = 4 and uses the naive synchronisation procedure (Section 5). The LR automaton uses the grammar G (base) m (Figure 7 ) and the update method is early update (Section 4). The set of templates is given in Figure 6 except for English where agreement, mood and subcat are ignored since there is no morphology directly available. Experiment 1 This first experiment tests the impact of the beam size by running the parser with different sizes: K = 2, K = 4, K = 8, K = 16. Experiment 2 The second experiment contrasts the naive synchronisation (naive) with the ghost reduction synchronisation (sync) described in section 5. Experiment 3 This third experiment contrasts two different matrix grammars (Figure 7 ). This experiment aims to test whether we can take advantage of the LR automaton to better account for compound words encoded in the French data. To this end we designed two matrix grammars generating two different automata. In Figure 7 , the top left tree is an example of the representation of compound words in the French data set. The corresponding binary structure is given on bottom left. The general grammar G (base) m encodes a matrix grammar that does not specifically handle compound words and for which equivalence classes are [a] the axiom symbol, [n] non terminal symbols and [w] terminal symbols. Each temporary non terminal t \u2208 T yields its own equivalence class. The grammar G (cpd) m adds further equivalence classes: [n] cpd gathers non terminals marked as compounds (cpd) and is disjoint from [n], the non compound non terminals. T (cpd) gathers temporary symbols marked as compounds and is disjoint from T . From these two matrix grammar we generate two different LR automata with one of them encoding a specific subgrammar for compounds (cpd) while the other is a generic grammar (base).  Experiment 4 This experiment contrasts early update with max violation update. Max violation update is trained over 12 epochs, while early update is trained over 25 epochs [a] \u2192 [n] [n] [n] \u2192 [n] , [n] t \u2192 [n] , [n] (\u2200t \u2208 T ) [a] \u2192 [n] , [w] [n] \u2192 [n] , [w] t \u2192 [n] , [w] (\u2200t \u2208 T ) [a] \u2192 [w] [w] [n] \u2192 [w] , [w] t \u2192 [w] , [w] (\u2200t \u2208 T ) [a] \u2192 [w] [n] \u2192 [w] t \u2192 [n] , t (\u2200t \u2208 T ) [a] \u2192 [n] , t (\u2200t \u2208 T ) [n] \u2192 [n] , t (\u2200t \u2208 T ) t \u2192 [w] , t (\u2200t \u2208 T ) [a] \u2192 [w] , t (\u2200t \u2208 T ) [n] \u2192 [w] , t (\u2200t \u2208 T ) Additional immediate dominance rules for G cpd m [a] \u2192 [n] cpd , [n] [n] \u2192 [n] cpd , [n] t \u2192 [n] cpd , [n] (\u2200t \u2208 T ) [a] \u2192 [n] cpd , [n] cpd [n] \u2192 [n] cpd , [n] cpd t \u2192 [n] cpd , [n] cpd (\u2200t \u2208 T ) [a] \u2192 [n] cpd , [w] [n] \u2192 [n] cpd , [w] t \u2192 [n] cpd , [w] (\u2200t \u2208 T ) [a] \u2192 [n] cpd , t (\u2200t \u2208 T ) [n] \u2192 [n] cpd , t (\u2200t \u2208 T ) t \u2192 [n] cpd , t (\u2200t \u2208 T ) [n] cpd \u2192 [w] , [w] [n] cpd \u2192 t cpd , [w] (\u2200t cpd \u2208 T cpd ) t cpd \u2192 t cpd , [w] (\u2200t cpd \u2208 T cpd ) [n] cpd \u2192 [w] t cpd \u2192 [w] , [w] (\u2200t cpd \u2208 T cpd ) t cpd \u2192 [w] (\u2200t cpd \u2208 T cpd ) Experiment 5 This last experiment contrasts the use of morphology. We remove (no-morph) the templates under mood, agreement and subcategories in Figure 6 in order to assess their impact. Results Results with respect to accurracy are given in table 2 . Experiments are carried out on the development set with gold part of speech tags (Table 2 , left) and predicted part of speech tags (Table 2 , right). Experiment 1 The parser achieves its best result with a beam of size 8 (K = 8). Quite surprisingly it achieves already a very correct score with a beam of size 4. We observe that increasing the size of the beam does not proide significant improvements. Using beams of size 16 (or even 32) only bring marginal accurracy improvements, if any, at the expense of more important parsing times. Experiment 2 This second experiment is apparently more disappointing: synchronisation does not seem to play a significant role on accurracy, or a detrimental one if any. This effect seems caused by a property of the dataset. A more careful analysis of the parser error patterns shows that the parsing model naturally misses many unary reductions. Since the naive automaton is biased towards predicting longer sequences with higher weights, it somehow helps to favor longer derivations containing more unary reductions, hence improving the accurracy. Experiment 3 This experiment highlights the problems related to further constraining a parser with approximative search: we observe that parsing coverage is reduced. This can be explained by the fact that further constraining the grammar creates less success states in the automaton and that the parser sometimes has to perform less local decisions without all the necessary information available. This suggests for further work that a more constrained matrix grammar should be used with a more robust search strategy than simple beam search. Experiment 4 In experiment 4, we observe that max violation update converges twice as fast as early update but we experienced more overfitting problems explaining the lower scores. It is however harder to achieve fair comparisons since the number of iterations is significantly different. Experiment 5 This last experiment is probably the most significative. We observe that morphology is the variable that allows the parser to improve significantly on French (dev F=81.79). This result thus confirms those observed by (Hohensee and Bender, 2012) on several languages for dependency parsing, yet we had to isolate agreement, refined subcategories and verbal mood to get significant improvements (Figure 6 ). Final tests In order to compare this proposal with current state of the art parsers, we provide comparative measures of speed and accurracy with the Berkeley parser (Petrov et al., 2006) , known to be representative of the state of the art in accurracy and in speed on French and in accurracy on English (Table 3 ). Interestingly parsing the English dataset with templates designed on French data is almost state of the art on English (dev F=89.3, test F=89.1). This suggests that feature engineering is a less important issue than often thought and it also suggests that the parser is likely to be easy to adapt to other languages by generalizing the method used to parse English. Although the differences are modest, the parser is state of the art on French (F=81.43) if we compare with the Berkeley parser (F=80.73) known to be indicative of the state of the art on French (Seddah et al., 2013 ) and if we ignore ensemble and semi-supervised parsers. The most important difference is related to speed. (Petrov et al., 2006 ) is reported to be the fastest phrase structure parser for English by (Huang and Sagae, 2010) where the authors compare with (Charniak, 2000) . Yet (Petrov et al., 2006 ) is a polynomial time parser, while this one has linear time behaviour. We compared the speed of both parsers on the same hardware (ignoring input/output times) and we find (Petrov et al., 2006) has an average parse time of t \u00b5 = 0.28s with maximum t max = 10.27s while our linear time algorithm has mean time t \u00b5 = 0.06s and maximum t max = 0.1s with beam 4 and t \u00b5 = 0.1s, t max = 0.5s with beam 8 (Figure 8 ). Further constraining the automaton shows to be useful for speed, since for experiment 3, t \u00b5 = 0.04s with K = 4 which is clearly faster.  We finally observe on English that the LR strategy performs reasonably accurately and faster than the implementation of (Petrov et al., 2006) whereas optimisations of PCFG-LA described by (Bodenstab et al., 2011) are significantly less accurate and not significantly faster. Although it is currently hard to to compare directly on French with the most similar proposal, the Chinese/English parser described by (Zhu et al., 2013) , since it does not handle morphology. With respects to speed, their impressive result on English suggests that there is still room for speed improvements without loss of accurracy. Conclusion To our knowledge, this is the first formulation of a discriminative LR-automaton driven parser for natural language. This LR inspired algorithm shares many properties with shift reduce parsers for phrase structure grammar described by (Sagae and Lavie, 2006) and (Zhu et al., 2013) . (Sagae and Lavie, 2006) describe a first version of this kind of algorithm using a weighting system based on a local maximum entropy classifier. It thus enables them to use a best first search strategy that allows in principle to achieve near-optimal parsing. By contrast, like (Zhu et al., 2013) , we use here a global perceptron algorithm together with a beam based breadth first search to which we add an explicit LR component. The LR automaton allows us to guarantee that the parser generates a viable prefix. We believe the LR framework can also shed light on theoretical, practical and experimental issues related to phrase structure parsing by comparison with dependency parsing. However using the LR automaton to constrain the parsing model for multi-word expressions turns out to be disappointing since it forces the parser to take less local decisions for which the beam approximation is not well suited. This suggests for future work to explore search methods aiming to achieve optimality (Zhao et al., 2013) . Mirroring a common practice in dependency parsing, the parser also provides a first support for phrase structure parsing of morphologically rich languages thanks to structured word representations. The richer lexical structure makes morphological information available during the parsing process. For the case of French it enables, among others, to integrate agreement in the parsing model. This simple integration of morphology then allows the parser to achieve state of the art accurracy on French. Since in principle nothing in the algorithm is specific to French, we expect to generalize and experiment with the model on other morphologically rich languages. Further work for such languages is expected to involve a refinement of the interface with morphology along the lines of (Hatori et al., 2012; Bohnet et al., 2013) . Acknowledgements I am grateful to Maximin Coavoux who helped at some stages of the implementation. I am also grateful to Benoit Sagot for his encouragments and several discussions that helped to clarify the contents of this paper, and finally to Djam\u00e9 Seddah who brought his expertise with the actual data sets.",
    "abstract": "The paper introduces an LR-based algorithm for efficient phrase structure parsing of morphologically rich languages. The algorithm generalizes lexicalized parsing (Collins, 2003) by allowing a structured representation of the lexical items. Together with a discriminative weighting component (Collins, 2002) , we show that this representation allows us to achieve state of the art accurracy results on a morphologically rich language such as French while achieving more efficient parsing times than the state of the art parsers on the French data set. A comparison with English, a lexically poor language, is also provided.",
    "countries": [
        "France"
    ],
    "languages": [
        "French",
        "English"
    ],
    "numcitedby": "14",
    "year": "2014",
    "month": "August",
    "title": "An {LR}-inspired generalized lexicalized phrase structure parser"
}