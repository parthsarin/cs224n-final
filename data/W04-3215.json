{
    "article": "Accurate dependency recovery has recently been reported for a number of wide-coverage statistical parsers using Combinatory Categorial Grammar (CCG). However, overall figures give no indication of a parser's performance on specific constructions, nor how suitable a parser is for specific applications. In this paper we give a detailed evaluation of a CCG parser on object extraction dependencies found in WSJ text. We also show how the parser can be used to parse questions for Question Answering. The accuracy of the original parser on questions is very poor, and we propose a novel technique for porting the parser to a new domain, by creating new labelled data at the lexical category level only. Using a supertagger to assign categories to words, trained on the new data, leads to a dramatic increase in question parsing accuracy. Introduction Several wide-coverage statistical parsers have recently been developed for Combinatory Categorial Grammar (CCG; Steedman, 2000) and applied to the WSJ Penn Treebank (Clark et al., 2002; Hockenmaier and Steedman, 2002; Hockenmaier, 2003b; Clark and Curran, 2004b) . One motivation for using CCG is the recovery of the long-range dependencies inherent in phenomena such as coordination and extraction. Recovery of these dependencies is important for NLP tasks which require semantic interpretation and for processing text which contains a high frequency of such cases, e.g. Wh-questions fed to a Question Answering (QA) system. One shortcoming of treebank parsers such as Collins (1999) and Charniak (2000) is that they typically produce phrase-structure trees containing only local syntactic information. Johnson (2002) uses post-processing methods to insert \"empty\" nodes into the trees, and Dienes and Dubey (2003) use preprocessing methods to determine where discontinuities are likely to appear in the sentence. In contrast, the CCG parsers detect long-range dependencies as an integral part of the parsing process. The CCG parser used here (Clark and Curran, 2004b) is highly accurate and efficient, recovering labelled dependencies with an overall F-score of over 84% on WSJ text, and parsing up to 50 sentences per second. Thus the parser should be useful for large-scale NLP tasks. However, the overall accuracy figures give no indication of the parser's performance on specific constructions, nor how suitable the parser is for specific applications. In this paper we give a detailed evaluation for object extraction dependencies and show how the parser can be used to parse questions for QA. We find that the parser performs well on the object extraction cases found in the Penn Treebank, given the difficulty of the task. In contrast, the parser performs poorly on questions from TREC, due to the small number of questions in the Penn Treebank. This motivates the remainder of the paper, in which we describe the creation of new training data consisting of labelled questions. Crucially, the questions are labelled at the lexical category level only, and not at the derivation level, making the creation of new labelled data relatively easy. The parser uses a supertagger to assign lexical categories to words, and the supertagger can be adapted to the new question domain by training on the newly created data. We find that using the original parsing model with the new supertagger model dramatically increases parsing accuracy on TREC questions, producing a parser suitable for use in a QA system. For evaluation we focus on What questions used in the TREC competitions. As well as giving an overall evaluation on this test set, we also consider a number of object extraction cases. The creation of new training data at the lexical category level alone is a technique which could be used to rapidly port the parser to other domains. This technique may also be applicable to other lexicalised grammar formalisms, such as Tree Adjoining Grammar (Bangalore and Joshi, 1999) . 1 1 Doran et al. (1997) propose using a supertagger for semiautomatically porting the XTAG grammar to a new domain. The Parser The parser used in this paper is described in Clark and Curran (2004b) . It takes as input a POS tagged sentence with a set of lexical categories assigned to each word. The CCG combinatory rules are used to combine the categories. A packed chart efficiently represents all of the possible analyses for a sentence, and the CKY chart parsing algorithm described in Steedman (2000) is used to build the chart. A Maximum Entropy CCG supertagger (Clark and Curran, 2004a ) is used to assign the categories. The lexical category set is obtained from CCGbank (Hockenmaier, 2003a) , a treebank of normal-form CCG derivations derived from the Penn Treebank. CCGbank is also used for learning the parameters of the supertagger and parsing models. The Supertagger The supertagger uses a log-linear model to define a distribution for each word over the lexical category set. Model features are defined by the words and POS tags in the 5-word window surrounding the target word. The supertagger selects the most probable categories locally rather than maximising the sequence probability, assigning all categories whose probability is within some factor, \u03b2, of the highest probability category. For a word seen frequently in the training data, the supertagger can only assign categories from the word's entry in the tag dictionary, which lists the categories each word has been seen with in the data. In Clark et al.'s (2002) parser, a supertagger is used as follows: first around 4 lexical categories are assigned to each word, on average; if the chart gets too big or parsing takes too long, the number of categories is reduced until the sentence can be parsed. In this paper we use our more recent approach (Clark and Curran, 2004a) : first a small number of categories is assigned to each word, e.g. 1.5, and the parser requests more categories if a spanning analysis cannot be found. This method relies on the grammar being constraining enough to decide whether the categories provided by the supertagger are likely to contain the correct sequence. Section 6 shows that this approach works well for parsing questions. Parsing Model In Clark and Curran (2004b) we investigate several log-linear parsing models for CCG. In this paper we use the following conditional model: p(y|x) = 1 Z(x) e i \u03bb i f i (y) (1) where y is a normal-form derivation and x is a sentence. (A normal-form derivation is one where com-position and type-raising are used only when necessary.) There are various features, f i , used by the model: rule instantiation features which count the number of times a local tree occurs in a derivation; features defined by the root category of a derivation; and features defined by the lexical categories at the leaves. Each feature type has unlexicalised and head-lexicalised versions. The remaining features capture word-word dependencies, which significantly improve accuracy. The best-performing model encodes word-word dependencies in terms of the local rule instantiations, as in Hockenmaier and Steedman (2002) . We have also tried predicate-argument dependencies, including long-range dependencies, but these have not improved performance. Note we still recover longrange dependencies, even if modelling them does not improve performance. The parser returns a derived structure corresponding to the most probable derivation. For evaluation the parser returns dependency structures, but we have also developed a module which builds firstorder semantic representations from the derivations, which can be used for inference (Bos et al., 2004) . 3 Object Extraction Steedman (1996) presents a detailed study of various extraction phenomena. Here we focus on object extraction, since the dependencies in such cases are unbounded, and CCG has been designed to handle these cases. Correct dependency recovery for object extraction is also difficult for shallow methods such as Johnson (2002) and Dienes and Dubey (2003) . We consider three types of object extraction: object relative clauses, free object relatives, and toughadjectives (Hockenmaier, 2003a) . Examples of the first two from CCGbank are given in Figures 1  and 2 , together with the normal-form derivation. The caption gives the number of sentences containing such a case in Sections 2-21 of CCGbank (the training data) and Section 00 (development data). The pattern of the two derivations is similar: the subject of the verb phrase missing an object is type-raised (T); the type-raised subject composes (B) with the verb-phrase; and the category for the relative pronoun ((NP\\NP)/(S[dcl]/NP) or NP/(S[dcl]/NP)) applies to the sentence-missingits-object (S[dcl]/NP). Clark et al. (2002) show how the dependency between the verb and object can be captured by co-indexing the heads of the NPs in the relative pronoun category. Figure 3 gives the derivation for a toughadjective. The dependency between take and That can be recovered by co-indexing the heads of NPs in  the categories for hard and got. These cases are relatively rare, with around 50 occurring in the whole of the treebank, and only two in the development set; the parser correctly recovers one of the two object dependencies for the tough-adjective cases in 00. For the free object relative cases in Section 00, the parser recovers 14 of the 17 gold-standard dependencies 2 between the relative pronoun and the head of the relative clause. The precision is 14/15. For the three gold standard cases that are misanalysed, the category NP/S[dcl] is assigned to the relative pronoun, rather than NP/(S[dcl]/NP). For the cases involving object relative clauses the parser provides a range of errors for which it is useful to give a detailed analysis. Analysis of Object Extraction Cases Figure 4 gives the 20 sentences in Section 00 which contain a relative pronoun with the category (NP\\NP)/(S[dcl]/NP). There are 24 object dependencies in total, since some sentences contain more than one extraction (11), and some extractions involve more than one head (8, 18, 19) . For evaluation, we determined whether the parser correctly re-2 One of the 16 sentences contains two such dependencies. covered the dependency between the head of the extracted object and the verb. For example, to get the two dependencies in sentence 18 correct, the parser would have to assign the correct lexical category to had, and return respect and confidence as objects. The parser correctly recovers 15 of the 24 object dependencies. 3 Overall the parser hypothesises 20 extracted object dependencies, giving a precision of 15/20. Hockenmaier (2003a) reports similar results for a CCG parser using a generative model: 14/24 recall and 14/21 precision. The results here are a significant improvement over those in Clark et al. (2002) , in which only 10 of the 24 dependencies were recovered correctly. Below is a detailed analysis of the mistakes made by the parser. For Sentence 1 the parser cannot provide any analysis. This is because the correct category for estimated, ((S[pt]\\NP)/PP)/NP, is not in the tag dictionary's entry for estimated. Since estimated occurs around 200 times in the data, the supertagger only considers categories from the tag dictionary entry, and thus cannot provide the correct category as an option. 3 Unless stated otherwise the parser uses automatically assigned, rather than gold standard, POS tags. 15. The Japanese companies bankroll many small U.S. companies with promising products or ideas, frequently putting their money behind projects that commercial banks won't touch. \u221a 16. In investing on the basis of future transactions, a role often performed by merchant banks, trading companies can cut through the logjam that small-company owners often face with their local commercial banks. 17. A high-balance customer that banks pine for, she didn't give much thought to the rates she was receiving, nor to the fees she was paying. \u221a 18. The events of April through June damaged the respect and confidence which most Americans previously had for the leaders of China. \u221a 19. He described the situation as an escrow problem, a timing issue, which he said was rapidly rectified, with no losses to customers. \u221a 20. But Rep. Marge Roukema (R., N.J.) instead praised the House's acceptance of a new youth training wage, a subminimum that GOP administrations have sought for many years. For Sentence 2 the correct category is assigned to the relative pronoun that, but a wrong attachment results in many as the object of placed rather than countries. In Sentence 5 the incorrect lexical category ((S\\NP)\\(S\\NP))/S[dcl] is assigned to the relative pronoun that. In fact, the correct category is provided as an option by the supertagger, but the parser is unable to select it. This is because the category for agree is incorrect, since again the correct category, ((S[dcl]\\NP)/NP)/(S[dcl]\\NP), is not in the verb's entry in the tag dictionary. In Sentence 6 the correct category is assigned to the relative pronoun, but a number of mistakes elsewhere result in the wrong noun attachment. In Sentences 8 and 9 the complementizer category S[em]/S [dcl] is incorrectly assigned to the relative pronoun that. For Sentence 8 the correct analysis is available but the parsing model chose incorrectly. For Sentence 9 the correct analysis is unavailable because the correct category for suffer, ((S[b]\\NP)/PP)/NP, is not in the verb's entry in the tag dictionary. In Sentence 13 the correct category is again assigned to the relative pronoun, but a wrong attachment results in return being the object of placed, rather than time. In Sentence 17 the wrong category S[em]/S[b] is assigned to the relative pronoun that. Again the problem is with the category for the verb, but for a different reason: the POS tagger incorrectly tags pine as a base form (VB), rather than VBP, which completely misleads the supertagger. This small study only provides anecdotal evidence for the reasons the parser is unable to recover some long-range object dependencies. However, the analysis suggests that the parser fails largely for the same reasons it fails on other WSJ sentences: wrong attachment decisions are being made; the lexical coverage of the supertagger is lacking for some verbs; the model is sometimes biased towards incorrect lexical categories; and the supertagger is occasionally led astray by incorrect POS tags. Note that the recovery of these dependencies is a difficult problem, since the parser must assign the correct categories to the relative pronoun and verb, and make two attachment decisions: one attaching the relative pronoun to the verb, and one attaching it to the noun phrase. The recall figures for the individual dependencies in the relative pronoun category are 16/21 for the verb attachment and 15/24 for the noun attachment. In conclusion, the kinds of errors made by the parser suggest that general improvements in the coverage of the lexicon and parsing models based on CCGbank will lead to better recovery of longrange object dependencies. Parsing Questions Wide-coverage parsers are now being successfully used as part of open-domain QA systems, e.g. Pasca and Harabagiu (2001) . The speed and accuracy of our CCG parser suggests that it could be used to parse answer candidates, and we are currently integrating the parser into a QA system. We would also like to apply the parser to the questions, for two reasons: the use of CCG allows the parser to deal with extraction cases, which occur relatively frequently in questions; and the comparison of potential answers with the question, performed by the answer extraction component, is simplified if the same parser is used for both. Initially we tried some experiments applying the parser to questions from previous TREC competitions. The results were extremely poor, largely because the questions contain constructions which appear very infrequently, if at all, in CCGbank. 4 For example, there are no What questions with the general form of What President became Chief Justice after his precidency? in CCGbank, but this is a very common form of Wh-question. (There is a very small number (3) of similar question types beginning How or Which in Sections 2-21.) One solution is to create new annotated question data and retrain the parser, perhaps combining the data with CCGbank. However, the creation of goldstandard derivation trees is very expensive. A novel alternative, which we pursue here, is to annotate questions at the lexical category level only. Annotating sentences with lexical categories is simpler than annotating with derivations, and can be done with the tools and resources we have available. The key question is whether training only the supertagger on new question data is enough to give high parsing accuracy; in Section 6 we show that it is. The next Section describes the creation of the question corpus. A What-Question Corpus We have created a corpus consisting of 1,171 questions beginning with the word What, taken from the TREC 9-12 competitions (2000-2003) . We chose to focus on What-questions because these are a com-4 An earlier version of our QA system used RASP (Briscoe and Carroll, 2002) to parse the questions, but this parser also performed extremely poorly on some question types. mon form of question, and many contain cases of extraction, including some unbounded object extraction. A sample of questions from the corpus is given in Figure 5 . The questions were tokenised according to the Penn Treebank convention and automatically POS tagged. Some of the obvious errors made by the tagger were manually corrected. The first author then manually labelled 500 questions with lexical categories. The supertagger was trained on the annotated questions, and used to label the remaining questions, which were then manually corrected. The performance of the supertagger was good enough at this stage to significantly reduce the effort required for annotation. The second author has verified a subset of the annotated sentences. The question corpus took less than a week to create. Figure 6 gives the derivations for some example questions. The lexical categories, which make up the annotation in the question corpus, are in bold. Note the first example contains an unbounded object extraction, indicated by the question clause missing an object (S[q]/NP) which is an argument of What. Table 1 gives the distribution of categories assigned to the first word What in each question in the corpus. The first row gives the category of object question What. The second row is the object question determiner. The third row is the subject question determiner. And Evaluation A development set was created by randomly selecting 171 questions. For development purposes the remaining 1,000 questions were used for training; these were also used as a final cross-validation training/test set. The average length of the tokenised questions in the whole corpus is 8.6 tokens. The lexical category set used by the parser contains all categories which occur at least 10 times in CCGbank, giving a set of 409 categories. In creating the question corpus we used a small number of new category types, of which 3 were needed to cover common question constructions. One of these, (S[wq]/(S[dcl]\\NP))/N, applies to What, as in the second example in Figure 6 . This category does appear in CCGbank, but so infrequently that it is not part of the parser's lexical category set. Two more apply to question words like did and is; for example, (S[q]/(S[pss]\\NP))/NP applies to is in What instrument is Ray Charles best known for playing?, and (S[q]/PP)/NP applies to is in What city in Florida is Sea World in?. Supertagger Accuracy As an initial evaluation we tested the accuracy of just the supertagger on the development data. The supertagger was run in two modes: one in which a single category was assigned to each word, and one in which 1.5 categories were assigned to each word, on average. Table 2 gives the per-word accuracy on the development question data for a number of supertagging models; SENT accuracy gives the percentage of sentences for which every word is assigned the correct category. Four supertagging models were used: one trained on CCGbank only; one trained on the 1,000 questions; one trained on the 1,000 questions plus CCGbank; and one trained on 10 copies of the 1,000 questions plus CCGbank. The supertagger performs well when trained on the question data, and benefits from a combination of the questions and CCGbank. To increase the influence of the questions, we tried adding 10 copies of the question data to CCGbank, but this had little impact on accuracy. However, the supertagger performs extremely poorly when trained only on CCGbank. One reason for the very low SENT accuracy figure is that many of the questions contain lexical categories which are not in the supertagger's category set derived from CCGbank: 56 of the 171 development questions have this property. The parsing results in Clark and Curran (2004b) rely on a supertagger per-word accuracy of at least 97%, and a sentence accuracy of at least 60% (for 1.5 categories per word). Parser Accuracy Since the gold-standard question data is only labelled at the lexical category level, we are only able to perform a full evaluation at that level. However, the scores in Clark and Curran (2004b) give an indication of how supertagging accuracy corresponds to overall dependency recovery. In addition, in Section 6.3 we present an evaluation on object extraction dependencies in the development data. We applied the parser to the 171 questions in the development data, using the supertagger model from the third row in Table 2 , together with a loglinear parsing model trained on CCGbank. We used the supertagging approach described in Section 2.1, in which a small number of categories is initially assigned to each word, and the parser requests more categories if a spanning analysis cannot be found. We used 4 different values for the parameter \u03b2 (which determines the average number of categories per word): 0.5, 0.25, 0.075 and 0.01. The average number of categories at each level for the development data is 1.1, 1.2, 1.6 and 3.8. The parser provided an analysis for all but one of the 171 questions. The first row of Table 3 gives the per-word, and sentence, category accuracy for the parser output. Figures are also given for the accuracy of the categories assigned to the first word What. The figures show that the parser is more accurate at supertagging than the single-category supertagger. The second row gives the results if the original supertagging approach of Clark et al. (2002) is used, i.e. starting with a high number of categories per word, and reducing the number if the sentence cannot be parsed within reasonable space and time constraints. The third row corresponds to our new supertagging approach, but chooses a derivation at random, by randomly traversing the packed chart representation used by the parser. The fourth row corresponds to the supertagging approach of Clark et al. (2002) the derivation. The baseline method in the fifth row assigns to a word the category most frequently seen with it in the data; for unseen words N is assigned. The results in Table 3 demonstrate that our new supertagging approach is very effective. The reason is that the parser typically uses the first supertagger level, where the average number of categories per word is only 1.1, and the per-word/sentence category accuracies are 95.5 and 70.8%, repsectively. 136 of the 171 questions (79.5%) are parsed at this level. Since the number of categories per word is very small, the parser has little work to do in combining the categories; the supertagger is effectively an almost-parser (Bangalore and Joshi, 1999) . Thus the parsing model, which is not tuned for questions, is hardly used by the parser. This interpretation is supported by the high scores for the random method in row 3 of the table. In contrast, the previous supertagging method of Clark et al. (2002) results in a large derivation space, which must be searched using the parsing model. Thus the accuracy of the parser is greatly reduced, as shown in rows 2 and 4. As a final test of the robustness of our results, we performed a cross-validation experiment using the 1,000 training questions. The 1,000 questions were randomly split into 10 chunks. Each chunk was used as a test set in a separate run, with the remaining chunks as training data plus CCGbank. Table 4 gives the results averaged over the 10 runs for the two supertagging approaches. Object Extraction in Questions For the object extraction evaluation we considered the 36 questions in the development data which have the category (S[wq]/(S[q]/NP))/N assigned to What. Table 7 gives examples of the questions. We assume these are fairly representative of the kinds of object extraction found in other question types, and thus present a useful test set. We parsed the questions using the best performing configuration from the previous section. All but one of the sentences was given an analysis. The perword/sentence category accuracies were 90.2% and 71.4%, respectively. These figures are lower than for the corpus as a whole, suggesting these object extraction questions are more difficult than average.  We inspected the output to see if the object dependencies had been recovered correctly. To get the object dependency correct in the first question in Table 7, for example, the parser would need to assign the correct category to take and return amount as the object of take. Of the 37 extracted object dependencies (one question had two such dependencies), 29 (78.4%) were recovered correctly. Given that the original parser trained on CCGbank performs extremely poorly on such questions, we consider this to be a highly promising result. Conclusion We have presented a detailed evaluation of a CCG parser on object extraction dependencies in WSJ text. Given the difficulty of the task, the accuracy of the parser is encouraging. The errors made by the parser suggest that general improvements in the coverage of the lexicon and parsing models derived from CCGbank will lead to improved recovery of long-range object dependencies. In contrast, we have suggested that general improvements in CCGbank parsing models will not lead to satisfactory performance on question parsing. The reason is that the Wh-question domain is syntactically distinct from WSJ text. We have presented a novel method for porting the parser to the question domain, which has led to good performance on question parsing. This has also demonstrated the close integration of the supertagger and the CCG parser on which our method depends. One of the major drawbacks of current NLP technology is that in general it performs very poorly outside of the training data domain. Our porting method only requires lexical category data, which is far easier to produce than full parse trees. This is an efficient method for porting the parser to other domains. The method may also be applicable to other lexicalised grammar formalisms. We will extend the question corpus to other question types. We are also continuing to develop the supertagger, which we have demonstrated is central to efficient portable wide-coverage CCG parsing.",
    "abstract": "Accurate dependency recovery has recently been reported for a number of wide-coverage statistical parsers using Combinatory Categorial Grammar (CCG). However, overall figures give no indication of a parser's performance on specific constructions, nor how suitable a parser is for specific applications. In this paper we give a detailed evaluation of a CCG parser on object extraction dependencies found in WSJ text. We also show how the parser can be used to parse questions for Question Answering. The accuracy of the original parser on questions is very poor, and we propose a novel technique for porting the parser to a new domain, by creating new labelled data at the lexical category level only. Using a supertagger to assign categories to words, trained on the new data, leads to a dramatic increase in question parsing accuracy.",
    "countries": [
        "United Kingdom"
    ],
    "languages": [
        "Japanese"
    ],
    "numcitedby": "49",
    "year": "2004",
    "month": "July",
    "title": "Object-Extraction and Question-Parsing using {CCG}"
}