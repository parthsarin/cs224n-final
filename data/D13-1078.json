{
    "article": "We present an approach to time normalization (e.g. the day before yesterday\u21d22013-04-12) based on a synchronous context free grammar. Synchronous rules map the source language to formally defined operators for manipulating times (FINDENCLOSED, STARTATENDOF, etc.). Time expressions are then parsed using an extended CYK+ algorithm, and converted to a normalized form by applying the operators recursively. For evaluation, a small set of synchronous rules for English time expressions were developed. Our model outperforms HeidelTime, the best time normalization system in TempEval 2013, on four different time normalization corpora. Introduction Time normalization is the task of converting a natural language expression of time into a formal representation of a time on a timeline. For example, the expression the day before yesterday would be normalized to the formal representation 2013-04-12 (assuming that today is 2013-04-14) in the ISO-TimeML representation language (Pustejovsky et al., 2010) . Time normalization is a crucial part of almost any information extraction task that needs to place entities or events along a timeline. And research into methods for time normalization has been growing since the ACE 1 and TempEval (Verhagen et al., 2010; UzZaman et al., 2013) challenges began to include time normalization as a shared task. 1 http://www.itl.nist.gov/iad/mig/tests/ace/ Most prior work on time normalization has taken a rule-based, string-to-string translation approach. That is, each word in a time expression is looked up in a normalization lexicon, and then rules map this sequence of lexical entries directly to the normalized form. HeidelTime (Str\u00f6tgen and Gertz, 2012) , which had the highest performance in TempEval 2010 and 2013 , and TIMEN (Llorens et al., 2012) , which reported slightly higher performance in its own experiments, both follow this approach. A drawback of this approach though is that there is no nesting of rules: for example, in HeidelTime the rules for yesterday and the day before yesterday are completely separate, despite the compositional nature of the latter. A notable exception to the string-to-string approach is the work of (Angeli et al., 2012) . They define a target grammar of typed pre-terminals, such as YESTERDAY (a SEQUENCE) or DAY (a DURATION), and compositional operations, such as SHIFTLEFT (a (RANGE, DURATION) \u2192 RANGE). They apply an expectation-maximization approach to learn how words align to elements of the target grammar, and achieve performance close to that of the rule-based systems. However, their grammar does not allow for non-binary or partially lexicalized rules (e.g. SE-QUENCE \u2192 DURATION before SEQUENCE would be impossible), and some of their primitive elements could naturally be expressed using other primitives (e.g. YESTERDAY as SHIFTLEFT(TODAY, 1 DAY)). We present a synchronous grammar for time normalization that addresses these shortcomings. We first define a grammar of formal operations over temporal elements. We then develop synchronous rules that map time expression words to temporal opera- tors, and perform normalization by parsing with an extended CYK+ parsing algorithm. We evaluate this approach to time normalization on the TimeBank, AQUAINT, Timen and TempEval 2013 corpora. Synchronous grammars Our time grammar is based on the synchronous context free grammar formalism. Synchronous grammars allow two trees, one in the source language and one in the target language, to be constructed simultaneously. A synchronous context free grammar has rules of the form X \u2192 (S, T, A), where X is a non-terminal, S is the sequence of terminals and nonterminals that X expands to in the source language, T is the sequence of terminals and non-terminals that X expands to in the target language, and A is the alignment between the non-terminals of S and T (which must be the same). For time normalization, the source side is the natural language text, and the target side is a formal grammar of temporal operators. Figure 1 shows a synchronous parse of the week of March 6 2 . The left side is the source side (an English expression), the right side is the target side (a temporal operator expression), and the alignment is shown via subscripts. 2 Figure 1 corresponds to an interpretation along the lines of the week of the last March 6. The full grammar developed in this article would also produce an interpretation corresponding to the week of the next March 6, since the phrase is ambiguous. Target time grammar The right side of Figure 1 shows an example of our target formal representation: FINDENCLOSING( FINDEARLIER(PRESENT, MONTHOFYEAR\u21923, DAYOFMONTH\u21926), WEEKS). Each terminal in the parse is either a numeric value or an operator like FINDENCLOSING, WEEKS or MONTHOF-YEAR. Each non-terminal combines terminals or non-terminals to create a [TIMESPAN], [PERIOD], [FIELD], [UNIT] or [INT] . The list of rules allowed by our target grammar (the right-hand side of our synchronous grammar) is given in Table 1 . Each of the target operators defines a procedure for creating a temporal object from others. For example, FINDENCLOSING takes a [TIMESPAN] and a [UNIT] and expands the start and end of the time span to fill a period of one unit. This could be used, for example, to define today as FINDENCLOSING(PRESENT, DAYS), where the PRESENT, which is instantaneous, is expanded out to the enclosing day. Note that we define things like today and yesterday in terms of primitive operations, rather than making them primitives themselves as in (Angeli et al., 2012) . The left side of Figure 1 shows the synchronous parse of the source language. Note that each of the non-terminals is aligned (shown as a subscript) with a non-terminal in the target parse 3 , while terminals are not aligned and may freely appear or disappear from the source to the target. Each non-terminal thus corresponds to a synchronous grammar rule that describes how a source expression should be translated into the target time grammar. For example the root nodes correspond to an application of the following full synchronous rule: [INT] \u2192 integer [UNIT] \u2192 unit [FIELD] \u2192 field [INT] [FIELD] \u2192 [FIELD]* [PERIOD] \u2192 SIMPLE [INT] [UNIT] [PERIOD] \u2192 FRACTIONAL [INT] [INT] [UNIT] [PERIOD] \u2192 UNSPECIFIED [UNIT] [PERIOD] \u2192 WITHMODIFIER [PERIOD] modifier [TIMESPAN] \u2192 PAST [TIMESPAN] \u2192 PRESENT [TIMESPAN] \u2192 FUTURE [TIMESPAN] \u2192 FINDEARLIER [TIMESPAN] [FIELD] [TIMESPAN] \u2192 FINDLATER [TIMESPAN] [FIELD] [TIMESPAN] \u2192 FINDENCLOSING [TIMESPAN] [UNIT] [TIMESPAN] \u2192 FINDENCLOSED [TIMESPAN] [FIELD] [TIMESPAN] \u2192 STARTATENDOF [TIMESPAN] [PERIOD] [TIMESPAN] \u2192 ENDATSTARTOF [TIMESPAN] [PERIOD] [TIMESPAN] \u2192 MOVEEARLIER [TIMESPAN] [PERIOD] [TIMESPAN] \u2192 MOVELATER [TIMESPAN] [PERIOD] [TIMESPAN] \u2192 WITHMODIFIER [TIMESPAN] modifier [TIMESPAN] \u2192 source: [UNIT] of [TIMESPAN] target: FINDENCLOSING [TIMESPAN] [UNIT] 4 Parsing algorithm Parsing with a synchronous context free grammar is much the same as parsing with just the source side of the grammar. Only a small amount of bookkeeping is necessary to allow the generation of the target parse once the source parse is complete. We can therefore apply standard parsing algorithms to this task. However, we have some additional grammar requirements. As shown in Figure 1 , we allow rules that expand into more than two terminals or nonterminals, the mixing of terminals and non-terminals in a production, a special [NIL] non-terminal for the ignoring of words, and a special [INT] non-terminal that can match ranges of integers and does not require all possible integers to be manually listed in the grammar. This means that we can't directly use CYK parsing or even CYK+ parsing (Chappelier and Rajman, 1998) , which allows rules that expand into more than two terminals or non-terminals, but does not meet our other requirements. Algorithm 1 shows our extended version of CYK+ parsing. As with standard CYK+ parsing, two charts are filled, one for rules that have been completed (C) and one for rules that have been only partially advanced (P ). All parses covering 1 terminal are completed first, then these are used to complete parses covering 2 terminals, etc. until all parses covering all terminals are complete. Our extensions to the standard CYK+ parsing are as follows. To handle integers, we modify the initialization to generate new rules on the fly for any numeric terminals that fit the range of an [INT:X-Y] non-terminal in the grammar (starts at line 5). To allow mixing of terminals and non-terminals, we extend the initialization step to also produce partial parses (line 17), and extend the parse advancement step to allow advancing rules with terminals (starting at line 23). Finally, to handle [NIL] rules, which consume tokens but are not included in the final parse, we add a step where rules are allowed to advance, unchanged, past a [NIL] rule (starting at line 35). Parsing example As an example, consider parsing the week of March 6 with the following source side grammar: [NIL] \u2192 the [UNIT] \u2192 week [MONTH] \u2192 March [DAY] \u2192 [INT:1-31] [FIELD] \u2192 [MONTH][DAY] [TIMESPAN] \u2192 [FIELD] [TIMESPAN] \u2192 [UNIT] of [TIMESPAN] First the algorithm handles the numeric special case, completing an [INT] parse for the token 6 at index 4: C (1,4) \u222a= [INT:1-31] \u2192 6 Then it completes parses based on just the terminals: C (1,0) \u222a= [NIL] \u2192 the C (1,1) \u222a= [UNIT] \u2192 week C (1,3) \u222a= [MONTH] \u2192 March Next, the algorithm starts working on parses that span 1 token. It can start two partial parses, using the [UNIT] at C (1,1) , and using the [MONTH] at C (1,3) : P (1,1) \u222a= [TIMESPAN] \u2192 [UNIT] \u2022 of [TIMESPAN] P (1,3) \u222a= [FIELD] \u2192 [MONTH] \u2022 [DAY] Algorithm 1 CYK+ parsing, extended for partially lexicalized rules, [Nil] the algorithm can make a complete size 1 parse: C (1,4) \u222a= [DAY] \u2192 [INT:1-31] The algorithm then moves on to create parses that span 2 tokens. The special handling of [NIL] allows the [UNIT] at C (1,1) to absorb the [NIL] at C (1,0) : C (2,0) \u222a= [UNIT] \u2192 week This [UNIT] then allows the start of a partial parse: P (2,0) \u222a= [TIMESPAN] \u2192 [UNIT] \u2022 of [TIMESPAN] The partial parse at P (1,1) can be advanced using of at position 2, creating another 2 token partial parse: P (2,1) \u222a= [TIMESPAN] \u2192 [UNIT] of \u2022 [TIMESPAN]) The partial parse at P (1,3) can be advanced using the [DAY] at C (1,4) , completing the 2 token parse: C (2,3) \u222a= [FIELD] \u2192 [MONTH][DAY] This [FIELD] allows completion of a 2 token parse: C (2,3) \u222a= [TIMESPAN] \u2192 [FIELD] The algorithm then moves on to 3 token parses. Only one is possible: the partial parse at P (2,0) can be advanced using the of at position 2, yielding: P (3,0) \u222a= [TIMESPAN] \u2192 [UNIT] of \u2022 [TIMESPAN] The algorithm moves on to 4 token parses, finding that the partial parse at P (2,1) can be advanced using the [TIMESPAN] at C (2,3) , completing the parse: C (4,1) \u222a= [TIMESPAN] \u2192 [UNIT] of [TIMESPAN] Finally, the algorithm moves on to 5 token parses, where (1) the special handling of [NIL] allows the partial parse at C (4,1) to consume the [NIL] at C (1,0) and (2) the partial parse at P (3,0) can be advanced using the [TIMESPAN] at C (2,3) . Both of these yield: C (5,0) \u222a= [TIMESPAN] \u2192 [UNIT] of [TIMESPAN] The complete parses in C (5,0) are then deterministically translated into target side parses using the alignments in the rules of the synchronous grammar. 6 Evaluation TimeBank (Pustejovsky et al., 2003) corpora. The resulting grammar has 354 rules, 192 of which are only lexical, e.g., [UNIT] \u2192 (seconds, SECONDS). Our grammar produces multiple parses when the input is ambiguous. For example, the expression Monday could mean either the previous Monday or the following Monday, and the expression the day could refer either to a period of one day, or to a specific day in time, e.g. 2013-04-14. For such expressions, our grammar produces both parses. To choose between the two, we employ a very simple set of heuristics: (1) prefer [TIMESPAN] to [PERIOD], (2) prefer an earlier [TIMESPAN] to a later one and (3) prefer a [TIMESPAN] with QUARTERS granularity if the anchor time is also in QUARTERS (this is a common rule in TimeBank annotations). We evaluate on the AQUAINT corpus, the Time-Bank corpus, the Timen corpus (Llorens et al., 2012) and the TempEval 2013 test set (UzZaman et al., 2013) 5 . We compare to two 6 state-of-the-art systems: TIMEN and HeidelTime. Table 2 shows the results. Our synchronous grammar approach outperformed HeidelTime on all corpora, both on the training corpora (AQUAINT and TimeBank) and on the test corpora (Timen and TempEval 2013). Both our model and HeidelTime outperformed TIMEN on all corpora except for the Timen corpus. To better understand the issues in the Timen corpus, we manually inspected the 33 time expressions that TIMEN normalized correctly and our approach normalized incorrectly. 4 errors were places where our heuristic was wrong (e.g. we chose the earlier, not the later Sept. 22). 6 errors were coverage problems of our grammar, e.g. not handling season, every time or long ago. 2 errors were actually human annotation errors (several years ago was annotated as PASTREF and daily was annotated as XXXX-XX-XX, while the guidelines say these should be PXY and P1D respectively). The remaining 21 errors were from two new normalization forms not present at all in the training data: 19 instances of THH:MM:SS (times were always YYYY-MM-DDTHH:MM:SS in the training data) and 2 instances of BCYYYY (years were always YYYY in the training data). Discussion Our synchronous grammar approach to time normalization, which handles recursive structures better than existing string-to-string approaches and handles a wider variety of grammars than existing parsing approaches, outperforms the HeidelTime system on four evaluation corpora and outperforms the TIMEN system on three of the four corpora. Our time normalization code and models are freely available. The source code and English grammar are hosted at https://github.com/ bethard/timenorm, and official releases are published to Maven Central (group=info.bethard, artifact=timenorm). In future work, we plan to replace the heuristic for selecting between ambiguous parses with a more principled approach. It would be a simple extension to support a probabilistic grammar, as in (Angeli et al., 2012) . But given an expression like Monday, it would still be impossible to decide whether it refers to the future or the past, since the surrounding context, e.g. tense of the governing verb, is needed for such a judgment. A more promising approach would be to train a classifier that selects between the ambiguous parses based on features of the surrounding context. Acknowledgements The project described was supported in part by Grant Number R01LM010090 from the National Library Of Medicine. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Library of Medicine or the National Institutes of Health.",
    "abstract": "We present an approach to time normalization (e.g. the day before yesterday\u21d22013-04-12) based on a synchronous context free grammar. Synchronous rules map the source language to formally defined operators for manipulating times (FINDENCLOSED, STARTATENDOF, etc.). Time expressions are then parsed using an extended CYK+ algorithm, and converted to a normalized form by applying the operators recursively. For evaluation, a small set of synchronous rules for English time expressions were developed. Our model outperforms HeidelTime, the best time normalization system in TempEval 2013, on four different time normalization corpora.",
    "countries": [
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "32",
    "year": "2013",
    "month": "October",
    "title": "A Synchronous Context Free Grammar for Time Normalization"
}