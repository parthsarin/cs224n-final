{
    "article": "We apply Support Vector Machines (SVMs) to identify English base phrases (chunks). SVMs are known to achieve high generalization performance even with input data of high dimensional feature spaces. Furthermore, by the Kernel principle, SVMs can carry out training with smaller computational overhead independent of their dimensionality. We apply weighted voting of 8 SVMsbased systems trained with distinct chunk representations. Experimental results show that our approach achieves higher accuracy than previous approaches. Support Vector Machines Optimal Hyperplane Let us define the training samples each of which belongs either to positive or negative class as: Introduction Chunking is recognized as series of processesfirst identifying proper chunks from a sequence of tokens (such as words), and second classifying these chunks into some grammatical classes. Various NLP tasks can be seen as a chunking task. Examples include English base noun phrase identification (base NP chunking), English base phrase identification (chunking), Japanese chunk (bunsetsu) identification and named entity extraction. Tokenization and part-of-speech tagging can also be regarded as a chunking task, if we assume each character as a token. Machine learning techniques are often applied to chunking, since the task is formulated as estimating an identifying function from the information (features) available in the surrounding context. Various machine learning approaches have been proposed for chunking (Ramshaw and Marcus, 1995; Tjong Kim Sang, 2000a; Tjong Kim Sang et al., 2000; Tjong Kim Sang, 2000b; Sassano and Utsuro, 2000; van Halteren, 2000) . Conventional machine learning techniques, such as Hidden Markov Model (HMM) and Maximum Entropy Model (ME), normally require a careful feature selection in order to achieve high accuracy. They do not provide a method for automatic selection of given feature sets. Usually, heuristics are used for selecting effective features and their combinations. New statistical learning techniques such as Support Vector Machines (SVMs) (Cortes and Vapnik, 1995; Vapnik, 1998) and Boosting (Freund and Schapire, 1996) have been proposed. These techniques take a strategy that maximizes the margin between critical samples and the separating hyperplane. In particular, SVMs achieve high generalization even with training data of a very high dimension. Furthermore, by introducing the Kernel function, SVMs handle non-linear feature spaces, and carry out the training considering combinations of more than one feature. In the field of natural language processing, SVMs are applied to text categorization and syntactic dependency structure analysis, and are reported to have achieved higher accuracy than previous approaches. (Joachims, 1998; Taira and Haruno, 1999; Kudo and Matsumoto, 2000a) . In this paper, we apply Support Vector Machines to the chunking task. In addition, in order to achieve higher accuracy, we apply weighted voting of 8 SVM-based systems which are trained using distinct chunk representations. For the weighted voting systems, we introduce a new type of weighting strategy which are derived from the theoretical basis of the SVMs. Small Margin Large Margin Figure 1: Two possible separating hyperplanes ples. In the basic SVMs framework, we try to separate the positive and negative samples by a hyperplane expressed as: \u00a2 \u00a4E GF @\u00a3 H4 PI RQ TS T\u00a2 \u00a4E U$ V& W( H \u00a7 \u00a8I X$ & Y . SVMs find an \"optimal\" hyperplane (i.e. an optimal parameter set for E ` \u00a7 aI ) which separates the training data into two classes. What does \"optimal\" mean? In order to define it, we need to consider the margin between two classes. Figure 1 illustrates this idea. Solid lines show two possible hyperplanes, each of which correctly separates the training data into two classes. Two dashed lines parallel to the separating hyperplane indicate the boundaries in which one can move the separating hyperplane without any misclassification. We call the distance between those parallel dashed lines as margin. SVMs find the separating hyperplane which maximizes its margin. Precisely, two dashed lines and margin (b ) can be expressed as: . In other words, this problem becomes equivalent to solving the following optimization problem: v xw y w w W \u00a2 \u00a4E Q \u00a5 s E ts d Vd fe W \u00a9 \" fg h\u00a2 \u00a4E iF \u00a3 A\" j A4 PI lk m T6 1\u00a2 B Q n6 h \u00a7 \u00a7 D The training samples which lie on either of two dashed lines are called support vectors. It is known that only the support vectors in given training data matter. This implies that we can obtain the same decision function even if we remove all training samples except for the extracted support vectors. In practice, even in the case where we cannot separate training data linearly because of some noise in the training data, etc, we can build the separating linear hyperplane by allowing some misclassifications. Though we omit the details here, we can build an optimal hyperplane by introducing a soft margin parameter o , which trades off between the training error and the magnitude of the margin. Furthermore, SVMs have a potential to carry out the non-linear classification. Though we leave the details to (Vapnik, 1998) , the optimization problem can be rewritten into a dual form, where all feature vectors appear in their dot products. By simply substituting every dot product of \u00a3 A\" and \u00a3 Hp in dual form with a certain Kernel function q \u00a2 \u00a4\u00a3 #\" r \u00a7 f\u00a3 Hp \u00a8 , SVMs can handle non-linear hypotheses. Among many kinds of Kernel functions available, we will focus on the s -th polynomial kernel: q \u00a2 t\u00a3 A\" r \u00a7 f\u00a3 up l vQ w\u00a2 \u00a4\u00a3 A\" hF x\u00a3 Hp y4 z6 f{ . Use of s -th polynomial kernel functions allows us to build an optimal separating hyperplane which takes into account all combinations of features up to s . Generalization Ability of SVMs Statistical Learning Theory (Vapnik, 1998) , the risk is bounded by | '| } 4 T \u00a2 \u00a4 y 4 T6 8 u y 7 D \u00a7 (1) where is a non-negative integer called the Vapnik Chervonenkis (VC) dimension, and is a measure of the complexity of the given decision function. The r.h.s. term of (1) is called VC bound. In order to minimize the risk, we have to minimize the empirical risk as well as VC dimension. It is known that the following theorem holds for VC dimension and margin b (Vapnik, 1998) . (2) In order to minimize the VC dimension , we have to maximize the margin b , which is exactly the strategy that SVMs take. Vapnik gives an alternative bound for the risk. becomes the r.h.s. term of (3). In practice, it is known that this bound is less predictive than the VC bound. Chunking Chunk representation There are mainly two types of representations for proper chunks. One is Inside/Outside representation, and the other is Start/End representation. Inside/Outside This representation was first introduced in (Ramshaw and Marcus, 1995), and has been applied for base NP chunking. This method uses the following set of three tags for representing proper chunks. I Current token is inside of a chunk. O Current token is outside of any chunk. B Current token is the beginning of a chunk which immediately follows another chunk. Tjong Kim Sang calls this method as IOB1 representation, and introduces three alternative versions -IOB2,IOE1 and IOE2 (Tjong Kim Sang and Veenstra, 1999) . IOB2 A B tag is given for every token which exists at the beginning of a chunk. Other tokens are the same as IOB1. IOE1 An E tag is used to mark the last token of a chunk immediately preceding another chunk. IOE2 An E tag is given for every token which exists at the end of a chunk. Start/End This method has been used for the Japanese named entity extraction task, and requires the following five tags for representing proper chunks (Uchimoto et al., 2000) 1 . In B Current token is the start of a chunk consisting of more than one token. E Current token is the end of a chunk consisting of more than one token. I Current token is a middle of a chunk consisting of more than two tokens. S Current token is a chunk consisting of only one token. O Current token is outside of any chunk. Examples of these five representations are shown in Table 1 . If we have to identify the grammatical class of each chunk, we represent them by a pair of an I/O/B/E/S label and a class label. For example, in IOB2 representation, B-VP label is given to a token which represents the beginning of a verb base phrase (VP). Chunking with SVMs Basically, SVMs are binary classifiers, thus we must extend SVMs to multi-class classifiers in order to classify three (B,I,O) or more (B,I,O,E,S) classes. There are two popular methods to extend a binary classification task to that of q classes. One is one class vs. all others. The idea is to build q classifiers so as to separate one class from all others. The other is pairwise classification. The idea is to build q \u00a2\u00a1 \u00a2 q 8 36 fp hi classifiers considering all pairs of classes, and final decision is given by their weighted voting. There are a number of other methods to extend SVMs to multiclass classifiers. For example, Dietterich and Bakiri (Dietterich and Bakiri, 1995) and Allwein (Allwein et al., 2000) introduce a unifying framework for solving the multiclass problem we want to keep consistency with Inside/Start (B/I/O) representation. by reducing them into binary models. However, we employ the simple pairwise classifiers because of the following reasons: (1) In general, SVMs require (2) Some experiments (Kre\u00dfel, 1999) report that a combination of pairwise classifiers performs better than the one vs. all others. For the feature sets for actual training and classification of SVMs, we use all the information available in the surrounding context, such as the words, their part-of-speech tags as well as the chunk labels. More precisely, we give the following features to identify the chunk label a\" for the B -th word: \u00a7 Direction \u00a7 Word: \u00a8\" \u00a4\u00a9 \u00a8\" \u00a4\u00a9 H\u00a5 \u00a8\" \u00a8\" \u00aa #\u00a5 \u00a8\" \u00aa A\u00a5 POS: \" \u00a4\u00a9 \" h\u00a9 H\u00a5 \" \" \u00aa A\u00a5 \" \u00aa #\u00a5 Chunk: a\" \u00a4\u00a9 a\" \u00a4\u00a9 \u00a5 a\" Here, \u00a8\" is the word appearing at B -th position, r\" is the POS tag of \u00a8\" , and a\" is the (extended) chunk label for B -th word. In addition, we can reverse the parsing direction (from right to left) by using two chunk tags which appear to the r.h.s. of the current token ( \" \u00aa A\u00a5 \u00a7 a \" \u00aa ). In this paper, we call the method which parses from left to right as forward parsing, and the method which parses from right to left as backward parsing. Since the preceding chunk labels ( \u00a8\" \u00a4\u00a9 H\u00a5 \u00a7 \u00a8 a\" \u00a4\u00a9 for forward parsing , a\" \u00aa #\u00a5 \u00a7 \u00a8 a\" \u00aa for backward parsing) are not given in the test data, they are decided dynamically during the tagging of chunk labels. The technique can be regarded as a sort of Dynamic Programming (DP) matching, in which the best answer is searched by maximizing the total certainty score for the combination of tags. In using DP matching, we limit a number of ambiguities by applying beam search with width . In CoNLL 2000 shared task, the number of votes for the class obtained through the pairwise voting is used as the certain score for beam search with width 5 (Kudo and Matsumoto, 2000a) . In this paper, however, we apply deterministic method instead of applying beam search with keeping some ambiguities. The reason we apply deterministic method is that our further experiments and investigation for the selection of beam width shows that larger beam width dose not always give a significant improvement in the accuracy. Given our experiments, we conclude that satisfying accuracies can be obtained even with the deterministic parsing. Another reason for selecting the simpler setting is that the major purpose of this paper is to compare weighted voting schemes and to show an effective weighting method with the help of empirical risk estimation frameworks. Weighted Voting Tjong Kim Sang et al. report that they achieve higher accuracy by applying weighted voting of systems which are trained using distinct chunk representations and different machine learning algorithms, such as MBL, ME and IGTree (Tjong Kim Sang, 2000a; Tjong Kim Sang et al., 2000) . It is well-known that weighted voting scheme has a potential to maximize the margin between critical samples and the separating hyperplane, and produces a decision function with high generalization performance (Schapire et al., 1997) . The boosting technique is a type of weighted voting scheme, and has been applied to many NLP problems such as parsing, part-of-speech tagging and text categorization. In our experiments, in order to obtain higher accuracy, we also apply weighted voting of 8 SVMbased systems which are trained using distinct chunk representations. Before applying weighted voting method, first we need to decide the weights to be given to individual systems. We can obtain the best weights if we could obtain the accuracy for the \"true\" test data. However, it is impossible to estimate them. In boosting technique, the voting weights are given by the accuracy of the training data during the iteration of changing the frequency (distribution) of training data. However, we cannot use the accuracy of the training data for voting weights, since SVMs do not depend on the frequency (distribution) of training data, and can separate the training data without any mis-classification by selecting the appropriate kernel function and the soft margin parameter. In this paper, we introduce the following four weighting methods in our experiments: Uniform weights We give the same voting weight to all systems. This method is taken as the baseline for other weighting methods. Cross validation Dividing training data into portions, we employ the training by using 8 P6 portions, and then evaluate the remaining portion. In this fashion, we will have individual accuracy. Final voting weights are given by the average of these accuracies. VC-bound By applying (1) and ( 2 ), we estimate the lower bound of accuracy for each system, and use the accuracy as a voting weight. The voting weight is calculated as: \u00a8Q \u00ab6 18 ' o I C s . The value of , which represents the smallest diameter enclosing all of the training data, is approximated by the maximum distance from the origin. Leave-One-Out bound By using (3), we estimate the lower bound of the accuracy of a system. The voting weight is calculated as: \u00a8Q i6 8 | . The procedure of our experiments is summarized as follows: 1. We convert the training data into 4 representations (IOB1/IOB2/IOE1/IOE2). 2. We consider two parsing directions (Forward/Backward) for each representation, i.e. \u00ac \u00a1 i Q T systems for a single training data set. Then, we employ SVMs training using these independent chunk representations. After training, we examine the VC bound and Leave-One-Out bound for each of 8 systems. As for cross validation, we employ the steps 1 and 2 for each divided training data, and obtain the weights. 4. We test these 8 systems with a separated test data set. Before employing weighted voting, we have to convert them into a uniform representation, since the tag sets used in individual 8 systems are different. For this purpose, we re-convert each of the estimated results into 4 representations (IOB1/IOB2/IOE2/IOE1). 5. We employ weighted voting of 8 systems with respect to the converted 4 uniform representations and the 4 voting schemes respectively. Finally, we have \u00ac (types of uniform representations) \u00a1 4 (types of weights) Q \u00ae6 \u00afr esults for our experiments. Although we can use models with IOBES-F or IOBES-B representations for the committees for the weighted voting, we do not use them in our voting experiments. The reason is that the number of classes are different (3 vs. 5) and the estimated VC and LOO bound cannot straightforwardly be compared with other models that have three classes (IOB1/IOB2/IOE1/IOE2) under the same condition. We conduct experiments with IOBES-F and IOBES-B representations only to investigate how far the difference of various chunk representations would affect the actual chunking accuracies. Experiments Experiment Setting We use the following three annotated corpora for our experiments. (20) for the test data. The data has part-ofspeech (POS) tags annotated by the Brill tagger (Brill, 1995) . \u00b0Base NP large data set (baseNP-L) This data set consists of 20 sections (02-21) of the WSJ part of the Penn Treebank for the training data, and one section (00) for the test data. POS tags in this data sets are also annotated by the Brill tagger. We omit the experiments IOB1 and IOE1 representations for this training data since the data size is too large for our current SVMs learning program. In case of IOB1 and IOE1, the size of training data for one classifier which estimates the class I and O becomes much larger compared with IOB2 and IOE2 models. In addition, we also omit to estimate the voting weights using cross validation method due to a large amount of training cost. \u00b0Chunking data set (chunking) This data set was used for CoNLL-2000 shared task (Tjong Kim Sang and Buchholz, 2000) . In this data set, the total of 10 base phrase classes (NP,VP,PP,ADJP,ADVP,CONJP, INITJ,LST,PTR,SBAR) are annotated. This data set consists of 4 sections (15-18) of the WSJ part of the Penn Treebank for the training data, and one section (20) for the test data 3 . All the experiments are carried out with our software package TinySVM 4 , which is designed and optimized to handle large sparse feature vectors and large number of training samples. This package can estimate the VC bound and Leave-One-Out bound automatically. For the kernel function, we use the 2-nd polynomial function and set the soft margin parameter o to be 1. In the baseNP identification task, the performance of the systems is usually measured with three rates: precision, recall and \u00b1 #\u00b2 h\u00b3 \u00a5 \u00a2 jQ Gi fF 5 B B C F D jD p 0\u00a2 B B C 4 P D jD f . In this paper, we refer to \u00b1 \u00b2 h\u00b3 \u00a5 as accuracy. Results of Experiments Table 2 shows results of our SVMs based chunking with individual chunk representations. This table also lists the voting weights estimated by different approaches (B:Cross Validation, C:VC-bound, D:Leave-one-out). We also show the results of Start/End representation in Table 2 . Table 3 shows the results of the weighted voting of four different voting methods: A: Uniform, B: Cross Validation ( Q \u00b5\u00b4) , C: VC bound, D: Leave-One-Out Bound. Table 4 shows the precision, recall and \u00b1 \u00b2 h\u00b3 \u00a5 of the best result for each data set. Accuracy vs Chunk Representation We obtain the best accuracy when we apply IOE2-B representation for baseNP-S and chunking data set. In fact, we cannot find a significant difference in the performance between Inside/Outside(IOB1/IOB2/IOE1/IOE2) and Start/End(IOBES) representations. Sassano and Utsuro evaluate how the difference of the chunk representation would affect the performance of the systems based on different machine learning algorithms (Sassano and Utsuro, 2000) . They report that Decision List system performs better with Start/End representation than with Inside/Outside, since Decision List considers the specific combination of features. As for Maximum Entropy, they report that it performs better with Inside/Outside representation than with Start/End,   We believe that SVMs perform well regardless of the chunk representation, since SVMs have a high generalization performance and a potential to select the optimal features for the given task. Effects of Weighted Voting By applying weighted voting, we achieve higher accuracy than any of single representation system regardless of the voting weights. Furthermore, we achieve higher accuracy by applying Cross validation and VC-bound and Leave-One-Out methods than the baseline method. By using VC bound for each weight, we achieve nearly the same accuracy as that of Cross validation. This result suggests that the VC bound has a potential to predict the error rate for the \"true\" test data accurately. Focusing on the relationship between the accuracy of the test data and the estimated weights, we find that VC bound can predict the accuracy for the test data precisely. Even if we have no room for applying the voting schemes because of some real-world constraints (limited computation and memory capacity), the use of VC bound may allow to obtain the best accuracy. On the other hand, we find that the prediction ability of Leave-One-Out is worse than that of VC bound. Cross validation is the standard method to estimate the voting weights for different systems. However, Cross validation requires a larger amount of computational overhead as the training data is divided and is repeatedly used to obtain the voting weights. We believe that VC bound is more effective than Cross validation, since it can obtain the comparable results to Cross validation without increasing computational overhead. Comparison with Related Works Tjong Kim Sang et al. report that they achieve accuracy of 93.86 for baseNP-S data set, and 94.90 for baseNP-L data set. They apply weighted voting of the systems which are trained using distinct chunk representations and different machine learning algorithms such as MBL, ME and IGTree (Tjong Kim Sang, 2000a; Tjong Kim Sang et al., 2000) . Our experiments achieve the accuracy of 93.76 -94.11 for baseNP-S, and 95.29 -95.34 for baseNP-L even with a single chunk representation. In addition, by applying the weighted voting framework, we achieve accuracy of 94.22 for baseNP-S, and 95.77 for baseNP-L data set. As far as accuracies are concerned, our model outperforms Tjong Kim Sang's model. In the CoNLL-2000 shared task, we achieved the accuracy of 93.48 using IOB2-F representation (Kudo and Matsumoto, 2000b) 5 . By combining weighted voting schemes, we achieve accuracy of 93.91. In addition, our method also outperforms other methods based on the weighted voting (van Halteren, 2000; Tjong Kim Sang, 2000b) . Future Work \u00b0Applying to other chunking tasks Our chunking method can be equally applicable to other chunking task, such as English POS tagging, Japanese chunk(bunsetsu) identification and named entity extraction. For future, we will apply our method to those chunking tasks and examine the performance of the method. \u00b0Incorporating variable context length model In our experiments, we simply use the socalled fixed context length model. We believe that we can achieve higher accuracy by selecting appropriate context length which is actually needed for identifying individual chunk tags. Sassano and Utsuro (Sassano and Utsuro, 2000) introduce a variable context length model for Japanese named entity identification task and perform better results. We will incorporate the variable context length model into our system. \u00b0Considering more predictable bound In our experiments, we introduce new types of voting methods which stem from the theorems of SVMs -VC bound and Leave-One-Out bound. On the other hand, Chapelle and Vapnik introduce an alternative and more predictable bound for the risk and report their proposed bound is quite useful for selecting the kernel function and soft margin parameter (Chapelle and Vapnik, 2000) . We believe that we can obtain higher accuracy using this more predictable bound for the voting weights in our experiments. Summary In this paper, we introduce a uniform framework for chunking task based on Support Vector Machines (SVMs). Experimental results on WSJ corpus show that our method outperforms other conventional machine learning frameworks such MBL and Maximum Entropy Models. The results are due to the good characteristics of generalization and nonoverfitting of SVMs even with a high dimensional vector space. In addition, we achieve higher accuracy by applying weighted voting of 8-SVM based systems which are trained using distinct chunk representations.",
    "abstract": "We apply Support Vector Machines (SVMs) to identify English base phrases (chunks). SVMs are known to achieve high generalization performance even with input data of high dimensional feature spaces. Furthermore, by the Kernel principle, SVMs can carry out training with smaller computational overhead independent of their dimensionality. We apply weighted voting of 8 SVMsbased systems trained with distinct chunk representations. Experimental results show that our approach achieves higher accuracy than previous approaches. Support Vector Machines Optimal Hyperplane Let us define the training samples each of which belongs either to positive or negative class as:",
    "countries": [
        "Austria"
    ],
    "languages": [
        "English",
        "Japanese"
    ],
    "numcitedby": "590",
    "year": "2001",
    "month": "",
    "title": "Chunking with Support Vector Machines"
}