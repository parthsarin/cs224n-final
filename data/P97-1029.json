{
    "article": "We present a constraint-based morphological disambiguation system in which individual constraints vote on matching morphological parses, and disambiguation of all the tokens in a sentence is performed at the end by selecting parses that receive the highest votes. This constraint application paradigm makes the outcome of the disambiguation independent of the rule sequence, and hence relieves the rule developer from worrying about potentially conflicting rule sequencing. Our results for disambiguating Turkish indicate that using about 500 constraint rules and some additional simple statistics, we can attain a recall of 95-96~ and a precision of 94-95~ with about 1.01 parses per token. Our system is implemented in Prolog and we are currently investigating an efficient implementation based on finite state transducers. Introduction Automatic morphological disambiguation is an important component in higher level analysis of natural language text corpora. There has been a large number of studies in tagging and morphological disambiguation using various techniques such as statistical techniques, e.g., (Church, 1988; Cutting et al., 1992; DeRose, 1988) , constraint-based techniques (Karlsson et al., 1995; Voutilainen, 1995b; Voutilainen, Heikkil/i, and Anttila, 1992; Voutilainen and Tapanainen, 1993; Oflazer and KuruSz, 1994; Oflazer and Till 1996) and transformation-based techniques (Brilt, 1992; Brill, 1994; Brill, 1995) . This paper presents a novel approach to constraint based morphological disambiguation which relieves the rule developer from worrying about conflicting rule ordering requirements. The approach depends on assigning votes to constraints according to their complexity and specificity, and then letting constraints cast votes on matching parses of a given lexical item. This approach does not reflect the outcome of matching constraints to the set of morphological parses immediately. Only after all applicable rules are applied to a sentence, all tokens are disambiguated in parallel. Thus, the outcome of the rule applications is independent of the order of rule applications. Rule ordering issue has been discussed by Voutilainen(1994) , but he has recently indicated 1 that insensitivity to rule ordering is not a property of their system (although Voutilainen(1995a) states that it is a very desirable property) but rather is achieved by extensively testing and tuning the rules. In the following sections, we present an overview of the morphological disambiguation problem, highlighted with examples from Turkish. We then present our approach and results. We finally conclude with a very brief outline of our investigation into efficient implementations of our approach. Morphological Disambiguation In all languages, words are usually ambiguous in their parts-of-speech or other morphological features, and may represent lexical items of different syntactic categories, or morphological structures depending on the syntactic and semantic context. In languages like English, there are a very small number of possible word forms that can be generated from a given root word, and a small number of part-ofspeech tags associated with a given lexical form. On the other hand, in languages like Turkish or Finnish with very productive agglutinative morphology, it is possible to produce thousands of forms (or even millions (Hankamer, 1989 )) from a given root word and the kinds of ambiguities one observes are quite different than what is observed in languages like English. In Turkish, there are ambiguities of the sort typically found in languages like English (e.g., book/noun vs book/verb type). However, the agglutinative nature of the language usually helps resolution of such ambiguities due to the restrictions on morphotactics of subsequent morphemes. On the 1Voutilainen, Private communication. other hand, this very nature introduces another kind of ambiguity, where a lexical form can be morphologically interpreted in many ways not usually predictable in advance. Furthermore, Turkish allows very productive derivational processes and the information about the derivational structure of a word form is usually crucial for disambiguation (Oflazer and Tiir, 1996) . Most kinds of morphological ambiguities that we have observed in Turkish typically fall into one the following classes: ~ 1. the form is uninflected and assumes the default inflectional features, e.g., I. taS (made of stone) [ [CAT=ADJ] [ROOT=taS]] 2. taS (stone) [ [CAT=NOUN] [ROOT=taS] [AGR=3SG] [POSS=NONE] [CASE=NOM] ] 3. taS (overflow!) [ [CAT=VERB] [ROOT=t aS] [SENSE=POS] [TAMI=IMP] [AGR=2SQ]] 2. Lexically different affixes (conveying different morphological features) surface the same due to the morphographemic context, e.g., 1. ev+[n]in (of the house) [ [CAT=NOUN] [ROOT=ev] [AGR=3SG] [PDSS=NONE] [CASE=GEN] ] 2. ev+in (your house) [ [CAT=NOUN] [ROOT=ev] [AGR=3SG] [POSS=2SG] [CASE=NOM] ] 3. The root of one of the parses is a prefix string of [ [CAT=NOUN] [ROOT=uygulama] [AGR=3SG] [POSS=NONE] [CASE=NDM] ] 2. uygula+ma / ((the act of) applying) [ [CAT=VERB] [ROOT=uygula] [SENSE=POS] [CONV=NOUN=MA] [TYPE=INFINITIVE] [AGR=3SG] [POSS=NONE] [CASE=NOM] ] 3. uygula+ma / (do not apply!) [ [CAT=VERB] [ROOT=uygula] [SENSE=NEG] [TAMI=IMP] [AGR=2SG] ] \u2022 The main intent of our system is to achieve morphological disambiguation by choosing for a given ambiguous token, the correct parse in a given context. It is certainly possible that a given token may have nmltiple correct parses, usually with the same inflectional features, or with inflectional features not ruled out by the syntactic context, but one will be the \"correct\" parse usually on semantic grounds. We consider a token fully disambiguated if it has only one morphological parse remaining after automatic disambiguation. We Consider a token as correctly disambiguated, if one of the parses remaining for that token is the correct intended parse. We evaluate the resulting disambiguated text by a number of metrics defined as follows (Voutilainen, 1995a) : #Parses Ambiguity-#Tokens Recall = #Tokens Correctly Disambiguated #Tokens Precision = #Tokens Correctly Disambiguated #Parses In the ideal case where each token is uniquely and correctly disambiguated with the correct parse, both recall and precision will be 1.0. On the other hand, a text where each token is annotated with all possible parses, 3 the recall will be 1.0, but the precision will be low. The goal is to have both recall and precision as high as possible. 3 Constraint-based Morphological Disambiguation This section outlines our approach to constraintbased morphological disambiguation where constraints vote on matching parses of sequential tokens. 3.1 Constraints on morphological parses We describe constraints on the morphological parses of tokens using rules with two components R= (Cl,C~.,...,C,~;V) where the Ci are (possibly hierarchical) feature constraints on a sequence of the morphological parses, and V is an integer denoting the vote of the rule. To illustrate the flavor of our rules we can give the following examples: 1. The following rule with two constraints matches parses with case feature ablative, preceding a parse matching a postposition subcategorizing for an ablative nominal form. [ which matches tile derived participle reading of a verb with narrative past tense, if it is followed by an underived noun parse. Determining the vote of a rule There are a number of ways votes can be assigned to rules. For the purposes of this work the vote of a rule is determined by its static properties, but it is certainly conceivable that votes can be assigned or learned by using statistics from disambiguated corpora. 4 For static vote assignment, intuitively, we would like to give high votes to rules that are more specific: i.e., to rules that have aAssuming no unknown words. 4We have left this for future work. \u2022 higher number of constraints, \u2022 higher number of features in the constraints, \u2022 constraints that make reference to nested stems (from which the current form is derived), \u2022 constraints that make reference to very specific features or values. Let R = (C1,C2,'\",C~;V) be a constraint rule. The vote V is determined as where fi is the name of a morphological feature, and vi is one of the possible values for that feature. The contribution of fi : vi in the vote of a constraint depends on a number of factors: 1. The value vi may be a distinguished value that has a more important function in disambiguation. 5 In this case, the weight of the feature constraint is w(vi)(> 1). 2. The feature itself may be a distinguished feature which has more important function in disambiguation. In this case the weight of the feature is w(fi)(> 1). 3. If the feature fi refers to the stem of a derived form and the value part of the feature constraint is a full fledged constraint C' on the stem structure, the weight of the feature constraint is found by recursively computing the vote of C' and scaling the resulting value by a factor (2 in our current system) to improve its specificity. 4. Otherwise, the weight of the feature constraint is 1. For example suppose we have the following constraint: Assuming the value gen is a distinguished value with weight 4 (cf., factor 1 above), the vote of this constraint is computed as follows: 1. cat :noun contributes 1, 2. case:gen contributes 4, We also employ a set of rules which express preferences among the parses of single lexical form independent of the context in which the form occurs. The weights for these rules are currently manually determined. These rules give negative votes to the parses which are not preferred or high votes to certain parses which are always preferred. Our experience is that such preference rules depend on the kind of the text one is disambiguating. For instance if one is disambiguating a manual of some sort, imperative readings of verbs are certainly possible, whereas in normal plain text with no discourse, such readings are discouraged. Voting and selecting parses A rule R = (C1,62,'\", Cn; V) will match a sequence of tokens wi, Wi+l, \u2022 \u2022., wi+n-1 within a sentence wl through ws if some morphological parse of every token wj,i < j < i + n -1 is subsumed by the corresponding constraint Cj-i+l. When all constraints match, the votes of all the matching parses are incremented by V. If a given constraint matches more than one parse of a token, then the votes of all such matching parses are incremented. After all rules have been applied to all token positions in a sentence and votes are tallied, morphological parses are selected in the following manner. Let vt and Vh be the votes of the lowest and highest scoring parses for a given token. All parses with votes equal to or higher than vt + m * (Vh --vt) are selected with m (0 _< m _< 1) being a parameter. m = 1 selects the highest scoring parse(s). 4 Results from Disambiguating Turkish Text We have applied our approach to disambiguating Turkish text. Raw text is processed by a preprocessor which segments the text into sentences using various heuristics about punctuation, and then tokenizes and runs it through a wide-coverage highperformance morphological analyzer developed using two-level morphology tools by Xerox (Karttunen, 1993) . The preprocessor module also performs a number of additional functions such as grouping of lexicalizcd and non-lexicalized collocations, compound verbs, etc., (Ofiazer and Kurubz, 1994; Oflazer and Tiir, 1996) . The preprocessor also uses a second morphological processor for dealing with unknown words which recovers any derivational and inflectional information from a word even if the root word is not known. This unknown word processor has a (nominal) root lexicon which recognizes S +, where S is the Turkish surface alphabet (in the two-level morphology sense), but then tries to interpret an arbitrary postfix string of the unknown word, as a sequence of Turkish suffixes subject to all morphographemic constraints (Oflazer and Tfir, 1996) . We have applied our approach to four texts labeled ARK, HIST, MAN, EMB, with statistics given in Table 1 . The tokens considered are those that are generated after morphological analysis, unknown word processing and any lexical coalescing is done. The words that are counted as unknown are those that could not even be processed by the unknown noun processor as they violate Turkish morphographemic constraints. Whenever an unknown word has more than one parse it is counted under the appropriate group. 6 The fourth and fifth columns in this table give the average parses per token and the initial precision assuming initial recall is 100%. We have disambiguated these texts using a rule base of about 500 hand-crafted rules. Most of the rule crafting was done using the general linguistic constraints and constraints that we derived from the first text, ARK. In this sense, this text is our \"training data\", while the other three texts were not considered in rule crafting. Our results are summarized in Table 2 . The last four columns in this table present results for different values for the parameter rn mentioned above, m = 1 denoting the case when only the highest scoring parse(s) is (are) selected. The columns for m < 1 are presented in order to emphasize that drastic loss of precision for those cases. Even at m = 0.95 there is considerable loss of precision and going up to m = 1 causes a dramatic increase in precision without a significant loss in recall. It can be seen that we can attain very good recall and quite acceptable precision with just voting constraint rules. Our experience is that we can in principle add highly specialized rules by covering a larger text base to improve our recall and precision for the m = 1. A post-mortem analysis has shown that cases that have been missed are mostly due to morphosyntactic dependencies that span a context much wider that 5 tokens that we currently employ. Using root and contextual statistics We have employed two additional sources of information: root word usage statistics, and contextual statistics. We have statistics compiled from previously disambiguated text, on root frequencies. After the application of constraints as described above, for 6The reason for the (comparatively) high number of unknown words in MAN, is that tokens found in such texts, like .[10, denoting a function key in the computer can not be parsed as a Turkish root word! On top of this, we use the following heuristic using context statistics to eliminate any further ambiguities. For every remaining ambiguous token with unambiguous immediate left and right contexts (i.e., the tokens in the immediate left and right are unambiguous), we perform the following, by ignoring the root/stem feature of ~he parses: 1. For every ambiguous parse in such an unambiguous context, we count how many times, this parse occurs unambiguously in exactly the same unambiguous context, in the rest of the text. 2. We then choose the parse whose count is substantially higher than the others. The results after applying this step on of the previous two steps are shown in the last column of Table 3 (labeled V+R+C). One can see from the last three columns of this table, the impact of each of the steps. By ignoring root/stem features during this process, we essentially are considering just the top level inflectional information of the parses. This is very similar to Brill's use of contexts to induce transformation rules for his tagger (Brill, 1992; Brill, 1995) , but instead of generating transformation rules from a training text, we gather statistics and apply them to parses in the text being disambiguated. 5 Efficient Implementation Techniques and Extensions The current implementation of the voting approach is meant to be a proof of concept implementation and is rather inefficient. However, the use of regular relations and finite state transducers (Kaplan and Kay, 1994) provide a very efficient implementation method. For this, we view the parses of the tokens making up a sentence as making up a acyclic a finite state recognizer with the states marking word boundaries and the ambiguous interpretations of the tokens as the state transitions between states, the rightmost node denoting the final state, as depicted in Figure 1 for a sentence with 5 tokens. In Figure 1 , the transition labels are triples of the sort (wi, pj, O) for the jth parse of token i, with the 0 indicating the initial vote of the parse. The rules imposing constraints can also be represented as transducers which increment the votes of the matching transi- tion labels by an appropriate amount. ~ Such transducers ignore and pass through unchanged, parses that they are not sensitive to. When a finite state recognizer corresponding to the input sentence (which actually may be considered as an identity transducer) is composed with a constraint transducer, one gets a slightly modified version of the sentence transducer with possibly additional transitions and states, where the votes of some of the labels have been appropriately increlnented. When the sentence transducer is composed with all the constraint transducers in sequence, all possible votes are cast and the final sentence transducer reflects all the votes. The parse corresponding to each token with the highest vote can then be selected. The key point here is that due to the nature of the composition operator, the constraint transducers can be composed off-line first, giving a single constraint transducer and then this one is composed with every sentence transducer once (See Figure 2 ). The idea of voting can further be extended to a path voting framework where rules vote on paths containing sequences of matching parses and the path from the start state to the final stated with the highest votes received, is then selected. This can be implemented again using finite state transducers as described above (except that path vote is apportioned equally to relevant parse votes), but instead of selecting highest scoring parses, one selects the path from the start state to one of the final states where the sum of the parse votes is maximum. We have recently completed a prototype implementation of this approach (in C) for English (Brown Corpus) and have obtained quite similar results (Tiir, Oflazer, and Oz-kan, 1997) . Conclusions We have presented an approach to constraint-based morphological disambiguation which uses constraint voting as its primary mechanism for parse selection and alleviates the rule developer from worrying about rule ordering issues. Our approach is quite general and is applicable to any language. Rules describing language specific linguistic constraints vote on matching parses of tokens, and at the end, parses TSuggested by Lauri Karttunen (private communication). for every token receiving the highest tokens are selected. We have applied this approach to Turkish, a language with complex agglutinative word forms exhibiting morphological ambiguity phenomena not usually found in languages like English and have obtained quite promising results. The convenience of adding new rules in without worrying about where exactly it goes in terms of rule ordering (something that hampered our progress in our earlier work on disambiguating Turkish morphology (Oflazer and KuruSz, 1994; Oflazer and Tiir, 1996) ), has also been a key positive point. Furthermore, it is also possible to use rules with negative votes to disallow impossible cases. This has been quite useful for our work on tagging English (Tfir, Oflazer, and 0z-kan, 1997) where such rules with negative weights were used to fine tune the behavior of the tagger in various problematic cases. The proposed approach is also amenable to an efficient implementation by finite state transducers (Kaplan and Kay, 1994) . By using finitestate transducers, it is furthermore possible to use a bit more expressive rule formalism including for instance the Kleene * operator so that one can use a much smaller set of rules to cover the same set of local linguistic phenomena. Our current and future work in this framework involves the learning of constraints and their votes from corpora, and combining learned and handcrafted rules. 7 Acknowledgments This research has been supported in part by a NATO Science for Stability Grant TU-LANGUAGE. We thank Lauri Karttunen of Rank Xerox Research Centre in Grenoble for providing the Xerox two-level morphology tools on which the Turkish morphological analyzer was built. ",
    "abstract": "We present a constraint-based morphological disambiguation system in which individual constraints vote on matching morphological parses, and disambiguation of all the tokens in a sentence is performed at the end by selecting parses that receive the highest votes. This constraint application paradigm makes the outcome of the disambiguation independent of the rule sequence, and hence relieves the rule developer from worrying about potentially conflicting rule sequencing. Our results for disambiguating Turkish indicate that using about 500 constraint rules and some additional simple statistics, we can attain a recall of 95-96~ and a precision of 94-95~ with about 1.01 parses per token. Our system is implemented in Prolog and we are currently investigating an efficient implementation based on finite state transducers.",
    "countries": [
        "T\u00fcrkiye"
    ],
    "languages": [
        "English",
        "Turkish"
    ],
    "numcitedby": "46",
    "year": "1997",
    "month": "July",
    "title": "Morphological Disambiguation by Voting Constraints"
}