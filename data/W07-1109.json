{
    "article": "This paper proposes an approach of processing Japanese compound functional expressions by identifying them and analyzing their dependency relations through a machine learning technique. First, we formalize the task of identifying Japanese compound functional expressions in a text as a machine learning based chunking problem. Next, against the results of identifying compound functional expressions, we apply the method of dependency analysis based on the cascaded chunking model. The results of experimental evaluation show that, the dependency analysis model achieves improvements when applied after identifying compound functional expressions, compared with the case where it is applied without identifying compound functional expressions. Introduction In addition to single functional words, the Japanese language has many more compound functional expressions which consist of more than one word including both content words and functional words. They are very important for recognizing syntactic structures of Japanese sentences and for understanding their semantic content. Recognition and understanding of them are also very important for various kinds of NLP applications such as dialogue systems, machine translation, and question answering. However, recognition and semantic interpretation of compound functional expressions are especially difficult because it often happens that one compound expression may have both a literal (i.e. compo-sitional) content word usage and a non-literal (i.e. non-compositional) functional usage. For example, Table 1 shows two example sentences of a compound expression \"\u306b (ni) \u3064\u3044\u3066 (tsuite)\", which consists of a post-positional particle \"\u306b (ni)\", and a conjugated form \"\u3064\u3044\u3066 (tsuite)\" of a verb \"\u3064\u304f (tsuku)\". In the sentence (A), the compound expression functions as a case-marking particle and has a non-compositional functional meaning \"about\". On the other hand, in the sentence (B), the expression simply corresponds to a literal concatenation of the usages of the constituents: the postpositional particle \"\u306b (ni)\" and the verb \"\u3064\u3044\u3066 (tsuite)\", and has a content word meaning \"follow\". Therefore, when considering machine translation of these Japanese sentences into English, it is necessary to judge precisely the usage of the compound expression \"\u306b (ni) \u3064\u3044\u3066 (tsuite)\", as shown in the English translation of the two sentences in Table 1 . There exist widely-used Japanese text processing tools, i.e. combinations of a morphological analysis tool and a subsequent parsing tool, such as JU-MAN 1 + KNP 2 and ChaSen 3 + CaboCha 4 . However, they process those compound expressions only partially, in that their morphological analysis dictionaries list only a limited number of compound expressions. Furthermore, even if certain expressions are listed in a morphological analysis dictionary, those existing tools often fail in resolving the ambigui-\u79c1 (watashi) \u306f (ha) \u5f7c (kare) 1 . This is mainly because the framework of these existing tools is not designed so as to resolve such ambiguities of compound (possibly functional) expressions by carefully considering the context of those expressions. \u306b (ni) \u3064\u3044\u3066 (tsuite) \u8a71\u3057\u305f (hanashita) (A) (I) ( TOP) (he) ( about) ( talked) (I talked about him.) \u79c1 (watashi) \u306f (ha) \u5f7c (kare) \u306b (ni) \u3064\u3044\u3066 (tsuite) \u8d70\u3063\u305f (hashitta) (B) (I) ( TOP) (he) (ACC) ( follow) ( ran) (I ran following him.) Actually, as we introduce in the next section, as a first step towards studying computational processing of compound functional expressions, we start with 125 major functional expressions which have noncompositional usages, as well as their variants (337 expressions in total). Out of those 337 expressions, 111 have both a content word usage and a functional usage. However, the combination of JUMAN+KNP is capable of distinguishing the two usages only for 43 of the 111 expressions, and the combination of ChaSen+CaboCha only for 40 of those 111 expressions. Furthermore, the failure in distinguishing the two usages may cause errors of syntactic analysis. For example, (1) of Figure 1 gives an example of identifying a correct modifiee of the second bunsetsu segment 5 \"\u89e3\u6c7a\u624b\u6bb5\u3068\u3057\u3066 (as a means for solution)\" including a Japanese compound functional expression \"\u3068\u3057\u3066 (as)\", by appropriately detecting the compound functional expression before dependency analysis. On the other hand, (2) of Figure 1 gives an example of incorrectly indicating an erroneous modifiee of the third bunsetsu \"\u3057\u3066\", which actually happens if we do not identify the compound functional expression \"\u3068\u3057\u3066 (as)\" before dependency analysis of this sentence. Considering such a situation, it is necessary to develop a tool which properly recognizes and semantically interprets Japanese compound functional expressions. This paper proposes an approach of processing Japanese compound functional expressions by identifying them and analyzing their dependency relations through a machine learning technique. The overall flow of processing compound functional expressions in a Japanese sentence is il- 2 . First of all, we assume a sequence of morphemes obtained by a variant of ChaSen with all the compound functional expressions removed from its outputs, as an input to our procedure of identifying compound functional expressions and analyzing their dependency relations. We formalize the task of identifying Japanese compound functional expressions in a text as a machine learning based chunking problem (Tsuchiya et al., 2006) . We employ the technique of Support Vector Machines (SVMs) (Vapnik, 1998) as the machine learning technique, which has been successfully applied to various natural language processing tasks including chunking tasks such as phrase chunking and named entity chunking. Next, against the results of identifying compound functional expressions, we apply the method of dependency analysis based on the cascaded chunking model (Kudo and Matsumoto, 2002) , which is simple and efficient because it parses a sentence deterministically only deciding whether the current bunsetsu segment modifies the one on its immediate right hand side. As we showed in Figure 1 , identifying compound functional expressions before analyzing dependencies in a sentence does actually help deciding dependency relations of compound functional expressions. In the experimental evaluation, we focus on 59 expressions having balanced distribution of their usages in the newspaper text corpus and are among the most difficult ones in terms of their identification in a text. We first show that the proposed method of chunking compound functional expressions significantly outperforms existing Japanese text processing tools. Next, we further show that the dependency analysis model of (Kudo and Matsumoto, 2002) applied to the results of identifying compound functional expressions significantly outperforms the one applied to the results without identifying compound functional expressions. Japanese Compound Functional Expressions There exist several collections which list Japanese functional expressions and examine their usages. For example, (Morita and Matsuki, 1989) (\u223c \u3092 \u223c \u3068\u3057\u3066 (to-shite) = make \u223c \u223c (5) \u3068\u3044\u3046 \u5f7c\u306f\u751f\u304d\u3066\u3044\u308b \u3068\u3044\u3046 \u77e5\u3089\u305b\u3092\u805e\u3044\u305f\u3002 functional (to-iu) (I heard that he is alive.) (\u223c \u3068\u3044\u3046 (to-iu) = that \u223c) (6) \u3068\u3044\u3046 \u300c\u904a\u3073\u306b\u6765\u3066\u4e0b\u3055\u3044\u300d \u3068\u3044\u3046 \u4eba\u3082\u3044\u308b\u3002 content (to-iu) (Somebody says \"Please visit us.\".) (\u223c \u3068\u3044\u3046 (to-iu) = say (that) \u223c) (7) \u3066\u3044\u3044 \u3053\u306e\u8b70\u8ad6\u304c\u7d42\u3063\u305f\u3089\u4f11\u61a9\u3057 \u3066\u3044\u3044 \u3002 functional (te-ii) (You may have a break after we finish this discussion.) tal) . In this paper, following (Sag et al., 2002) , we regard each variant as a fixed expression, rather than a semi-fixed expression or a syntactically-flexible expression 7 . Then, we focus on evaluating the effectiveness of straightforwardly applying a standard chunking technique to the task of identifying Japanese compound functional expressions. (\u223c \u3066\u3044\u3044 (te-ii) = may \u223c) (8) \u3066\u3044\u3044 \u3053\u306e\u304b\u3070\u3093\u306f\u5927\u304d\u304f \u3066\u3044\u3044 \u3002 content (te-ii) (This bag is nice because it is big.) (\u223c \u3066\u3044\u3044 (te-ii) = nice because \u223c) As in Table 2 (a), according to their grammatical functions, those 337 expressions in total are roughly classified into post-positional particle type, and auxiliary verb type. Functional expressions of post-positional particle type are further classified into three subtypes: i) conjunctive particle types, which are used for constructing subordinate clauses, ii) case-marking particle types, iii) adnominal particle types, which are used for constructing adnominal 7 Compound functional expressions of auxiliary verb types can be regarded as syntactically-flexible expressions. clauses. Furthermore, for examples of compound functional expressions listed in Table 2 (a), Table 2 (b) gives their example sentences as well as the description of their usages. Identifying Compound Functional Expressions by Chunking with SVMs This section describes summaries of formalizing the chunking task using SVMs (Tsuchiya et al., 2006) . In this paper, we use an SVMs-based chunking tool YamCha 8 (Kudo and Matsumoto, 2001 ). In the SVMs-based chunking framework, SVMs are used as classifiers for assigning labels for representing chunks to each token. In our task of chunking Japanese compound functional expressions, each sentence is represented as a sequence of morphemes, where a morpheme is regarded as a token. Chunk Representation For representing proper chunks, we employ IOB2 representation, which has been studied well in various chunking tasks of natural language processing. This method uses the following set of three labels for representing proper chunks. I Current token is a middle or the end of a chunk consisting of more than one token. O Current token is outside of any chunk. B Current token is the beginning of a chunk. Given a candidate expression, we classify the usages of the expression into two classes: functional and content. Accordingly, we distinguish the chunks of the two types: the functional type chunk and the content type chunk. In total, we have the following five labels for representing those chunks: Bfunctional, I-functional, B-content, I-content, and O. Finally, as for extending SVMs to multi-class classifiers, we experimentally compare the pairwise method and the one vs. rest method, where the pairwise method slightly outperformed the one vs. rest method. Throughout the paper, we show results with the pairwise method. Features For the feature sets for training/testing of SVMs, we use the information available in the surrounding context, such as the morphemes, their parts-of-speech tags, as well as the chunk labels. More precisely, suppose that we identify the chunk label c i for the i-th morpheme: \u2212\u2192 Parsing Direction \u2212\u2192 Morpheme mi\u22122 mi\u22121 mi mi+1 mi+2 Feature set Fi\u22122 Fi\u22121 Fi Fi+1 Fi+2 at a position Chunk label ci\u22122 ci\u22121 ci Here, m i is the morpheme appearing at i-th position, F i is the feature set at i-th position, and c i is the chunk label for i-th morpheme. Roughly speaking, when identifying the chunk label c i for the i-th morpheme, we use the feature sets F i\u22122 , F i\u22121 , F i , F i+1 , F i+2 at the positions i \u2212 2, i \u2212 1, i, i + 1, i + 2, as well as the preceding two chunk labels c i\u22122 and c i\u22121 . The detailed definition of the feature set F i at i-th position is given in (Tsuchiya et al., 2006) , which mainly consists of morphemes as well as in-formation on the candidate compound functional expression at i-th position. Learning Dependency Relations of Japanese Compound Functional Expressions 4.1 Japanese Dependency Analysis using Cascaded Chunking Cascaded Chunking Model First of all, we define a Japanese sentence as a sequence of bunsetsu segments B = b 1 , b 2 , . . . , b m and its syntactic structure as a sequence of dependency patterns D = Dep(1), Dep(2), . . . , Dep(m \u2212 1) , where Dep(i) = j means that the bunsetsu segment b i depends on (modifies) bunsetsu segment b j . In this framework, we assume that the dependency sequence D satisfies the following two constraints: 1. Japanese is a head-final language. Thus, except for the rightmost one, each bunsetsu segment modifies exactly one bunsetsu segment among those appearing to its right. 2. Dependencies do not cross one another. Unlike probabilistic dependency analysis models of Japanese, the cascaded chunking model of Kudo and Matsumoto (2002) does not require the probabilities of dependencies and parses a sentence deterministically. Since Japanese is a head-final language, and the chunking can be regarded as the creation of a dependency between two bunsetsu segments, this model simplifies the process of Japanese dependency analysis as follows: 9 1. Put an O tag on all bunsetsu segments. The O tag indicates that the dependency relation of the current segment is undecided. 2. For each bunsetsu segment with an O tag, decide whether it modifies the bunsetsu segment on its immediate right hand side. If so, the O tag is replaced with a D tag. 3. Delete all bunsetsu segments with a D tag that immediately follows a bunsetsu segment with an O tag. Figure 3 shows an example of the parsing process with the cascaded chunking model. Features As a Japanese dependency analyzer based on the cascaded chunking model, we use the publicly available version of CaboCha (Kudo and Matsumoto, 2002) , which is trained with the manually parsed sentences of Kyoto text corpus (Kurohashi and Nagao, 1998) , that are 38,400 sentences selected from the 1995 Mainichi newspaper text. The standard feature set used by CaboCha consists of static features and dynamic features. Static features are those solely defined once the pair of modifier/modifiee bunsetsu segments is specified. For the pair of modifier/modifiee bunsetsu segments, the following are used as static features: head words and their parts-of-speech tags, inflection-types/forms, functional words and their parts-of-speech tags, inflection-types/forms, inflection forms of the words that appear at the end of bunsetsu segments. As for features between modifier/modifiee bunsetsu segments, the distance of modifier/modifiee bunsetsu segments, existence of case-particles, brackets, quotation-marks, and punctuation-marks are used as static features. On the other hand, dynamic features are created during the parsing process, so that, when a certain dependency relation is determined, it can have some influence on other dependency relations. Dynamic features include bunsetsu segments modifying the current candidate modifiee (see Kudo and Matsumoto (2002) for the details). Coping with Compound Functional Expressions As we show in Figure 2 , a compound functional expression is identified as a sequence of several morphemes and then chunked into one morpheme. The result of this identification process is then transformed into the sequence of bunsetsu segments. Finally, to this modified sequence of bunsetsu segments, the method of dependency analysis based on the cascaded chunking model is applied. Here, when chunking a sequence of several morphemes constituting a compound functional expression, the following two cases may exist: (A) As in the case of the example (A) in Table 1 , the two morphemes constituting a compound functional expression \"\u306b (ni) \u3064\u3044\u3066 (tsuite)\" overlaps the boundary of two bunsetsu segments. In such a case, when chunking the two morphemes into one morpheme corresponding to a compound functional expression, those two bunsetsu segments are concatenated into one bunsetsu segment. \u5f7c \u306b kare ni (he) \u3064\u3044\u3066 tsuite =\u21d2 \u5f7c \u306b\u3064\u3044\u3066 kare ni-tsuite (he) (about) (B) As we show below, a compound functional expression \"\u3053\u3068 (koto) \u304c (ga) \u3042\u308b (aru)\" overlaps the boundary of two bunsetsu segments, though the two bunsetsu segments concatenating into one bunsetsu segment does include no content words. In such a case, its immediate left bunsetsu segment (\"\u884c\u3063(itt) \u305f (ta)\" in the example below), which corresponds to the content word part of \"\u3053\u3068 (koto) \u304c (ga) \u3042\u308b (aru)\", has to be concatenated into the bunsetsu segment \"\u3053\u3068 (koto) \u304c (ga) \u3042\u308b (aru)\". Next, to the compound functional expression, we assign one of the four grammatical function types listed in Table 2 as its POS tag. For example, the compound functional expression \"\u306b (ni) \u3064\u3044\u3066 (tsuite)\" in (A) above is assigned the grammatical function type \"case-marking particle type\", while \" \u3053\u3068 (koto) \u304c (ga) \u3042\u308b (aru)\" in (B) is assigned \"auxiliary verb type\". These modifications cause differences in the final feature representations. For example, let us compare the feature representations of the modifier bunsetsu segments in (1) and (2) of Figure 1 . In (1), the modifier bunsetsu segment is \"\u89e3\u6c7a\u624b\u6bb5\u3068\u3057\u3066\" which has the compound functional expression \"\u3068\u3057\u3066\" in its functional word part. On the other hand, in (2), the modifier bunsetsu segment is \"\u3057\u3066\", which corresponds to the literal verb usage of a part of the compound functional expression \"\u3068\u3057\u3066\". In the final feature representations below, this causes the following differences in head words and functional words / POS of the modifier bunsetsu segments: (1) of Figure 1 (2) of Figure 1 Chunking As we show in Table 4 , performance of our SVMsbased chunkers as well as several baselines including existing Japanese text processing tools is evaluated in terms of precision/recall/F \u03b2=1 of identifying all the 5,744 functional chunks included in the test data (Kyoto text corpus in Table 3 ). Performance is evaluated also in terms of accuracy of classifying detected candidate expressions into functional/content chunks. Among those baselines, \"majority ( = functional)\" always assigns functional usage to the detected candidate expressions. Performance of our SVMs-based chunkers is measured through 10-fold cross validation. Our SVMs-based chunker significantly outperforms those baselines both in F \u03b2=1 and classification accuracy. As we mentioned in section 1, existing Japanese text processing tools process compound functional expressions only partially, which causes damage in recall in Table 4 . Analyzing Dependency Relations We evaluate the accuracies of judging dependency relations of compound functional expressions by the variant of CaboCha trained with Kyoto text corpus annotated with usage labels of compound functional expressions. This performance is measured through 10-fold cross validation with the modified version of the Kyoto text corpus. In the evaluation phase, according to the flow of Figure 2 , first we apply the chunker of compound functional expressions trained with all the 2,429 sentences in formed by our variant of CaboCha, where accuracies of identifying modifier(s)/modifiee of compound functional expressions are measured as in Table 5 (\"chunker + CaboCha (proposed)\" denotes that inputs to CaboCha (proposed) are with 90% correct rate, while \"reference + CaboCha (proposed)\" denotes that they are with 100% correct rate). Here, \"CaboCha (w/o FE)\" denotes a baseline variant of CaboCha, with all the compound functional expressions removed from its inputs (which are outputs from ChaSen), while \"CaoboCha (public)\" denotes the publicly available version of CaboCha, which have some portion of the compound functional expressions included in its inputs. For the modifier accuracy, the difference of \"chunker + CaboCha (proposed)\" and \"CaboCha (w/o FE)\" is statistically significant at a level of 0.05. Identifying compound functional expressions typically contributes to improvements when the literal constituents of a compound functional expression include a verb. In such a case, for bunsetsu segments which usually modifies a verb, an incorrect modifee candidate is removed, which results in improvements in the modifier accuracy. The difference between 'CaoboCha (public)\" and \"chunker + CaboCha (proposed)\" is slight because the publicly available version of CaboCha seems to include compound functional expressions which are damaged in identifying their modifiers with \"CaboCha (w/o FE)\". For the modifiee accuracy, the difference of \"chunker + CaboCha (proposed)\" and \"CaboCha (w/o FE)\" is zero. Here, more than 100 instances of improvements like the one in Figure 1 are observed, while almost the same number of additional failures are also observed mainly because of the sparseness problem. Furthermore, in the case of the modifiee accuracy, it is somehow difficult to expect improvement because identifying modifiees of functional/content bunsetsu segments mostly depends on features other than functional/content distinction. Concluding Remarks We proposed an approach of processing Japanese compound functional expressions by identifying them and analyzing their dependency relations through a machine learning technique. This approach is novel in that it has never been applied to any language so far. Experimental evaluation showed that the dependency analysis model applied to the results of identifying compound functional expressions significantly outperforms the one applied to the results without identifying compound functional expressions. The proposed framework has advantages over an approach based on manually created rules such as the one in (Shudo et al., 2004) , in that it requires human cost to create manually and maintain those rules. Related works include Nivre and Nilsson (2004) , which reports improvement of Swedish parsing when multi word units are manually annotated.",
    "abstract": "This paper proposes an approach of processing Japanese compound functional expressions by identifying them and analyzing their dependency relations through a machine learning technique. First, we formalize the task of identifying Japanese compound functional expressions in a text as a machine learning based chunking problem. Next, against the results of identifying compound functional expressions, we apply the method of dependency analysis based on the cascaded chunking model. The results of experimental evaluation show that, the dependency analysis model achieves improvements when applied after identifying compound functional expressions, compared with the case where it is applied without identifying compound functional expressions.",
    "countries": [
        "Japan"
    ],
    "languages": [
        "Swedish",
        "English",
        "Japanese"
    ],
    "numcitedby": "9",
    "year": "2007",
    "month": "June",
    "title": "Learning Dependency Relations of {J}apanese Compound Functional Expressions"
}