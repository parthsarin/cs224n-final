{
    "article": "We show how features can easily be added to standard generative models for unsupervised learning, without requiring complex new training methods. In particular, each component multinomial of a generative model can be turned into a miniature logistic regression model if feature locality permits. The intuitive EM algorithm still applies, but with a gradient-based M-step familiar from discriminative training of logistic regression models. We apply this technique to part-of-speech induction, grammar induction, word alignment, and word segmentation, incorporating a few linguistically-motivated features into the standard generative model for each task. These feature-enhanced models each outperform their basic counterparts by a substantial margin, and even compete with and surpass more complex state-of-the-art models. Introduction Unsupervised learning methods have been increasingly successful in recent NLP research. The reasons are varied: increased supplies of unlabeled data, improved understanding of modeling methods, additional choices of optimization algorithms, and, perhaps most importantly for the present work, incorporation of richer domain knowledge into structured models. Unfortunately, that knowledge has generally been encoded in the form of conditional independence structure, which means that injecting it is both tricky (because the connection between independence and knowledge is subtle) and timeconsuming (because new structure often necessitates new inference algorithms). In this paper, we present a range of experiments wherein we improve existing unsupervised models by declaratively adding richer features. In particular, we parameterize the local multinomials of exist-ing generative models using features, in a way which does not require complex new machinery but which still provides substantial flexibility. In the featureengineering paradigm, one can worry less about the backbone structure and instead use hand-designed features to declaratively inject domain knowledge into a model. While feature engineering has historically been associated with discriminative, supervised learning settings, we argue that it can and should be applied more broadly to the unsupervised setting. The idea of using features in unsupervised learning is neither new nor even controversial. Many top unsupervised results use feature-based models (Smith and Eisner, 2005; Haghighi and Klein, 2006) . However, such approaches have presented their own barriers, from challenging normalization problems, to neighborhood design, to the need for complex optimization procedures. As a result, most work still focuses on the stable and intuitive approach of using the EM algorithm to optimize data likelihood in locally normalized, generative models. The primary contribution of this paper is to demonstrate the clear empirical success of a simple and accessible approach to unsupervised learning with features, which can be optimized by using standard NLP building blocks. We consider the same generative, locally-normalized models that dominate past work on a range of tasks. However, we follow Chen (2003) , Bisani and Ney (2008), and Bouchard-C\u00f4t\u00e9 et al. (2008) , and allow each component multinomial of the model to be a miniature multi-class logistic regression model. In this case, the EM algorithm still applies with the E-step unchanged. The M-step involves gradient-based training familiar from standard supervised logistic regression (i.e., maximum entropy models). By integrating these two familiar learning techniques, we add features to unsupervised models without any specialized learning or inference. A second contribution of this work is to show that further gains can be achieved by directly optimizing data likelihood with LBFGS (Liu et al., 1989) . This alternative optimization procedure requires no additional machinery beyond what EM uses. This approach is still very simple to implement, and we found that it empirically outperforms EM. This paper is largely empirical; the underlying optimization techniques are known, even if the overall approach will be novel to many readers. As an empirical demonstration, our results span an array of unsupervised learning tasks: part-of-speech induction, grammar induction, word alignment, and word segmentation. In each task, we show that declaring a few linguistically motivated feature templates yields state-of-the-art results. Models We start by explaining our feature-enhanced model for part-of-speech (POS) induction. This particular example illustrates our approach to adding features to unsupervised models in a well-known NLP task. We then explain how the technique applies more generally. Example: Part-of-Speech Induction POS induction consists of labeling words in text with POS tags. A hidden Markov model (HMM) is a standard model for this task, used in both a frequentist setting (Merialdo, 1994; Elworthy, 1994) and in a Bayesian setting (Goldwater and Griffiths, 2007; Johnson, 2007) . A POS HMM generates a sequence of words in order. In each generation step, an observed word emission y i and a hidden successor POS tag z i+1 are generated independently, conditioned on the current POS tag z i . This process continues until an absorbing stop state is generated by the transition model. There are two types of conditional distributions in the model-emission and transition probabilitiesthat are both multinomial probability distributions. The joint likelihood factors into these distributions: P \u03b8 (Y = y, Z = z) = P \u03b8 (Z 1 = z 1 ) \u2022 |z| i=1 P \u03b8 (Y i = y i |Z i = z i ) \u2022 P \u03b8 (Z i+1 = z i+1 |Z i = z i ) The emission distribution P \u03b8 (Y i = y i |Z i = z i ) is parameterized by conditional probabilities \u03b8 y,z,EMIT for each word y given tag z. Alternatively, we can express this emission distribution as the output of a logistic regression model, replacing the explicit conditional probability table by a logistic function parameterized by weights and features: \u03b8 y,z,EMIT (w) = exp w, f (y, z, EMIT) y \u2032 exp w, f (y \u2032 , z, EMIT) This feature-based logistic expression is equivalent to the flat multinomial in the case that the feature function f (y, z, EMIT) consists of all indicator features on tuples (y, z, EMIT), which we call BASIC features. The equivalence follows by setting weight w y,z,EMIT = log(\u03b8 y,z,EMIT ). 1 This formulation is known as the natural parameterization of the multinomial distribution. In order to enhance this emission distribution, we include coarse features in f (y, z, EMIT), in addition to the BASIC features. Crucially, these features can be active across multiple (y, z) values. In this way, the model can abstract general patterns, such as a POS tag co-occurring with an inflectional morpheme. We discuss specific POS features in Section 4. General Directed Models Like the HMM, all of the models we propose are based on locally normalized generative decisions that condition on some context. In general, let X = (Z, Y) denote the sequence of generation steps (random variables) where Z contains all hidden random variables and Y contains all observed random variables. The joint probability of this directed model factors as: P w (X = x) = i\u2208I P w X i = x i X \u03c0(i) = x \u03c0(i) , where X \u03c0(i) denotes the parents of X i and I is the index set of the variables in X. In the models that we use, each factor in the above expression is the output of a local logistic regression model parameterized by w: Pw `Xi = d \u02dbX\u03c0(i) = c \u00b4= exp w, f (d, c, t) P d \u2032 exp w, f (d \u2032 , c, t) Above, d is the generative decision value for X i picked by the model, c is the conditioning context tuple of values for the parents of X i , and t is the type of decision being made. For instance, the POS HMM has two types of decisions: transitions and emissions. In the emission model, the type t is EMIT, the decision d is a word and the context c is a tag. The denominator normalizes the factor to be a probability distribution over decisions. The objective function we derive from this model is the marginal likelihood of the observations y, along with a regularization term: L(w) = log P w (Y = y) \u2212 \u03ba||w|| 2 2 (1) This model has two advantages over the more prevalent form of a feature-rich unsupervised model, the globally normalized Markov random field. 2 First, as we explain in Section 3, optimizing our objective does not require computing expectations over the joint distribution. In the case of the POS HMM, for example, we do not need to enumerate an infinite sum of products of potentials when optimizing, in contrast to Haghighi and Klein (2006) . Second, we found that locally normalized models empirically outperform their globally normalized counterparts, despite their efficiency and simplicity. Optimization Optimizing with Expectation Maximization In this section, we describe the EM algorithm applied to our feature-rich, locally normalized models. For models parameterized by standard multinomials, EM optimizes L(\u03b8) = log P \u03b8 (Y = y) (Dempster et al., 1977) . The E-step computes expected counts for each tuple of decision d, context c, and multinomial type t: e d,c,t \u2190 E \u03b8 i\u2208I 1(X i = d, X \u03c0(i) = c, t) Y = y (2) 2 The locally normalized model class is actually equivalent to its globally normalized counterpart when the former meets the following three conditions: (1) The graphical model is a directed tree. (2) The BASIC features are included in f . (3) We do not include regularization in the model (\u03ba = 0). This follows from Smith and Johnson (2007) . These expected counts are then normalized in the M-step to re-estimate \u03b8: c ,t Normalizing expected counts in this way maximizes the expected complete log likelihood with respect to the current model parameters. \u03b8 d,c,t \u2190 e d,c,t d \u2032 e d \u2032 , EM can likewise optimize L(w) for our locally normalized models with logistic parameterizations. The E-step first precomputes multinomial parameters from w for each decision, context, and type: \u03b8 d,c,t (w) \u2190 exp w, f (d, c, t) d \u2032 exp w, f (d \u2032 , c, t) Then, expected counts e are computed according to Equation 2. In the case of POS induction, expected counts are computed with the forwardbackward algorithm in both the standard and logistic parameterizations. The only change is that the conditional probabilities \u03b8 are now functions of w. The M-step changes more substantially, but still relies on canonical NLP learning methods. We wish to choose w to optimize the regularized expected complete log likelihood: \u2113(w, e) = d,c,t e d,c,t log \u03b8 d,c,t (w) \u2212 \u03ba||w|| 2 2 (3) We optimize this objective via a gradient-based search algorithm like LBFGS. The gradient with respect to w takes the form \u2207\u2113(w, e) = d,c,t e d,c,t \u2022 \u2206 d,c,t (w) \u2212 2\u03ba \u2022 w (4) \u2206 d,c,t (w) = f (d, c, t) \u2212 d \u2032 \u03b8 d \u2032 ,c,t (w)f (d \u2032 , c, t) This gradient matches that of regularized logistic regression in a supervised model: the difference \u2206 between the observed and expected features, summed over every decision and context. In the supervised case, we would observe the count of occurrences of (d, c, t), but in the unsupervised M-step, we instead substitute expected counts e d,c,t . This gradient-based M-step is an iterative procedure. For each different value of w considered during the search, we must recompute \u03b8(w), which requires computation in proportion to the size of the parameter space. However, e stays fixed throughout the M-step. Algorithm 1 outlines EM in its entirety. The subroutine climb(\u2022, \u2022, \u2022) represents a generic optimization step such as an LBFGS iteration. until convergence until convergence Direct Marginal Likelihood Optimization Another approach to optimizing Equation 1 is to compute the gradient of the log marginal likelihood directly (Salakhutdinov et al., 2003) . The gradient turns out to have the same form as Equation 4 , with the key difference that e d,c,t is recomputed for every different value of w. Algorithm 2 outlines the procedure. Justification for this algorithm appears in the Appendix. Algorithm 2 Feature-enhanced direct gradient repeat Compute expected counts e \u00a3 Eq. 2 Compute L(w) \u00a3 Eq. 1 Compute \u2207\u2113(w, e) \u00a3 Eq. 4 w \u2190 climb(w, L(w), \u2207\u2113(w, e)) until convergence In practice, we find that this optimization approach leads to higher task accuracy for several models. However, in cases where computing e d,c,t is expensive, EM can be a more efficient alternative. Part-of-Speech Induction We now describe experiments that demonstrate the effectiveness of locally normalized logistic models. We first use the bigram HMM described in Section 2.1 for POS induction, which has two types of multinomials. For type EMIT, the decisions d are words and contexts c are tags. For type TRANS, the decisions and contexts are both tags. POS Induction Features We use the same set of features used by Haghighi and Klein (2006) in their baseline globally normalized Markov random field (MRF) model. These are all coarse features on emission contexts that activate for words with certain orthographic properties. We use only the BASIC features for transitions. For an emission with word y and tag z, we use the following feature templates: BASIC: 1(y = \u2022, z = \u2022) CONTAINS-DIGIT: Check if y contains digit and conjoin with z: 1(containsDigit(y) = \u2022, z = \u2022) CONTAINS-HYPHEN: 1(containsHyphen(x) = \u2022, z = \u2022) INITIAL-CAP: Check if the first letter of y is capitalized: 1(isCap(y) = \u2022, z = \u2022) N-GRAM: Indicator functions for character ngrams of up to length 3 present in y. POS Induction Data and Evaluation We train and test on the entire WSJ tag corpus (Marcus et al., 1993) . We attempt the most difficult version of this task where the only information our system can make use of is the unlabeled text itself. In particular, we do not make use of a tagging dictionary. We use 45 tag clusters, the number of POS tags that appear in the WSJ corpus. There is an identifiability issue when evaluating inferred tags. In order to measure accuracy on the hand-labeled corpus, we map each cluster to the tag that gives the highest accuracy, the many-1 evaluation approach (Johnson, 2007) . We run all POS induction models for 1000 iterations, with 10 random initializations. The mean and standard deviation of many-1 accuracy appears in Table 1 . POS Induction Results We compare our model to the basic HMM and a bigram version of the feature-enhanced MRF model of Haghighi and Klein (2006) . Using EM, we achieve a many-1 accuracy of 68.1. This outperforms the basic HMM baseline by a 5.0 margin. The same model, trained using the direct gradient approach, achieves a many-1 accuracy of 75.5, outperforming the basic HMM baseline by a margin of 12.4. These results show that the direct gradient approach can offer additional boosts in performance when used with a feature-enhanced model. We also outperform the globally normalized MRF, which uses the same set of features and which we train using a direct gradient approach. To the best of our knowledge, our system achieves the best performance to date on the WSJ corpus for totally unsupervised POS tagging. 3 Grammar Induction We next apply our technique to a grammar induction task: the unsupervised learning of dependency parse trees via the dependency model with valence (DMV) (Klein and Manning, 2004) . A dependency parse is a directed tree over tokens in a sentence. Each edge of the tree specifies a directed dependency from a head token to a dependent, or argument token. Thus, the number of dependencies in a parse is exactly the number of tokens in the sentence, not counting the artificial root token. Dependency Model with Valence The DMV defines a probability distribution over dependency parse trees. In this head-outward attachment model, a parse and the word tokens are derived together through a recursive generative process. For each token generated so far, starting with the root, a set of left dependents is generated, followed by a set of right dependents. There are two types of multinomial distributions in this model. The Bernoulli STOP probabilities \u03b8 d,c,STOP capture the valence of a particular head. For this type, the decision d is whether or not to stop generating arguments, and the context c contains the current head h, direction \u03b4 and adjacency adj. If a head's stop probability is high, it will be encouraged to accept few arguments. The ATTACH multinomial probability distributions \u03b8 d,c,ATTACH capture attachment preferences of heads. For this type, a decision d is an argument token a, and the context c consists of a head h and a direction \u03b4. We take the same approach as previous work (Klein and Manning, 2004; Cohen and Smith, 2009) and use gold POS tags in place of words. 3 Haghighi and Klein (2006) achieve higher accuracies by making use of labeled prototypes. We do not use any external information. Grammar Induction Features One way to inject knowledge into a dependency model is to encode the similarity between the various morphological variants of nouns and verbs. We encode this similarity by incorporating features into both the STOP and the ATTACH probabilities. The attachment features appear below; the stop feature templates are similar and are therefore omitted. BASIC: 1(a = \u2022, h = \u2022, \u03b4 = \u2022) NOUN: Generalize the morphological variants of nouns by using isNoun(\u2022): 1(a = \u2022, isNoun(h) = \u2022, \u03b4 = \u2022) 1(isNoun(a) = \u2022, h = \u2022, \u03b4 = \u2022) 1(isNoun(a) = \u2022, isNoun(h) = \u2022, \u03b4 = \u2022) VERB: Same as above, generalizing verbs instead of nouns by using isVerb(\u2022) NOUN-VERB: Same as above, generalizing with isVerbOrNoun(\u2022) = isVerb(\u2022)\u2228isNoun(\u2022) BACK-OFF: We add versions of all other features that ignore direction or adjacency. While the model has the expressive power to allow specific morphological variants to have their own behaviors, the existence of coarse features encourages uniform analyses, which in turn gives better accuracies. Cohen and Smith's (2009) method has similar characteristics. They add a shared logistic-normal prior (SLN) to the DMV in order to tie multinomial parameters across related derivation events. They achieve their best results by only tying parameters between different multinomials when the corresponding contexts are headed by nouns and verbs. This observation motivates the features we choose to incorporate into the DMV. Grammar Induction Data and Evaluation For our English experiments we train and report directed attachment accuracy on portions of the WSJ corpus. We work with a standard, reduced version of WSJ, WSJ10, that contains only sentences of length 10 or less after punctuation has been removed. We train on sections 2-21, and use section 22 as a development set. We report accuracy on section 23. These are the same training, development, and test sets used by Cohen and Smith (2009) . The regularization parameter (\u03ba) is tuned on the development set to maximize accuracy. For our Chinese experiments, we use the same corpus and training/test split as Cohen and Smith (2009) . We train on sections 1-270 of the Penn Chinese Treebank (Xue et al., 2002) , similarly reduced (CTB10). We test on sections 271-300 of CTB10, and use sections 400-454 as a development set. The DMV is known to be sensitive to initialization. We use the deterministic harmonic initializer from Klein and Manning (2004) . We ran each optimization procedure for 100 iterations. The results are reported in Table 1 . Grammar Induction Results We are able to outperform Cohen and Smith's (2009) best system, which requires a more complicated variational inference method, on both English and Chinese data sets. Their system achieves an accuracy of 61.3 for English and an accuracy of 51.9 for Chinese. 4 Our feature-enhanced model, trained using the direct gradient approach, achieves an accuracy of 63.0 for English, and an accuracy of 53.6 for Chinese. To our knowledge, our method for featurebased dependency parse induction outperforms all existing methods that make the same set of conditional independence assumptions as the DMV. Word Alignment Word alignment is a core machine learning component of statistical machine translation systems, and one of the few NLP tasks that is dominantly solved using unsupervised techniques. The purpose of word alignment models is to induce a correspondence between the words of a sentence and the words of its translation. Word Alignment Models We consider two classic generative alignment models that are both used heavily today, IBM Model 1 (Brown et al., 1994) and the HMM alignment model (Ney and Vogel, 1996) . These models generate a hidden alignment vector z and an observed foreign sentence y, all conditioned on an observed English sentence e. The likelihood of both models takes the form: P (y, z|e) = j p(z j = i|z j\u22121 ) \u2022 \u03b8 y j ,e i ,ALIGN 4 Using additional bilingual data, Cohen and Smith (2009) achieve an accuracy of 62.0 for English, and an accuracy of 52.0 for Chinese, still below our results. Model Inference (Johnson and Goldwater, 2009) 87 Table 1 : Locally normalized feature-based models outperform all proposed baselines for all four tasks. LBFGS outperformed EM in all cases where the algorithm was sufficiently fast to run. Details of each experiment appear in the main text. The distortion term p(z j = i|z j\u22121 ) is uniform in Model 1, and Markovian in the HMM. See Liang et al. (2006) for details on the specific variant of the distortion model of the HMM that we used. We use these standard distortion models in both the baseline and feature-enhanced word alignment systems. The bilexical emission model \u03b8 y,e,ALIGN differentiates our feature-enhanced system from the baseline system. In the former, the emission model is a standard conditional multinomial that represents the probability that decision word y is generated from context word e, while in our system, the emission model is re-parameterized as a logistic regression model and feature-enhanced. Many supervised feature-based alignment models have been developed. In fact, this logistic parameterization of the HMM has been proposed before and yielded alignment improvements, but was trained using supervised estimation techniques (Varea et al., 2002) . 5 However, most full translation systems to-day rely on unsupervised learning so that the models may be applied easily to many language pairs. Our approach provides efficient and consistent unsupervised estimation for feature-rich alignment models. Word Alignment Features The BASIC features on pairs of lexical items provide strong baseline performance. We add coarse features to the model in order to inject prior knowledge and tie together lexical items with similar characteristics. 1(e = \u2022, charAt(y, i) = \u2022) for index i in the Chinese word. These features correspond to several common augmentations of word alignment models, such as adding dictionary priors and truncating long words, but here we integrate them all coherently into a single model. Word Alignment Data and Evaluation We evaluate on the standard hand-aligned portion of the NIST 2002 Chinese-English development set (Ayan et al., 2005) . The set is annotated with sure S and possible P alignments. We measure alignment quality using alignment error rate (AER) (Och and Ney, 2000) . We train the models on 10,000 sentences of FBIS Chinese-English newswire. This is not a large-scale experiment, but large enough to be relevant for lowresource languages. LBFGS experiments are not provided because computing expectations in these models is too computationally intensive to run for many iterations. Hence, EM training is a more appropriate optimization approach: computing the Mstep gradient requires only summing over word type pairs, while the marginal likelihood gradient needed for LBFGS requires summing over training sentence alignments. The final alignments, in both the baseline and the feature-enhanced models, are computed by training the generative models in both directions, combining the result with hard union competitive thresholding (DeNero and Klein, 2007) , and us-ing agreement training for the HMM (Liang et al., 2006) . The combination of these techniques yields a state-of-the-art unsupervised baseline for Chinese-English. Word Alignment Results For both IBM Model 1 and the HMM alignment model, EM training with feature-enhanced models outperforms the standard multinomial models, by 2.4 and 3.8 AER respectively. 6 As expected, large positive weights are assigned to both the dictionary and edit distance features. Stem and character features also contribute to the performance gain. Word Segmentation Finally, we show that it is possible to improve upon the simple and effective word segmentation model presented in Liang and Klein (2009) by adding phonological features. Unsupervised word segmentation is the task of identifying word boundaries in sentences where spaces have been removed. For a sequence of characters y = (y 1 , ..., y n ), a segmentation is a sequence of segments z = (z 1 , ..., z |z| ) such that z is a partition of y and each z i is a contiguous subsequence of y. Unsupervised models for this task infer word boundaries from corpora of sentences of characters without ever seeing examples of well-formed words. Unigram Double-Exponential Model Liang and Klein's (2009) unigram doubleexponential model corresponds to a simple derivational process where sentences of characters x are generated a word at a time, drawn from a multinomial over all possible strings \u03b8 z,SEGMENT . For this type, there is no context and the decision is the particular string generated. In order to avoid the degenerate MLE that assigns mass only to single segment sentences it is helpful to independently generate a length for each segment from a fixed distribution. Liang and Klein (2009) constrain individual segments to have maximum length 10 and generate lengths from the following distribution: \u03b8 l,LENGTH = exp(\u2212l 1.6 ) when 1 \u2264 l \u2264 10. Their model is deficient since it is possible to generate lengths that are inconsistent with the actual lengths of the generated segments. The likelihood equation is given by: P (Y = y, Z = z) = \u03b8 STOP |z| i=1 (1 \u2212 \u03b8 STOP ) \u03b8 zi,SEGMENT exp(\u2212|z i | 1.6 ) Segmentation Data and Evaluation We train and test on the phonetic version of the Bernstein-Ratner corpus (1987) . This is the same set-up used by Liang and Klein (2009) , Goldwater et al. (2006), and Johnson and Goldwater (2009) . This corpus consists of 9790 child-directed utterances transcribed using a phonetic representation. We measure segment F1 score on the entire corpus. We run all word segmentation models for 300 iterations with 10 random initializations and report the mean and standard deviation of F1 in Table 1 . Segmentation Features The SEGMENT multinomial is the important distribution in this model. We use the following features: The phonological class prefix and suffix features project each phoneme of a string to a coarser class and then take prefix and suffix indicators on the string of projected characters. We include two versions of these features that use projections with different levels of coarseness. The goal of these features is to help the model learn general phonetic shapes that correspond to well-formed word boundaries. As is the case in general for our method, the feature-enhanced unigram model still respects the conditional independence assumptions that the standard unigram model makes, and inference is still performed using a simple dynamic program to compute expected sufficient statistics, which are just segment counts. Segmentation Results To our knowledge our system achieves the best performance to date on the Bernstein-Ratner corpus, with an F1 of 88.0. It is substantially simpler than the non-parametric Bayesian models proposed by Johnson et al. (2007) , which require sampling procedures to perform inference and achieve an F1 of 87 (Johnson and Goldwater, 2009) . Similar to our other results, the direct gradient approach outperforms EM for feature-enhanced models, and both approaches outperform the baseline, which achieves an F1 of 76.9. Conclusion We have shown that simple, locally normalized models can effectively incorporate features into unsupervised models. These enriched models can be easily optimized using standard NLP building blocks. Beyond the four tasks explored in this paper-POS tagging, DMV grammar induction, word alignment, and word segmentation-the method can be applied to many other tasks, for example grounded semantics, unsupervised PCFG induction, document clustering, and anaphora resolution. Acknowledgements We thank Percy Liang for making his word segmentation code available to us, and the anonymous reviewers for their comments. Appendix: Optimization In this section, we derive the gradient of the log marginal likelihood needed for the direct gradient approach. Let w0 be the current weights in Algorithm 2 and e = e(w0) be the expectations under these weights as computed in Equation 2 . In order to justify Algorithm 2, we need to prove that \u2207L(w0) = \u2207\u2113(w0, e). We use the following simple lemma: if \u03c6, \u03c8 are real-valued functions such that: (1) \u03c6(w0) = \u03c8(w0) for some w0; (2) \u03c6(w) \u2264 \u03c8(w) on an open set containing w0; and (3), \u03c6 and \u03c8 are differentiable at w0; then \u2207\u03c8(w0) = \u2207\u03c6(w0). We set \u03c8(w) = L(w) and \u03c6(w) = \u2113(w, e)\u2212 P z Pw 0 (Z = z|Y = y) log Pw 0 (Z = z|Y = y). If we can show that \u03c8, \u03c6 satisfy the conditions of the lemma we are done since the second term of \u03c6 depends on w0, but not on w. Property (3) can be easily checked, and property (2) follows from Jensen's inequality. Finally, property (1) follows from Lemma 2 of Neal and Hinton (1998) .",
    "abstract": "We show how features can easily be added to standard generative models for unsupervised learning, without requiring complex new training methods. In particular, each component multinomial of a generative model can be turned into a miniature logistic regression model if feature locality permits. The intuitive EM algorithm still applies, but with a gradient-based M-step familiar from discriminative training of logistic regression models. We apply this technique to part-of-speech induction, grammar induction, word alignment, and word segmentation, incorporating a few linguistically-motivated features into the standard generative model for each task. These feature-enhanced models each outperform their basic counterparts by a substantial margin, and even compete with and surpass more complex state-of-the-art models.",
    "countries": [
        "United States"
    ],
    "languages": [
        "Chinese",
        "English"
    ],
    "numcitedby": "246",
    "year": "2010",
    "month": "June",
    "title": "Painless Unsupervised Learning with Features"
}