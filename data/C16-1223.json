{
    "framing_question": "If this paper introduces a task or benchmark, which groups are stated to benefit from the task or benchmark, if any?",
    "response": "This question is not answerable from the given context because the provided text does not specify which groups would benefit from the task or benchmark.",
    "article": "Relation classification is the task of classifying the semantic relations between entity pairs in text. Observing that existing work has not fully explored using different representations for relation instances, especially in order to better handle the asymmetry of relation types, in this paper, we propose a neural network based method for relation classification that combines the raw sequence and the shortest dependency path representations of relation instances and uses mirror instances to perform pairwise relation classification. We evaluate our proposed models on two widely used datasets: SemEval-2010 Task 8 and ACE-2005. The empirical results show that our combined model together with mirror instances achieves the state-of-the-art results on both datasets. Introduction Relation classification is a very important task for many Natural Language Processing (NLP) applications including question answering (Yao and Van Durme, 2014) , knowledge base population (Socher et al., 2013) and opinion mining (Kobayashi et al., 2007) . The goal of relation classification is to automatically identify the semantic relation between a pair of entities in free text. For example, a relation classification system should be able to capture the Cause-Effect relation between the entities pressure and burst in the sentence \"The burst has been caused by water hammer pressure.\" Like any classification task, a key research question of relation classification is the identification of a good feature representation for each relation instance. Traditional approaches focus on either combining many manually designed features (Zhou et al., 2005; Jiang and Zhai, 2007; Li and Ji, 2014) or leveraging various kernels to implicitly explore a large feature space (Bunescu and Mooney, 2005; Zhang et al., 2006; Qian et al., 2008; Nguyen et al., 2009) , but both approaches suffer from their poor generalization ability on unseen words, and fail to achieve very satisfactory performance (Nguyen et al., 2015) . Recently, with the advances of deep learning in NLP, neural networks (NNs) have exhibited their advantages in dealing with unseen words through pre-trained word embeddings and capturing meaningful hidden representations. Different NN architectures, including Convolutional Neural Network (CNN) (Zeng et al., 2014) , Recursive Neural Network (ReNN) (Socher et al., 2012) and Recurrent Neural Network (RNN) (Xu et al., 2015b) , have been applied to relation classification. However, most existing NN-based approaches only exploit one of the following structures to represent relation instances: raw word sequences (Zeng et al., 2014; dos Santos et al., 2015) , constituency parse trees (Socher et al., 2012; Hashimoto et al., 2013) and dependency parse trees (Xu et al., 2015a; Xu et al., 2015b; Miwa and Bansal, 2016) . For the models based on raw sequence, despite maintaining all the information in relation instances, they cannot well handle long-distance relations. For the models based on constituency parse trees, one of the bottlenecks is handling long-distance relations (Ebrahimi and Dou, 2015) . For the dependency tree-based models, although they focus on the condensed information captured by the shortest dependency path between the two entities and thus are good at capturing longdistance relations, they lose some supplementary information in the original instance (Liu et al., 2015) . Observing that the raw sequence and the dependency path representations highly complement each other, we expect a combination of the two structures to be more effective in capturing long-distance relations without losing any information. Moreover, another important issue with the feature representation of relation instances is regarding the asymmetry of relation types. Most relation types are asymmetric. Take the Cause-Effect relation in the SemEval dataset as an example. Cause-Effect(e 1 , e 2 ) indicates that e 1 is the cause and e 2 is the effect. If their roles are reversed, we need to represent the relation as either Cause-Effect(e 2 , e 1 ) or Effect-Cause(e 1 , e 2 ). Suppose we have K different asymmetric relation types. The current common practice to handle the relation directions is to transform the K+1 class labels (where the +1 is for the Other relation, which is symmetric) into 2K+1 class labels, where each of the K asymmetric relations is expanded into two labels to capture the two directions. For example, from Cause-Effect, another label Effect-Cause is created. Given any sentence containing two entities, we can always treat the first entity as e 1 and the second entity as e 2 . We can then classify their relation into one of the 2K+1 labels. Although this approach has been shown to be effective, it neglects the fact that the two class labels corresponding to the same original asymmetric relation are correlated. Take the above-mentioned burstpressure sentence as an example. Most previous methods will treat it as a positive instance for the Effect-Cause relation only (because the first entity burst in the sentence is the effect). They will not relate the sentence to the Cause-Effect relation, although if we treat the second entity pressure as e 1 , its relation to the first entity burst is Cause-Effect. We believe that if we represent each relation instance in two ways by swapping the order of the two entities, we can not only implicitly link the pair of relation labels from the same relation but also make a better prediction on a relation instance based on its two representations. Based on the two observations above regarding the complementary nature of the raw sequence and dependency path representations and the asymmetry of relation types, in this paper, we propose a mirror instance based pairwise relation classification (MI) method using a convolutional neural network that combines raw sequence and dependency path representations. Our MI method creates mirror instances from the original relation instances by swapping the order of the two entities and using the reversed relation label. The method also learns appropriate weights to combine the predictions made on the original instance and the mirror instance for the final prediction. Evaluation on SemEval-2010 Task 8 and ACE-2005 shows that both mirror instances and combining raw sequence and dependency path representations help improve the performance of relation classification. Our results also show that: (1) by using only half of the negative training instances to generate mirror instances, we can push the F 1 score to 85.0 on SemEval-2010 Task 8 without using any additional manually-crafted, linguistic-driven features; (2) and with only one additional linguistic-driven feature (entity type), we can obtain results competitive with the state-of-the-art results on ACE-2005. Our Proposed Model In this section, we first formally formulate the task and introduce our notation. We then present our proposed mirror instance method, including the mirror instance generation strategy and our pairwise relation classification framework. Finally, we present our proposed combined CNN models. Problem Formulation A relation instance consists of a sentence with two entities inside tagged as e 1 and e 2 . Here e 1 always precedes e 2 in the sentence. Let R be a set of pre-defined asymmetric relation types, and S be a set of pre-defined symmetric relations including no relation. A labeled relation instance has a relation label that indicates both the relation existing between the two entities and the direction of the relation. For example, a relation label can be in the form of either r(e 1 , e 2 ) or r(e 2 , e 1 ), where r \u2208 R \u222a S. We further assume that each relation instance has two kinds of word representations. The first is the raw sequence (RSeq) representation, which consists of the sequence of words in the original sentence. The second is the shorted dependency path (SDP) representation, which is the shortest path from e 1 to e 2 in the dependency parse tree of the original sentence. Let us use V to denote the vocabulary that contains all unique words in our dataset and E the set of directed dependency relation labels such as pobj \u2212 \u2212 \u2192. The RSeq representation of a relation instance contains a sequence of words (w 1 , w 2 , . . .) where w i \u2208 V. In addition, inspired by the work by Zeng et al. (2014) , to tag the positions of e 1 and e 2 , we assume that each word w i in the sequence is associated with two position indices p i and q i , which indicate the relative distances of w i from e 1 and e 2 , respectively. Take the token \"caused\" in the previous burst-pressure sentence as an example. Since its relative distance to the two entities \"burst\" and \"pressure\" are 3 and \u22124 respectively, its two position indices are 3 and \u22124. We use P to denote the set of all possible position indices in our dataset. The SDP representation can also be regarded as a sequence of tokens (t 1 , t 2 , . . .), where each token is either a word or a directed dependency relation, that is, t j \u2208 V \u222a E. Similar to the RSeq representation, we also use the relative distances of t j to e 1 and e 2 to indicate the positions of e 1 and e 2 , namely c j and d j . The left side of the bottom layer of Figure 2 shows the RSeq and the SDP representations of the relation instance \"The [burst] e 1 has been caused by water hammer [pressure] e 2 .\" Formally, we assume that we are given a set of labeled relation instances {(x (n) , y (n) )} N n=1 , where y (n) is a relation label and x (n) has two kinds of word representations: RSeq(x (n) ) and SDP(x (n) ). Mirror Instance Method Our first proposal is a new framework to model each relation instance by a pair of representations. The key idea is to first generate a mirror instance from each original relation instance, and then perform joint training and testing by making use of both the original and the mirror instances. Our method is motivated by the observation that each relation instance can provide us with a pair of examples with opposite directions. For example, \"The [burst] e 1 has been caused by water hammer [pressure] e 2 .\" is an original relation instance and is labeled as Effect-Cause. If we swap the order of e 1 and e 2 , then the resulting mirror instance \"The [burst] e 2 has been caused by water hammer [pressure] e 1 .\" should be labeled as Cause-Effect. Recall that in standard practice the relation labels Cause-Effect and Effect-Cause are treated as two unrelated relations. But intuitively these two relation labels are highly related, and should not be independent of each other. By generating a mirror instance from each original instance, we can not only double the number of training data but also implicitly link the two labels r and rev(r). More importantly, for each testing instance, we can better identify its relation label based on its two representations. For a relation instance x, let us use x to denote its mirror instance that we generate, and for a relation label y, let us use rev(y) to denote its mirror label, which is the reverse of y. Note that if y corresponds to a symmetric relation label, then rev(y) also corresponds to the same relation label. Our mirror instance generation idea is inspired by the negative sampling method by Xu et al. (2015a) but our practice is fairly different. In their method, they only create a negative instance for each positive instance by reversing the original SDP, which will cause the expanded training set more biased to negative instances and thus largely reduce the recall of positive instances, whereas in our method, our generated mirror instances are not simply labeled as Other (or None) but labeled as a reversed relation from the original relation label. As a result, the class distribution of our generated mirror training set is almost the same as that of the original training set because of the mirror relationship between the original and mirror instances. More importantly, they simply expand the original training set with additional negative samples and their training process is the same as that in standard practice, while we propose a different pairwise relation classification framework in which the original and the mirror representations are jointly used for each relation instance. Mirror Instance Generation The next question is how we should construct RSeq(x) and SDP(x), the word representations of the mirror instance, such that we can use the same CNN architecture to learn the hidden sentence representations of these mirror instances. For both SDP(x) and RSeq(x), although we could simply reverse the original representation as was done by Xu et al. (2015a) , we feel that this would result in a completely reversed sentence or shortest dependency path that is unnatural. So we adopt the following way of constructing RSeq(x) and SDP(x). We leave the sequence of words untouched. For the position indices, since they are used to indicate the positions of the two entities, we simply swap the two position indices for each word such that the original e 1 now becomes e 2 and the original e 2 now becomes e 1 . The bottom row of Figure 1 shows RSeq(x) and SDP(x) for the mirror instance \"The [burst] e 2 has been caused by water hammer [pressure] e 1 .\" Pairwise Relation Classification Training: Once it is clear how the RSeq and the SDP representations of a mirror instance are constructed, the next challenge is how to train with these pairs of original and mirror instances such that we can make a final prediction for each relation instance. Essentially, in addition to the original training data {(x (n) , y (n) )} N n=1 , we now have additional N training instances {(x (n) , rev(y (n) )} N n=1 , where x(n) is the mirror instance of x (n) and rev(\u2022) is as defined previously. Moreover, these pairs of original and mirror instances have a one-to-one correspondence relationship, and therefore there should not be any disagreement between their labels. We therefore design the following loss function to capture two components. The first component is to maximize the log-likelihood of both the original and the mirror instances as follows: J c = \u2212 N n=1 log p(y (n) |x (n) ; \u0398) + log p(rev(y (n) )|x (n) ; \u0398 ) , (1) where \u0398 and \u0398 are two sets of parameters respectively in the CNN model of the original instances and the mirror instances, which will be detailed in Section 2.3. However, the Eqn. (1) above still treats each label separately and cannot link y (n) and rev(y (n) ) to capture the relations between x (n) and x(n) . Consequently, we further construct a one-to-one correspondence relationship between (x (n) , y (n) ) and (x (n) , rev(y (n) )). Intuitively, for (x (n) , x(n) ), the probability of the final label being y (n) should be a weighted combination of the probability of x (n) being y (n) and the probability of x(n) being rev(y (n) ). We therefore introduce another parameter \u03c9 \u2208 R 2K+L as a weight vector to combine the likelihood of the original and the mirror instances. The loss function is given as follows: J f = \u2212 N n=1 log \u03c3(\u03c9 y (n) )p(y (n) |x (n) ; \u0398) + (1 \u2212 \u03c3(\u03c9 y (n) ))p(rev(y (n) )|x (n) ; \u0398 ) , where \u03c3(\u03c9 y (n) ) = 1 1+e \u2212\u03c9 y (n) is a tradeoff weight between the probability of x (n) being y (n) and the probability of x(n) being rev(y (n) ). Finally, we minimize J c + J f as our overall objective function. Since the overall objective function consists of two components and each component is related to the other, we propose to jointly optimize them via stochastic gradient descent with shuffled mini-batches, based on the practice by Kim (2014) . In our implementation, the learning rate of each parameter is scheduled by Adadelta (Zeiler, 2012) ( = 10 \u22121 , \u03c1 = 0.95 for \u03c9, and = 10 \u22126 , \u03c1 = 0.95 for \u0398 and \u0398 ). Testing: After training with pairs of original and mirror instances, during the testing stage, how to predict the label of a relation instance becomes straightforward. For a test instance x t , we should again generate its mirror instance xt . Thereafter, we can obtain two class distributions by using the trained model, one from x t and the other from xt . Let us use c(x t ) to denote the former and c(x t ) the latter. Finally, we can obtain the final class distribution c(x t , xt ) based on c(x t ) and c(x t ): c k (x t , xt ) = \u03c3(\u03c9 k )c k (x t ) + (1 \u2212 \u03c3(\u03c9 k ))c rev(k) (x t ), 1 \u2264 k \u2264 2K + L, where c k (x t ) and c rev(k) (x t ) represent the probability of x t having the relation k and xt having the relation rev(k) respectively, and c k (x t , xt ) denotes the probability of the pair of relation instances having the relation k. The final predicted label is the relation with the highest probability among c(x t , xt ). Our Combined CNN Model Under the mirror instance based pairwise relation classification (MI) framework, we further target at learning better representations for both the original and the mirror instances. Motivated by the observation that the raw sequence and the dependency path representations highly complement each other, we propose to combine the RSeq and the SDP representations of each relation instance (either the original or the mirror instance) together based on the multi-channel CNN architecture by Kim (2014) . Figure 2 illustrates the whole architecture of the MI framework, which contains two proposed combined CNN models. Each model obtains hidden representations of both the raw sequence and the shortest dependency path of a relation instance and then concatenates them for relation classification. It consists of a lookup layer, a convolution-pooling layer and an MLP layer. Lookup: The lookup layer maps the input sequences to real-valued embedding vectors. Let W e \u2208 R d 1 \u00d7|V\u222aE| denote the lookup table for words and directed dependency relations, where each column is a d 1 -dimensional embedding vector for either a word in V or a dependency relation in E. Let W p \u2208 R d 2 \u00d7|P| denote another lookup table for position indices, where each column is a d 2 -dimensional embedding vector for a position index. Note that this position embedding idea is borrowed from the work by Zeng et al. (2014) , and thus word representations of the raw sequence in our combined model is the same as theirs. After applying the lookup layer, both the RSeq and the SDP representations are transformed into a sequence of (d 1 + 2d 2 )-dimensional vectors. Convolution-Pooling: Two separate CNNs are used to process the RSeq representation and the SDP representation, and their mechanisms are the same. For each CNN, at position i of the original sequence, the embedding vectors inside a window of size n centered at i are concatenated into a new vector, which we refer to as z i \u2208 R d . A convolution operation is then performed by applying a filter F \u2208 R h\u00d7d on z i to produce a hidden vector h i = g(Fz i + b), where b \u2208 R h is a bias vector and g is a element-wise non-linear transformation function. Note that we pad the original sequence in front and at the back to ensure that at each position i we have n vectors to be combined into h i . After the convolution operation is applied to the whole sequence, we obtain H = [h 1 , h 2 , . . .], and we apply a max-over-time pooling operator to take the maximum value of each row of H to obtain an overall hidden vector h * , which encodes the information from the entire sequence. Let h * r denote this hidden vector derived from RSeq and h * s the hidden vector derived from SDP. MLP: The top layer of our model is a multilayer perceptron (MLP) with a softmax layer at the end to predict a (2K + L)-class distribution. This means the objective function for training our model is J(\u0398) = \u2212 N n=1 log p(y (n) |x (n) ; \u0398) , where \u0398 is the set of all model parameters including W e , W p , F, b and the weights in the multilayer perceptron, y (n) is the true relation label for relation instance x (n) , and p(y (n) |x (n) ; \u0398) is the probability of assigning y (n) to x (n) based on the softmax layer. As discussed in Section 2.2, in our implementation, the gradients are computed via back propagation. Experiments Dataset and Evaluation Metric To evaluate our proposed method, we conduct our experiments on the SemEval-2010 Task 8 dataset and the English portion of the ACE-2005 dataset. SemEval-2010 Task 8: This dataset contains 10,717 relation instances, including 8000 instances for training and 2717 for testing. Following Kim (2014) instances as the development set. Following all previous work, we use the macro-averaged F 1 score to evaluate our model based on the SemEval-2010 Task 8 official scorer. ACE-2005: This dataset consists of 6 domains: broadcast news (bn), newswire (nw), broadcast conversation (bc), telephone conversation (cts), weblogs (wl) and usenet (un). Following some previous work (Plank and Moschitti, 2013; Nguyen et al., 2015; Gormley et al., 2015) , we consider a domain adaptation setting for coarse-grained relation extraction. Specifically, we take the union of bn and nw as the training set, half of bc as the development set, and the remainder (i.e., cts and wl as well as the other half of bc) as the test set. Following Plank and Moschitti (2013) , we use the micro-averaged F 1 score to evaluate our model. Experiment Settings We use the pre-trained word embeddings from word2vec 1 to initialize the lookup table W e , and set the dimension d 1 to 300. For unknown words and directed dependency labels, we randomly initialize their 300-dimensional embedding vectors. We also randomly initialized the other lookup table of the position embeddings W p , and set the dimension d 2 to 50. Note that in our preliminary experiments for ACE-2005, we found that the performance without considering the entity types of the two entity mention heads is very limited. Hence, for ACE-2005, we also randomly initialize another lookup table of the entity type embeddings, whose dimension is set to 50, and represent each token by concatenating its word embedding, position embedding and entity embedding. We want to compare our combined CNN model with models that use either RSeq or SDP alone, so we consider three experiment settings: SDP refers to a CNN model that uses only SDP representation of a relation instance, RSeq refers to a CNN model that uses only the RSeq, and Comb refers to our combined model. For each setting, we use the development set to tune the window size n and the dimension of the hidden states h. In a previous study by Nguyen and Grishman (2015) , it was found that using multiple window sizes in CNN can bring significant improvements for the RSeq representation. We therefore also experiment with combining multiple window sizes for RSeq and SDP. In the end, we find that for RSeq, the optimal setting is to use a combination of windows with sizes 2, 3, 4 and 5 and to set h to 150. For SDP, the optimal setting is to use a single window of size 5 and to set h to 400. For Comb, we use the same window sizes and hidden sizes h as RSeq and SDP. For the other parameters in \u0398 and \u0398 , we adopt the settings reported by Nguyen and Grishman (2015). That is, the non-linear transformation function g is tanh, the mini-batch size is 50, the dropout rate \u03b1 equals 0.5, and the hyperparameter for the l 2 norms is set to be 3. Evaluation of our Proposed Approach In this section, we evaluate the different components of our method. Effect of the Mirror Instance Method To evaluate the effect of the mirror instances, first, we apply the mirror instance method on top of the two baseline methods RSeq and SDP, and show the results on SemEval-2010 in on ACE-2005 in Table 6 . We can see that with the help of the mirror instances, both RSeq and SDP can improve their performance in most cases, and the improvements are statistically significant. This indicates the usefulness of the mirror instances generated by our method. The Combined CNN Model To check the effect of combining RSeq and SDP representations, in Table 4 and Table 7 , we compare Comb with SDP and RSeq on SemEval-2010 and ACE-2005 respectively. We can observe that Comb outperforms both SDP and RSeq on two datasets and the improvements are statistically significant. We can also see that the precision of Comb and that of the other two models are relatively close, especially on SemEval-2010, and the advantage of Comb is mainly from its recall. It suggests that the RSeq and the SDP representations complement each other and therefore can work better when combined. The Combined CNN Model together with the Mirror Instance Method We then apply our mirror instance method on top of Comb. In Table 5 and the top two rows of Table 9 , we can observe that our mirror instance method (Comb+MI) can significantly improve the F 1 score of Comb, especially making high improvements in recall, which further verifies the usefulness of our mirror instance method. Since the goal of our relation classification task is to improve the F 1 score for the positive relation types excluding the label Other, we further investigate the impact of reducing the number of mirror instances generated from the Other relation instances, i.e., the negative relation instances on SemEval-2010. By tuning the percentage of negative mirror instances to reduce, we achieve the best performance when reducing 50% of the negative mirror instances. We refer to this method as Comb+RMI and show its performance in Table 5 in the last row. We can see that it achieves a F 1 score of 84.96. Comparison with the State of the Art In this section, we compare our proposed method with all recently published results for SemEval-2010 Task 8 and ACE-2005. SemEval-2010 Task 8: Since most existing studies have used additional hand-crafted linguistic features (AF) to help the classification task, we show two different F 1 scores, one with AF and one without in Table 8 . It is easy to observe that without AF, Vu et al. (2016) obtained the best F 1 score of 84.9 by combining CNN and RNN models via a voting strategy; with AF, Xu et al. (2015b) We can also see that without utilizing any AF, our Comb+RMI method can push the F 1 score to the state-of-the-art, 85.0. Furthermore, we also consider adding two kinds of lexical features to our model, namely, Named Entity type (NER) and WordNet hypernyms. We first obtain the NER features of all words and Wordnet hypernyms of the two entities using the tool developed by Ciaramita and Altun (2006) . Then, we represent each token by concatenating its word embedding, position embedding and entity embedding. Finally, following the practice by Zeng et al. (2014) , we also concatenate the Wordnet hypernyms of the two entities with the combined hidden vector. As we can see from the last line of Table 8 , our method can achieve the state-of-the-art F 1 score, 85.7. ACE-2005: In Table 9 , it is easy for us to observe that on all three test domains, our proposed Comb+MI method can outperform the state-of-the-art single system FCM with a large margin, which combines traditional linguistic features with learned word embeddings by a log-bilinear model. In addition, we can also find that even in comparison with a competitive hybrid model, which integrates FCM and a traditional feature-based method, Comb+MI can still achieve slightly better performance on the bc and cts domains, and similar performance on the wl domain. Recently, Nguyen and Grishman (2016) proposed an ensemble method by first combining CNN and RNN via a stacking strategy and then integrating it with a traditional feature-based method in a hyrid model. Although our result is slightly lower than Hybrid(CNN+RNN+Feat) on average, we believe that our model can be further improved with such an ensemble strategy, which we leave to our future work. Related Work Traditional work on relation classification can be categorized into feature-based methods and kernelbased methods. The former relies on a large number of human-designed features (Zhou et al., 2005; Jiang and Zhai, 2007; Li and Ji, 2014) while the latter leverages various kernels to implicitly explore a much larger feature space (Bunescu and Mooney, 2005; Nguyen et al., 2009) . However, both methods suffer from error propagation problems and poor generalization abilities on unseen words. The most popular method to solve the two limitations is based on neural networks (NNs), which have been shown successful in extracting meaningful features and generalizing on unseen words for many NLP tasks (Kim, 2014) . For relation classification, Socher et al. (2012) proposed a recursive matrix-vector model based on constituency parse trees. Zeng et al. (2014) and dos Santos et al. (2015) respectively proposed a standard and a ranking-based CNN model based on the raw word sequences. More recently, Xu et al. (2015b) and Miwa and Bansal (2016) respectively proposed a multi-channel sequential LSTM model and a bidirectional tree-LSTM model on the shortest dependency path for relation classification. Although all these models have been shown to be effective, all of them only focus on learning a single representation for each relation instance. Different from all previous methods, we first design a strategy to generate a mirror instance from each original relation instance and then propose a pairwise relation classification framework to learn a pair of representations for each relation instance. On the other hand, most existing NN-based approaches for relation classification are either based on the shortest dependency path or the raw sequence, although these two representations may complement each other. In this work, we propose to combine them together based on the multi-channel CNN architecture (Kim, 2014) , aiming to capture long-distance relations without losing any information. Conclusions In this paper, we first proposed a mirror instance method to learn a pair of representations for each instance, which basically includes a mirror instance generation strategy and a pairwise relation classification framework. Based on this, we further proposed a combined CNN model based on both the RSeq and the SDP representations of relation instances. Our experimental results demonstrate that our mirror instance method can improve the baseline models and our combined model without mirror instances, and our combined CNN model is more effective than models only using the RSeq or the SDP representation of relation instances. Finally, with the help of some lexical features, our combined CNN model together with the mirror instance method achieves the state-of-the-art result on SemEval-2010 and highly competitive results on ACE-2005. Acknowledgment We would like to thank the reviewers for their valuable comments. This research is supported by the Singapore National Research Foundation under its International Research Centre@Singapore Funding Initiative and administered by the IDM Programme Office, Media Development Authority (MDA).",
    "funding": {
        "military": 1.9361263126072004e-07,
        "corporate": 0.0,
        "research agency": 0.006097941225280401,
        "foundation": 5.20015297911236e-06,
        "none": 0.9999995679800934
    }
}