{
    "article": "Scott-Strachey style denotational semantics is proposed as a suitable means of communicating the specification of \"natural\" language question answerers to computer programmers and software engineers. The method is exemplified by a simple question answerer communicating with a small data base. This example is partly based on treatment of fragments of English by Montague. Emphasis is placed on the semantic interpretation of questions. The \"meaning\" of a question is taken as a function from the set of universes to a set of possible answers. Gordon (1979 ), McGettrick (1980 ), Pagan (1981 ), and Tennent (1981) . Additionally, linguistic treatments of natural language, such as Montague (1973) , are basically denotational and we can modify such Introduction We advocate the use of Scott-Strachey denotational semantics for \"natural\" language question-answering programs. The majority of this paper demonstrates the use of denotational semantics for a small question answerer. The types of questions possible are similar to those in Harris (1979) , Winograd (1972) , and Woods (1972) . The analysis is not as deep as in Karttunen (1977) or similar studies, as it is oriented to the specification of useful, but linguistically modest, capabilities. Before the demonstration, we discuss the benefits of formal semantics and why denotational semantics is an appropriate formalization. The semantics of a question answerer is given by defining the action of the program for each possible input. An informal semantic description, perhaps in narrative form, is necessary for a potential user who wants to know what questions he may ask and what sort of answers the program will provide. Informal meanings are also valuable to the designer and implementer of a question answerer. However, the designer and implementer must understand all aspects of a proposed question answerer in a precise unambiguous way that informal 1 This research was supported in part by NSF grants MCS7708486 and MCS8003433. 2 Current Address: Department of Computer Science, University of Colorado, Boulder, CO 80309. methods do not provide. In short, a formal method of specifying the semantics is needed at the design and implementation stage (see Ashcroft and Wadge 1982) . Once a formal semantics has been given, it can be put to other uses as well. It can provide the basis for a rigorous proof of correctness of an implementation. Furthermore, formal specifications might allow partial automation of the implementation process in the same way that automatic compiler-writers produce parts of a compiler from a formal specification of a programming language (see Johnson 1975) . With the advent of at least one commercially available \"natural\" language question-answering program (Harris 1979 ), these advantages become even more concrete. If there is a familiarity to these arguments, it is because the same reasoning is used to justify formal semantics for programming languages. The problems of design and analysis of question answerers are much the same for programming languages - Benson (1975) argues this point at length. An obvious approach is to apply a programming language technique -denotational semantics -to the problem of formally specifying a question answerer. As a bonus, the method is understood by many programmers and software engineers through introductory textbooks such as Stoy (1977) , treatments to meet our needs. In denotational semantics for programming languages, evaluation functions map program segments into objects in various semantic domains. These objects are taken as the meanings of the program segments, and determine the output of a program. Similarly, in the semantics of a question answerer, evaluation functions map input (questions) into objects that determine the output (answers) . Deciding what objects are in the semantic domains has a fundamental effect on the capabilities of the overlying question answerer, as well as an effect on the usefulness and clarity of the semantic descriptions. Lewis (1972) discusses these considerations for natural language sentences and the domains described in section 2 are based on his, although the treatment of questions is closer to Ajdukiewicz (1926) . Also introduced in section 2 are the lambda expressions that denote individual semantic objects. Such expressions have been used in denotational semantics of programming languages (see Scott 1970 , Milne and Strachey 1976 , Stoy 1977) and in treatments of fragments of English by Montague (1973) . In section 3, evaluation functions mapping inputs for a small question answerer to objects in the semantic domain are given. The allowable questions are defined by a category grammar as has been done by Ajdukiewicz (1935) , Carnap (1937) , Lewis (1972) , Montague (1973) , and others. An account of the answer relationship is given in section 4. In the final section, we briefly describe an implementation of the question answerer and suggest some broad principles for designing question answerers. Semantic Domains for Natural Language The Domains A semantic domain is a set of objects. The objects are meanings of syntactic constructs; in our case the syntactic constructs are natural language phrases. In denotational semantics for programming languages, the semantic domains often have some order imposed on the objects to treat recursively defined functions. The specification of a question answerer may also involve explicit recursively defined questions, although in this demonstration only quantification is used and not recursion. This does not prevent an implementation from using recursion -almost surely it will, to handle the quantification. But lack of recursion does allow us to use unordered semantic domains, as described below. One domain is the set of objects about which questions will be asked, e.g., moon rocks, toy blocks, or whatever. We are not concerned with the internal structure of these objects; hence they are called atoms and the domain is designated A. Two other domains are the set of natural numbers, designated N, and the set of truth values {true, false}, designated T. A fourth domain is the set of possible universes, designated U. Intuitively, a universe is a description of properties of atoms, the relationships between atoms, the relationships between relationships, etc .... A universe is usually a partial description including only the properties and relationships of interest. For example, in the toy blocks world (Winograd 1972 ) a universe is the specification of the size, shape, color, and position of all the blocks in the scene. A toy blocks universe does not include a description of the density, mass, or material composition of the various blocks. In application, the set of possible universes may be called a \"data base\", and each actual universe is a specific state or configuration of the data base. The internal structure of such a data base is left unspecified in this paper. Other semantic domains are built from the four basic domains. For example, the set of functions from universes to truth values, designated [U--T}, is a new domain. In general, if X and Y designate sets, then [X--Y} designates the set of functions from X to Y. Other semantic domains could be conceived (e.g., product or sum domains), but function domains will be adequate for our examples. Assigning domains to syntactic categories Natural language phrases have been divided into many different categories (see Kahn 1978) . Exactly which categories are used depends upon syntax. In the category grammar of section 3, the categories include sentence, intransitive verb, common noun, noun group, noun modifier, numeral, and so on. There are also separate interrogative categories for phrases that ask a question, such as how many stones. To each syntactic category, a semantic domain is assigned. The meaning of a phrase is an object in the assigned domain. Ultimately, from the meaning of a question, we will derive its answer. But first we assign domains to non-interrogative categories, beginning with the category of sentences. A declarative sentence is a proposition -that is, something to which a truth value can be assigned. The meaning of a sentence somehow determines what that truth value is in any possible universe. So, an appropriate semantic object for a sentence is a function from possible universes to truth values. The domain assigned to the category of sentences is therefore [U--T}, which we will designate S. If a declarative sentence has a meaning a E S, and/3 is a universe, then a/3 is true just if the sentence is true in the universe/3.3 If there is a single fixed universe, then sentences could be assigned meanings in T alone. However, question answerers are generally based on a changeable universe or data base. Hence, the [U--T] approach is needed to give a fixed meaning to a sentence whose truth value may vary from universe to universe. Both common nouns and intransitive verbs define subsets of A. The subset of stone (a common noun) is the set of atoms that are stones. The subset for the intransitive verb phrase belong to Preston is the set of atoms that belong to Preston. The meaning of such a phrase determines what that subset is for any possible universe. This can be done by an object in [U-~[A-~T]] (i.e., functions from U to [A--T]). This domain is assigned to both common noun and intransitive verb categories, and is designated by C. If a common noun has a meaning a e C, and/3 is a universe and 3' an atom, then a/33' is true just if ~, is in the subset defined by the common noun in the universe /3 -and similarly for intransitive verbs. For most other syntactic categories, the semantic domain is determined by how phrases in that category combine with sentences, common nouns, intransitive verbs, and other phrases to form new phrases. For example, a noun group combines with an intransitive verb to form a sentence. Therefore, a semantic object for a noun group should take a semantic object from C (the domain for intransitive verbs) and yield a semantic object from S (the domain for sentences). Thus, the semantic domain for noun groups is [C-~S]. 4 Similarly, a noun modifier, such as black, combines with a common noun, such as stone, to form a new common nounblack stone. So, the semantic domain for noun modifiers is [C--C]. By examining the syntactic rules, this method can be applied to most categories. 5 Occasional exceptions can be made -for example, numerals are assigned the domain, N, of natural numbers. Interrogative categories So far, the categories include only non-interrogative phrases. Syntactically, the interrogative phrases parallel the non-interrogatives, but semantically an interrogative lacks something. For example, Ajdukiewicz (1926) would represent the meaning of the interroga-tive sentence what is black and white and read all over as: ?x(x is black and white and read all over). Here, x is a variable and \"?\" a quantifier indicating the lack. In this case, the range of the variable is the set of noun group phrases that could answer the question. There are also interrogative phrases in other categories, such as the intransitive verb phrase owns what. And it is not always a noun group that is missing; for \u2022 example, the noun group how many stones lacks a numeral. In general, any non-interrogative category is made into an interrogative category by indicating what is lacking. Hence, if X and Y are non-interrogative categories, then X?Y designates the category of interrogative phrases that are syntactically like X-phrases but semantically lack a Y-phrase. 6 If Y has semantic domain Y and X has semantic domain X, then X?Y will have semantic domain [Y--X]. Furthermore, if an interrogative phrase in X?Y has a meaning aE[Y-~X], then a/3 is that object of X that results when /3eY answers the interrogative. For example, the interrogative sentence who killed cock robin will have a meaning aE[[C-~S]--S], since it is a sentence (domain S) lacking a noun group (domain [C--S]). If the sparrow has a meaning /3tIC--S], and the sparrow killed cock robin has a meaning 7ES, then a/3=~,. A similar idea can be applied to one other category: yes-no questions. Such an interrogative lacks a truth value, so the semantic domain assigned to yes-no questions is [T--S]. If at[T--S] is the meaning of a yes-no question, then a(true)\u00a3 S is the meaning of the sentence when it is answered by yes, and similarly for an a(false). Lambda expressions Up to this point, semantic objects have been described in English. In order to be more precise, a formal notation is needed. We use a typed lambda expression for denoting functions, similar to the lambda calculi of Church (1951) . Every lambda expression has a type that indicates the semantic domain of the object denoted by the expression. These types are in one-to-one correspondence with the semantic domains (A, U, T, N, [U-~T], etc .... ), so we will use the same letters in ordinary typescript for the expression types (A, U, T, N, [U-~T], etc .... ). The expressions of each type include a set of constants and a denumerable set of variables. A function that maps the constants into semantic objects is an interpretation, and generally remains fixed. A function that maps variables into semantic objects is a variable assignment and, as its name suggests, will change. If q, is a variable assignment, x is a variable of any type, and a is an object from the semantic domain of x, then ~p[a/x] is a changed variable assignment that is like ~ except that q~[a/x] assigns a to the variable x. In this way, new variable assignments are formed from old. Finally, each lambda expression denotes one semantic object, but which object this is varies as the variable assignment changes. So, for an expression b the notation [[bll ~ is to denote the semantic object for the expression b, with variable assignment ~p.7 Table 1 gives recursive rules defining lambda expressions and the semantic objects they denote. We take as given a set of constants and a denumerable set of variables for each type, and a fixed interpretation, q0. X and Y are arbitrary types, with corresponding semantic domains X and Y. Some lambda expressions can be derived more than one way. Any such ambiguities are resolved as follows: a. The expression following a lambda abstraction (i.e., ),x) or a quantifier (i.e., 3x, \u00a5x, 3nx,) will be as long as possible -that is, to the first unmatched right parenthesis or to the end of the entire expression. b. The unary operator -, has higher priority than any of the binary operators (A, V, =, =>, .-, >, and functional application, which is indicated by juxtaposition). Functional application has the highest priority of the binary operators and associates leftto-right, e.g., bcd=(bc)d. The other binary operators have equal precedence and also associate leftto-right, e.g., bcAdcVc = ((bc)A(dc))Vc. Syntax and Semantics of a Small Question Answerer Syntactic categories To illustrate the mechanics of the previous section, we give the syntax and semantics of a small question answerer. The question answerer accepts questions about configurations of pieces in the game of Go. Briefly, a configuration consists of a 19 by 19 grid of points, labeled A-1 through S-19. Each point may contain a black or a white stone. Like-colored stones, connected horizontally or vertically, form blocks. Empty points adjacent to a block are that block's liberties. Each configuration is a universe in the semantic domain U. The syntax for a question answerer must answer the question: what phrases are grammatically correct input to the question answerer? Our approach uses various syntactic categories, in the style of Montague (1973) . A syntactic category is a set of phrases, including basic phrases and derived phrases. The derived phrases are specified by recursive syntactic rules that describe how phrases from various categories combine to form new phrases. The syntax presented here has two kinds of categories. First, non-interrogative categories, whose phrases do not ask questions. These categories are listed in Table 2 , along with an abbreviation for each, the lists of basic expressions, and the associated semantic domains from section 2. In the table, A-I, A-2, and so on are names of points on the Go board. The basic phrases heo, he 1, they o, they 1, and so on are used as variables in a manner made precise by syntactic rules given later. The second kind of category is the interrogative category. Syntactically, an interrogative category behaves like some non-interrogative category, but it also asks a question whose answer is from some other noninterrogative category. If a phrase is syntactically like a phrase from category X, and asks a question whose answer is in category Y, then that phrase is in a category X?Y. This separation of interrogatives is needed because the semantic domain for interrogatives differs from that for non-interrogatives (see section 2.3). One additional interrogative category does not follow the X?Y pattern -the yes-no questions. We designate this category YN and list it in Table 3 with the other interrogative categories. Syntactic and semantic rules We now give syntactic rules that define the phrases of each category. With each syntactic rule is a semantic rule. For each phrase that a syntactic rule creates, the corresponding semantic rule tells precisely how to translate that phrase into a lambda expression denoting the meaning of the phrase. In these rules, italic letters (u, v, w, ...) 7 The semantic object associated with a lambda expression also depends on the interpretation function, but we assume this is fixed. LAMBDA EXPRESSION SEMANTIC OBJECT 1. If b is a constant of type X, then b is an expression of type X. 2. If x is a variable of type X, then x is an expression of type X. 3. If b is an expression of type X, then (b) is also an expression of type X. II n+ 1 II q~ is the natural number successor of II n II q~. 113x.bll~ is true iff there exists an aEX, such that Ilbllq~[~/x] is true. IlVx.bllq~ is 11-,3x.-,bll~. Let n = II n II ~k. Then II 3nx.b II ~ is true iff there exist ,/ distinct objects in X, so that for any of these ,/ objects, say a, II b II q~[~/x] is true. For any two non-interrogative categories, X and Y, X?Y is an interrogative category. [T-~S]. No basic phrases. [[C--S]--[C-~S]]. who, what [Y-~X], where X is X's domain and Y is Y's domain. None of these categories, except NG?NG, have basic phrases. Table 3 . Syntactic categories (interrogative). The basic rule Syntactic Rule: RI. For each category, its basic phrases are phrases. Semantics: We give a translation of each basic phrase, according to which category it is in:  NU: 0 translates to 0, a constant of type N, which interprets to the natural number 0 in N; and similarly for other numerals. NG?NG: what translates to ~,y.y and who translates to ~yAx.~u.y(player)u/x yxu. The combinative rules These rules use a set of syntactic functions, F 1 through F4, which combine phrases in various ways involving person, plurality, and so on. We give these functions first. Ft(u,v) is uv', where v' is v (if the first noun in u is plural) or the result of replacing the first verb in v by its third person singular form (if the first noun in u is singular). F2(u,v) is uv t, where v' is the result of replacing the first noun in v by its objective form. F3(u,v) = uv. F4(u,v) = vu. Syntactic Rules: R2. If u is a phrase from NG and v is a phrase from IV, then Fl(U,V) is a phrase from SE. R3. If u is a phrase from TV and v is a phrase from  Case (ii): If u is from an interrogative category X?Y, then w translates to ~s.bsc, where s is a variable of type assigned to the category Y. Case (iii): If v is from an interrogative category X?Y, then w translates to ~s.b(cs), where s is a variable of type assigned to the category Y. Extracategorical rules These rules combine phrases with words from outside the categories to form new phrases. The rules use two syntactic functions given here: Fs(u,v) is vu v, where u t is u (if v = 1) , or the result of replacing the first noun in u by its plural form (if v~ 1). F6(u ) is the result of replacing the first noun in u with its plural form. Syntactic Rules and Semantics: R7. Let u be a phrase from CN, translating to b. Then: (i) (ii) (iii) (iv) The abstraction rule This rule is to replace the variables he i and they i by other noun phrases. The necessity for abstraction is discussed in Lewis (1972) . The syntactic functions F 7 and Fs, defined below, are used. In these definitions, let u' be the result of replacing the first noun in u with its objective form, let up be the result of replacing the first noun in u with its plural form, and let u'p be the result of replacing the first noun in u with its plural objective form. FT(U,v,i) is the result of replacing, in v, all occurrences of he i by u and all occurrences of him i by u'. F8(u,v,i) is the result of replacing in v, all occurrences of they i by Up and all occurrences of them i by U'p. Syntactic Rule: Rll. Let u be a phrase from NG, v be a phrase from SE, IV, or CN, and i be a variable index (e.g., 0, 1, 2 .... ). Then FT(U,v,i) and Fs(u,v,i) are phrases from the same category as v. Interrogative Variant of Syntactic Rule: Either u may be from NG?Y or v may be from SE?Y, IV?Y, or CN?Y (but not both), where Y is any non-interrogative category. In all cases, the result is from X?Y, where X is the first portion of the category of v. Semantics: Let b be the translation of u and c be the translation of v. The translation of FT(U,v,i) is given in the following table, where s is a variable of type Y: The translation is identical for F8, except that qi is replaced by Pi-Some of the notions in the syntactic rules must still be formalized. We must define the plural, objective, and plural objective forms of each basic phrase in CN, NG, and NG?NG. A noun is then any such basic phrase or one of these forms. A verb is any basic phrase in IV or TV. For each verb we must define its third person singular form. A brief discussion of the abstraction rules can clarify their usage and purpose. A sentence such as every player owns some stone has two possible meanings. It can mean: there is some particular stone owned by every player; or alternately, every player owns at least one stone, but not necessarily the same stone for each player. These two meanings will be achieved by introducing the NG some stone at different times. The abstraction rules allow this by delaying the introduction of a noun phrase. Initially, a variable (perhaps he o) is put in the sentence as a place holder. The abstraction rules allow an NG to later replace the variable. Questions and Answers Questions A question is any phrase from category YN, SE?NG, or SE?NU, along with its syntactic derivation. The syntactic derivation is needed because some phrases can be derived in more than one way (e.g., is it the case that every player owns some stone). Derivations are represented by trees. Each leaf in a derivation tree is labeled with a basic phrase. Each internal node is labeled with a derived phrase, plus the number of the syntactic rule that is used to derive it from its daughter leaves. From the semantic rules, every question translates to exactly one lambda expression. Answers Let Q be a question that translates to a lambda expression, b, of type [X ~ S]. Also let: \u2022 q, be a variable assignment, \u2022 g be a constant of type U and II g II 4~ = ~', \u2022 d be a constant of type X and II d II q~ = ,~. Then 6 is an answer to Q, in the universe 3' with variable assignment ~b iff II bdg II ~k is true. If b is an expression of type [X --S], then the answers to its corresponding question are semantic objects in X. In general, these objects depend on the choice of the universe and also on the variable assignment. However, if the question does not contain any variables (he i or theYi), then the set of answers is the same for any variable assignment. Such a question is called invariable, and we may speak of an answer without respect to a variable assignment. Examples All of these examples are invariable questions, so we may choose a variable assignment, ~p, at random. The types of variables are as in section 3.2, and we also use a lambda constant g, of type U. As always, there is a fixed interpretation assigning the lambda constants to semantic objects. In translating the examples to lambda expressions, we use the semantic rules of section 3.2. However, after translating a phrase, we will sometimes alter the lambda expression in ways that cannot change the semantic object. 9 Example 1. One derivation of the phrase is it the case that every player owns some stone is: (R9) is it the case that every player owns some stone 9 In particular, we use logical conversion (such as b A b converts to b) and the a-and /3-conversions of lambda calculus. a-conversion involves changing the name of a bound variable (e.g., ?,x.x A y converts to ),z.z A y). /3-conversion corresponds to functional application (e.g., (~,x.x A y)z converts to z A y). Details can be found in Stoy (1977) .  The difficulty with examples such as these is that even when the translations of individual constructions are fairly simple the translation of a complex construction inevitably appears cryptic and the translation process is tedious. However, the formal translations are amenable to mechanical manipulations and the translating process is also easily mechanized. Hence, we leave it as an exerciue in the manipulations to show that the translation of what blocks own at least 3 stones with less than 2 liberties is as follows: Xy.ku.y(bloek)u A y(Xu.Xz\"33zL(stone)uz' A -,(32z.(liberty)uz A (with)uz'z) A (own)uz\"z')u The first part of the translation guarantees that a possible answer, y, is indeed a block. The second part checks that y owns at least 3 stones with less than 2 liberties. Note that, although there may be other parsings of this sentence in a complete English grammar, our simple syntactic rules have forced this particular translation upon us. Answers to SE?NG questions are objects from [C -~ S]. However, it might be more convenient to have these answers be objects from A. A modification to the definition of an answer could allow this. In particular, let b be a lambda constant of type A, which interprets to flEA. Then /3 could answer a question in the universe II g II ~, with variable assignment ~b, iff II XxAu.xuh II ~ E [C -~ S], does. Discussion We have used denotational techniques to define the semantics of a \"natural\" language question answerer. The questions are defined by syntactic rules -a category grammar. Associated with each syntactic rule is a semantic rule, giving a semantic object for each phrase the syntactic rule produces. The semantic objects for questions are functions, from possible answers to propositions, where a proposition is an object that takes on a truth value. Thus, if a question, Q, has a semantic object that maps an answer, A, to a true proposition, then A answers Q. In this way, the relation between questions and answers is formalized. While it is not our intent to give implementation details for the question answerer, an outline of the program's organization will lead to some concluding remarks. The program was written as a class project by the first author and four other students. The logical divisions of the program were as follows: \u2022 Lexical analysis. The input is broken into basic component words, or \"tokens\", using finite automata techniques as in Johnson et al. (1968) . \u2022 Syntactic parser. An augmented transition network (Woods 1970) parses the input according to the category grammar with heuristic rules and interactive query to solve ambiguities. The output is a single derivation tree. \u2022 Semantic interpretation. The \"meaning\" of the sentence is computed according to the semantic rules. The output of this phase can be thought of as \"machine code\" for finding answers. At this stage, the \"code\" is independent of the actual structure of the implementation of the underlying data base. \u2022 Deductive components. The \"code\" from the previous stage is improved based on conversion rules of logic, such as x or x = x. It is also modified according to the specific structure of the data base. The latter modifications are implementation dependent. \u2022 Answerer. This corresponds to a database queryretrieval program. The \"code\" from the previous step is executed to produce an answer. In the actual implementation, the above stages are not strictly separate; still, the model is useful. There is a direct correspondence between the first four stages of the implementation and the initial four stages of a typical compiler (Aho and Ullman 1977) . Hobbs and Rosenschein (1977) indicate how these last three stages could be developed using an augmented LISP as \"code\". In this paper, we have recommended using denotational semantics as a specification technique for question-answering programs. The implementation suggests that principles of compiler design can be used as principles of question answerer design by the software engineer.",
    "abstract": "Scott-Strachey style denotational semantics is proposed as a suitable means of communicating the specification of \"natural\" language question answerers to computer programmers and software engineers. The method is exemplified by a simple question answerer communicating with a small data base. This example is partly based on treatment of fragments of English by Montague. Emphasis is placed on the semantic interpretation of questions. The \"meaning\" of a question is taken as a function from the set of universes to a set of possible answers. Gordon (1979 ), McGettrick (1980 ), Pagan (1981 ), and Tennent (1981) . Additionally, linguistic treatments of natural language, such as Montague (1973) , are basically denotational and we can modify such",
    "countries": [
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "9",
    "year": "1983",
    "month": "",
    "title": "Denotational Semantics for {``}Natural{''} Language Question-Answering Programs"
}