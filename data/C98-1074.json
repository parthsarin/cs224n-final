{
    "article": "Introduction The \"glue\" approach to semantic composition in Lexical-Functional Grammar uses linear logic to assemble meanings from syntactic analyses (Dalrymple et al., 1993) . It has been computationally feasible ill practice (Dalrymple et al., 1997b) . Yet deduction in linear logic is known to be intractable. Even the propositional tensor fragment is NP complete (Kanovich, 1992) . In this paper, we investigate what has made the glue approach computationally feasible and show how to exploit that to efficiently deduce underspecified representations. In the next section, we identify a restricted pattern of use of linear logic in the glue analyses we are aware of, including those in (Crouch and Genabith, 1997; Dalrymple et al., 1996; Dalrymple et al., 1995) . And we show why that fragment is computationally feasible. In other words, while the glue approach could be used to express computationally intractable analyses, actual analyses have adhered to a pattern of use of linear logic that is tractable. The rest of the paper shows how this pattern of use can be exploited to efficiently capture all possible deductions. We present a conservative extension of linear logic that allows a reformulation of the semantic contributions to better exploit this pattern, almost turning them into Horn clauses. We present a deduction algorithm tbr this formulation that yields a compact description of the possible deductions. And finally, we show how that description of deductions can be turned into a compact underspecifled description of the possible meanings. Throughout the paper we will use the illustrative sentence \"every gray cat left\". It has fu~('tional structure For our purposes, it is more convenient to follow (Dalrymple et al., 1997a) and separate the two parts of the semantic contributions: use a lambda term to capture the meaning formulas, and a type to capture the connections to the f-structure. In this form, the contributions are leave: \u00ae(go --~ H)) --oH With this separation, the possible derivations are determined solely by the \"types\", the connections to the f-structure. The meaning is assembled by applying the lambda terms in accordance with a proof of a type for the sentence. We give the formal system behind this approach, C in Figure 1 --this is a different presentation of the system given in (Dalrymple et al., 1997a) , adding the two standard rules for tensor, using pairing for meanings. For the types, the system merely consists of the linear logic rules for the glue fi'agment. We give the proof for our example in Figure 2 , where we have written the types only, and have omitted the trivial proofs at the top of the tree. The meaning evc'ry(gray(cat),left ) may be assembled by putting the meanings back in according to the rules of O and rl-reduction. Skeleton references and modifier references The terms that describe atomic types, terms like g~ and (g~ VAlt), are semantic structure refer-~nc~, the type atoms that connect the semantic assembly to the syntax. There is a pattern to how they occur ill glue analyses, which reflects their function in the semantics. Consider a particular type atom in the example, such as g~. It occurs once positively in the contribution of \"every\" and once negatively in the contribution of \"leave\". A slightly more complicated example, the type (go I~ESTR) occurs once positively in the contribution of \"cat\", once negatively in the contribution of \"every\", and once each positively and negatively in the contribution of \"gray\". The pattern is that every type atom occurs once positively in one contribution, once negatively in one contribution, and once each posi-tively and negatively in zero or more other contributions. (To make this generalization hold, we add a negative occurrence or \"consumer\" of re, the final meaning of the sentence.) This pattern holds in all the glue analyses we know of, with one exception that we will treat shortly. We call the independent occurrences the skeleton occurrences, and the occurrences that occur paired in a contribution modifier occurrences. The pattern reflects the functions of the lexical entries in LEG. For the type that corresponds to a particular f-structure, the idea is that, the entry corresponding to the head mMces positive skeleton contribution, the entry that subcategorizes for the f-structure makes a negative skeleton contribution, and modifiers on the f-structure make both positive and negative modifier contributions. Itere are the contributions for the example sentence again, with the occurrences classified. Each occurrence is marked positive or negative, and the skeleton occurrences are underlined. This pattern explains the empirical tractability of glue inference. In the general case of multiplieative linear logic, there can be complex combinatorics in matching up positive and negative occurrences of literals, which leads to NPcompleteness (Kanovich, 1992) . But in the glue fragment, on the other hand, the only combinatorial question is the relative ordering of moditiers. In the common case, each of those orderings is legal and gives rise to a different meaning. So the combinatorics of inference tends to be proportional to the degree of semantic ambiguity. The complexity per possible reading is thus roughly linear in the size of the utterance. But, this simple eombinatoric structure suggests a better way to exploit the pattern. Rather than have inference explore all tile combinatorics of different modifier orders, we can get a single underspecified representation that captures all possible orders, without having to The idea is to do a preliminary deduction involving just the skeleton, ignoring the modifier occurrences. This will be completely deterministic and linear in the total length of the formulas. Once we have this skeletal deduction, we know that the sentence is well-formed and has a meaning, since modifier occurrences essentially occur as instances of the identity axiom and do not contribute to the type of the sentence. Then the system can determine the meaning terms, and describe how the modifiers can be attached to get the final meaning term. That is the goal of the rest of the paper. Conversion toward horn clauses The first hurdle is that the distinction between skeleton and modifier applies to atomic types, not to entire contributions. The contribution of \"every\", for example, has skeleton contributions for g~, (.q~ Via), and (g~ aESTR), but modifier contributions for H. Furthermore, the nested implication structure allows no nice way to disentangle the two kinds of occurrences. When a deduction interacts with the skeletal g\u00a2 in the hypothetical it also brings in the modifier H. If the problematic hypothetical could be convetted to Horn clauses, then we could get a better separation of the two types of occurrences. We can approximate this by going to an indexed linear logic, a conservative extension of the system of Figure 1 , similar to Hepple's system (Hepple, 1996) . To handle nested implications, we introduce the type constructor A{B}, which indicates an A whose derivation made use of B. This is similar to Hepple's use of indices, except that we indicate dependence on types, rather than on in-dices. This is sufficient in our application, since each such type has a unique positive skeletal occurrence. We can eliminate problematic nested implications by translating them into this construct, in accordance with the following rule: For a nested hypothetical at top level that has a mix of skeleton and modifier types: M :(A -o B) --o C replace it with x:d, M:(B{A}--oC) where x is a new variable, and reduce complex dependency formulas as follows: 1. Replace A{B -oe} with A{C{Bi}. Replace (A -o B){C} with A -o 13{C}. The semantics of the new type constructors is captured by the additional proof rule: F,x:A~-M:B F,x : A ~-)~x.M : B{A} The translation is sound with respect to this rule: Theorem 1 If r is a set of sentences in the unextended system of Figure 1 , A is a sentence in that system, and F ~ results from r by applying the above conversion rules, then F t-A in the system of Figure 1 iff F ~ ~-A in the extended system. The analysis of pronouns present a different problem, which we discuss in section 5. For all other glue analyses we know of, these conversions are sufficient to separate items that mix interaction and modification into statements of the form 8, M, or S --o M, where ,5 is pure skeleton and 3,4 is pure modifier. Furthermore, 3,4 will be of the form A -o A, where A may be a formula, not just an atom. In other words, the type of the modifier will be an identity axiom. The modifier will consume some meaning and produce a modified meaning of the same type. In our example, the contribution of \"every\", can be transformed by two applications of the nested hypothetical rule to every :AR.AS'.every( g, 3) : vu. (g~ aESTR){(~ v.R)} -o H { go } ---o tt x :(go v,r\u00a2) Y :go Here, the last two sentences are pure skeleton, producing (g~ VAtt) and g~, respectively. The first is of the form ,5\" --o jr4, consuming (g~ aESTR), to produce a pure modifier. While the rule for nested hypotheticals could be generalized to eliminate all nested implications, as Hepple does, that is not our goal, because that does remove the combinatorial combination of different modifier orders. We use the rule only to segregate skeleton atoms fl'om modifier atoms. Since we want modifiers to end up looking like the identity axiom, we leave them in the A --o A form, even if A contains further ilnplications. For example, we would not apply the nested hypothetical rule to simplify the entry for gray any further, since it is already in the form A-o A. Ifandling intensional verbs requires a more precise definition of skeleton and modifier. The type part of an intensional verb contribution looks like (VV.(h~ ---o F) --o F) -o g~ --o f~ (Dalrymple et al., 1996) . First, we have to deal with the small technical problem that the VF gets in the way of the nested hypothetical translation rule. This is easily resolved by introducing a skolem constant, S, turning the type into ((h~, --o S) --o ,5') -o g~ --o f~. Now, the nested hypothetical rule can be applied to yield (h~ --o S) and ,5'{S{h~}} --o g~ --o f~. But now we have the interesting question of whether the occurrences of the skolem constant, S, are skeleton or modifier. If we observe how S resources get produced and consumed in a deduction involving the intensional verb, we find that (ho --o S) produces an S, which may be modified by quantifiers, and then gets consumed by S{S{h\u00a2}} -o ga --o f~. So unlike a modifier, which takes an existing resource from the environment and puts it back, the intentional verb places the initial resource into the environment, allows modifiers to act on it, and then takes it out. In other words, the intensional verb is acting like a combination of a skeleton producer and a skeleton consumer. So just because an atom occurs twice in a contribution doesn't make the contribution a modifier. It is a modifier if its atoms must interact with the outside, rather than with each other. Roughly, paired modifier atoms function as f --o f, rather than as f \u00ae f_k, as do the S atoms of intensional verbs. Stated precisely: Definition 2 Assume two occurrences of the same type atom occur in a single contribution. Convert the formula to a normal form consisting of just \u00ae, ~ , and \u00b1 on atoms by converting subformulas A -o B to the equivalent A \u00b1 :2 B, and then using DeMowan's laws to push all \u00b1 's down to atoms. Now, if the occurrences of the same type atom occur with opposite polarity and the connective between the two subexpressions in which they occur is ~ , then the occurrences are modifiers. All other occurrences are skeleton. For the glue analyses we are aware of, this definition identifies exactly one positive and one negative skeleton occurrence of each type among all the contributions for a sentence. Efficient deduction of underspecified representation In the converted form, the skeleton deductions can be done independently of the modifier deductions. Furthermore, the skeleton deductions are completely trivial, they require just a linear time algorithm: since each type occurs once positively and once negatively, the algorithm just resolves the matching positive and negative skeleton occurrences. The result is several deductions starting from the contributions, that collectively use all of the contributions. One of the deductions produces a meaning for f~, for the whole f-structure. The others produce pure modifiers --these are of the form A -o A. For the example sentence, the results are shown in Figure 3 . These skeleton deductions provide a compact representation of all possible complete proofs. Complete proofs can be read off from the skeleton proofs by interpolating the deduced modifiers into the skeleton deduction. One way to think about interpolating the modifiers is in terms of proof nets. A modifier is interpolated by disconnecting the arcs of the proof net that connect the type or types it modifies, and reconnecting them through the modifier. Quantifiers, which turn into modifiers of type VF.F -o F, can choose which type they modify. Not all interpolations of modifiers are legal. however. For example, a quantifier must outscope its noun phrase. The indices of the modifier record these limitations. In the case of the modifier resulting from \"every cat\", VH.H{g~} --o H, it records that it must outscope \"every cat\" in the {g~}. The indices determine a partial order of what modifiers must outscope other modifiers or skeleton terms. In this particular example, there is no choice about where modifiers will act or what their relative order is. In general, however, there will be choices, as in the sentence \"someone likes every cat\", analyzed in Figure 4 . To summarize so far, the skeleton proofs provide a compact representation of all possible deductions. Particular deductions are read off by interpolating modifiers into the proofs, subject to the constraints. But we are usually more interested in all possible meanings than in all pos-sible deductions. Fortunately, we can extract a compact representation of all possible meanings from the skeleton proofs. We do this by treating the meanings of the skeleton deductions as trees, with their arcs annotated with the types that correspond to the types of values that flow along the arcs. Just as modifiers were interpolated into the proof net links, now modifiers are interpolated into the links of the meaning trees These trees are a compact description of the possible meanings, in this case the one possible meaning. We believe it will be possible to translate this representation into a UDRS representation (Reyle, 1993) , or other similar representations for ambiguous sentences. We can also use the trees directly as an underspecified representation. To read out a particular meaning, we just interpolate modifiers into the arcs they modify. Dependencies on a The functional structure of \"Someone likes every cat\".  In some cases, the link called for by a higher order modifier is not directly present in the tree, and we need to do A-abstraction to support it. Consider the sentence \"John read llamlet quickly\". We get the following two trees fi'om the skeleton deductions: quickl y( P )( x ) There is no link labeled go --o f~ to be modified. The left tree however may be converted by A-abstraction to the following tree, which has a required link. The @ symbol represents k application of the right subtree to the left. LI- Acknowledgements We would like to thank Mary Dalrymple, John Fry, Stephan Kauffmann, and Hadar Shemtov for discussions of these ideas and for comments on this paper. derspecified representation. Furthermore, the introduction is unavoidable, as the link will be present in any final meaning. Anaphora As mentioned earlier, anaphoric pronouns present a different challenge to separating skeleton and modifier. Their analysis yields types like f~ -o (f~ \u00ae g~) where g~ is skeleton and f~ is modifier. We sketch how to separate them. We introduce another type constructor (B)A, informally indicating that A has not been fully used, but is also used to get B. This lets us break apart an implication whose right hand side is a product in accordance with the following rule: For an implication that occurs at top level, and has a product on the right hand side that mixes skeleton and modifier types: Ax.M : (C)A --o B, N : C The semantics of this constructor is captured by the two rules: where the primed terms are obtained by replacing free x's with what was applied to the Ax. in the deduction of (B)A With these rules, we get the analogue of Theorem 1 for the conversion rule. In doing the skeleton deduction we don't worry about the (B)A constructor, but we introduce constraints on modifier positioning that require that a hypothetical dependency can't be satisfied by a deduction that uses only part of the resource it requires.",
    "abstract": "",
    "countries": [
        "United States"
    ],
    "languages": [
        "Ho"
    ],
    "numcitedby": "0",
    "year": "1998",
    "month": "",
    "title": "Efficient Linear Logic Meaning Assembly"
}