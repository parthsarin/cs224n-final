{
    "article": "The valid prefix property (VPP) , the capability of a left to right parser to detect errors as soon as pos sible, often goes unnoticed in parsing CFGs. Ear ley's parser for CFGs (Earley, 1968; Earley, 1970) maintains the valid prefix property and obtains an O(n 3 )-time worst case complexity, as good as parsers that do not maintain such as the CKY parser (Younger, 1967; Kasami, 1965). Contrary to CFGs, maintaining the valid prefix property for TAGs is costly. \u2022 This research was partially fu nded by ARO grant DAAL03-89-C0031PRI and DARPA grant N00014-90-J-1863 . The difficulty of maintaining the valid prefix property for TAGS was first noticed in joint work with Vijay-Shanker in the context of deterministic parsing of tree-adjoining grammars (Schabes and Vijay-Shanker, 1990). I am in debted to Vijay-Shanker for nwnerous discussions on this topic. I am also indebted to Aravind Joshi for his sugges tions and for his support of this research. The discussions I had with Mitchell Marcus greatly improved the presenta tion of the algorithm introduced in this paper. I would also like to thank Bob Frank, Bernard Lang, Fernando Pereira, Philip Resnik and Stuart Shieber for providing valuable comments. The valid prefix property is also sometimes re ferred as the error detecting prop erty because it implies that errors can be detected as soon as pos sible. However, the lack of VPP does not imply that errors are undetected. 1 The valid prefix property is independent from the on lin e property. An on-line left to right parser is able to output for each new token read whether the string seen so far is a valid string of the language. In 1988, Schabes and Joshi proposed an Earley type parser for TA Gs. It maintains the valid pre fix property at the expense of its worst case com plexity (O(n 9 )-time) . To our knowledge, it is the only known polynomial time parser for TAGs that maintains the valid prefix property. In this paper, we explain why the valid prefix property is expensive to maintain for TAGs and we introduce a predictive left to right parser for TAGs that does not maintain the valid prefix prop erty but that achieves an 0( n 6 )-time worst case behavior, O(n 4 )-time for unambiguous grammars and linear time for a large class of grammars. Organization of the paper This paper discusses of two subjects: the difficulty of parsing tree-adjoining grammars (TAGs) while maintaining the valid prefix property (Sections 1 and 2) and the design of a predictive left to right parser for TA Gs (Section 3). Although the two topics are related, they can be read independently of each other. Definition of the Valid Pre fix Property The valid prefix property is a property of left of to right parsing algorithms which guarantees that errors in the input are detected \"as soon as possi ble\" . Parsers satisfying the valid prefix property guar antee that, as they read the input from left to right, the substrings read so far are valid prefi xes of the language defined by the grammar : if the parser has read the tokens a1 \u2022 \u2022 \u2022 ak from the in put a 1 \u2022 \u2022 \u2022 ak ak+l \u2022\u2022\u2022a n , then it is guaranteed that there is a string of tokens b 1 \u2022 \u2022 \u2022 b m (bi may not be part of the input) with which the string a1 \u2022 \u2022 \u2022 ak can be suffixed to form a string of the language; i.e. The _ Va lid Prefix Prop erty and Parsing of Tree Adjoining Grammar The valid prefix property, the capability of a left to right parser to detect errors as soon as possi ble, is often unobserved in parsing CFGs . Earley's parser for CFGs (Earley, 1968 ) maintains the valid prefix property and obtains a worst case complex ity (O(n 3 )-time) , as good as parsers that do not maintain it, such as the CKY parser (Younger, 1967; Kasami, 1965) . This follows from the path set complexity, as we will see. Maintaining the VPP requires a parser to recog nize the possible parse trees in a prefix order. The prefix traversal of the output tree consists of two components: a top-down component that expands a constituent to go to the next level down, and a bottom-up component that reduces a constituent to go to the next level up. When the VPP is main tained, these two components must be constrained together . Context-free productions can be expanded in dependently of their context, in particular, inde pendently of the productions that subsume them. The path set (language defined as the set of paths from root to frontier of all derived trees) of CFGs is therefore a regular set. 2 It follows that no addi tional complexity is required to correctly constrain the top-down and bottom-up behavior required by the prefix traversal of the parse tree: the expan sion and the reduction of a constituent. Contrary to CFGs, maintaining the valid prefix property for TA Gs is costly. 3 Two observations corroborate this statement and an explanation can be found in the path set complexity of TAG . Our first observation was that the worst case complexity of parsers for TAG that maintain the VPP is higher than the parsers that do not main tain VPP. Vijay-Shanker and Joshi (1985) 4 pro posed a CKY-type parser for TAG that achieves 0( n 6 )-\" time worst case complexity. 5 As the orig inal CKY parser for CFGs, this parser does not maintain the VPP. The Earley-type parser de veloped for TAGs (Schabes and Joshi, 1988 ) is bottom-up and uses top-down prediction. It main-tains the VPP at a cost to its worst case com plexity (O(n 9 )-time in the worst case). However, the goal of our 1988 enterprise was to build a practical parser which behaves in practice better than its worst case complexity. Other parsers for TAGs have been proposed (Lang, 1988; Satta and Lavelli, 1990; Vijay-Shanker and Weir, 1990) . 6 Al though they achieve 0( n 6 ) worst case time com plexity, none of these algorithms satisfies the VPP. To our knowledge, Schabes and Joshi's parser (1988) is the only known polynomial-time parser for TAG which satisfies the valid prefix property. It is still an open problem whether a better worst case complexity can be obtained for parsing TAGs while maintaining the valid prefix property. The second observation is in the context of de terministic left to right parsing of TAGs (Schabes and Vijay-Shanker, 1990) where it was for the first time explicitly noticed that VPP is problem atic to obtain. The authors were not able to de fine a bottom-up deterministic machine that sat isfies the valid prefix property and which recog nizes exactly tree-adjoining languages when used non-deterministically. Instead, they used a deter ministic machine that does not satisfy the VPP, the bottom-up embedded push-down automaton, which recognizes exactly tree-adjoining languages when used non-deterministically. The explanation for the difficulty of maintaining the VPP can be seen in in the complexity of the path set of TAGs. Tree-adj oining grammars gen erate some languages that are context-sensitive. The path set of a TAG is a context-free language . (_ Weir, 1988) and is therefore more powerful than the path set of a CFG. Therefore in TAGs, the expansion of a branch may depend on the parent super-tree, i.e. what is above this branch. Going bottom-up, these dependencies can be captured by a stack mechanism since trees are embedded by ad junction. However, if one would like to maintain the valid prefix property, which requires travers ing the output tree in a prefix fashion, the depen dencies are more complex than a context-free lan guage and the complexity of the parsing algorithm mcreases. For example, consider the trees a, /3 and , in Figure J. When , is adjoined into /3 at the B node, and the result is adjoined into a at the A node, the resulting tree yields the string ux 'zx\"vy \"ty'w ( see Figure 1 ).  If this TA G derived tree is recognized purely bottom-up from leaf to root ( and therefore with out maintaining the VPP), a stack based mech anism suffices for keeping track . of the trees to which to algorithm needs to come back. This is illustrated by the fact that the tree domains are embedded (see bottom left tree in Figure 1 ) when they . _ are read from leaf to root in the derived tree. However, if this derivation is recognized from left to right while maintaining the valid prefix property, the dependencies are more complex and can no longer be captured by a stack ( see bottom right tree in Figure 1 ). The context-free complexity of the path set of TAGs makes the valid prefix property costly to maintain. We suspect that the same difficulty arises for context-sensitive formalism which use operations such as adjoining or wrapping (Joshi et al. , Forthcoming 1990) . languages it recognizes still needs to be determined. 23 A Predictive Left to Right Parser fo r TA Gs In this section, we defi ne a new predictive left to right (Earley-style) parser for TAGs with adjoin ing constraints (Joshi, 1987) . It is a bottom-up parser that uses some but not all the top-down in formation given by prediction. As a consequence, the parser does not satisfy the valid prefi x prop erty: it always detects errors but not as soon as possible. However, it achieves an O(n 6 )-time worst case behavior, O(n 4 )-time for unambiguous grammars and linear time for a large class of gram mars (for example, the language a n b n ec n d n is rec ognized in linear time). This parser as well as in the one introduced by Schabes and Joshi ( 1988 ) are practical parsers for TAGs since as is well known for CFGs, the average behavior of Earley style parsers is superior to their worst case com plexity. The algorithm has been modified to han dle extensions of TAGs such as substitution, fea ture structures for TA Gs and a version of multiple component TAG ( these extensions are explained in Schabes [1990] ). Prel i m i nary Concepts Any tree a will be considered to be a function from tree addresses to symbols of the grammar ( ter minal and non-terminal symbols) : if x is a valid address in a, then a( x) is the label of the node at address x in the tree a . A ddresses of nodes in a tree are encoded by Gorn-positions (Gorn, 1965) as defined by the following inductive defini tion: 0 is the address of the root node, k (k E N) is the address of the P h child of the root node, x \u2022 y ( x is an address, y E N) is the address of the y th child of the node at address x. Given a tree a and an address address in a, we define Adjunct(a, address) to be the set of aux iliary trees that can be adjoined at the node at address address in a. For TAGs with no con straints on adjunction, Adjunct( a, address) is the set of elementary auxiliary trees whose root node is labeled by a( address). We define a dotted tree as a tree associated with a dot above or below and either to the left or to th e right of a given node. The four positions of the dot are annotated by la, lb, ra, rb (resp. left above, left below, right above, right below): ibA;b. We write < a, dot , pos > for a dotted tree in which the dot is at address dot and at position pos in the tree a. The tree traversal we define for parsing TAGs consists of moving a dot in an elementary tree in a manner consistent with the left to right scanning of the yield while still being able to recognize ad junctions on interior nodes of the tree. The tree traversal starts when the dot is above and to the left of the root node and ends when the dot is above and to the right of the root node. At any time, there is only one dot in the dotted tree. An example of tree traversal is shown in Figure 2 . We consider to equivalent two successive ( ac cording to the tree traversal) dot positions that do not cross a node in the tree (see Figure 2 ). For ex ample the following equivalences hold for the tree a pictured in Figure 2 The algorithm uses one data structure: a state.7 A state s is defined as an 8-tuple, , dot ,pos,i,j,k,l,sat?] where: s = [a \u2022 a is an elementary tree, initial or auxiliary tree : a E JU A. \u2022 dot is the address of the dot in the tree a. \u2022 pos is the position of the dot: to the left and above, or to the left and below, or to the right and below, or to the right and above; pos E {la, lb, rb, ra } . In the following, we will refer to one of the two equivalent dot positions for the dotted tree. For example, if the dot at address dot and at position pos in the tree a is equivalent to the dot at address dot' at position pos' in a, then s = [a, dot, pos, i,j, k, l, sat? ] and s' = [a, dot' ,pos', i, j, k, l, sat?] refer to the same state. We will use to our convenience s or s' to refer to this unique state. Analogy between Dotted Trees and Dotted Rules There is a useful analogy between dotted TAG trees and dotted rules. It is by no mean a formal correspondence between TAG and a production system but it will give an intuitive understanding of the parser we define. It will also be used as a notation for referring to a dotted tree. One can interpret a TA G elementary tree as a set of productions on pairs of trees and addresses (i.e. nodes). For example, the tree in Figure 2 , let 's call it a, can be written as: (a, 0) -+ (a, 1) (a, 2 ) (a, 3) (a, 2 )-+ (a, 2 \u2022 1) (a, 2 \u2022 2 ) (a, 2 \u2022 3) (a , 3) -+ (a , 3 -1) (a , 3 \u2022 2 ) Of course, the label of the node at address i in a is associated with each pair (a, i) . 8 One can then relate a dotted tree to a dotted rule. For example, consider the dotted tree < a, 2, ra > in which the dot is at address 2 and at position \"right above\" in the tree a (tree in Figure 2 ). Note that the dotted trees < a, 2, ra > and < a, 3 , la > are equivalent. 8 TAGs could be defined in term of such productions. However adjunction must be defined within this production system. This is not our goal, since we want to draw an analogy and not to define a formal system. \ufffd The dotted tree < a, 2, ra > is analogous to the dotted rule: (a, 0) -+ (a, 1) (a, 2) \u2022 (a, 3) One can therefore put into correspondence a state defined on a dotted tree with a state defined on a dotted rule. A state s = [a, dot , pos , i,j, k , I, sat?] can also be written as the corresponding dotted rule associated with the in dices i,j, k, I and the flag sat?: T/o -+ 'f/1 \u2022 \u2022 \u2022 T/ y \u2022 T/ y +l \u2022 \u2022 \u2022 'f/z [i,j, k , I, sat?] where TJo = (a, u) and T/p = (a, u \u2022 p), p E [1, z] Here u is the ad-dress of the parent node of the dotted node when the dot is above to the left or to the right, and where u = dot when the dot is below to the left or to the right. Invariant of the Algorithm The algorithm collects states into a set C called a chart. The algorithm maintains an invariant that is satisfied for all states in the chart C. The cor rectness of the algorithm is a corollary of this in variant . The invariant is pictured in Figure 3 in terms of dotted trees. We informally describe it equivalently in terms of dotted rules. A state of the form: TJz [i, j, k ,l, sat?] with TJo = (a, u) and T/ p = ( a, u . p) is in the chart if and only if the elementary tree a derives a tree such that : 'f/0 --+ 'f/1 \u2022\u2022\u2022TJ y \u2022 T/ y +1 \u2022\u2022 \u2022 (1) 'f/1 \u2022 \u2022 \u2022 'f/ y \u21d2 \u20ac{!)' \u2022 a1 (2) (a, f) \u21d2 a i+l \u2022 \u2022 \u2022 ak where / is the address of the foot node of a. (2) only applies when the foot node of a (if there is one) is subsumed by one of the nodes 'f/ i .. . T/ y When the pos = rb, the dot is at the end the dotted rule and if sat? = t the boundaries ai \u2022 \u2022 \u2022 a 1 include the string introduced by an adjunction on the dotted tree. 9 sat? = t indicates that an adjunction was rec ognized on the dotted node ( node at address dot in a). No more adjunction must be attempted on this node. 10 9 The algorithm will set sat? to t only when pos = rb. 10 The derivations in TAG disallow more than one auxil iary tree adjoined on the same node. The Recognizer The algorithm is a bottom-up parser that uses top-down information. It is a general recognizer for TAGs with adjunction constraints. Unlike the CKY-type algorithm for TAGs, it requires no con dition on the grammar: the elementary trees (ini tial or auxiliary) need not to be binary and they may have the empty string as frontier. The al gorithm given below is off-line: it needs to know the length n of the input string before starting any computation. However it can very easily be modified to an on-line algorithm by the use of an end-marker in the input string. Initially, the chart C consists of all states of the form [a , 0, la, 0, -, -, 0, nil], with a an initial tree. These initial states correspond to d\ufffded initial trees with the dot above and to the left of the root node ( at address O). Depending on the existing states in the chart C, new states are added to the chart by four proces sors until no more states can be added to the chart. The processors are: the Predictor, the Completor, the Adjunctor and the Scanner. If, in the final chart, there is a state corresponding to an initial tree completely recognized, i.e. witli the dot to the right and above the root node which spans the in put form position O to n (i.e. a state of the form [a, 0, ra, 0, -, -, n , \ufffd) , the input is recognized. The recognizer r6rT\ufffdGs follows: Let G = (\"E, NT, I, A) be a TAG . Let a1 [a, 0, ra, 0, -, -, n, nil] in C with a E J then return acceptance otherwise return rej ection . end . The initialization step C={ [a, 0 , la, 0, -, -, 0, nil]la E J } puts all initial trees with the dot to the left and above the root node. The four processes are ex plained one by one in the four next sections. 1 Scanner The Scanner is a bottom-up processor that scans the input string. It applies when the dot is to the left and above a terminal symbol. It consists of two cases: one when the terminal is not the empty string, and the other when it is. [a, dot,la, i,j, k, l, nil] such that a(dot) E \ufffd u {l} . \u2022 Case 1: a(dot) = a1+1 The stat e s= [a, dot,ra, i,j, k, l+l ,nil] is added to C. \u2022 Case 2: a(dot) = f. (empty string) The stat e s [a, dot,ra, i, j, k, l, nil] is added to C. Predictor The Predictor constitutes the top-down processor of the parser. It predicts new states accordingly to the left context that has been been read. The Predictor creates new states from a given state. It consists of three steps which are not ap plicable all simultaneously. Step 1 applies when the dot is to the left and above a non-terminal symbol. All auxiliary trees adjoinable at the dot ted node are predicted. Step 2 also applies when the dot is to the left and above a non-terminal symbol. If there is no obligatory adjoining con straint on the dotted node, the algorithm tries to recognize the tree without any adjunction by mov ing the dot below the dotted node. Step 3 applies when the dot is to the left and below the foot node of an auxiliary tree. \ufffda lgorithm then consider\ufffd ; all nodes on which the auxiliary tree could have been adjoined and tries to recognize the subtree below each o _. -7 It is in Step 3 of the predictor that the VPP is violated since not all nodes that are predicted are compatible with the left context seen so far. The ones that are not compatible will be pruned in a later point in the algorithm (by the Comple tor). Ruling them out during this step requires more complex data-structures and increases the complexity of the algorithm (Schabes and Joshi, 1988) . Predictor (see Figure 5 ) : If the conditions are satisfied, for all elementary trees 6 E JU A and for all addresses dot' in 6 such that a E Adjunct( 6, dot'), the state [6 {p) lb, l, -,-,l, nil] is added to C. (1) (2 ) (3) \u2022 (1) A \ufffd [ij, k,l,n il] [I,-,-,l,nil] (2) Predictor. Completor The Co mpletor is a bottom-up processor that com bines two states to form another state that spans a bi gg er portion of the input. It consists of three possibly non-exclusive steps that apply when the dot is at position rb (right below). Step 1 considers that the next token comes from the part to the right of the foot node of an auxiliary tree adjoined on the dotted node. Steps 2 and 3 try to further recognize the same tree and concatenate boundaries of two states. [a, dot , rb, i,j,-k, 1, nil] such that a(dot) E NT , with a state s2 = [,B, dot',lb, i, -,-,i,nil] such that /3 E Adjunct(a, dot) and such that dot' is the address of the foot node of (3. It adds the state [,B, dot',rb, i, i, l, l, nil] to C. [a, dot , la, h, -,-,i, nil] . It adds the state [a, dot , ra, h, j, k, 1, nil] to C. \u2022 Step 3 combines a state of the form s 1 = [a,dot, rb, i,j, k, l, sat?] such that a( dot) E NT and s. t. the node at address dot in a does not subsume the foot node of a with a state s2 = [a , dot, la, h,j, k,i,nil] . It adds the state [a, dot , ra, h, j, k, 1, nil] to C. Adjunctor The Adjunctor is a bottom-up processor that com bines two states by adjunction to form a state that spans a bigger portion of the input. It consists of a single step. [a, dot , rb,j, m, n, k, nil] such that /3 E Adjunct(a, dot) . It adds the state [a, dot , rb, i, m, n, k, true] to C. An Example We giv\ufffd an example that illustrates how the rec ognizer works. The grammar used for the exam ple ( see Figure 8 ) generates the language L = {a n b n ec n d n ln \ufffd 0} . The grammar consists of an initial tree a and an auxiliary tree /3. There is a null adjoining constraint on the root node and the foot node of /3. The input string given to the recognizer is: aabbeccdd. The corresponding chart is shown in Figure 9 . For purpose of explanation, we have preceded each state with a number that uniquely identifies the state and we followed the state with the operation(s) that caused it t9 be placed into the chart. We used the following abbreviations: init for the initialization step, pred(k) for the Pre dictor applied to the state numbered by k, sc(k) for the Scanner applied to the state numbered by k, compl(k+l) for the combination with the Comple tor of the states numbered by k and I and adj(k+l) for the combination with the Adjunctor of the states numbered by k and I. With this conven tion, one can trace step by step the building of the chart . For example, 31. [/3, dot : 2, rb, l, 4, 5, 8 , t] adj(30+24) stands for the state [/3, dot : 2, rb, 1,4, 5, 8,t] uniquely identified by the number 31 which was placed into the chart by combining with the Ad junctor the states identified by the numbers 30 and 24. The input is recognized since [a , 0 , right, above, 0, -, -, 9 , nil] is in the chart C. 7 Implementation The algorithm described in Section 3.5 can be \u2022implemented to follow an arbitrary search space strategy by using a priority function that ranks the states to be processed. The ranking function can also be defined to obtain a left to right behav ior as in (Earley, 1968) . Such a function may also very well be of statistical nature as for example in (Magerman and Marcus, 1991) . In order to bound the worst case complexity as stated in the next section, arrays must be used to implement efficiently the diffe rent processors. Due to the lack of space, we do not include the details of such implementation in this paper but they are found in (Schabes , 1991) . 28 Correctness and Complexity The algorithm is a general parser for TAGs with constraints on adjunction that takes in worst case O(IGl 2 Nn 6 ) time and O(IGINn 4 ) space, n being the length of the input string, IGI the number of elementary trees in the grammar and N the maxi mum number of nodes in an elementary tree. The worst case complexity comes from the Adjunctor processor. An intuition of the validity of this re sult can be obtained by observing that that this processor (see Section 3.5.4) may be called at most IGl 2 N n 6 time since there are at most n 6 instances of the indices (i,j, k,l, m,n) and at most IGl 2 N pairs of dotted trees to combine (a, /3, dot). When it is used with unambiguous tree-adjoining gram mars, the algorithm takes at most O(IGl 2 Nn 4 ) time 11 and linear time on a large class of gram mars. The proof of correctness consists in the proof of the invariant stated in Section 3.4. Due to the lack of space, the details of the proofs of correctness and complexity are not given in this paper, but they are found in Schabes (1991). The Parser The algorithm that we described in section :3.5 is a recognizer. However, if we include pointers from a state to the other states ( to a pair of states for the Completor and the Adjunctor or to a state for the Scanner and the Predictor) which caused it to be placed in the chart (in a similar manner to that shown in Figure 9 ) , the recognizer can be modi fied to record all parse trees of the input string. The representation is similar to a shared forest. The worst case time complexity for the parser is the same as for the recognizer (O(IGl 2 Nn 6 )-time) but the worst case space complexity increases to O(IGl 2 Nn 6 )-space. Extensions The algorithm has been modified to handle exten sions of TAGs such as substitution (Schabes et al., 1988) , unification based TAGs (Vijay-Shanker and Joshi, 1988; Vijay-Shanker, 199 1) and a version of multiple component TAG (see Schabes, 1990 , for details on how to modify the parser to. handle these extensions). It can also take advantage of lexicalized TAGs (Schabes and Joshi, 1989) . Conclusion We have shown that maintaining the valid prefix property for TAG parsing is costly because of the context-freeness of the path set of TA G derived trees. In 1988, Schabes and Joshi introduced an Earley-style parser that satisfies the VPP how ever at a cost to its complexity ( 0( n 9 )-time in the worst case but linear on some gr:ammars). To our knowledge, it is the only known polynomial time parser for TAG which satisfies the valid prefix property. We have introduced a predictive left to right parser for TAGs which does not maintain the valid prefix property but takes at most 0(n 6 )-time in the worst case, 0( n 4 )-time for unambiguous gram mars, and can behave linearly on some classes of grammars. The parser which we introduced is a practical parser since it often behaves better than its worst case complexity. It has been extended to handle extensions of TAGs such as unification based TAG and a restricted version of multiple component TAGs. This predictive left to right parser can be adapted to other grammatical formalisms w\ufffdakly equivalent to tree-adjoining languages (Joshi et al. , Forthcoming 1990 ) such as linear index gram mar, head grammars and a version of combinatory categorial grammars. I Input read States if:i the chart a a aa aa aab aab aabb 1. [a, dot : 0 , la, 0 , -, -, 0, nil] init 3. [a, dot : 1 , la, 0, -, -, 0, nil] pred{l) 5. [, 8 , dot : 2, la, 0, -, -, 1 , nil] sc(4) _z__t,a.,_. daL :-2. l, la,-l, -,_ :-, 1,nil] pred{5) 9. [, 8 , dot : 2, la, 1, -, -, 2, nil] sc{8} 11. [,B, dot : , la 2, -, -, 2, nil] pred{9) [, 8, dot : 0, la, 0, -, -, 0, nil] pred{l) ,{ . [.8, dot '. 1 , la, 0 , -, -, 0, n\ufffdl] p_ red(g) _ ( \u00a7) [,B, dot . 0, la, 1, -, -, 1, nil] pred{5) -1:.._ [P, dot \ufffd), [a, 1 , -, -, 1 , nil]",
    "abstract": "The valid prefix property (VPP) , the capability of a left to right parser to detect errors as soon as pos sible, often goes unnoticed in parsing CFGs. Ear ley's parser for CFGs (Earley, 1968; Earley, 1970) maintains the valid prefix property and obtains an O(n 3 )-time worst case complexity, as good as parsers that do not maintain such as the CKY parser (Younger, 1967; Kasami, 1965). Contrary to CFGs, maintaining the valid prefix property for TAGs is costly. \u2022 This research was partially fu nded by ARO grant DAAL03-89-C0031PRI and DARPA grant N00014-90-J-1863 . The difficulty of maintaining the valid prefix property for TAGS was first noticed in joint work with Vijay-Shanker in the context of deterministic parsing of tree-adjoining grammars (Schabes and Vijay-Shanker, 1990). I am in debted to Vijay-Shanker for nwnerous discussions on this topic. I am also indebted to Aravind Joshi for his sugges tions and for his support of this research. The discussions I had with Mitchell Marcus greatly improved the presenta tion of the algorithm introduced in this paper. I would also like to thank Bob Frank, Bernard Lang, Fernando Pereira, Philip Resnik and Stuart Shieber for providing valuable comments. The valid prefix property is also sometimes re ferred as the error detecting prop erty because it implies that errors can be detected as soon as pos sible. However, the lack of VPP does not imply that errors are undetected. 1 The valid prefix property is independent from the on lin e property. An on-line left to right parser is able to output for each new token read whether the string seen so far is a valid string of the language.",
    "countries": [
        "United States"
    ],
    "languages": [],
    "numcitedby": "22",
    "year": "1991",
    "month": "February 13-25",
    "title": "The Valid Prefix Property and Left to Right Parsing of {T}ree-{A}djoining {G}rammar"
}