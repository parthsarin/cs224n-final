{
    "article": "When building spoken dialogue systems for a new domain, a major bottleneck is developing a spoken language understanding (SLU) module that handles the new domain's terminology and semantic concepts. We propose a statistical SLU model that generalises to both previously unseen input words and previously unseen output classes by leveraging unlabelled data. After mapping the utterance into a vector space, the model exploits the structure of the output labels by mapping each label to a hyperplane that separates utterances with and without that label. Both these mappings are initialised with unsupervised word embeddings, so they can be computed even for words or concepts which were not in the SLU training data. Introduction Spoken Language Understanding (SLU) in dialogue systems is the task of taking the utterance output by a speech recognizer and assigning it a semantic label that represents the dialogue actions of that utterance accompanied with their associated attributes and values. For example, the utterance \"I would like Chinese food\" is labelled with inform(food=Chinese), in which inform is the dialogue action that provides the value of the attribute food that is Chinese. Dialogue systems often use hand-crafted grammars for SLU, such as Phoenix (Ward, 1994) , which are expensive to develop, and expensive to extend or adapt to new attributes and values. Statistical SLU models are usually trained on the data obtained from a specific domain and location, using a structured output classifier that can be discriminative (Pradhan et al., 2004; Kate and Mooney, 2006; Henderson et al., 2012) or generative (Schwartz et al., 1996; He and Young, 2005) . Gathering and annotating SLU data is costly and time consuming and therefore SLU datasets are small compare to the number of possible labels. Because training sets for a new domain are small, or non-existent, learning is often an instance of Zero-shot or One-shot learning problems (Palatucci et al., 2009; L. Fei-Fei; Fergus, 2006) , in which zero or few examples of some output classes are available during the training. For example, in the restaurant reservation domain, not all possible combinations of foods and dialogue actions may be included in the training set. The general idea to solve this type of problems is to map the input and class labels to a semantic space of usually lower dimension in which similar classes are represented by closer points in the space (Palatucci et al., 2009; Weston et al., 2011; Weston et al., 2010) . Usually unsupervised knowledge sources are used to form semantic codes of the labels that helps us to generalize to unseen labels. On the other hand, there are also different ways to express the same meaning, and similarly, most of them can not be included in the training set. For instance, the system may have seen \"Please give me the telephone number\" in training, but the user might ask \"Please give me the phone\" at test time. This problem, feature sparsity, is a common issue in many NLP tasks. Decomposition of input feature parameters using vector-matrix multiplication (Bengio et al., 2003; Collobert et al., 2011; Collobert and Weston, 2008) has addressed this sparsity issue successfully in previous work. In this way, by sharing the word representations and composition matrices, we can overcome feature sparsity by producing similar representations for similar utterances. In order to represent words and concepts we use word embeddings, which are a form of vector space model. Word embeddings have proven to be effective models of semantic representation of words in various NLP tasks (Baroni et al., 2014; Yazdani and Popescu-Belis, 2013; Collobert et al., 2011; Collobert and Weston, 2008; Huang et al., 2012; Mikolov et al., 2013b) . In addition to parameter sharing, these representations enable us to leverage large scale unlabelled data. Because word embeddings trained on unlabeled data reflect the similarity between words, they help the model generalize from the words in the original training corpora to the words in the new extended domain, and help generalize from small amounts of data in the extended domain. The contribution of this paper is to build a representation learning classifier for the SLU task that can generalize to unseen words and labels. For every utterance we learn how to compose the word vectors to form the semantics of that utterance for this task of language understanding. Furthermore, we learn how to compose the semantics of each label from the semantics of the words used to name that label. This enables us to generalize to unseen labels. In this work we use the word2vec software of Mikolov et al. (2013a) 1 to induce unsupervised word embeddings that are used to initialize word embedding parameters. For this, we use an English Wikipedia dump as our unlabelled training corpus, which is a diverse broad-coverage corpus. It has been shown (Baroni et al., 2014; Mikolov et al., 2013b ) that these embeddings capture lexical similarities even when they are trained on a diverse corpus like Wikipedia. We test our models on a restaurant booking domain. We investigate domain adaptation by adding new attribute types (e.g. goodformeal) and new attribute values (e.g. Hayes Valley as a restaurant location). Our experiments indicate that our model has better performance compared to a hand-crafted system as well as a SVM baseline. SLU Datasets The dialogue utterances used to build the SLU dataset were collected during a trial of online dialogue policy adaptation for a restaurant reservation system based in San Francisco. The trial began with (area, pricerange and food), and adapted the Interaction Manager online to handle the additional attribute types near, allowedforkids, and goodformeal (Ga\u0161ic et al., 2014) . User utterances from these trials were transcribed and annotated with dialogue acts by an expert, and afterwards edited by another expert 2 . Each user utterance was annotated with a set of labels, where each label consists of an act type (e.g. inform, request), an attribute type (e.g. foodtype, pricerange), and an attribute value (e.g. Chinese, Cheap). The dataset is separated into four subsets, SFCore, SF1Ext, SF2Ext and SF3Ext, each with an increasing set of attribute types, as specified in Table 1 . This table also gives the total number of utterances in each data set. For our first experiment, we split each dataset into about 15% for the testing set and 85% for the training set. For our second experiment we use each extended subset for testing and its preceding subsets for training. The SLU model is run on each hypothesis output by the ASR component, and tries to predict the correct set of dialogue act labels for each hypothesis. This problem is in general an instance of multi-label classification, because a single utterance can have multiple dialogue act labels. Also, these labels are structured, since each label consist of an act type, an attribute type, and an attribute value. Each label component also has canonical text associated with it, which is the text used to name the label component (e.g. \"Chinese\" as a value). The number of possible dialogue acts grows rapidly as the domain is extended with new attribute types and values, making this task one of multi-label classification with a very large number of labels. One natural approach to this task is to train one binary classifier for each possible label, to decide whether or not to include it in the output. In our case, this requires training a large number of classifiers, and it is impossible to generalize to 2 This data is publically available from https://sites.google.com/site/ parlanceprojectofficial/home/ datarepository dialogue acts that include attributes or values that were not in the training set since there won't be any parameter sharing among label classifiers. In our alternative approach, we build the representation of the utterance and the representation of the label from their constituent words, then we check if these representations match or not. In the following we explain in details this representation learning model. Utterance Representation Learning In this section we explain how to build the utterance representation from its constituent words. In addition to words, we use bigrams, since they have been shown previously to be effective features for this task (Henderson et al., 2012) . Following the success in transfer learning from parsing to understanding tasks (Henderson et al., 2013; Socher et al., 2013) , we use dependency parse bigrams in our features as well. We learn to build a local representation at each word position in the utterance by using the word representation, adjacent word representations, and the head word representation. Let \u03c6(w) be a d dimensional vector representing the word w, and \u03c6(U i ) be a h dimensional vector which is the local representation at word position i. We compute the local representation as follows: \u03c6(U i ) = \u03c3(\u03c6(w i )W word + \u03c6(w h )W parse R k + \u03c6(w j )W previous + \u03c6(w k )W next ) (1) in which w h is the head word with the dependency relation R k to w i , and w j and w k are the previous and next words. W word is a d \u00d7 h matrix that transforms the word embedding to hidden representation inputs. W parse R k is a d \u00d7 h matrix for the relation R k that similarly transforms the head word embedding (so W parse is a tensor), and W previous and W next similarly transform the previous and next words' embeddings. Figure 1 depicts this representation building at each word. Label Representation Learning One standard way to address the problem of multilabel classification is building binary classifiers for each possible label. Large margin classifiers have been shown to be an effective tool for this task (Pradhan et al., 2004; Kate and Mooney, 2006) . We use the same idea of binary classifiers to learn one hyperplane per label, which separates the utterances with this label from all other utterances, with a large margin. In the standard way of Figure 1 : The multi-label classifier building the classifier, each label's hyperplane is independent of other labels. To extend this model to a zero-shot learning classifier, we use parameter sharing among label hyperplanes so that similar labels have similar hyperplanes. We exploit the structure of labels by assuming that each hyperplane representation is a composition of representations of the label's constituent components, namely dialogue action, attribute and attribute value. We learn the composition function and the constituent representations while training the classifiers, using the labelled SLU data. The constituent representations are initialised as the word embeddings for the label constituent's name string, such as \"inform\", \"food\" and \"Chinese\", where these embeddings are trained on the unlabelled data. Figure 1 depicts the classifier model. We define the hyperplane of the label a j (att k = val l ) with its normal vector W a j ,att k ,val l as: W a j ,att k ,val l = \u03c3([\u03c6(a j ), \u03c6(att k ), \u03c6(val l )]W ih )W ho where \u03c6(\u2022) is the same mapping to d dimensional word vectors that is used above in the utterance representation, W ih is a 3d \u00d7 h matrix and W ho is a h \u00d7 h matrix. The score of each local representation vector \u03c6(U i ) is its distance from this label hyperplane, which is computed as the dot product of the local vector \u03c6(U i ) with the normal vector W a j ,att k ,val l . We sum these local scores for each position i to build the whole utterance score: i \u03c6(U i )W T a j ,att k ,val l . Alternatively we can think of this computation as summing the local vectors to get a whole-utterance representation \u03c6(U ) = i \u03c6(U i ) and then doing the dot product. The pooling method (sum) used in the model is (intentionally) over-simplistic. We did not want to distract from the main contribution of the paper, and our dataset did not justify any more complex solution since utterances are short. It can be replaced by more powerful approaches if it is needed. To train a large margin classifier, we train all the parameters such that the score of an utterance is bigger than a margin for its labels and less than the negative margin for all other labels. Thus, the loss function is as follows: min \u03b8 \u03bb 2 \u03b8 2 + U max(0, 1\u2212y i \u03c6(U i )W T a j ,att k ,val l ) (2) where \u03b8 is all the parameters of the model, namely \u03c6(w i ) (word embeddings), W word , W P arse , W previous , W next , W ih , and W ho . y is either 1 or \u22121 depending whether the input U has that label or not. To optimize this large margin classifier we form stochastic gradient descent by using the adagrad algorithm on this primal loss function, similarly to Pegasos SVM (Shalev-Shwartz et al., 2007) , but here we backpropagate the errors to the representations to train the word embeddings and composition functions. In each iteration of the stochastic training algorithm, we randomly select an utterance and its labels as positive examples and choose randomly another utterance with a different label as a negative example. When choosing the negative sample randomly, we sample utterances with the same dialogue act but different attribute or value with 4 times higher probability than utterances with a different dialogue act. This biased negative sampling speeds up the training process since it provides more difficult training examples to the learner. The model is able to address the adaptivity issues because the utterance and the dialogue act representations are in the same space using the same shared parameters \u03c6(w), which are initialised with unsupervised word embeddings. It has been shown that such word embeddings capture word similarities and hence the classifier is no longer ignorant about any new attribute type or attribute value. Also, there is parameter sharing between dialogue acts because these word/label embeddings are shared, and the matrices for the composition of these representations are the same across all dialogue acts. This can help overcome sparsity in the SLU training set by transferring learning between similar situations and similar dialogue act triples. For example, if the training set does not contain any examples of the act \"request(postcode)\", but many examples of \"request(phone)\", sharing the parameters can help with the recognition of \"request(postcode)\" in utterances similar to \"request(phone)\". Moreover, the SLU model is to some extent robust against paraphrasing in the input utterance because it maps the utterance to a semantic space, and uses parse bigrams. More sophisticated vector-space semantic representations of the utterance are an area for future work, but should be largely orthogonal to the contribution of this paper. To find the set of compatible dialogue acts for a given utterance, we should check all possible dialogue acts. This can severely slow down SLU. To avoid testing all possible dialogue combinations, we build three different classifiers: The first one recognises the act types in the utterance, the second one recognises the attribute types for each of the chosen act types, and the third classifier recognises the full dialogue acts as we described above, but only for the chosen pairs of act types and attribute types. SLU Experiments In the first experiment, we measure SLU performance trained on all available data, by building a dataset that is the union of all the above datasets. This measures the performance of SLU when there is a small amount of data for an extended domain. This dataset, similarly to SF3Ext, has 6 main attribute types. Table 2 shows the performance of this model. We report as baselines the performance of the Phoenix system (hand crafted for this domain) and a binary linear SVM trained on the same data. The hidden layers have size h=d=50. For this experiment, we split each dataset into about 15% for the testing set and 85% for the training set.   Table 3 : SLU performance: trained on a smaller domain and tested on more inclusive domains. particularly that the recall is almost twice as high as the hand-crafted baseline. This shows that our SLU can recognise most of the dialogue acts in an utterance, where the rule-based Phoenix system and a classifier without composed output cannot. Overall there are 1042 dialogue acts in the test set. SLU recall is very important in the overall dialogue system performance, as the effect of a missed dialogue act is hard to handle for the Interaction Manager. Both hand-crafted and our system show relatively high precision. In the next experiment, we measure how well the new SLU model performs in an extended domain without any training examples from that extended domain. We train a SLU model on each subset, and test it on each of the more inclusive subsets. Table 3 shows the results. Not surprisingly, the performance is better if SLU is trained on a similar domain to the test domain, and adding more attribute types and values decreases the performance more. But our SLU can generalise very well to the extended domain, achieving much better generalisation that the SVM model. Conclusion In this paper, we describe a new SLU model that is designed for improved domain adaptation. The multi-label classification problem of dialogue act recognition is addressed with a classifier that learns to build an utterance representation and a dialogue act representation, and decides whether or not they are compatible. The dialogue act representation is a vector composition of its constituent labels' embeddings, and is trained as the hyperplane of a large margin binary classifier for that dialogue act. The utterance representation is trained as a composition of word embeddings. Since the utterance and the dialogue act representations are both built using unsupervised word embeddings and share these embedding parameters, the model can address the issues of domain adaptation. Word embeddings capture word similarities, and hence the classifier is able to generalise from known attribute types or values to similar novel attribute types or values. We tested this SLU model on datasets where the number of attribute types and values is increased, and show much better results than the baselines, especially in recall. The model succeeds in both adapting to an extended domain using relatively few training examples and in recognising novel attribute types and values. Acknowledgments The research leading to this work was funded by the EC FP7 programme FP7/2011-14 under grant agreement no. 287615 (PARLANCE), and Hasler foundation project no. 15019, Deep Neural Network Dependency Parser for Context-aware Representation Learning. The authors also would like to thank Dr.Helen Hastie for her help in annotating the dataset.",
    "abstract": "When building spoken dialogue systems for a new domain, a major bottleneck is developing a spoken language understanding (SLU) module that handles the new domain's terminology and semantic concepts. We propose a statistical SLU model that generalises to both previously unseen input words and previously unseen output classes by leveraging unlabelled data. After mapping the utterance into a vector space, the model exploits the structure of the output labels by mapping each label to a hyperplane that separates utterances with and without that label. Both these mappings are initialised with unsupervised word embeddings, so they can be computed even for words or concepts which were not in the SLU training data.",
    "countries": [
        "Switzerland"
    ],
    "languages": [
        "Chinese",
        "English"
    ],
    "numcitedby": "56",
    "year": "2015",
    "month": "September",
    "title": "A Model of Zero-Shot Learning of Spoken Language Understanding"
}