{
    "framing_question": "If this paper introduces a task or benchmark, which communities does it state are the subject of the task or benchmark, if any?",
    "response": "This paper does not introduce a task or benchmark, so it does not state that any communities are the subject of the task or benchmark.",
    "article": "We present the specification for a modeling language, VoxML, which encodes semantic knowledge of real-world objects represented as three-dimensional models, and of events and attributes related to and enacted over these objects.VoxML is intended to overcome the limitations of existing 3D visual markup languages by allowing for the encoding of a broad range of semantic knowledge that can be exploited by a variety of systems and platforms, leading to multimodal simulations of real-world scenarios using conceptual objects that represent their semantic values. Introduction In this paper, we describe a modeling language for constructing 3D visualizations of concepts denoted by natural language expressions. This language, VoxML (Visual Object Concept Modeling Language), is being used as the platform for creating multimodal semantic simulations in the context of human-computer communication. 1  Prior work in visualization from natural language has largely focused on object placement and orientation in static scenes (Coyne and Sproat, 2001; Siskind, 2001; Chang et al., 2015) , and we have endeavored to incorporate dynamic semantics and motion language into our model. In previous work (Pustejovsky and Krishnaswamy, 2014; Pustejovsky, 2013) , we introduced a method for modeling natural language expressions within a 3D simulation environment built on top of the game development platform Unity (Goldstone, 2009) . The goal of that work was to evaluate, through explicit visualizations of linguistic input, the semantic presuppositions inherent in the different lexical choices of an utterance. This work led to two additional lines of research: an explicit encoding for how an object is itself situated relative to its environment; and an operational characterization of how an object changes its location or how an agent acts on an object over time. The former has developed into a semantic notion of situational context, called a habitat (Pustejovsky, 2013; McDonald and Pustejovsky, 2014) , while the latter is addressed by dynamic interpretations of event structure (Pustejovsky and Moszkowicz, 2011; Pustejovsky, 2013) . The requirements on a visual simulation include, but are not limited to, the following components: 1. A minimal embedding space (MES) for the simulation must be determined. This is the 3D region within which the state is configured or the event unfolds; 2. Object-based attributes for participants in a situation or event need to be specified; e.g., orientation, relative size, default position or pose, etc.; 3. An epistemic condition on the object and event rendering, imposing an implicit point of view (POV); 4. Agent-dependent embodiment; this determines the relative scaling of an agent and its event participants and their surroundings, as it engages in the environment. In order to construct a robust simulation from linguistic input, an event and its participants must be embedded within an appropriate minimal embedding space. This must sufficiently enclose the event localization, while optionally including space enough for a frame of reference for the event (the viewer's perspective). We return to this issue later in the paper when constructing our simulation from the semantic interpretation associated with motion events. Existing representation languages for 3D modeling, such as VRML (Parisi and Pesce, 1994) , (Carson et al., 1999) or X3D (Brutzman and Daly, 2010) , adequately represent the vertices, edges, faces, and UV texture mapping that make up the model itself, but contain no information about how such an object interacts with other objects in a real or simulated environment. Such information is represented on an ad hoc basis for the needs of the particular platform or environment in which the model will be deployed. Our goal in developing VoxML is twofold: to specify a language for both designing and representing data structures that generate simulations of linguistically represented objects, properties, and events. Just as the lexical items in a language are specified and encoded with a richly typed framework, such as Generative Lexicon, most lexemes will have a representation within VoxML that encodes an interpretation of the word's semantic content as a visualization. We have followed a strict methodology of specification development, as adopted by ISO TC37/SC4 and outlined in (Bunt, 2010) and (Ide and Romary, 2004) , and as implemented with the development of ISO-TimeML (Pustejovsky et al., 2005; Pustejovsky et al., 2010) and others in the family of SemAF standards. Further, our work shares many of the goals pursued in (Dobnik et al., 2013; Dobnik and Cooper, 2013) , for specifying a rigidly-defined type system for spatial representations associated with linguistic expressions. In this paper, we describe a specification language for modeling \"visual object concepts\", VoxML. The object defined within VoxML will be called a voxeme, and the library of voxemes, a voxicon. Habitats and Affordances Before we introduce the VoxML specification, we review our assumptions regarding the semantics underlying the model. Following Generative Lexicon (GL) (Pustejovsky, 1995) , lexical entries in the object language are given a feature structure consisting of a word's basic type, its parameter listing, its event typing, and its qualia structure. The semantics of an object will consist of the following: Objects can be partially contextualized through their qualia structure: a food item has a TELIC value of eat, an instrument for writing, a TELIC of write, a cup, a TELIC of hold, and so forth. For example, the lexical semantics for the noun chair carries a TELIC value of sit in: \u03bbx\u2203y \uf8ee \uf8ef \uf8f0 chair AS = ARG1 = x : e QS = \uf8ee \uf8ef \uf8f0 F = phys(x) T = \u03bbz, e[sit in(e, z, x)] \uf8f9 \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fb While an artifact is designed for a specific purpose (its TELIC role), this can only be achieved under specific circumstances. (Pustejovsky, 2013) introduces the notion of an object's habitat, which encodes these circumstances. Assume that, for an artifact, x, given the appropriate context C, performing the action \u03c0 will result in the intended or desired resulting state, R, i.e., C \u2192 [\u03c0]R. That is, if a context C (a set of contextual factors) is satisfied, then every time the activity of \u03c0 is performed, the resulting state R will occur. The precondition context C is necessary to specify, since this enables the local modality to be satisfied. Using this notion, we define a habitat as a representation of an object situated within a partial minimal model; it is a directed enhancement of the qualia structure. Multidimensional affordances determine how habitats are deployed and how they modify or augment the context, and compositional operations include procedural (simulation) and operational (selection, specification, refinement) knowledge. The habitat for an object is built by first placing it within an embedding space and then contextualizing it. For example, in order to use a table, the top has to be oriented upward, the surface must be accessible, and so on. A chair must also be oriented up, the seat must be free and accessible, it must be able to support the user, etc. An illustration of what the resulting knowledge structure for the habitat of a chair is shown below. \u03bbx \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 chair hab F = [phys(x), on(x, y1), in(x, y2), orient(x, up)] C = [seat(x1), back(x2), legs(x3), clear(x1)] T = \u03bbz\u03bbe[C \u2192 [sit(e, z, x)]Rsit(x)] A = [made(e , w, x)] \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb As described in more detail below, event simulations are constructed from the composition of object habitats, along with particular constraints imposed by the dynamic event structure inherent in the verb itself, when interpreted as a program. The final step in contextualizing the semantics of an object is to operationalize the TELIC value in its habitat. This effectively is to identify the affordance structure for the object (Gibson, 1977; Gibson, 1979) . The affordance structure available to an agent, when presented with an object, is the set of actions that can be performed with it. We refer to these as GIBSONIAN affordances, and they include \"grasp\", \"move\", \"hold\", \"turn\", etc. This is to distinguish them from more goal-directed, intentionally situated activities, what we call TELIC affordances. The VoxML Specification VoxML Elements Entities modeled in VoxML can be objects, programs, or logical types. Objects are logical constants; programs are nary predicates that can take objects or other evaluated predicates as arguments; logical types can be divided into attributes, relations, and functions, all predicates which take objects as arguments. Attributes and relations evaluate to states, and functions evaluate to geometric regions. These entities can then compose into visualizations of natural language concepts and expressions. Objects The VoxML OBJECT is used for modeling nouns. The current set of OBJECT attributes is shown below: The LEX attribute contains the subcomponents PRED, the predicate lexeme denoting the object, and TYPE, the object's type according to Generative Lexicon. The TYPE attribute (different from LEX's TYPE subcomponent) contains information to define the object geometry in terms of primitives. HEAD is a primitive 3D shape that roughly describes the object's form (such as calling an apple an \"ellipsoid\"), or the form of the object's most semantically salient subpart. We ground our possible values for HEAD in, for completeness, mathematical formalism defining families of polyhedra (Gr\u00fcnbaum, 2003) , and, for annotator's ease, common primitives found across the \"corpus\" of 3D artwork and 3D modeling software 2 (Giambruno, 2002) . Using common 3D modeling primitives as convenience definitions provides some built-in redundancy to VoxML, as is found in NL description of structural forms. For example, a rectangular prism is the same as a parallelepiped that has at least two defined planes of reflectional symmetry, meaning that an object whose HEAD is rectangular prism could be defined two ways, an association which a reasoner can unify axiomatically. Possible values for HEAD are given below: HEAD prismatoid, pyramid, wedge, parallelepiped, cupola, frustum, cylindroid, ellipsoid, hemiellipsoid, bipyramid, rectangular prism, toroid, sheet It should be emphasized that these values are not intended to reflect the exact structure of a particular geometry, but rather a cognitive approximation of its shape, as is used in some image-recognition work (Goebel and Vincze, 2007) . Object subparts are enumerated in COMPONENTS. CON-CAVITY can be concave, flat, or convex and refers to any concavity that deforms the HEAD shape. ROTAT-SYM, or rotational symmetry, defines any of the world's three orthogonal axes around which the object's geometry may be rotated for an interval of less than 360 degrees and retain identical form as the unrotated geometry. A sphere may be rotated at any interval around any of the three axes and retain the same form. A rectangular prism may be rotated 180 degrees around any of the three axes and retain the same shape. An object such as a ceiling fan would only have rotational symmetry around the Y axis. Reflectional symmetry, or REFLECTSYM, is defined similarly. If an object may be bisected by a plane defined by two of the world's three orthogonal axes and then reflected across that plane to obtain the same geometric form as the original object, it is considered to have reflectional symmetry across that plane. A sphere or rectangular prism has reflectional symmetry across the XY, XZ, and YZ planes. A wine bottle only has reflectional symmetry across the XY and YZ planes. The possible values of ROTATSYM and REFLECTSYM are intended to be world-relative, not object-relative. That is, because we are only discussing objects when situated in a minimal embedding space (even an otherwise empty one) wherein all coordinates are given Cartesian values, the axis of rotational symmetry or plane of reflectional symmetry are those denoted in the world, not of the object. Thus, a tetrahedron-which in isolation has seven axes of rotational symmetry, no two of which are orthogonal-when placed in the MES such that it cognitively satisfies all \"real-world\" constraints, must be situated with one base downward (a tetrahedron placed any other way will fall over). Thus reducing the salient in-world axes of rotational symmetry to one: the world's Y-axis. When the orientation of the ob-ject is ambiguous relative to the world, the world should be assumed to provide the grounding value. The HABITAT element defines habitats INTRINSIC to the object, regardless of what action it participates in, such as intrinsic orientations or surfaces, as well as EXTRIN-SIC habitats which must be satisfied for particular actions to take place. We can define intrinsic faces of an object in terms of its geometry and axes. The model of a computer monitor, when axis-aligned according to 3D modeling convention, aligns the screen with the world's Z-axis facing the direction of increasing Z values. When discussing the object \"computer monitor,\" the lexeme \"front\" singles out the screen of the monitor as opposed to any other part. We can therefore correlate the lexeme with the geometrical representation by establishing an intrinsic habitat of the computer monitor of front(+Z). We adopt the terminology of \"alignment\" of an object dimension, d \u2208 {x, y, z}, with the dimension, d , of its embedding space, E d , as follows: align(d, E d ). AFFORD STR describes the set of specific actions, along with the requisite conditions, that the object may take part in. There are low-level affordances, called GIBSO-NIAN, which involve manipulation or maneuver-based actions (grasping, holding, lifting, touching); there are also TELIC affordances (Pustejovsky, 1995) , which link directly to what goal-directed activity can be accomplished, by means of the GIBSONIAN affordances. EMBODIMENT qualitatively describes the SCALE of the object compared to an in-world agent (typically assumed to be a human) as well as whether the object is typically MOV-ABLE by that agent. Programs PROGRAM is used for modeling verbs. The type of a program as shown above is given in terms of how the visualization of the action is realized. Basic program distinctions, such as test versus assignment are included within this typology and further distinguished through subtyping. Logical Types Like OBJECTs and PROGRAMS, all functional type classes contain a LEX attribute and a PRED parameter that denote the lexeme related to the VoxML representation. The distinction between ATTRIBUTEs, RELATIONs, and FUNC-TIONs lies mainly in differences in their TYPE structure, discussed in each subsection below. Attributes Adjectival modification and predication involve reference to an ATTRIBUTE in our model, along with a specific value for that attribute. Often, but not always, this attribute is associated with a family of other attributes, structured according to some set of constraints, which we call a SCALE. The least constrained association is a conventional sortal classification, and its associated attribute family is the set of pairwise disjoint and non-overlapping sortal descriptions (nonsuper types). Following (Stevens, 1946; Luce et al., 1990) , we will call this classification a nominal scale, and it is the least restrictive scale domain over which we can predicate an individual. binary classifications are a two-state subset of this domain. When we impose more constraints on the values of an attribute, we arrive at more structured domains. For example, by introducing a partial ordering over values, we can have transitive closure, assuming all orderings are defined. This is called an ordinal scale. When fixed units of distance are imposed between the elements on the ordering, we arrive at an interval scale. Finally, when a zero value is introduced, we have a scalar structure called a ratio scale. In reality, of course, there are many more attribute categories than the four listed above, but the goal in VoxML is to use these types as the basis for an underlying cognitive classification for creating measurements from different attribute types. In other words, these scale types are models of cognitive strategies for structuring values for conceptual attributes associated with natural language expressions involving scalar values. VoxML encodes how attributes and the associated programs that change their values can be grouped into these scalar domains of measurement. As VoxML is intended to model visualizations of physical objects and programs, we should note here that we are only examining first-order attributes, and not those that require any subjective interpretation relative to their arguments (that is, VoxML is intended to model \"the image is red\" but not \"the image is depressing\" VoxML also denotes an attribute's ARITY, or the relative of the attribute to the object it describes compared to other instances of the same object class. transitive attributes are considered to describe object qualities that require comparison to other object instances (e.g. the small cup vs. the big cup), whereas intransitive attributes do not require that comparison (a red cup is not red compared to other cups; it is objectively red-or its redness can be assessed quantitatively). Finally, every attribute must be realized as applying to an object, so attributes require an ARG, a variable representing said object and the typing thereof. This is denoted identically to the individual ARGS of VoxML PROGRAMs. Relations A RELATION's type structure specifies a binary CLASS of the relation: configuration or force dynamic, describing the nature of the relation. These classes themselves have subvalues-for configurational relations these are values from the region connection calculus (Randell et al., 1992) . Also specified are the arguments participating in the relations. These, as above, are represented as typed variables. Functions FUNCTIONs' typing structures take as ARG the OBJECT voxeme being computed over. REFERENT takes any subparameters of the ARG that are semantically salient to the function, such as the voxeme's HEAD. If unspecified, the entire voxeme should be assumed as the referent. MAP-PING is set to a denotation of the type of transformation the function performs over the object, such as dimensionality reduction (notated as dimension(n):n-1 for a function that takes in an object of n dimensions and returns a region of n-1). Finally, ORIENTATION provides three values: SPACE, which notes if the function is performed in world space or object space; AXIS, which notes the primary axis and direction the function exploits; and ARITY, which returns transitive or intransitive based on the boolean value of a specified input variable (x[y]:intransitive denotes a function that returns intransitive if the value of y in x is true). Defintions of transitive and intransitive follow those for ATTRIBUTEs. Examples of Voxemes In this section, we illustrate the representational capabilities of the specification by briefly presenting example voxeme entries from the current VoxML voxicon. VoxML OB-JECT representations are intended to correspond with specific voxeme geometries, which are given below the markup example. In cases where a representation instance is given independently of a geometry, it should be assumed to denote a prototypical or \"default\" representation of the voxeme's associated lexeme. We explore the richness of the language in more detail in the long version of the paper. Objects In this section, we illustrate the visual object concept modeling capabilities for objects by differentiating between properties of the object's type, habitat, afforfance structure, and how it is embodied. Consider the voxeme structures for wall and table. \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 wall LEX = \uf8ee \uf8f0 PRED = wall TYPE = physobj \uf8f9 \uf8fb TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 HEAD = rectangular prism COMPONENTS = nil CONCAVITY = flat ROTATSYM = {X, Y, Z} REFLECTSYM = {XY, XZ, Y Z} \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb HABITAT = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 INTR = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 UP = align(Y, EY ) FRONT = f ront(+Z) CONSTR = Z Y, Z X \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb EXTR = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb AFFORD STR = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 A1 = H1 \u2192 [E1]R A2 = ... A3 = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb EMBODIMENT = \uf8ee \uf8f0 SCALE = >agent MOVABLE = false \uf8f9 \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Figure 1: Wall voxeme instance While walls and tables are both geometries that have habitats which are upwardly aligned, tables have a head geometry of sheet, which is a special case of rectangular prism where the Y dimension is significantly less than X or Z. This head is identified in the habitat as the top of the object, facing up. \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 table LEX = \uf8ee \uf8f0 PRED = table TYPE = physobj \uf8f9 \uf8fb TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 HEAD = sheet [1] COMPONENTS = surface [1], leg+ CONCAVITY = flat ROTATSYM = {Y } REFLECTSYM = {XY, Y Z} \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb HABITAT = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 INTR = \uf8ee \uf8ef \uf8f0 UP = align(Y, EY ) TOP = top(+Y ) \uf8f9 \uf8fa \uf8fb EXTR = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb AFFORD STR = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 A1 = H1 \u2192 [E1]R A2 = ... A3 = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb EMBODIMENT = \uf8ee \uf8f0 SCALE = agent MOVABLE = true \uf8f9 \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Now consider the voxeme for plate. This illustrates how the habitat feeds into activating the affordance structure associated with the object. Namely, if the appropriate conditions are satisfied ([1]), then the telic affordance associated with a plate is activated; every putting of x on y results in y holding x. 2: Table voxeme instance \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 plate LEX = \uf8ee \uf8f0 PRED = plate TYPE = physobj \uf8f9 \uf8fb TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 HEAD = sheet COMPONENTS = surface, base CONCAVITY = concave ROTATSYM = {Y } REFLECTSYM = {XY, Y Z} \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb HABITAT = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 INTR = [1] \uf8ee \uf8ef \uf8f0 UP = align(Y, EY ) TOP = top(+Y ) \uf8f9 \uf8fa \uf8fb EXTR = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb AFFORD STR = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 A1 = H[1] \u2192 [put(x, y)]hold(y, x) A2 = ... A3 = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb EMBODIMENT = \uf8ee \uf8f0 SCALE = < agent MOVABLE = true \uf8f9 \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Figure 3: Plate voxeme instance \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 apple LEX = \uf8ee \uf8f0 PRED = apple TYPE = physobj \uf8f9 \uf8fb TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 HEAD = ellipsoid [1] COMPONENTS = fruit [1], stem, leaf CONCAVITY = convex ROTATSYM = {Y } REFLECTSYM = {XY, Y Z} \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb HABITAT = \uf8ee \uf8f0 INTR = {} EXTR = ... \uf8f9 \uf8fb AFFORD STR = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 A1 = H1 \u2192 [E1]R A2 = ... A3 = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb EMBODIMENT = \uf8ee \uf8f0 SCALE = < agent MOVABLE = true \uf8f9 \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Programs Events are interpreted as programs, moving an object or changing an object property or relation from state to state, as described in more detail in the next section. Program structure derives largely from the lexical semantics of the verb in GL. However, the semantics of the predicative change over the event structure is interpreted operationally. We illustrate this with two predicates as programs, slide and \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 slide LEX = \uf8ee \uf8f0 PRED = slide TYPE = process \uf8f9 \uf8fb TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 HEAD = process ARGS = \uf8ee \uf8f0 A1 = x:physobj A2 = y:physobj \uf8f9 \uf8fb BODY = \uf8ee \uf8ef \uf8f0 E1 = while(EC(x, y), move(x)) \uf8f9 \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 put LEX = \uf8ee \uf8f0 PRED = put TYPE = transition event \uf8f9 \uf8fb TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 HEAD = transition ARGS = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 A1 = x:agent A2 = y:physobj A3 = z:location \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb BODY = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 E1 = grasp(x, y) E2 = [while( hold(x, y), move(x)] E3 = [at(y, z) \u2192 ungrasp(x, y)] \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Attributes Unlike physical objects, which can be associated with specific geometries, attributes are abstract predications over distinct domains, and can only be simulated by application to an element of this domain. Below is an example of the nominal attributive interpretation of the adjective brown, and the ordinal attributive interpretation of small. \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 brown LEX = PRED = brown TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 SCALE = nominal ARITY = intransitive ARG = x:physobj \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 small LEX = PRED = small TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 SCALE = ordinal ARITY = transitive ARG = x:physobj \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Relations Spatial relations are propositional expressions, contributing configurational information about two or more objects in a state. \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 touching LEX = PRED = is touching TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 CLASS = config VALUE = EC ARGS = \uf8ee \uf8ef \uf8ef \uf8ef \uf8f0 A1 = x:3D A2 = y:3D A3 = ... \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Functions Finally, we illustrate the semantics of spatial functions with top. This applies to an object of dimensionality n, returning an object of dimensionality n \u2212 1; the top of a cube is a plane; that of a rectangular sheet is a line; and the top of a line is a point. \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 top LEX = PRED = top TYPE = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 ARG = x:physobj REFERENT = x\u2192HEAD MAPPING = dimension(n):n-1 ORIENTATION = \uf8ee \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8ef \uf8f0 SPACE = world AXIS = +Y ARITY = x\u2192HABITAT\u2192 INTR[top(axis)]: intransitive \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb \uf8f9 \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fa \uf8fb Using VoxML for Simulation Modeling of Language VoxML treats objects and events in terms of a dynamic event semantics, Dynamic Interval Temporal Logic (DITL) (Pustejovsky and Moszkowicz, 2011) . The advantage of adopting a dynamic interpretation of events is that we can map linguistic expressions directly into simulations through an operational semantics (Miller and Charles, 1991; Miller and Johnson-Laird, 1976) . Models of processes using updating typically make reference to the notion of a state transition (van Benthem, 1991; Harel, 1984) . This is done by distinguishing between formulae, \u03c6, and programs, \u03c0. A formula is interpreted as a classical propositional expression, with assignment of a truth value in a specific model. For the present discussion, we represent the dynamics of actions in terms of Labeled Transition Systems (LTSs) (van Benthem, 1991) . 3 An LTS consists of a triple, S, Act, \u2192 , where: S is the set of states; Act is a set of actions; and \u2192 is a total transition relation: \u2192\u2286 S \u00d7 Act \u00d7 S. An action, \u03b1 \u2208 Act, provides the labeling on an arrow, making it explicit what brings about a state-to-state transition. As a shorthand for (e 1 , \u03b1, e 2 ) \u2208\u2192, we will also use e 1 \u03b1 \u2212\u2192 e 2 . Simulation generation begins by parsing a natural English sentence, currently using the ClearNLP parser (Choi and McCallum, 2013) . 4 The dependency parse is then transformed into a predicate-argument set representation using the root of the parse as the main predicate and its dependencies as arguments. Each predicate can have more than one argument and arguments may themselves be predicates (thus higher-order predicates are permissible). This predicate-argument set formula is then evaluated from the innermost first order predicates outward until a single firstorder representation is reached.  The evaluation of predicates entails the composition of the voxemes involved. Since we allow for program voxemes (verbs), logical type voxemes (relations, attributes, functions) and object voxemes (nominals), evaluation involves executing a snippet of code that operationalizes a program voxeme using the geometric and VoxML-encoded semantic information from the voxeme(s) indicated by the input predicate's argument(s). In the example given above, the predicate on(plate) is evaluated to a specific location that satisfies the constraint denoted by \"on the plate\", using information about the plate object, specifically its dimensions and concavity. The program put can then be realized as a DITL program that moves the object apple toward that location until the apple's location and the location evaluated for on(plate) are equal, and executed as a simple state transition \u00ac\u03c6 e1 \u03b1 \u2212\u2192 \u03c6 e2 . Given a 3D scene that contains voxemes for all nominals referred to in the text, the program can be operationalized in code and the state transition can be executed over the geometries visualized in 3D space. We use an updated version of the the simulator built for (Pustejovsky and Krishnaswamy, 2014) and the C# language to generate visualizations like that shown in Figure 9 below. Conclusion In this paper we have outlined a specification to represent semantic knowledge of real-world objects represented as three-dimensional models. We use a combination of parameters that can be determined from the object's geometrical properties as well as lexical information from natural language, with methods of correlating the two where applicable. This information allows for the visualization and simulation software to fill in information missing from the natural language input and allows the software to render a   As our library of available voxemes continues to grow the specification elements may as well, allowing us to operationalize a larger library of various and more complicated programs, and to compose complex behaviors out of simpler ones. The voxeme library and visualization software will be deployed at http://www.voxicon.net. There users may find the current library of voxemes and conduct visualizations of available behaviors driven by VoxML after parsing and interpretation. Acknowledgements",
    "funding": {
        "military": 1.9361263126072004e-07,
        "corporate": 0.0,
        "research agency": 5.080950091884695e-06,
        "foundation": 6.6305886174955475e-06,
        "none": 0.999953079650794
    }
}