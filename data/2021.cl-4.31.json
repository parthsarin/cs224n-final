{
    "article": "The universal generation problem for LFG grammars is the problem of determining whether a given grammar derives any terminal string with a given f-structure. It is known that this problem is decidable for acyclic f-structures. In this brief note, we show that for those f-structures the problem is nonetheless intractable. This holds even for grammars that are off-line parsable. The universal generation problem for LFG grammars (Kaplan and Bresnan 1982) is the problem of determining for an arbitrary grammar G and an arbitrary f-structure F whether G derives any terminal string with F. This has been shown to be undecidable even for grammars that are off-line parsable (Wedekind 2014). If F is acyclic, however, Wedekind and Kaplan (2012) have shown that the problem is decidable. They prove that the set of strings that an LFG grammar relates to an acyclic f-structure can be described by a context-free grammar. Decidability of the problem then follows because the emptiness problem is decidable for context-free languages. To date, however, the complexity status of this problem has been unknown. In this brief note, we show the intractability of LFG's generation problem from acyclic f-structures by polynomial-time reduction from the 3-SAT problem, a problem that is known to be NP-complete. The 3-SAT problem is the problem of determining the satisfiability of a Boolean formula in conjunctive normal form where each of the conjoined clauses is a disjunction of three literals. That is, each formula is a conjunction of the form C 1 \u2227 .. \u2227 C m , each clause C j is a disjunction of the form l j 1 \u2228 l j 2 \u2228 l j 3 , and each literal l j k , k = 1, .., 3, is a propositional variable p i or a negated variable \u00acp i . Without loss of generality, we assume in the following that every literal occurs only once in a clause and a clause does not contain both, a variable and its complement. To state the generation problem more formally, recall that an LFG grammar G defines a binary derivation relation \u2206 G between terminal strings and f-structures, as given in (1). (1) \u2206 G (s, F) if and only if G derives terminal string s with f-structure F The generation problem from acyclic f-structures is then the problem of determining for an arbitrary LFG G and an arbitrary acyclic f-structure F whether {s | \u2206 G (s, F)} is empty or not. Reductions to Problem-specific Grammars For any instance \u03c8 = C 1 \u2227 .. \u2227 C m of the 3-SAT problem over variables p 1 , .., p n , we construct an LFG grammar G \u03c8 and an acyclic f-structure F \u03c8 such that there is a string s and (s, F \u03c8 ) \u2208 \u2206 G \u03c8 if and only if \u03c8 is satisfiable. The grammar G \u03c8 includes the start rule (2) S \u2192 P 1 \u2022\u2022 P n \u2191 = \u2193 \u2191 = \u2193 and for each propositional variable p i two terminal rules of the form (3a,b). (3) a. P i \u2192 $ p i occurs in C j j=1,..,m (\u2191 C j ) = TRUE b. P i \u2192 $ \u00acp i occurs in C j j=1,..,m (\u2191 C j ) = TRUE (The conjunction symbol is usually omitted.) In this construction, the rules in (3) record for each variable p i the clauses C j that are true if p i is true (by the annotations (\u2191 C j ) = TRUE in (3a)) and the clauses that are true if \u00acp i is true (3b). Thus, there must be a truth assignment for the variables that makes all clauses C j of C 1 \u2227 .. \u2227 C m = \u03c8 true if and only if G \u03c8 derives terminal string $ n with the f-structure (4) \uf8ee \uf8ef \uf8f0 C 1 TRUE . . . C m TRUE \uf8f9 \uf8fa \uf8fb in which for all clauses C j the C j attributes have value TRUE. Hence, \u03c8 is satisfiable if and only if G \u03c8 derives a terminal string with the f-structure F \u03c8 in (4). G \u03c8 has 2n + 1 rules, a single start rule (2) of length n with n annotations and two rules (3) of constant length for each of the n propositional variables with a total of 3m annotations. The input structure F \u03c8 has size m (measured in the number of attributevalue pairs). The rules and the input can be constructed just by scanning \u03c8, which is of length 3m, from left to right. However, in each step, the list of rules already built is scanned to check whether a new annotation has to be added to an existing P i rule or a new P i rule has to be created. During the same scan a new daughter is added to the start rule if needed. Thus, the total time needed to construct the grammar rules and the input is at most of order m \u2022 n, a polynomial in the size of the original 3-SAT problem. S P 1 \u2191 = \u2193 $ (\u2191 C 2 ) = TRUE (\u2191 C 3 ) = TRUE P 2 \u2191 = \u2193 $ (\u2191 C 1 ) = TRUE (\u2191 C 3 ) = TRUE P 3 \u2191 = \u2193 $ (\u2191 C 1 ) = TRUE (\u2191 C 2 ) = TRUE Figure 1 One of 5 annotated c-structure derivations that the LFG grammar with the rules in (6) provides for the input f-structure (7). This derivation corresponds to the truth-value assignment on which p 1 is false and p 2 and p 3 are true. By construction, there are 2 n annotated c-structure derivations in G \u03c8 , for any 3-SAT instance \u03c8 over n propositional variables, and all those derivations derive the string $ n . Thus, in the worst case, 2 n annotated c-structure derivations may have to be examined to determine whether (s, F \u03c8 ) \u2208 \u2206 G \u03c8 , for any string s. 1 As a simple illustration consider the satisfiable formula in (5). ( ) \u03c8 = C 1 \u2227 C 2 \u2227 C 3 = (p 1 \u2228 p 2 \u2228 p 3 ) \u2227 (\u00acp 1 \u2228 \u00acp 2 \u2228 p 3 ) \u2227 (\u00acp 1 \u2228 p 2 \u2228 \u00acp 3 ) 5 For this formula the construction results in the rules in (6) and the input structure (7). The P rules in the left column reflect the positive literals and the ones in the right the negative ones. (6) S \u2192 P 1 P 2 P 3 \u2191 = \u2193 \u2191 = \u2193 \u2191 = \u2193 P 1 \u2192 $ (\u2191 C 1 ) = TRUE P 1 \u2192 $ (\u2191 C 2 ) = TRUE (\u2191 C 3 ) = TRUE P 2 \u2192 $ (\u2191 C 1 ) = TRUE (\u2191 C 3 ) = TRUE P 2 \u2192 $ (\u2191 C 2 ) = TRUE P 3 \u2192 $ (\u2191 C 1 ) = TRUE (\u2191 C 2 ) = TRUE P 3 \u2192 $ (\u2191 C 3 ) = TRUE (7) \uf8ee \uf8f0 C 1 TRUE C 2 TRUE C 3 TRUE \uf8f9 \uf8fb There are 8 annotated c-structure derivations that this grammar provides for the terminal string $$$, but only 5 of them are assigned the f-structure (7). One of those derivations is depicted in Figure 1 . In order to guarantee decidability of the recognition problem, Kaplan and Bresnan (1982) introduced a constraint, later called the Off-line Parsability Constraint, that proscribes empty productions and nonbranching dominance chains and thus bounds the number and size of the c-structures of a string by a function of the length of that string. Because the grammars G \u03c8 do not contain empty productions and do not produce nonbranching dominance chains, the acyclic generation problem is intractable even for off-line parsable LFGs. Note also that a transposition of this reduction can be used to show the intractability of the recognition problem for off-line parsable LFGs. This transposition is intrinsically simpler than Berwick's original reduction (Berwick 1982) . The grammar G \u03c8 includes the start rule (8) S \u2192 C 1 \u2022\u2022 C m \u2191 = \u2193 \u2191 = \u2193 and for each literal l j k of l j 1 \u2228 l j 2 \u2228 l j 3 = C j a terminal rule of the form (9). (9) C j \u2192 $ (\u2191 P i ) = TRUE if l j k = p i FALSE if l j k = \u00acp i Here, the rules in ( 9 ) encode truth-value assignments for the variables that could separately satisfy each clause and the annotations of ( 8 ) ensure that the assignments are consistent. By construction, there are 3 m annotated c-structure derivations for a string of length m that may have to be inspected to determine whether there is an f-structure F with ($ m , F) \u2208 \u2206 G \u03c8 . G \u03c8 has 3m + 1 rules: One rule of constant size for each literal in each disjunctive clause C j (i.e., in total 3m rules) and a single start rule of length m with m annotations. Because the rules for the literals of each clause are independent of the rules for the literals in other clauses, rescanning of already constructed rules is not required. Thus, the total time needed to construct the grammar rules is at most of order m. We have demonstrated that LFG's acyclic generation and recognition problems can be reduced from the 3-SAT problem in polynomial time. Because the satisfiability of the f-description of a given annotated c-structure can be tested quickly, LFG's recognition problem is in NP and hence NP-complete. For the acyclic generation problem, however, it is not yet clear whether it belongs to NP, because the problem of deciding whether the input f-structure and the f-structure assigned to a given derivation are structurally identical is an instance of the isomorphism problem for labeled directed acyclic graphs. Because it is not yet known whether that problem can be solved in polynomial time (Basin 1994) , with current knowledge we can only establish that the acyclic generation problem is NP-hard. In these reductions, the size parameters n and m of the 3-SAT problem instances are reflected in certain size parameters of the corresponding LFG grammars, namely, the length of the rules and the number of attributes. These technical demonstrations reveal the expressive power of the basic LFG formalism, but they do not immediately carry over to the way that the formalism is deployed in linguistic practice. Grammars of natural language are not revised and specialized for every input that is presented for recognition or generation. Rather, they describe particular natural languages with a fixed number of rules and attributes that are intended to operate correctly on inputs of arbitrary size. We can make our analysis more directly relevant by providing a grammatical framework with a fixed set of rules and attributes that can reduce 3-SAT problems of any size. In this framework the particular problem to be solved is not encoded in the grammar but is presented as the input, either as a string or an f-structure. Reductions to Generic Grammars We first describe the generic reduction for the recognition problem. We encode the specific literals p i , \u00acp i as sequences of i $ terminals followed by + or \u2212 ($ i +, $ i \u2212). The literal \u00acp 3 is thus represented as the string $ $ $\u2212. A clause is represented as the concatenation of the representations of its 3 literals and a whole problem as the concatenation of the representations of its clauses. Hence, the 3-SAT formula ( 5 ) is represented as the terminal string $ + $ $ + $ $ $ + $ \u2212 $ $ -$ $ $ + $ \u2212 $ $ + $ $ $ \u2212. The LFG grammar consists of the 8 rules in (10). The S rules generalize the start rule in (8) to an unlimited number of clauses. As now string encodings of satisfiable 3-SAT instances are to be recognized, the C rules expand to three L daughters for deriving representations of the three literals and they guess, similar to (9) but now through trivial annotations, the true literal in each clause. The L rules derive the string representations of the literals $ i + or $ i \u2212 and assign to them attribute-chain encodings of the form P i VAL TRUE or P i VAL FALSE. (10) S \u2192 C S \u2191 = \u2193 \u2191 = \u2193 S \u2192 C \u2191 = \u2193 C \u2192 L L L \u2191 = \u2193 C \u2192 L L L \u2191 = \u2193 C \u2192 L L L \u2191 = \u2193 L \u2192 $ L (\u2191 P) = \u2193 L \u2192 + (\u2191 VAL) = TRUE L \u2192 \u2212 (\u2191 VAL) = FALSE In this construction, the trivial annotations ensure the consistency of the truth assignments guessed in the C rules because there will be a clash if two chain-encodings of the same variable bottom out in different VAL assignments. Thus a 3-SAT problem instance is satisfiable if and only if its terminal-string representation belongs to the language of the LFG. The terminal-string representation of a 3-SAT instance \u03c8 with m clauses can be constructed by scanning \u03c8 from left to right. Thus the total time needed to construct the input string is at most of order m. The generic reduction for the acyclic generation problem is more involved. For convenience, we use the traditional parenthetic notation for optional annotated categories and optional annotations and {..|..} for disjunction. We define a generic grammar G and construct for any 3-SAT problem instance \u03c8 an f-structure F \u03c8 such that G derives a terminal string with F \u03c8 if and only if \u03c8 is satisfiable. F \u03c8 contains an encoding of \u03c8 and a solution structure, and the units of both structures are linked by edges labeled with the attribute S. We represent the problem with attribute-chain encodings for the literals and also for the clauses: p i is represented by P i POS, \u00acp i by P i NEG, and C j by C j . Then, a 3-SAT problem with n variables and m clauses is encoded in the input f-structure through chains that match the regular expression P i {POS|NEG} C j OCC +, with i \u2264 n, j \u2264 m, where P i POS C j OCC + records that p i occurs in C j and P i NEG C j OCC + records that \u00acp i occurs in C j . For our 3-SAT example (5), the problem encoding is schematically illustrated in the black substructure of the input f-structure depicted in Figure 2 . The solution structure corresponds to an attribute-chain conversion of the input structure (4) of the problem-specific reduction, that is, it is represented through attribute-value chains C j VAL TRUE, j = 1, .., m. The S edges link the encoding of every literal to the root of the solution structure and the encoding of every clause to its encoding in the solution structure. For our 3-SAT example (5), these components of the input f-structure are depicted in green (solution structure) and red (S edges). The rules in (11) derive the chain encodings for an arbitrary number of literals. (11) S \u2192 P (\u2191 P) = \u2193 (\u2191 S) = (\u2193 S) P \u2192 P C TRUE C C C TRUE (\u2191 P) = \u2193 (\u2191 POS) = \u2193 (\u2191 NEG) = \u2193 (\u2191 POS) = \u2193 (\u2191 NEG) = \u2193 (\u2191 S) = (\u2193 S) (\u2191 S) = (\u2193 S) (\u2191 S) = (\u2193 S) (\u2191 S) = (\u2193 S)(\u2191 S) = (\u2193 S) The S reentrancies link all encodings to the same solution structure. The disjunction guesses either the positive or the negative literal to be true and this nondeterministic guess is marked at the end of the derivation of the literals for a variable by the TRUE tag. The C productions in (12) allow it to encode through the optional OCC + annotations for each literal all possible occurrences in an arbitrary number of clauses, and the S reentrancies link every derived clause representation to the representation of that clause in the solution structure. For the encoding of the simple unsatisfiable 3-SAT problem (p 1 \u2228 p 1 \u2228 p 1 ) \u2227 (\u00acp 1 \u2228 \u00acp 1 \u2228 \u00acp 1 ), the TRUE guess for the POSitive literal of the P rule results in the f-structure on the left side and the alternative TRUE guess for the NEGative in the one on the right side (if the option OCC + of the L rules is exactly selected for those clauses in which the literal occurs). Because both structures are missing the VAL TRUE information at one clause representation, the problem is unsatisfiable. (12 ) C TRUE \u2192 \uf8eb \uf8ec \uf8ec \uf8ec \uf8ed C TRUE (\u2191 C) = \u2193 (\u2191 S C) = (\u2193 S) (\u2193 OCC) = + (\u2193 S VAL) = TRUE \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f8 $ C \u2192 \uf8eb \uf8ec \uf8ed C (\u2191 C) = \u2193 (\u2191 S C) = (\u2193 S) ((\u2193 OCC) = +) \uf8f6 \uf8f7 \uf8f8 $ The given rules can certainly derive for any 3-SAT problem \u03c8 a string with an fstructure that contains the encoding of \u03c8. To see that the rules derive the problem encoding together with the solution structure only if \u03c8 is satisfiable, let us consider the derivations that yield the problem encoding for a particular 3-SAT instance with n variables and m clauses. Because the disjunction of the P rules encodes the possible truth assignments to a variable, the recursive application of the P rule alternatives encodes in 2 n derivations all possible truth assignments for the n variables of the given problem. By construction only C TRUE but not C rules expand derivations for literals that are assigned true. Also, if a literal occurs in C j then only those rules add VAL TRUE to the encoding of C j in the solution structure, to indicate that the variable assignment that makes that literal true also makes C j true. Thus, if a clause representation in the solution structure is missing the VAL TRUE information, the truth assignment encoded in that derivation does not make that clause true. Hence, individual derivations match the input if and only if there is at least one variable assignment that satisfies every clause. A problem is unsatisfiable if no derivation matches the input. This can be made particularly clear by the trivial unsatisfiable 3-SAT problem instance (p 1 \u2228 p 1 \u2228 p 1 ) \u2227 (\u00acp 1 \u2228 \u00acp 1 \u2228 \u00acp 1 ), even though it does not comply with the simplifying assumptions that we made at the beginning. For the encoding of this problem, the LFG grammar provides the derivations depicted in Figure 3 . The generic LFG has 11 rules. The input f-structure, which has maximum depth n + m + 2, can be constructed by scanning \u03c8 (with length 3m) from left to right and by creating in each step an occurrence encoding of a literal in a clause. Because the input structure has to be scanned top-down in each step, the total time needed to construct the input is at most of order m 2 + mn. 2 Concluding Remarks This note has introduced new results concerning the complexity of LFG generation (and recognition) for grammars that assign acyclic f-structures to input strings. We observed that reductions to problem-specific grammars where the size parameters of the 3-SAT problem instances are reflected in grammar-size parameters are not particularly relevant to the linguistic enterprise. More relevant are the generic reductions where the LFG grammar is kept fixed across all possible 3-SAT problem instances. These show that computational complexity in the worst case can grow exponentially as a function of the size of the input f-structure or string, and that grammar or derivation restrictions of some sort must be imposed for tractability of LFG generation and recognition. Wedekind and Kaplan (2020) introduced a subclass of LFG grammars with particular restrictions that exclude our generic reduction grammars but ensure that at least the recognition problem is tractable for inputs of arbitrary length. Wedekind and Kaplan further argue that grammars that meet the conditions of this k-bounded subclass are still expressive enough for natural language description (see also Kaplan and Wedekind 2019) . However, it is at this point still an open question whether generation is polynomial for arbitrary grammars in this linguistically plausible subclass or whether polynomial generation can be established only for grammars within a yet more restricted proper subclass of the k-bounded class. Acknowledgments The authors would like to thank the three anonymous reviewers for their helpful suggestions and comments on earlier drafts of this squib.",
    "funding": {
        "defense": 0.0,
        "corporate": 0.0,
        "research agency": 0.0,
        "foundation": 0.0,
        "none": 0.9998760879877276
    },
    "reasoning": "Reasoning: The provided text does not mention any specific funding sources for the research conducted or the writing of the article. Without explicit mention of support from defense, corporate entities, research agencies, foundations, or an indication of no funding, it is not possible to accurately determine the funding sources based solely on the provided information.",
    "abstract": "The universal generation problem for LFG grammars is the problem of determining whether a given grammar derives any terminal string with a given f-structure. It is known that this problem is decidable for acyclic f-structures. In this brief note, we show that for those f-structures the problem is nonetheless intractable. This holds even for grammars that are off-line parsable. The universal generation problem for LFG grammars (Kaplan and Bresnan 1982) is the problem of determining for an arbitrary grammar G and an arbitrary f-structure F whether G derives any terminal string with F. This has been shown to be undecidable even for grammars that are off-line parsable (Wedekind 2014). If F is acyclic, however, Wedekind and Kaplan (2012) have shown that the problem is decidable. They prove that the set of strings that an LFG grammar relates to an acyclic f-structure can be described by a context-free grammar. Decidability of the problem then follows because the emptiness problem is decidable for context-free languages. To date, however, the complexity status of this problem has been unknown. In this brief note, we show the intractability of LFG's generation problem from acyclic f-structures by polynomial-time reduction from the 3-SAT problem, a problem that is known to be NP-complete. The 3-SAT problem is the problem of determining the satisfiability of a Boolean formula in conjunctive normal form where each of the conjoined clauses is a disjunction of three literals. That is, each formula is a conjunction of the form C 1 \u2227 .. \u2227 C m , each clause C j is a disjunction of the form l j 1 \u2228 l j 2 \u2228 l j 3 , and each literal l j k , k = 1, .., 3, is a propositional variable p i or a negated variable \u00acp i . Without loss of generality, we assume in the following that every literal occurs only once in a clause and a clause does not contain both, a variable and its complement.",
    "countries": [
        "Denmark",
        "United States"
    ],
    "languages": [
        ""
    ],
    "numcitedby": 1,
    "year": 2021,
    "month": "December",
    "title": "{LFG} Generation from Acyclic {F}-Structures is {NP}-Hard",
    "values": {
        "novelty": "This note has introduced new results concerning the complexity of LFG generation (and recognition) for grammars that assign acyclic f-structures to input strings. Wedekind and Kaplan (2020) introduced a subclass of LFG grammars with particular restrictions that exclude our generic reduction grammars but ensure that at least the recognition problem is tractable for inputs of arbitrary length. However, it is at this point still an open question whether generation is polynomial for arbitrary grammars in this linguistically plausible subclass or whether polynomial generation can be established only for grammars within a yet more restricted proper subclass of the k-bounded class."
    }
}