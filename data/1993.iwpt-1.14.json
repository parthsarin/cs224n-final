{
    "article": "Many applications make use of diagrams to represent complex objects. In such applications it is often necessary to recognise how some diagram has been pieced together from other diagrams. Examples are electrical circuit analysis, and program understanding in the plan calculus (Rich, 1981}. In these applications the recognition process can be formalised as flowgraph parsing, where a flowgraph is a special case of a plex (Feder 1971}. Nodes in a flowgraph are connected to each other via intermediate points known as tie-points. Lutz (1986, 1989} generalised chart parsing of context-free string languages (Thompson -Ritchie, 1984} to context-free flowgraph languages, enabling bottom-up and top-down recognition of flowgraphs. However, there are various features of the plan calculus that complicate this -in particular attributes, structure sharing, and relation ships between tie-points. This paper will present a chart parsing algorithm for analysing graphs with all these features, suitable for both program understanding and digital circuit analysis. For a fixed grammar, this algorithm runs in time polynomial in the number of tie-points in the input graph. Introduction and Motiva tion Many applications make use of diagrams to repre sent complex objects, and we often need to recog nise how some diagram has been constructed. Ex amples are electrical circuit analysis, and pro gram understanding in the plan calculus (Rich, 1981) , in which programs are represented by data and control-flow graphs, and stereotypical pro gramming techniques and algorithms (plans) are represented similarly. Understanding how a pro gram has been built up then amounts to treat ing plans as forming a grammar, and the under standing process as parsing. Ignoring control flow connections enables us to formalise this as flow graph parsing. Nodes in a flowgraph consist of labelled boxes with distinguished input and out put attaching points (ports), and input ports are connected to output ports via intermediate points known as tie-points, with the restriction that a port is only ever connected to a single tie-point, although fan-out and fan-in is allowed at .tie points. Lutz {1986, 1989) generalised chart pars ing of context-free string languages {Thompson -Ritchie, 1984) to context-free flowgraph lan guages, enabling bottom-up and top-down recog nition of flowgraphs. However, there are features of the plan calculus that complicate this: 1. Attributes -control flows in the plan cal culus are treated as attributes of the gram mar which are propagated during parsing. Data Plans and Overlays -Some plans in the plan calculus allow the introduction of new tie-points not in the input graph. These tie-points either represent aggregate data structures corresponding to collections of other tie-points, or represent a more ab stract view of some tie-point ( e.g. viewing a list as implementing a set), and act as inputs or outputs of \"higher-level\" opera tions. Dealing with this involves using a second chart storing information about data objects. Structure Sharing \ufffd when one component fe eds one or more of its \u2022 outputs to more than one other component (fan-out). In this situation the source component can be viewed as playing more than one role in the structure, and could have been dupli cated so that separate copies of the com ponent were responsible for each of these roles. This leads to no change in function ality, although there may be a loss in effi ciency as measured by the number of com ponents (digital circuits), or computational effort and code size (plan calculus). This paper will present a parsing algorithm for analysing graphs with these features, noting that we permit structure sharing, but do not enfo rce it. For a fixed grammar, this algorithm runs in time polynomial in the number of tie-points in the input graph. We will begin by discussing simple flowgraphs, and then progressively deal with the above features. Notation and Definitions Flowgraphs and flow grammars are special cases of plex languages and plex grammars (Feder, 1971) . A plex consists of labelled nodes having an arbitrary number, n, of distinct attaching points, used to join nodes together. Such a node is called an n-attaching point entity (NAPE). Attaching points of N APEs do not connect directly, but via intermediate points known as tie-points. A single tie-point may connect two or more attach ing points. If the direction of the connections is important then the plex is said to be directed. Many types of graph structure ( e.g. webs (Pfaltz -Rosenfeld, 1969; Rosenfeld -Milgram, 1972), directed graphs, and strings) are special cases of directed plexes. We will consider the special case of directed plexes in which each NAPE's attach ing points (from now on called ports) are subdi vided into two mutually exclusive groups, known as input ports ( restricted to only have incom ing connections) and output ports (restricted to only have outgoing connections). We further re strict ourselves to. the case in which each port of a NAPE is only cortnected to a single tie-point. This type of plex will be called a flowgraph and is a generalisation of Brotsky's (1984) use of the term. See Figure 1 (top) for a simple example. A production in a string _grammar specifies how one string may be replaced -Milgram, 1972) ), but most of it also applies to flowgraphs. Our approach is to specify with each production which tie-points on the left cor respond to which tie-points on the right and then connect everything connecting to one of these left hand tie-points (from the surrounding subgraph) to its corresponding right-hand tie-point. We define a flowgraph grammar to be a 4-tuple (N,T,P,S) where: N is a finite non-empty set of NAPEs known as nonterminals. T is a finite non-empty set of NAPEs known as terminals. P is a finite set of productions. S is a special member of N known as the ini tial, or start, NAPE where the intersection of N and T is empty. (NAPElabel, inputlist, outputlist) where NAP E-label is the label on the NAPE, and input list is a list in which the i th entry is the tie point to which the i th input port is connected. If we arbitrarily order the input and output ports of a NAPE then each NAPE in a flowgraph can be represented as a triple Similarly the output list specifies to which tie ) and the arity of the right side of the rule to be the or dered pair (IR i l, IR0 1). So this requirement simply states that the left-and right-side arities must be the same. The rewriting and embedding is done as follows: The instance of the left-side structure is re moved from W and replaced by an instance of the right-side structure. Now , for each tie-point X in L i any previous connections from N APEs in W to X are replaced by connections from the same attaching points of the same N APEs to the corresponding tie-point in R i . The same is done for tie-points in L 0 and R 0 \u2022 One can eliminate the need for explicit storing of Ri and R 0 by using the same variable names on the left and right hand sides of the production to denote corresponding tie-points. \u2022 Just as in the string case, by considering re strictions on X and Y in a production of the form: X ==>Y In a chart parser, assertions about what has been found by the parser are kept in a \"database\" known as the chart. Such assertions will be called patches, and are of two kindscomplete patches and partial patches. A complete patch asserts that a complete grammatical entity ( correspond ing to some terminal or non-terminal symbol of the grammar) has been found. Partial patches are assertions that part of some grammatical en tity has been found , and about what needs to be found to complete it. One can think of a patch as being a closed loop drawn round some sub graph of the flowgraph, indicating that this sub graph corresponds to all or part \u2022 of some gram matical entity. Regarding the right-side struc tures of rules as uninstantiated templates, \u2022 then complete patches with non-terminal labels corre spond to the occurrence of an instantiation of the right-side structure of some rule, thus forming an occurrence of the left-side structure of the rule. Partial patches correspond to partially instanti ated instances of the right-side structure of some rule, and thus to partially recognised instances of the left-side structure. Each patch A contains the following information : l. label{ A) -the name ( one of the terminal or non-terminal symbols) of the grammatical entity corresponding to the patch. For a partial patch, the input and output tie points (i.e. those by which the patch connects to the surrounding flowgraph) are each subdivided into two categories -the set of active tie-points where the patch still needs other components to attach to these tie-points, and the set of inac tive tie-points which are those which would be in puts or outputs of the patch were it complete. A NAPE needed by a partial patch will be called im mediately needed if any of its tie-points are active. The components entry of a patch lists (instanti ated versions of) those NAPEs in the right-side structure of the rule which have been completely instantiated, and the needed entry lists uninstan tiated (as yet) parts of the rule. Note that some of the tie-points in the needed entry may be in stantiated. These are where the needed NAPEs connect to the ones already found. We will say that a partial patch A is extendible by a com plete patch B ( or that B can extend A) in the case where A immediately needs a patch of the same type as B and the instantiated tie-points in this needed patch do not conflict with any instan tiations actually occurring in B. The essence of the chart parsing strategy can then be stated as follows: Every time a corn plete patch is added to the chart a search is made for any partial patches im mediately needing a patch like the one just added. For each of these partial patches a new patch is made extending it by the complete one, and this new patch is then added to an agenda of patches to be processed at some appropriate time. Sim ilarly, every time a partial patch is added to the chart a search is made for complete patches which can extend the partial patch just added, and if any are found new patches are made extending the partial one, and these are added to the agenda to be processed when appropriate. Note that patches are only ever added to the chart. They are never removed, thus avoiding duplication of previous effort. The basic operation of the algorithm is joining a complete patch to a partial patch to make a new enlarged patch. Figure 2 shows a partial patch being joined to a corn plete patch to make a new patch (the enclosing box). The resulting patch has the same items in its components entry as the original partial patch plus the complete patch. Its needed entry is equal to that of the original partial patch minus the needed patch corresponding to the complete patch. Note that the matching of a needed patch to an actual complete patch may in troduce further instantiations of tie-points in the needed entry of the new patch. On connecting the two patches all the inactive tie-points of the partial patch remain inactive. Some of its active tie-points will correspond to tie-points of the com plete patch ( this is where the two patches actually join). Other active tie-points remain active in the new patch since it is still looking for other patches to attach to them. Of the complete-patch's (input and output) tie-points some have : already been mentioned Le. those connecting directly to the partial patch. Others will become new inactive tie-points of the resulting patch since it will not be looking for anything to attach to them. How ever other (input and output) tie-points of the complete patch may now become active (viewed as belonging to the new patch) since it may now expect other patches to attach to them in order to complete itself. Provided all these distinctions are kept clear there is no great difficulty in imple menting the joining operation. With this joining operation a limited type of structure sharing happens automatically. This is illustrated in Figure 3. If we wish to prevent this, then, when trying to extend a partial patch P by a complete patch C, the parser must check (recur sively!) that none of the components of P have any sub-components in common with C, thus pre venting structure sharing at any level. This check will be referred to as the no-sharing check. The initialisation of the agenda will now be de scribed. Initially a complete patch is added to the agenda for each of the terminal N APEs in the original graph. If the algorithm is to run top down then an additional step is needed in which partial patches with empty components entries .149 are made for every rule in the grammar whose left-side structure is labelled by the start sym bol of the grammar. Each such rule\u2022 leads to several such empty patches, one for each per mutation of the input tie-points of the input graph. The inactive-inputs and active-outputs entries for these patches are the permuted in puts. The needed entry is the right-side structure of the rule with appropriate instantiations of the tie points occurring in it. These patches are also added to the agenda. The complete algorithm is shown below: { = . AN -1 if patch is already present in the chart AN + l \ufffd AN -1 + AQT K+ M -l + QR if patch partial and not in chart _ \u2022 \ufffd AN \ufffd l + (K + M) \u2022 R2QT K+ M+ A -l if How can we organise the chart for efficient searching? The chart is divided into two parts, one for complete patches, and one for partial. The part for complete patches is organised as two ar rays, one for indexing each patch by its inputs, and one for indexing by its outputs. So each com plete patch is entered several times into the chart, once for each of its inputs and outputs. For fur ther efficiency each of the elements in these ar rays is a hash table and the patches are actu ally entered into these hashed by their label. So the entries in the hash table are actually lists of patches with the same label which share a given input or output tie-point. This enables efficient retrieval of all patches with a particular label at a particular tie-point. The treatment of partial patches is slightly more complicated. For each of their immediately needed N APEs partial patches are entered into their part of the chart indexed by the active inputs and outputs of the needed NAPE, and hashed by the labels of each of these N APEs. This structure for the chart enables a complete patch to easily find partial patches im mediately needing it, and enables partial patches to easily find complete patches that they imme diately need. A similar technique can be used to store the grammar rules in order to enable efficient retrieval of appropriate rules. Complexity Analysis A Polynomial Bound In this section a relatively informal argument will be given to show that, for a fixed grammar, the al gorithm runs in time polynomial in the number of tie-points T of the input graph (if the grammar is allowed to vary and is therefore regarded as part of the input to the parsing problem, then Wills (1992) has shown that the problem becomes NP complete). We will not give a tight upper bound on the running time, but simply show that it is polynomial. Let: G =number of NAPEs in the graph T =number of tie-points in the graph K =maximum number of inputs to a NAPE M =maximum number of outputs from a NAPE L =number of possible labels R =number of rules in the grammar Q =maximum number of NAPEs in the right side structure of a rule A =maximum possible number of active tiepoints in a partial patch. Note that K, M, L, R, Q, and A all depend on the grammar, and are independent of the input graph. A < ANl +A \u2022 Q \u2022 T K+ M -l if patch partial and not in chart { = ANl if patch chosen is already present in the chart N + l < AN -l + (K + M) . PN if patch chosen is complete and not in the chart Figure 15 : The bottom-up case, the N + 1 th iteration For the purposes of adding new patches to the chart, patches are only distinguished according to some of the information contained in them, rather than strict equality being necessary. Complete and partial patches will be dealt with separately. Complete patches are distinguished which dif fer in at least one of their input tie-points, their output tie-points, or their label. The maximum number of inputs and outputs in a patch is de termined by the grammar, as is the number of possible labels. So the number of possible com plete patches in the chart is bounded above by the product of L and the number of possible ways of selecting at most K out of T tie-points, and the number of possible ways of choosing at most M out of T tie-points. This gives us O(L \u2022 T K+ M ) complete patches altogether. A similar argument shows that at a given set of K (input) tie-points, there are at most O(T M ) complete patches with a given label. Partial patches are distinguished which differ in at least one of their inactive input tie-points, their inactive output tie-points, their label, or in what they need in order to complete themselves (their needed entry). Now, a partial patch repre sents the partially recognised right side structure of a rule. The rule used determines the label, and there are at most 2Q subsets of the ( at most) Q NAPEs in the rule that could still be needed. Each such subset determines a set of ( at most) A active tie-points for the patch. So there can be at most O(R \u2022 2Q \u2022T A \u2022 T K \u2022T M ) = O(R \u2022 2Q \u2022 T A+ K+ M ) partial patches altogether. In fact there will be very much less than this, as this includes com plete patches with nothing needed, and (more im portantly) ignores completely any additional con straint\ufffd implied by the connectivity of the graph. Since the basic operation of the chart pars ing algorithm involves extending partial patches by complete ones, we need to know, for a given partial patch, the largest number of complete patches that could possibly extend it. A par tial patch can be extended at any of its ( at most) A active tie-points, and any complete patch which could extend it must join at least one of these tie-points, and must share a label with at least one of the NAPEs immediately required by the partial patch. So there are at most O(A . Q . T K+ Ml) such complete patches. Sim ilarly, given a complete patch, there are at most O((K +M) \u2022 R \u2022 2Q \u2022 T K+ M+ A -l) possible match ing partial patches. We can use these upper bounds to demon strate that the algorithm terminates, and does so in polynomial time. Let N denote the number of iterations of the main loop of the algorithm while it is running, and let: So, in both the bottom-up and top-down cases, C N and P N are monotonic functions of N. As dis cussed earlier both are bounded above. There fore after some number of iterations they must both have reached their maximum value (nor mally much less than the crude estimates above). Once this happens all patches on the agenda must be already present in the chart and AN de creases by one on each subsequent iteration until it reaches O (an empty agenda), and the algorithm terminates. Now on each iteration it can be seen that either: CN 1. both C N and P N remain constant (in which case AN decreases), or 2. P N increases by 1, and items are possibly added to the agenda, or 3. CN increases by 1, and items are possibly added to the agenda. From the above, at most O(L \u2022 T K + M ) itera tions involve adding a complete patch to the chart and add some items to the agenda, and at most O(R . 2 Q \u2022 r A + K + M ) iterations involve adding a partial patch to the chart and add some items to the agenda. All other iterations simply remove items from the agenda. So how many items get added to the agenda? This is given by: (no. of items in initial agenda) +(no. added for complete patches) +(no. added for partial patches) In the top down case this bounded by A0 + O(L \u2022 T K + M ) \u2022 O((K +M) \u2022 R \u2022 LUTZ 2 Q . r K + M + A -1 ) + O(R . 2 Q . r A + K + M) . (O(A . Q . r K + M -1 )) + Q . R and in the bottom-up case this is bounded by A0 + O(L \u2022 T K + M) \u2022 (O((K +M) \u2022 R \u2022 2 Q . r K + M + A-1 ) + Q . R) + O(R \u2022 2 Q . r A + K + M) . O(A . Q . r K + M -1 ) which are both clearly polynomial. So, in both cases the number of items added to the agenda, which is the same as the number of iterations performed, is polynomially bounded. How much work is done on each of these itera tions? The cost of seeing if a patch is already in the chart can be done in polynomial time. This is because ( even with no clever indexing) there are at most a polynomial number of patches \u2022 in the chart that need to be checked. If the no-shar ing check is included then the cost of checking if one patch is extendible by another can be done in time at worst O(G) since both the partial and complete patches are each ultimately made up of at most G NAPEs (at lowest level), and check ing for inter\ufffdection of these two sets can be done in linear time. If the no-sharing check is omitted then the cost of checking if one patch is extendible by another can be done in constant time (since it depends on checking that the instantiated tie points of the patches are compatible with each other, and the number of tie-points involved de pends on the grammar), as can the cost of making a new patch. All the costs involved in checking rules etc. are purely a function of the grammar. So the total cost of the algorithm is easily seen to have an upper bound which is a polynomial function of T. 2 Finding All Parses Athough the algorithm performs flowgraph recog nition in polynomial time, it does not find all parses in polynomial time. This is because for some flowgraphs and some grammars there may well be an exponential number of parses ( this is even true of Earley's algorithm operating on strings!). The algorithm will however find a parse if one exists. If an application requires all possi ble parses, then the algorithm can be modified to 1 R s is the number of rules for S (the start symbol); P a is the number of permutations of inputs of graph. store any complete patch which is equal to one already in the chart in terms of its inputs, out puts, and label, but not equal in terms of its com ponents, in an auxiliary data structure. At the end of the parsing there is then enough informa tion around in the chart and the auxiliary data structure to easily compute additional parses, by simply adding all the patches in the auxiliary structure to the agenda, and letting the pars ing continue with the test for equality of patches now being strict equality (i.e. all the components must be equal as well) rather than just the partial equality used earlier. Dealing With Attributes As stated earlier graphs and rules in the plan calculus also have a second type of connection between NAPEs -control flow arcs. These are handled as attributes of the graphs, where the attribute for a non-terminal NAPE is calculated from the attributes of its components. Details of this method of handling the control flows can be found in Wills (1986 Wills ( , 1990 Wills ( , 1992)) , and a general isation can be found in Lutz (1992) . For our pur poses we will assume that each NAPE in the orig inal graph is annotated with initial values for the attributes, and we will also assume that each rule has annotations describing how each attribute for the left-hand side of the rule is computed from the attributes of the NAPEs on its right-hand side. These annotations have the general form: where A ths represents an attribute of the left hand side of the rule, f Rule represents the rule specific computation, and A1 , ... , Ak represent the attributes of the NAPEs on the right. Computing the attributes is straightforward. Each patch is given an extra field for each of its attributes. When a complete patch ( correspond ing to some rule of the grammar) whose compo nents have attributes A1 , ... , Ak , is added to the chart, f Rule (Al, ... , Ak) is computed, and stored in the appropriate field for the attribute in the patch. The initial patches receive their attribute values from the original graph. Dealing With Tie-Point Relationships In order to capture implementation decisions, and data abstractions, the plan calculus contains what Rich (1981) calls data plans and data over lays. So far as the grammatical formalism is con cerned, these ' can be viewed as allowing rules to express named functional relationships that hold between tie-points. To handle these our gram matical formalism is extended to allow annota tions (following the keyword where) of the form: ti = F(t j i, ... , t jk ) Jar k 2:: 1 where ti represents either any of the tie-points occurring in the N APEs of the rule, or an ad ditional new tie-point, t j1 , \u2022\u2022\u2022 , t jk represent any of the tie-points occurring in the NAPEs of the rule or any new tie-points mentioned on the left of other relationships in the rule ( this must be non-recursive!), and F is the name of the func tional relationship involved. The set of these will be referred to as the tie-point relationships of the rule. We will only discuss the changes to deal with tie-point relationships for the parser running in bottom-up mode. Dealing with them in top-down mode is rather complicated and will not be de scribed further in this paper. Conside the rules bump+update and bump+update->push (Figures 4 and 5 ), which cause problems for the algorithm. Flowgraph grammar rules as described earlier have the same arities for their left-and right-hand sides, and this is true for bump+update. However, the left hand side of bump+update->push has arity (2,1), while the right hand side has arity (3, 2) . Further more, although the tie-point t3 occurs as input on both sides of the overlay, this is not true of t6 and any tie-point of the bump+update plan. It does not even correspond to the compound object ( the upper-segment) represented by t1 and t2. It corresponds to the upper-segment viewed as a list ( via a function upper-segment-> list) . To cope with these features the basic bottom-up chart parser presented earlier is modified as follows: 1. The rule format is modified to include the left-hand side inputs and outputs, since these may now be distinct from those on the right. Correspondingly, each patch now has two extra fieldsleft-hand-ins, and left-hand-outs, in addition to the two fields inputs and outputs ( corresponding to in puts and outputs of the right hand side of the rule). Complete patches are stored in the chart indexed by their left-hand-ins and left-hand-outs, rather than by their inputs and outputs as before. Partial patches are stored as before. A second chart is added. This chart (the tie-point chart) stores the functional rela tionships between tie-points discovered dur ing parsing. It contains entries with When a new patch is created, either by ex tending a partial patch, or by creating a new empty patch for some rule, any instan tiations for the tie-point variables occur ring in the patch If the match fails (because two dif fe rent known tie-points are being matched against each other) \u2022 then\u2022. the whole patch is invalid, and is rejected (i.e. is not added to the chart). 5. A patch is only considered complete if both its needed entry and its relations-needed en try are empty. If they are, then the patch is added to the chart as normal. If not , then the patch is considered partial, and is stored in the chart indexed as before, but also indexed by the relationship names and instantiated tie-points of any immediately needed (in the obvious generalised sense of the term) relationships in the relations needed entry. 6. When a relationship is added to the tie point chart, the (patch) chart is consulted to see if there are any partial patches wait ing for a tie-point relationship compatible with the one just added. If so, the patch is extended by the relationship, and added to the agenda. Figure 6 illustrates this for the above rules. Now consider rules like those in Figure 7 , which includes a rule (for A) with a \"straight-through\" arc, and a graph like that in Figure 8 . This can be recognised as forming an S, by the following sequence of events: 3. When the relationship 8=iterator(3, 4) is added to the tie-point chart, the main chart is ' consulted to see if there are any partial patches immediately needing a relationship As stated earlier we are also interested in the case where structure sharing is allowed. However, for reasons discussed in Lutz (1992), we do not want to allow any two NAPEs sharing the same inputs to be collapsed, but only NAPEs with appropri ate labels. To make this more precise we define a slightly more general notion: A re stricted structure sharing fiowgraph gram mar (RSSFG) is a 5-tuple (N, T, P, S, R) where N, T, P, S are the same as for ordinary context get a (full) structure sharing flowgraph grammar as defined in Lutz (1989) . Figure 9 illustrates several phenomena that can occur with RSSFGs, and which motivated the above definition. To see how the parsing algorithm can be mod ified to cope with RSSFGs it should first be noted that for any flowgraph G there is a smallest flow graph G m i n which is R-share-equivalent to G. Secondly, the right-side structure of any rule in an RSSFG can be replaced by any flowgraph R share-equivalent to it without altering the gen erative capacity of the grammar. We therefore define a canonical form for an RSSFG in which each rule of the form: A==> B has been replaced by the rule: A ==> Bmin So the first change to the algorithm is to put the grammar into canonical form. The second change is to the action of adding a complete patch to the chart. Previously the only check that was done was to see if the patch was already in the chart. Now the algorithm must additionally check if the label of the patch is in R and if there is an other patch in the chart with the same label and the same inputs. If so, the algorithm must col lapse the new patch and the one already present into a single patch, by identifying the output tie points of the two patches. Provided tie-points in the various triples making up the patches are represented as pointers to pointers to tie-points (rather than storing the tie-points directly in the triples) then simply changing the values of the second set of pointers will implement the identi fication universally throughout all patches in the chart. This can lead to \"chains\" of pointers which need to be fully dereferenced in order to actually access the tie-points themselves ( this is similar to the way variables are handled in many implemen tations of Prolog). After collapsing an additional step is needed since there may be patches in the chart indexed by the tiE\ufffd-point which has been effectively removed by the identification. These patches must now be stored in the chart indexed by their new output tie-points. If the informa tion that collapsing has been done is needed by an application the algorithm can make a note this fa ct either by annotating the tie-points involved or by an assertion held separately. Finally, the no-sharing check must be omitted. If the grammar also has attributes, then we need to specify how to compute the attribute A res of a NAPE resulting from collapsing two patches with attributes A 1 and A 2 \u2022 This specification takes the form (for each attribute): where ! co lla p se is a function which computes the value of the attribute for the new patch from the values for the two collapsed patches. Two NAPEs are only collapsed when an attempt is made to add a complete patch P2 (with attribute A2 ) to the chart, and there is already a patch Pi ( with attribute A 1 ) present in the chart with the same label and inputs. In this . case Pi is left in the chart (i.e. it is the output tie-points in P2 which are identified with those in Pi). Pi then has the value of its attribute set to f co ll a p se (A1 ,A2). If this new value for its attribute is different from its previous value, then any complete patches in the chart which have Pi as one of their compo nents must also have their attributes recalculated, and any of these patches whose attributes change must also have their attributes recalculated, and so on recursively. To facilitate this, each com plete patch P needs an extra field partof which holds a list of all corn plete patches of which P is a component. To maintain this field, whenever a complete patch P is added to the chart, P is added to the partof field of each of its compo nent patches. The initial patches ( corresponding to the original graph) all have this field initially set to empty. Applications The algorithm just described forms the basis of the program understanding process described in Lutz (1989b Lutz ( , 1991 Lutz ( , 1992)) . However, there are other domains, in particular digital circuit analy sis, in which a similar ability to parse flowgraphs is useful. Consider Figure 10 which shows a cir cuit for addition of 3-bit numbers. The grammar shown in Figure 11 is capable of generating this circuit. Adding a rule like that shown in Figure 12 enables the parser to recognise the circuit in Figure 10 as being equivalent to Figure 13 i.e. to recognise the circuit as adding two numbers, with the tie-point chart holding information about how the numbers have been \"implemented\" . Conclusions This paper has presented a polynomial time chart parsing algorithm for context-free flowgraph lan guages, capable of handling all the features of the plan calculus (Rich, 1981) , and which is also ap plicable to digital circuit analysis. Although there is a large literature on the gen erative abilities of various types of graph gram mar formalisms (see e.g. (Ehrig, 1979; Feder, 1971; Fu, 1974; Gonzalez -Thomason, 1978; Pfaltz -Rosenfeld, 1969; Rosenfeld -Milgram, 1972) ), there is relatively little on parsing strate gies, except for restricted classes of graph and web grammars (e.g. Della Vigna -Ghezzi (1978) ). In its top-down strictly left-to-right form chart pars ing of context-free string languages corresponds to Earley's algorithm (Earley, 1970) , which was generalised by Brotsky (1984) to parsing flow graphs of the kind described here, except that his algorithm could not cope with fan-out at tie points, or with tie-point relationships. However the approach taken here can also run bottom up, which is particularly useful in applications in which we want to recognise as much as possible even though full recognition may be impossible (because of errors in the graph, or because the grammar is necessarily incomplete). Wills (1986 Wills ( , 1990 ) modified Brotsky's algorithm to cope with fan-out, but her algorithm only runs in a pseudo bottom-up fashion by starting it running top down looking for every possible non-terminal at every possible place in the graph. More re cently, Wills (1992) developed an algorithm heav ily based on the chart parsing algorithm described here and in (Lutz, 1986 (Lutz, , 1989)) , which is also capa ble of dealing with attributes and tie-point rela tionships. However her algorithm and graph rep resentations make no mention of tie-points, but deal directly with the edges connecting N APEs. This makes it harder to deal elegantly with the tie-point relationships. More recently there have been several pa pers in the visual language literature which have adopted a chart parsing approach. In particu lar, Wittenburg et al. (1991) and Golin (1991) have both developed bottom up parsers for 2-dimensional languages, while O'Gorman (1992), Costagliola et al. (1991), and Wittenburg (1992) have developed top-down parsers. This work is all similar in spirit to that presented here, al though differences in representation, and appli cation, make it very different in detail. Indeed this seems to be a general problem with work on 2-dimensional languages -there is no known general method suitable for conveniently repre senting all the different classes of language, and this leads to algorithms for one domain being very different from those in another. Of course, some kind of definite clause encoding could be used for all of these, but this is not always natural, and does not always lend itself to the development of efficient algorithms. In this connection it should be noted that the flowgraph languages discussed in this paper can be encoded in the Datalog for-LUTZ malism (Abitoul -Vianu, 1988) for which it is known that parsing can be performed in polyno mial time. However, a special-purpose algorithm like the one presented can be particularly efficient and adaptable ( cf. the control of structure shar ing). A particular advantage of a chart parser is that it keeps a record of all partial patches. This is useful when we do not just wish to analyse how some graph has been generated, but also to make suggestions based on \"near-miss\" informa tion about how to correct the graph. As such this algorithm is being used as the basis of \u2022 an intelligent debugging system for Pascal programs (Lutz, 1992) . The algorithms described in this paper have been implemented in Pop-11, running under the POPLOG \u2122 system. free flowgraph grammars, and R \ufffd N U T. R is the set of NAPEs for which collapsing is allowed. Such a grammar has an additional rewriting rule which will be described below. We define a re lation In other words, G2 R-collapses Gl iff G 1 contains two instances of some NAPE A (whose label is in R) which have the same inputs, and G2 is iden tical to G 1 except that the two in stances of A have been replaced by a single instance of A ( with the same inputs) and all NAPES which origi nally connected to the outputs of one or other of the two instances of A now connect to the single instance (in G2). This amounts to identifying the two instances of A and their correspond ing tie-points. The reflexive, transitive, symmetric closure of R-collapses is then an equivalence relation (R share-equivalence) on the set of flowgraphs, and we want any parsing algorithm which can recog nise some graph G to also be able to recognise any flowgraphs R-share-equivalent to G. We also want the grammar to be able to generate not only the flowgraphs derivable directly from the gram mar, but also all R-share-equivalent flowgraphs. This can be done if we allow at any point in the generation of a flowgraph the replacement of the graph so far generated (Gl) by any graph G2 for which either Ehrig, H. (1979) \"Introduction to the Algebraic Theory of Graph Grammars (A Survey)\". In: Claus, V. & H. Ehrig & G. Rozenberg, (Eds):",
    "abstract": "Many applications make use of diagrams to represent complex objects. In such applications it is often necessary to recognise how some diagram has been pieced together from other diagrams. Examples are electrical circuit analysis, and program understanding in the plan calculus (Rich, 1981}. In these applications the recognition process can be formalised as flowgraph parsing, where a flowgraph is a special case of a plex (Feder 1971}. Nodes in a flowgraph are connected to each other via intermediate points known as tie-points. Lutz (1986, 1989} generalised chart parsing of context-free string languages (Thompson -Ritchie, 1984} to context-free flowgraph languages, enabling bottom-up and top-down recognition of flowgraphs. However, there are various features of the plan calculus that complicate this -in particular attributes, structure sharing, and relation ships between tie-points. This paper will present a chart parsing algorithm for analysing graphs with all these features, suitable for both program understanding and digital circuit analysis. For a fixed grammar, this algorithm runs in time polynomial in the number of tie-points in the input graph.",
    "countries": [
        "United Kingdom"
    ],
    "languages": [
        "Thompson"
    ],
    "numcitedby": "2",
    "year": "1993",
    "month": "August 10-13",
    "title": "Chart Parsing of Attributed Structure-Sharing Flowgraphs with Tie-Point Relationships"
}