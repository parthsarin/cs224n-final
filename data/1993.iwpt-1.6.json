{
    "article": "In pictorial LR parsing it is always difficult to establish from which point of a picture the parsing process has to start. This paper introduces an algorithm that allows any element of the input to be considered as the starting one and, at the same time, assures that the parsing process is not compromised. The algorithm is first described on string grammars seen as a subclass of pictorial grammars and then adapted to the two-dimensional case. The extensions to generalized LR parsing and pictorial generalized LR parsing are immediate. Introduction This paper introduces an LR algorithm for the parsing of input whose starting point is not de fined. The main motivation behind this comes from the area of the two-dimensional LR parsing. Given a two-dimensional pattern it is not always obvious how to determine the starting point from which the parsing process should begin. The pro posed algorithm avoids this problem allowing any element of the pattern to be considered as the starting one and, at the same time, it assures that the parsing process is not compromised. The main idea is to create two su bstring LR parsers, one for the given language and the other for the \"reverse\" version of the language. The two parsers proceed in parallel, scanning the input in opposite directions, from the designated starting element. Neither of the two is allowed to reduce beyond their parser stack. When this is required, a rendezvous with the other parser must occur and both must perform the same reduction. The two parser stacks can be considered as an only graph stack expanding to the right and to the left of a starting point. This paper describes the algorithm on string grarrimars and then shows an extension to the case of positional (two-dimensional) grammars. The algorithm can be easily extended to treat lan guages whose LR parsing tables present conflicts. In fact, the use of the graph stack is the same as the one adopted in To mita's generalized parser. Section 2 contains comments on the work re lated to this paper; in Section 3, the preliminary definitions of reverse grammar and of joint graph are given; Section 4 presents the data structures and the description of the algorithm; in Section 5 the algorithm is adapted to the two-dimensional LR parsing after the description of the positional grammars and positional parsing tables. Section 5 contains the Conclusions. Related work This section contains two parts: one relates to the pictorial parsing that is the main motivation behind this paper and the other relates to island driven parsing, since the algorithm presented in this paper can be considered as a bidirectional LR parser. .1 Pictorial parsing With the introduction of more and more powerful graphical interfaces, the interest in the study of pictorial parsing is increasing. At the moment, many parsers have been designed, each of them having advantages and disadvantages with rispect to one another. A recently proposed classification, (Witten burg, 1992) , considers two major classes: bottom up order-free pictorial parsers (Crimi et al., 1991; Golin, 1991; Helm, 1991; Wittenburg, 1991) and predictive pictorial parsers ( Costagliola -Chang, 1991; Wittenburg, 1991) . The main advantage of an order-free parser over a predictive one is that it can compose the input objects in any order and it is not bound to a mandatory pre-ordered navigation of the input. This gives great expressive power to the underly ing grammar formalisms. The input data structure for an order-free parser is made by two sets: a set of objects and the set of all the relations among them. The relations must be the same used in the parser. The parser then proceeds with a purely bottom up enumeration. The predictive pictorial parsers direct the or der in which the objects in the input space are processed by the parser. This limits the expres sive power of the underlying grammar formalisms but still retain expressive power enough to de scribe many interesting 2D languages like arith metic expressions, lines, document layouts, some class of graphs, etc. The input data structure only contains the set of the objects with their attributes and does not need to keep information about the rela tions among the objects. The relations are em bedded in the parser that use them to predict the attribute values of the next object to parse. This representation is more space efficient than the other and does not depend on the particular parser relations. Moreover, it refers to a relation only when necessary. The predictive nature of the parser makes it more efficient than an order-free bottom-up picto rial parser. In particular, for pictorial LR parsing it is even possible to use tools from string-based formal language theory like Yacc for the auto matic parser generation of a pictorial language (Costagliola et al., . 1993 ). However the prediction of the next object in duces an order on the visit of the input. The order can be linear (Costagliola -Chang 1991) or partial (Wittenburg, 1992) and, in any case, it forces the parser to begin its processing from one (linear case) Oi:' multiple (partial case) spe cific starting points. If the input is made of a set of objects with no indication on the starting COSTAGLIOLA point, like a scanned document layout, then pre dictive parsing becomes inefficient. This paper attempts to solve this problem by constructing a bidirectional LR parser that does not need spe cific starting points in the input. 2 Island-driven parsing Island-driven parsers are generally used for gener ating partial interpretations of a spoken sentence (Stock et al., 1989; Woods, 1982) . The parsing starts from words that have higher acoustic evi dence and then extends to both directions in the sentence. Each partial interpretation forms an \"island\" . Occasionally, two islands may 'collide' by proposing and discovering the same word in the gap among them and may then be combined into a single larger island. This can be effectively used in \u2022 pictorial par sing whenever there are objects of particular se mantic relevance, or objects particularly complex to be combined only when each of them has been recognized, or, in our case, the starting point is not easy to find. Other approaches to bidirectional parsing in clude bidirectional chart parsing (Stock et al., 1989; Steel -De Roeck, 1987) and some form of bidirectionality within a tabular approach, such as Earley's or Kasami-Cocke-Younger's (Bossi et al., 1983) . Some definitions This section contains two definitions that will be useful for the presentation of the final algorithm. Definition 1 ( reverse grammar) Given a context-free grammar G = (N, T, S, P) , a reverse grammar with respect to G is a new grammar G' = (N, T, S, P ), where P is defined as fo llows: whenever A := u is in P then A := u R is in P, where u R is the reverse version of u. In general, the reverse of an LR context-free grammar is not LR. For sake of simplicity, this paper considers only LR context-free grammars whose reverse is LR, too. The extension to general context free grammars can be easily done. Given an LR grammar G such that its reverse grammar G' is LR, it is always possible to con struct for each of them the canonical LR( 0) col lection of sets of items through the algorithms Closure, Goto and Set-of-Items Construction as defined in (Aho et al.,1985). The goto graphs for G and G' are shown in Let us define C 1 = lo ' , ... , I n the collection of sets of items for G and CR = Ro, .. . , Rm the col lection of sets of items for G'. In the following, the relation between elements of C 1 and CR is analyzed. It is assumed that no useless symbols or epsilon-productions are in G. Figure 3.1 Goto Graphs for G and G' Given a production \"A := u X i v\"' in G with u, v E (N U T)* and X i E (N U T), there must be a set-of-items I k reachable after the occurrence X i has been processed, i.e., a set-of-items I k con taining the item \" A := u X i . v\". If the corresponding production in G' \" A := v R X i u R \" is considered, there must exists a set of-items Rt reachable after the occurrence X i has been processed, i.e., a set-of-items R 1 containing the item \" A := v R X i . u R \". Here v R and u R are again the reverse versions of v and u, respectively In other words, if I k is the state reachable af ter a forward scanning of X i in the context of u X i v, then there must exists Rt , the state reach able after a backward scanning of X i still in the -Context Of U Xi V. As an example, the goto graphs above show that l3 and R s are both reachable through c3 . Definition 2 (joint graph) Let us consider a grammar G = (N, T, S, P) with indexing, its reverse grammar G' = (N, T, S, P) and their canonical LR {O) sets-of-items \u2022 collections C1 = lo , ... , I n and C R = Ro , . .. , R m , respectively. The joint graph fo r an occurrence X i of X in N U T is given by: Jg raph{X i ) = { {Ik , Rt) / there exist A E N, and u, v occurrences of strings E (N U T) * such that \"A := u X i . v\" E h AND \" A := v R X i . u R \" E R z } The joint graph fo r the symbol X in N U T is: Jgraph(X) = u Jgraph(Xi) i:name(Xi )=X Example 3.2. Considering the grammars in Example 3.1 and looking at the goto graphs above: (Tomita, 1985 (Tomita, , 1991)) Jgraph(c) = Jgraph(c 3 ) = { ( l3 , Rs) } Jgraph(d) = Jgraph{d s ) = { (l4, R 3 ) } Jgraph(S) = Jgraph(So) = { ( l1 , R1) } Jgraph(C) = Jgraph(C1) U Jgraph(C 2 ) U U Jgraph(C4) = {(l2 , \ufffd) } U { (I s , R2) } U U {(la, R 2 ) , ( l a, \ufffd) } = = {(l2 , R4), (I s , R 2 ), (la, R 2 ), (la, \ufffd) } To parse the string \"d' cd\" starting from the. symbol \"c\", a substring parser based on G will parse \"cd\" and a substring parser based \u2022 on G' will parse \"cd'\". As J graph{ c) = { ( l 3, R s) } , the first parser will start from state 1 3 , while the second one will start from \u2022 R s . To parse the whole string the comple tion of the substring parser based on G will have to match the parsed part of the reverse substring parser, and vice versa. After reducing the non-terminal C, the states of G to be considered are 1 2 , I s and l a while the states of G' are R 2 and R4. Note that if the par sing process starting in \ufffd fails, then that starting in h must fail, too, because it has no correspond ing state \ufffd left in Jgraph(C). The Algorithm The algorithm is based on the concepts of sub string parsing as presented in (Rekers -Koorn, 1991). In this paper, an algorithm for substring parsing for arbitrary context-free grammars is presented. It is based on the pseudo-parallel par-\u2022 sing algorithm of Tomita , which runs a dynamically varying number of LR parsers in parallel and accepts general context free grammars. Even though the algorithm can be easily ex tended to the general case, in this paper it will be limited to accept only LR context-free grammars COSTAGLIOLA whose reverse is still an LR grammar. Informally the algorithm can be described as follow. The input is given by a grammar G and its reverse grammar G', the Jgraph for each symbol of the grammars, the two parsing tables and an input sentence ao ... a n with an index O ::s; i ::s; n from where the parsing process is supposed to start. Jgraph(\ufffd) provides the initial states. As seen \u2022 before, a J graph contains states ( set-of items) from both the grammar G and its reverse. In the following, a / orward parser is an LR parser for G and a backward parser is an LR parser for G'. Moreover, the opposite parser of a forward parser is meant to be a backward parser and vice versa. Every state Ik in Jgraph(\ufffd) (with i being the starting position) becomes the initial state for a forward parser and every state Rz in Jgraph(ai) an initial state for a backward parser. The for ward parsers interact only with forward parsers in the same way as a generalized LR parser. The same is true for the backward parsers. The excep tion occurs when a parser tries to reduce a pro duction \"A := u\" requiring the stack to pop its initial state. That parser is then blocked waiting for an opposite parser to try the corresponding reduction \"A := u R \" on the same symbols. If the distance between the two parser stack tops is I u I and the initial states of the two parsers form an edge in Jgraph(ai), then a rendezvous occurs and Jgraph(A) is generated. Jgraph(A) will produce a new set of forward and backward parsers and the process will continue till when ei ther two opposite parsers have a rendezvous on the action \"accept\" or no rendezvous is possible and the input has all been consumed. Data Structures The algorithm is based on a graph-structured stack with two types of nodes: joint stack nodes and simple stack nodes and it is able to con struct a packed shared parse forest, (Tomita, 1985 (Tomita, , 1991)) . A joint stack node is a 5-tuple (Jgraph, X, blast, flast, sLptr) where Jgraph is as defined above; X is either a terminal or a non-terminal; blast and flast point to the last elements visited during the backward and forward parsing of the input, respectively; sLptr is a pointer to a node labeled X in the packed shared parse forest. A simple stack node is a 4-tuple (state, X, last, sLptr) where state is the state reached by the parser and corresponds to a set of items; last is the last terminal parsed; X and sLptr are as above. Note that a joint node ( { ... , (I, R), ... }, X, blast,flast, sLptr) represents a graph whose ele ments are simple stack nodes of the type (I, X, \u00a3last, sLptr) and (R, X, blast, sLptr) and the edges are defined in the Jgraph component. The operations on the graph stack are the Splitting, Combining and Local Ambiguity Pack ing operations, (Tomita, 1985 (Tomita, , 1991)) , as used in the definition of the Generalized LR Parser. The only difference regards the updating of the node fields \u00a3last and blast. The following are the defi nitions of two new operations that must be added to the previous. The Rendezvous Operation A graphical description of the rendezvous op eration is given in Figure 4 .1 (pointers from the stack graph to the parse forest are not shown). If there is a joint node: N 2 = ( { ... (I k , Rz ) ... }, X, b, f, X_ptr) and two simple nodes: N 1 = (R j , Z, q, Z_ptr) and N 3 = (Ii, Y, p, Y_ptr) such that \u2022 N 1 is the active stack top of a backward parser with initial state R z in N 2 \u2022 N 3 is the active stack top of a forward parser with initial state I k in N 2 \u2022 the edge (I k , Rz) is in the J graph of the node N 2 . \u2022 action(Ii, a p+ i) = \"reduce A:= a:\" where o:=Z ... X ... Y \u2022 action(R j , a q _i) = \"reduce A:= o: R \" \u2022 pathJength(N 2 ... Ni) + pathJength{N 2 \u2022 \u2022 \u2022 N 3 ) -1 = I O: I then N 1 and N 3 are made non-active and a new active joint stack node (Jgraph(A), A, q, p, A_ptr) is created, where A is the left-hand of the reduced production, q is the pointer to the last visited token in N 1 , p is the pointer to the last visited token in N 3 and A_ptr is the pointer to a new shared forest vertex whose children are ver tices pointed by stack nodes contained in the path N1 ... N 2 ... N 3 . Note that the path N 2 ... N 1 represents the stack nodes of the backward parser while N 2 ... N 3 are the stack nodes for the forward parser. The Accept Operation If there is a joint node: N = ( { . . . (I k , Rz ) ... S, 0, n, S_ptr) where S is the starting non-terminal, 0 and n are the positions of the first and last elements of the input, and \u2022 action(I k , $) = accept \u2022 action(Rl, $) = accept then accept the input and return the pointer to the parse forest, S_ptr. The LR parser with an arbitrary starting point Input: An LR grammar G = (N, T, S, P) and its reverse G', the Jgraph for every symbol in NUT, a sentence w = aoa 1 When all the parsers, both forward and backward, are in the wait state, apply the rendezvous operation wherever p\ufffdssible and go to step 3. If an accept operation is pos sible then return the corresponding potnter to the parse forest. If no rendezvous or ac cept operations are possible then the par sing process halts. If no parse forest pointer has been returned then the sentence has not been accepted. Example 4.1 COSTAGLIOLA On the lookahead symbol \u2022 $, the state R 4 of the backward parser built on G', requires the reduc tion \"(1) S := CC\". R2 and 1 5 have no action, on $ and 'd', respectively. At this point, no action is possible without in volving the joint node. Note that the nodes with states 1 5 and \ufffd meet the rendezvous operation requirements: both of them are active stack tops requiring the same redqce action, the sum of the depths of the stack of the two parsers -1 = I QC I = 2 and (h, R 4 ) is an edge in the J graph of the joint node. By applying the rendezvous operation on pro duction \"S := CC\" and recalling that Jgraph(S) = { (l1 , Rt)} the fo Uowing configuration is reached: An LR parser takes in i\ufffdput a sequence of tokens and returns a parse tree if the sequence is in the language accepted by the parser. The sequence of tokens are usually extracted from the string data structure. A first generalizatim1, of this model toward 2-D parsing regards the \u2022 possibility to have other input data structures different from the string. After all a string can be seen as a set of elem\ufffdnts each having an attribute whose value is given by the position of the element in the string. As an \u2022 I example, the strmg \"a b c\" can be seen as the set { (b 2), (a 1), (c 3)} where each pair represents the element and its attrjbute value. With this new data structure, the LR parser cannot simply require r1 \"next\" token to the lex ical analyzer but has also to give indication$ on the position of the token. When this is done, the input sequence of tokens to an LR parser can be extracted from any set of tokens with attributes. In the case of two-dimensional symbolic langua ges these attributes will correspond to Cartesian coordinates but other types of attributes can be thought of. In the case of diagrammatic langua ges, for example, size, shape, colour, etc. can be considered as attributes. But how is it possible to make an LR parser give indications on the attribute values of the next token to parse? This can only be done by insert ing appropriate information in the productions of the grammar from which the LR parser is built. In the case of 2-D symbolic parsing this infor mation is given by spatial operators that take in input the position of the last visited symbol and return the position of the next symbols to parse. Examples of spatial operators are: \"String Concatenation\" : i => i + 1 \"Up\" : (i, j) => (i, j+l) \"Left\": (i, j) => (i-1, j) \"Right\" : (i, j) => (i+ 1, j) Positional grammars While in the traditional case there is an implicit use of the only string concatenation spatial rela tion, in the 2-D case many other spatial relations can be used and must made explicit in the gram mar formalism. In the following, some definitions are re-called, (Costagliola -Chang, 1991) , to define a 2-D grammar formalism and the languages generated by it: where m \ufffd 1, A E N, each Xi is in N U T and each Re\ufffd is in POS. In the following, the words \"positional gram mar\" will also refer to a context-free positional . grammar. Definition 4 (pictorial language) Let PG = (N, T, S, P, POS, PE) . A positional sentential form is a string IT such that S =>* II, where =>* has the conventional meaning. A positional sen tence is a positional sentential fo rm not contain ing non-terminal symbols. A picture is the evalu ation of a positional sentence. Th e pictorial lan guage defined by a positional grammar L(PG) is the set of its pictures. Note that if POS contains the only \"string concatenation\" spatial relation the positional grammar formalism reduces to the traditional context-free grammar formalism. Example 5.1 The following positional grammar generates a simple subset of the arithmetic expressions: N = {E, S, T, F} T = {+, 1:, (, ), id, num} E is the starting symbol POS = { >, _} p = { E := E > + > T I T T := s >TI F s := L -id F := id _ id I num I ( > E > ) } Definition 3 (positional grammar) A context-where the characters '>' and '-' stand for \"horfree positional grammar PG is a six-tuple (N, T, izontal concatenation\" and \"under concatena-S, P, POS, PE) where: tion\" , respectively. A positional sentence is: N is a finite non-empty set of non-terminal symbols T is a finite non-empty set of terminal symbols Nn T=</J S E N is the starting symbol P is a finite set of productions POS is a finite set of spatial relation identifiers PE is a positional evaluator Each production in P has the fa llowing fo rm: \"5 > + > L -i > ( > x -i > + > y -i > ) \" From its evaluation the particular positional eval uator PE for this grammar produces the following picture: 5 + 1:/xi + Yi)-A more detailed definition of PE for this type of grammars can be found in ( Costagliola et al., 1992) . Example 5.2. The following\u2022 positional grammar PG will be used in the following to illustrate the execution of the algorithm. Note that to reverse a positional g;rammar, it is not enough to reverse the right side\u2022 of the pro d uctions. Every spatial relation must \ufffdso be sub stituted with a semantically opposite spatial relation. In this example, \"Down\" becpmes \"Up\" and \"Right\" becomes \"Left\" . Pictorial LR parsing The generalization of LR parsing tp the two dimensional case has already been tre , ted in ( Co stagliola et al., 1991, 1992, 1993) Every spatial relation name in the column \"pos\" indicates a spatial function that takes in . input a position and returns a terminal, if found, or the end-of-input marker $, otherwise. The only exception is 'Any' that always returns $. The action \"accept\" is actually a conditional \"accept\": if all the symbols of the picture have been processed then accept, otherwise reject. This can be done by marking each visited symbol and looking for unmarked ones. Looking at Figure p.l, if state Is is reached by shifting a terminal 'a' whose position is (i, j), then the next symbol to process is the terminal Down(i, j) in positioQ (i, j-1). Note that Down is the spatial function associated to Is . In the following, for sake of simplicity, each Cartesian coordinate (i, j) will be associated with a unique index k. The 2-D extension Definition 2 of \"j oint graph\" applies with no mod ification to the case of pictorial LR parsing. In particular, for the grammars PG and PG' of Ex ample 5.2, the Jgraph sets are so defined: 1992), the extension of the algorithm to the two dimensional case is -immediate. In this paper, only the simplest form of two di\u00b5iensional parsing, the so-called linear pictorial parsing, is referred to. In this type of pictorial parsing, the spatial relations are defined such that the position of the next symbol only depends on the last symbol processed. COSTAGLIOLA More complex forms include the possibility to calculate the next symbol based on the .positions of the elements of the last handle or of the whole input so far visited. 'f hese forms have been fo\ufffd vestigated in traditional pictorial generalized par\ufffd sing and are currently being investigated i\u00b5 the context of LR parsing with an arbitrary starting point.",
    "abstract": "In pictorial LR parsing it is always difficult to establish from which point of a picture the parsing process has to start. This paper introduces an algorithm that allows any element of the input to be considered as the starting one and, at the same time, assures that the parsing process is not compromised. The algorithm is first described on string grammars seen as a subclass of pictorial grammars and then adapted to the two-dimensional case. The extensions to generalized LR parsing and pictorial generalized LR parsing are immediate.",
    "countries": [
        "Italy"
    ],
    "languages": [],
    "numcitedby": "2",
    "year": "1993",
    "month": "August 10-13",
    "title": "(Pictorial) {LR} Parsing from an Arbitrary Starting Point"
}