{
    "article": "We consider the problem of learning factored probabilistic CCG grammars for semantic parsing from data containing sentences paired with logical-form meaning representations. Traditional CCG lexicons list lexical items that pair words and phrases with syntactic and semantic content. Such lexicons can be inefficient when words appear repeatedly with closely related lexical content. In this paper, we introduce factored lexicons, which include both lexemes to model word meaning and templates to model systematic variation in word usage. We also present an algorithm for learning factored CCG lexicons, along with a probabilistic parse-selection model. Evaluations on benchmark datasets demonstrate that the approach learns highly accurate parsers, whose generalization performance benefits greatly from the lexical factoring. Introduction Semantic parsers automatically recover representations of meaning from natural language sentences. Recent work has focused on learning such parsers directly from corpora made up of sentences paired with logical meaning representations (Kate et al., 2005; Kate and Mooney, 2006; Wong and Mooney, 2006, 2007; Zettlemoyer and Collins, 2005, 2007; Lu et al., 2008; Kwiatkowski et al., 2010) . For example, in a flight booking domain we might have access to training examples such as: Sentence: I want flights from Boston Meaning: \u03bb x. f light(x) \u2227 f rom (x, bos) and the goal is to learn a grammar that can map new, unseen, sentences onto their corresponding meanings, or logical forms. One approach to this problem has developed algorithms for leaning probabilistic CCG grammars (Zettlemoyer and Collins, 2005, 2007; Kwiatkowski et al., 2010) . These grammars are well-suited to the task of semantic parsing, as they closely link syntax and semantics. They can be used to model a wide range of complex linguistic phenomena and are strongly lexicalized, storing all language-specific grammatical information directly with the words in the lexicon. For example, a typical learned lexicon might include entries such as: (1) f light N : \u03bb x. f light(x) (2) f light N/(S|NP) : \u03bb f \u03bb x. f light(x) \u2227 f (x) (3) f light N\\N : \u03bb f \u03bb x. f light(x) \u2227 f (x) (4) f are N : \u03bb x.cost(x) (5) f are N/(S|NP) : \u03bb f \u03bb x.cost(x) \u2227 f (x) (6) f are N\\N : \u03bb f \u03bb x.cost(x) \u2227 f (x) (7) Boston NP : bos (8) Boston N\\N : \u03bb f \u03bb x. f rom(x, bos) \u2227 f (x) (9) New York NP : nyc (10) New York N\\N : \u03bb f \u03bb x. f rom(x, nyc) \u2227 f (x) Although lexicalization of this kind is useful for learning, as we will see, these grammars can also suffer from sparsity in the training data, since closely related entries must be repeatedly learned for all members of a certain class of words. For example, the list above shows a selection of lexical items that would have to be learned separately. In this list, the word \"flight\" is paired with the predicate flight in three separate lexical items which are required for different syntactic contexts. Item 1512 (1) has the standard N category for entries of this type, item (2) allows the use of the word \"flight\" with that-less relative clauses such as \"flight departing Boston\", and item (3) is useful for phrases with unconventional word order such as \"from Boston flight to New York\". Representing these three lexical items separately is inefficient, since each word of this class (such as \"fare\") will require three similarly structured lexical entries differing only in predicate name. There may also be systemtatic semantic variation between entries for a certain class of words. For example, in (6) \"Boston\" is paired with the constant bos that represents its meaning. However, item (7) also adds the predicate from to the logical form. This might be used to analyse somewhat elliptical, unedited sentences such as \"Show me flights Boston to New York,\" which can be challenging for semantic parsers (Zettlemoyer and Collins, 2007) . This paper builds upon the insight that a large proportion of the variation between lexical items for a given class of words is systematic. Therefore it should be represented once and applied to a small set of basic lexical units. 1 We develop a factored lexicon that captures this insight by distinguishing lexemes, which pair words with logical constants, from lexical templates, which map lexemes to full lexical items. As we will see, this can lead to a significantly more compact lexicon that can be learned from less data. Each word or phrase will be associated with a few lexemes that can be combined with a shared set of general templates. We develop an approach to learning factored, probabilistic CCG grammars for semantic parsing. Following previous work (Kwiatkowski et al., 2010) , we make use of a higher-order unification learning scheme that defines a space of CCG grammars consistent with the (sentence, logical form) training pairs. However, instead of constructing fully specified lexical items for the learned grammar, we automatically generate sets of lexemes and lexical templates to model each example. This is a difficult learning problem, since the CCG analyses that 1 A related tactic is commonly used in wide-coverage CCG parsers derived from treebanks, such as work by Hockenmaier and Steedman (2002) and Clark and Curran (2007) . These parsers make extensive use of category-changing unary rules, to avoid data sparsity for systematically related categories (such as those related by type-raising). We will automatically learn to represent these types of generalizations in the factored lexicon. are required to construct the final meaning representations are not explicitly labeled in the training data. Instead, we model them with hidden variables and develop an online learning approach that simultaneously estimates the parameters of a log-linear parsing model, while inducing the factored lexicon. We evaluate the approach on the benchmark Atis and GeoQuery domains. This is a challenging setup, since the GeoQuery data has complex meaning representations and sentences in multiple languages, while the Atis data contains spontaneous, unedited text that can be difficult to analyze with a formal grammar representation. Our approach achieves at or near state-of-the-art recall across all conditions, despite having no English or domain-specific information built in. We believe that ours is the only system of sufficient generality to run with this degree of success on all of these datasets. Related work There has been significant previous work on learning semantic parsers from training sentences labelled with logical form meaning representations. We extend a line of research that has addressed this problem by developing CCG grammar induction techniques. Zettlemoyer and Collins (2005, 2007) presented approaches that use hand generated, English-language specific rules to generate lexical items from logical forms as well as English specific type-shifting rules and relaxations of the CCG combinators to model spontaneous, unedited sentences. Zettlemoyer and Collins (2009) extends this work to the case of learning in context dependent environments. Kwiatkowski et al. (2010) described an approach for language-independent learning that replaces the hand-specified templates with a higher-order-unification-based lexical induction method, but their approach does not scale well to challenging, unedited sentences. The learning approach we develop for inducing factored lexicons is also language independent, but scales well to these challenging sentences. There have been a number of other approaches for learning semantic parsers, including ones based on machine translation techniques (Papineni et al., 1997; Ramaswamy and Kleindienst, 2000; Wong and Mooney, 2006) , parsing models (Miller et al., 1996; Ge and Mooney, 2006; Lu et al., 2008 Lu et al., ), in-1513 ductive logic programming algorithms (Zelle and Mooney, 1996; Thompson and Mooney, 2002; Tang and Mooney, 2000) , probabilistic automata (He and Young, 2005, 2006) , and ideas from string kernels and support vector machines (Kate and Mooney, 2006; Nguyen et al., 2006) . More recent work has focused on training semantic parsers without supervision in the form of logical-form annotations. Clarke et al. (2010) and Liang et al. (2011) replace semantic annotations in the training set with target answers which are more easily available. Goldwasser et al. (2011) present work on unsupervised learning of logical form structure. However, all of these systems require significantly more domain and language specific initialization than the approach presented here. Other work has learnt semantic analyses from text in the context of interactions in computational environments (Branavan et al. (2010) , Vogel and Jurafsky (2010) ); text grounded in partial observations of a world state (Liang et al., 2009) ; and from raw text alone (Poon and Domingos, 2009, 2010) . There is also related work that uses the CCG grammar formalism. Clark and Curran (2003) present a method for learning the parameters of a log-linear CCG parsing model from fully annotated normal-form parse trees. Watkinson and Manandhar (1999) describe an unsupervised approach for learning syntactic CCG lexicons. Bos et al. (2004) present an algorithm for building semantic representations from CCG parses but requires fully-specified CCG derivations in the training data. Overview of the Approach Here we give a formal definition of the problem and an overview of the learning approach. Problem We will learn a semantic parser that takes a sentences x and returns a logical form z representing its underlying meaning. We assume we have input data {(x i , z i )|i = 1 . . . n} containing sentences x i and logical forms z i , for example x i =\"Show me flights to Boston\" and z i = \u03bb x. f light(x) \u2227to(x, bos). Model We will represent the parser as a factored, probabilistic CCG (PCCG) grammar. A traditional CCG lexical item would fully specify the syntax and semantics for a word (reviewed in Section 4). For example, Boston NP : bos represents the entry for the word \"Boston\" with syntactic category NP and meaning represented by the constant bos. Where a lexicon would usually list lexical items such as this, we instead use a factored lexicon (L, T ) containing: \u2022 A list of lexemes L. Each lexeme pairs a word or phrase with a list of logical constants that can be used to construct its meaning. For example, one lexeme might be (Boston, [bos] ). \u2022 A list of lexical templates T . Each template takes a lexeme and maps it on to a full lexical item. For example, there is a single template that can map the lexeme above to the final lexical entry Boston NP : bos. We will make central use of this factored representation to provide a more compact representation of the lexicon that can be learned efficiently. The factored PCCG will also contain a parameter vector, \u03b8 , that defines a log-linear distribution over the possible parses y, conditioned on the sentence x. Learning Our approach for learning factored PC-CGs extends the work of Kwiatkowski et al. (2010) , as reviewed in Section 7. Specifically, we modify the lexical learning, to produce lexemes and templates, as well as the feature space of the model, but reuse the existing parameter estimation techniques and overall learning cycle, as described in Section 7. We present the complete approach in three parts by describing the factored representation of the lexicon (Section 5), techniques for proposing potential new lexemes and templates (Section 6), and finally a complete learning algorithm (Section 7). However, the next section first reviews the required background on semantic parsing with CCG. Background Lambda Calculus We represent the meanings of sentences, words and phrases with logical expressions that can contain constants, quantifiers, logical connectors and lambda abstractions. We construct the meanings of sentences from the meanings of words and phrases using lambda-calculus operations. We use a version of the typed lambda calculus (Carpenter, 1997) , in which the basic types include e, for entities; t, for truth values; and i for numbers. We also have function types that are assigned to lambda expressions. The expression \u03bb x. f light(x) takes an entity and returns a truth value, and has the function type e,t . Combinatory Categorial Grammar CCG (Steedman, 1996 (Steedman, , 2000) ) is a linguistic formalism that tightly couples syntax and semantics, and can be used to model a wide range of language phenomena. A traditional CCG grammar includes a lexicon \u039b with entries like the following: f lights N : \u03bb x. f light(x) to (N\\N)/NP : \u03bb y.\u03bb f .\u03bb x. f (x) \u2227 to(x, y) Boston NP : bos where each lexical item w X : h has words w, a syntactic category X, and a logical form h. For the first example, these are \"flights,\" N, and \u03bb x. f light(x). In this paper, we introduce a new way of representing lexical items as (lexeme, template) pairs, as described in section 5. CCG syntactic categories may be atomic (such as S or NP) or complex (such as (N\\N)/NP) where the slash combinators encode word order information. CCG uses a small set of combinatory rules to build syntactic parses and semantic representations concurrently. Two example combinatory rules are forward (>) and backward (<) application: X/Y : f Y : g \u21d2 X : f (g) (>) Y : g X\\Y : f \u21d2 X : f (g) (<) These rules apply to build syntactic and semantic derivations under the control of the word order information encoded in the slash directions of the lexical entries. For example, given the lexicon above, the phrase \"flights to Boston\" can be parsed to produce: flights to Boston N (N\\N)/NP NP \u03bb x. f light(x) \u03bb y\u03bb f \u03bb x. f (x) \u2227 to(x, y) bos > (N\\N) \u03bb f \u03bb x. f (x) \u2227 to(x, bos) < N \u03bb x. f light(x) \u2227 to(x, bos) where each step in the parse is labeled with the combinatory rule (\u2212 > or \u2212 <) that was used. CCG also includes combinatory rules of forward (> B) and backward (< B) composition: X/Y : f Y /Z : g \u21d2 X/Z : \u03bb x. f (g(x)) (> B) Y \\Z : g X\\Y : f \u21d2 X\\Z : \u03bb x. f (g(x)) (< B) These rules allow a relaxed notion of constituency which helps limit the number of distinct CCG lexical items required. To the standard forward and backward slashes of CCG we also add a vertical slash for which the direction of application is underspecified. We shall see examples of this in Section 10. Probabilistic CCGs Due to ambiguity in both the CCG lexicon and the order in which combinators are applied, there will be many parses for each sentence. We discriminate between competing parses using a log-linear model which has a feature vector \u03c6 and a parameter vector \u03b8 . The probability of a parse y that returns logical form z, given a sentence x is defined as: P(y, z|x; \u03b8 , \u039b) = e \u03b8 \u2022\u03c6 (x,y,z) \u2211 (y ,z ) e \u03b8 \u2022\u03c6 (x,y ,z ) (1) Section 8 fully defines the set of features used in the system presented. The most important of these control the generation of lexical items from (lexeme, template) pairs. Each (lexeme, template) pair used in a parse fires three features as we will see in more detail later. The parsing, or inference, problem done at test time requires us to find the most likely logical form z given a sentence x, assuming the parameters \u03b8 and lexicon \u039b are known: f (x) = arg max z p(z|x; \u03b8 , \u039b) (2) where the probability of the logical form is found by summing over all parses that produce it: p(z|x; \u03b8 , \u039b) = \u2211 y p(y, z|x; \u03b8 , \u039b) (3) In this approach the distribution over parse trees y is modeled as a hidden variable. The sum over parses in Eq. 3 can be calculated efficiently using the inside-outside algorithm with a CKY-style parsing algorithm. To estimate the parameters themselves, we use stochastic gradient updates (LeCun et al., 1998) . Given a set of n sentence-meaning pairs {(x i , z i ) : i = 1...n}, we update the parameters \u03b8 iteratively, for each example i, by following the local gradient of the conditional log-likelihood objective O i = log P(z i |x i ; \u03b8 , \u039b). The local gradient of the individual parameter \u03b8 j associated with feature \u03c6 j and training instance (x i , z i ) is given by: \u2202 O i \u2202 \u03b8 j = E p(y|x i ,z i ;\u03b8 ,\u039b) [\u03c6 j (x i , y, z i )] \u2212E p(y,z|x i ;\u03b8 ,\u039b) [\u03c6 j (x i , y, z)] (4) As with Eq. 3, all of the expectations in Eq. 4 are calculated through the use of the inside-outside algorithm on a pruned parse chart. For a sentence of length m, each parse chart span is pruned using a beam width proportional to m 2 3 , to allow larger beams for shorter sentences. Factored Lexicons A factored lexicon includes a set L of lexemes and a set T of lexical templates. In this section, we formally define these sets, and describe how they are used to build CCG parses. We will use a set of lexical items from our running example to discuss the details of how the following lexical items: (1) f light N : \u03bb x. f light(x) (2) f light N/(S|NP) : \u03bb f \u03bb x. f light(x) \u2227 f (x) . . . (6) Boston NP : bos (7) Boston N\\N : \u03bb f \u03bb x. f rom(x, bos) \u2227 f (x) are constructed from specific lexemes and templates. Lexemes A lexeme (w, c) pairs a word sequence w with an ordered list of logical constants c = [c 1 . . . c m ]. For example, item (1) and (2) above would come from a single lexeme (flight, [ f light]). Similar lexemes would be represented for other predicates, for example (fare, [cost] ). Lexemes also can contain multiple constants, for example (cheapest, [argmin, cost] ), which we will see more examples of later. Lexical Templates A lexical template takes a lexeme and produces a lexical item. Templates have the general form \u03bb (\u03c9, v).[\u03c9 X : h v ] where h v is a logical expression that contains variables from the list v. Applying this template to the input lexeme (w, c) gives the full lexical item w X :h where the variable \u03c9 has been replaced with the wordspan w and the logical form h has been created by replacing each of the variables in v with the counterpart constant from c. For example, the lexical item (6) above would be constructed from the lexeme (Boston, [bos]) using the template \u03bb (\u03c9, v).[\u03c9 NP:v 1 ]. Items (1) and (2) would both be constructed from the single lexeme (flight, [ f light]) with the two different templates \u03bb (\u03c9, v).[\u03c9 N : \u03bb x.v 1 (x)] and \u03bb (\u03c9, v).[\u03c9 N/(S|NP) : \u03bb f \u03bb x.v 1 (x) \u2227 f (x)] Parsing with a Factored Lexicon In general, there can by many different (lexeme, template) pairs that produce the same lexical item. For example, lexical item (7) in our running example above can be constructed from the lexemes (Boston, [bos] ) and (Boston, [ f rom, bos]), given appropriate templates. To model this ambiguity, we include the selection of a (lexeme, template) pair as a decision to be made while constructing a CCG parse tree. Given the lexical item produced by the chosen lexeme and template, parsing continues with the traditional combinators, as reviewed in Section 4.2. This direct integration allows for features that signal which lexemes and templates have been used while also allowing for well defined marginal probabilities, by summing over all ways of deriving a specific lexical item. Learning Factored Lexicons To induce factored lexicons, we will make use of two procedures, presented in this section, that factor lexical items into lexemes and templates. Section 7 will describe how this factoring operation is integrated into the complete learning algorithm. Maximal Factorings Given a lexical item l of the form w X : h with words w, a syntactic category X, and a logical form h, we define the maximal factoring to be the unique (lexeme, template) pair that can be used to reconstruct l and includes all of the constants of h in the lexeme (listed in a fixed order based on an ordered traversal of h). For example, the maximal factoring for the lexical item Boston NP : bos is the pair we saw before: (Boston, [bos] ) and \u03bb (\u03c9, v).[\u03c9 NP : v 1 ]. Similarly, the lexical item Boston N\\N : \u03bb f .\u03bb x. f (x) \u2227 f rom(x, bos) would be factored to produce (Boston, [ f rom, bos]) and \u03bb (\u03c9, v).[\u03c9 N\\N : \u03bb f .\u03bb x. f (x) \u2227 v 1 (x, v 2 )]. As we will see in Section 7, this notion of factor-ing can be directly incorporated into existing algorithms that learn CCG lexicons. When the original algorithm would have added an entry l to the lexicon, we can instead compute the factoring of l and add the corresponding lexeme and template to the factored lexicon. Introducing Templates with Content Maximal factorings, as just described, provide for significant lexical generalization but do not handle all of the cases needed to learn effectively. For instance, the maximal split for the item Boston N\\N : \u03bb f .\u03bb x. f (x) \u2227 f rom(x, bos) would introduce the lexeme (Boston, [ f rom, bos]), which is suboptimal since each possible city would need a lexeme of this type, with the additional from constant included. Instead, we would ideally like to learn the lexeme (Boston, [bos]) and have a template that introduces the from constant. This would model the desired generalization with a single lexeme per city. In order to permit the introduction of extra constants into lexical items, we allow the creation of templates that contain logical constants through partial factorings. For instance, the template below can introduce the predicate from \u03bb (\u03c9, v).[\u03c9 N\\N : \u03bb f .\u03bb x. f (x) \u2227 f rom(x, v 1 )] The use of templates to introduce extra semantic constants into a lexical item is similar to, but more general than, the English-specific type-shifting rules used in Zettlemoyer and Collins (2007) , which were introduced to model spontaneous, unedited text. They are useful, as we will see, in learning to recover semantic content that is implied, but not explicitly stated, such as our original motivating phrase \"flights Boston to New York.\" To propose templates which introduce semantic content, during learning, we build on the intuition that we need to recover from missing words, such as in the example above. In this scenario, there should also be other sentences that actually include the word, in our example this would be something like \"flights from Boston.\" We will also assume that we have learned a good factored lexicon for the complete example that could produce the parse: flights from Boston N (N\\N)/NP NP \u03bb x. f light(x) \u03bb y\u03bb f \u03bb x. f (x) \u2227 f rom(x, y) bos > (N\\N) \u03bb f \u03bb x. f (x) \u2227 f rom(x, bos) < N \u03bb x. f light(x) \u2227 f rom(x, bos) Given analyses of this form, we introduce new templates that will allow us to recover from missing words, for example if \"from\" was dropped. We identify commonly occurring nodes in the best parse trees found during training, in this case the nonterminal spanning \"from Boston,\" and introduce templates that can produce the nonterminal, even if one of the words is missing. Here, this approach would introduce the desired template \u03bb (\u03c9, v).[\u03c9 N\\N : \u03bb f .\u03bb x. f (x) \u2227 f rom(x, v 1 )] for mapping the lexeme (Boston, [bos]) directly to the intermediate structure. Not all templates introduced this way will model valid generalizations. However, we will incorporate them into a learning algorithm with indicator features that can be weighted to control their use. The next section presents the complete approach. Learning Factored PCCGs Our Factored Unification Based Learning (FUBL) method extends the UBL algorithm (Kwiatkowski et al., 2010) to induce factored lexicons, while also simultanously estimating the parameters of a loglinear CCG parsing model. In this section, we first review the NEW-LEX lexical induction procedure from UBL, and then present the FUBL algorithm. Background: NEW-LEX NEW-LEX generates lexical items by splitting and merging nodes in the best parse tree of each training example. Each parse node has a CCG category X : h and a sequence of words w that it spans. We will present an overview of the approach using the running example with the phrase w =\"in Boston\" and the category X : h = S\\NP : \u03bb x.loc(x, bos), which is of the type commonly seen during learning. The splitting procedure is a two step process that first splits the logical form h, then splits the CCG syntactic category X and finally splits the string w. The first step enumerates all possible splits of the logical form h into a pair of new expressions ( f , g) that can be used to reconstruct h by either function application (h = f (g)) or composition (h = \u03bb x. f (g(x))). For example, one possible split is: ( f = \u03bb y.\u03bb x.loc(x, y) , g = bos) which corresponds to the function application case. The next two steps enumerate all ways of splitting the syntactic category X and words w to introduce two new lexical items which can be recombined with CCG combinators (application or composition) to recreate the original parse node X : h spanning w. In our example, one possibility would be: (in (S\\NP)/NP : \u03bb y.\u03bb x.loc(x, y) , Boston NP : bos) which could be recombined with the forward application combinator from Section 4.2. To assign categories while splitting, the grammar used by NEW-LEX only uses two atomic syntactic categories S and NP. This allows NEW-LEX to make use of a direct mapping from semantic type to syntactic category when proposing syntactic categories. In this schema, the standard syntactic category N is replaced by the category S|NP which matches the type e,t and uses the vertical slash introduced in Section 4.2. We will see categories such as this in the evaluation. The FUBL Algorithm Figure 1 shows the FUBL learning algorithm. We assume training data {(x i , z i ) : i = 1 . . . n} where each example is a sentence x i paired with a logical form z i . The algorithm induces a factored PCCG, including the lexemes L, templates T , and parameters \u03b8 . The algorithm is online, repeatedly performing both lexical expansion (Step 1) and a parameter update (Step 2) for each training example. The overall approach is closely related to the UBL algorithm (Kwiatkowski et al., 2010) , but includes extensions for updating the factored lexicon, as motivated in Section 6. Initialization The model is initialized with a factored lexicon as follows. MAX-FAC is a function that takes a lexical item l and returns the maximal factoring of it, that is the unique, maximal (lexeme, template) pair that can be combined to construct l, as described in Section 6.1. We apply MAX-FAC to each of the training examples (x i , z i ), creating a single way of producing the desired meaning z i from a Inputs: Training set {(x i , z i ) : i = 1 . . . n} \u2022 For i = 1 . . . n \u2022 (\u03c8, \u03c0) = MAX-FAC(x i S : z i ) \u2022 L = L \u222a \u03c8 , T = T \u222a \u03c0 \u2022 Set L = L \u222a L e . \u2022 Initialize \u03b8 using coocurrence statistics, as described in Section 8. Algorithm: For t = 1 . . . J, i = 1 . . . n : Step 1: (Add Lexemes and Templates) \u2022 Let y * = arg max y p(y|x i , z i ; \u03b8 , (L, T )) \u2022 For l \u2208 NEW-LEX(y * ) \u2022 (\u03c8, \u03c0) = MAX-FAC(l) \u2022 L = L \u222a \u03c8 , T = T \u222a \u03c0 \u2022 \u03a0 = PART-FAC(y * ) , T = T \u222a \u03a0 Step 2: (Update Parameters) \u2022 Let \u03b3 = \u03b1 0 1+c\u00d7k where k = i + t \u00d7 n. \u2022 Let \u2206 = E p(y|x i ,z i ;\u03b8 ,(L,T )) [\u03c6 (x i , y, z i )] \u2212E p(y,z|x i ;\u03b8 ,(L,T )) [\u03c6 (x i , y, z)] \u2022 Set \u03b8 = \u03b8 + \u03b3\u2206 Output: Lexemes L, templates T , and parameters \u03b8 . lexeme containing all of the words in x i . The lexemes and templates created in this way provide the initial factored lexicon. Step 1 The first step of the learning algorithm in Figure 1 adds lexemes and templates to the factored model given by performing manipulations on the highest scoring correct parse y * of the current training example (x i , z i ). First the NEW-LEX procedure is run on y * as described in Section 6.1 to generate new lexical items. We then use the function MAX-FAC to create the maximal factorings of each of these new lexical items as described in Section 6 and these are added to the factored representation of the lexicon. New templates can also be introduced through partial factorings of internal parse nodes as described in Section 6.2. These templates are generated by using the function PART-FAC to abstract over the wordspan and a subset of the constants contained in the internal parse nodes of y * . This step allows for templates that introduce new semantic content to model elliptical language, as described in Section 6.2. Step 2 The second step does a stochastic gradient descent update on the parameters \u03b8 used in the parsing model. This update is described in Section 4.3 Discussion The FUBL algorithm makes use of a direct online approach, where lexemes and templates are introduced in place while analyzing specific sentences. In general, this will overgeneralize; not all ways of combining lexemes and templates will produce high quality lexical items. However, the overall approach includes features, presented in Section 8, that can be used to learn which ones are best in practice. The complete algorithm iterates between adding new lexical content and updating the parameters of the parsing model with each procedure guiding the other. Experimental setup Data Sets We evaluate on two benchmark semantic parsing datasets: GeoQuery, which is made up of natural language queries to a database of geographical information; and Atis, which contains natural language queries to a flight booking system. The Geo880 dataset has 880 (English-sentence, logicalform) pairs split into a training set of 600 pairs and a test set of 280. The Geo250 data is a subset of the Geo880 sentences that have been translated into Japanese, Spanish and Turkish as well as the original English. We follow the standard evaluation procedure for Geo250, using 10-fold cross validation experiments with the same splits of the data as Wong and Mooney (2007) . The Atis dataset contains 5410 (sentence, logical-form) pairs split into a 4480 example training set, a 480 example development set and a 450 example test set. Evaluation Metrics We report exact match Recall (percentage of sentences for which the correct logical-form was returned), Precision (percentage of returned logical-forms that are correct) and F1 (harmonic mean of Precision and Recall). For Atis we also report partial match Recall (percentage of correct literals returned), Precision (percentage of returned literals that are correct) and F1, computed as described by Zettlemoyer and Collins (2007) . Features We introduce two types of features to discriminate between parses: lexical features and logical-form features. Lexical features fire on the lexemes and templates used to build the lexical items used in a parse. For each (lexeme,template) pair used to create a lexical item we have indicator features \u03c6 l for the lexeme used, \u03c6 t for the template used, and \u03c6 (l,t) for the pair that was used. We assign the features on lexical templates a weight of 0.1 to prevent them from swamping the far less frequent but equally informative lexeme features. Logical-form features are computed on the lambda-calculus expression z returned at the root of the parse. Each time a predicate p in z takes an argument a with type Ty(a) in position i, it triggers two binary indicator features: \u03c6 (p,a,i) for the predicate-argument relation; and \u03c6 (p,Ty(a),i) for the predicate argument-type relation. Boolean operator features look at predicates that occurr together in conjunctions and disjunctions. For each variable v i that fills argument slot i in two conjoined predicates p 1 and p 2 we introduce a binary indicator feature \u03c6 con j(i,p 1 ,p 2 ) . We introduce similar features \u03c6 dis j(i,p 1 ,p 2 ) for variables v i that are shared by predicates in a disjunction. Initialization The weights for lexeme features are initialized according to coocurrance statistics between words and logical constants. These are estimated with the Giza++ (Och and Ney, 2003) implementation of IBM Model 1. The initial weights for templates are set by adding \u22120.1 for each slash in the syntactic category and \u22122 if the template contains logical constants. Features on lexeme-template pairs and all parse features are initialized to zero. Systems We compare performance to all recentlypublished, directly-comparable results. For Geo-Query, this includes the ZC05, ZC07 (Zettlemoyer and Collins, 2005 Collins, , 2007)) , \u03bb -WASP (Wong and Mooney, 2007) , UBL (Kwiatkowski et al., 2010) systems and DCS (Liang et al., 2011) . For Atis, we report results from HY06 (He and Young, 2006) , ZC07, and UBL. Results Tables 1-4 present the results on the Atis and Geoquery domains. In all cases, FUBL achieves or near state-of-the-art recall (overall number of correct parses) when compared to directly comparable systems and it significantly outperforms UBL on Atis. On Geo880 the only higher recall is achieved by DCS with prototypes -which uses significant English-specific resources, including manually specified lexical content, but does not require training sentences annotated with logical-forms. On Geo250, FUBL achieves the highest recall across languages. Each individual result should be interpreted with care, as a single percentage point corresponds to 2-3 sentences, but the overall trend is encouraging. On the Atis development set, FUBL outperforms ZC07 by 7.5% of recall but on the Atis test set FUBL lags ZC07 by 2%. The reasons for this discrepancy are not clear, however, it is possible that the syntactic constructions found in the Atis test set do not exhibit the same degree of variation as those seen in the development set. This would negate the need for the very general lexicon learnt by FUBL. Across the evaluations, despite achieving high recall, FUBL achieves significantly lower precision than ZC07 and \u03bb -WASP. This illustrates the tradeoff from having a very general model of proposing lexical structure. With the ability to skip unseen words, FUBL returns a parse for all of the Atis test sentences, since the factored lexicons we are learning can produce a very large number of lexical items. These parses are, however, not always correct. Analysis The Atis results in Tables 1 and 2 highlight the advantages of factored lexicons. FUBL outperforms the UBL baseline by 16 and 11 points respectively in exact-match recall. Without making any modification to the CCG grammars or parsing combinators, we are able to induce a lexicon that is general enough model the natural occurring variations in the data, for example due to sloppy, unedited sentences. Figure 2 shows a parse returned by FUBL for a sentence on which UBL failed. While the word \"cheapest\" is seen 208 times in the training data, in only a handful of these instances is it seen in the middle of an utterance. For this reason, UBL never proposes the lexical item, cheapest NP\\(S|NP)/(S|NP) : \u03bb f \u03bb g.argmin(\u03bb x. f (x) \u2227 g(x), \u03bb y.cost(y)), which is used to parse the sentence in Figure 2 . In contrast, FUBL uses a lexeme learned from the same word in different contexts, along with a template learnt from similar words in a similar context, to learn to per- (S|NP) (S|NP) \u03bb x.to(x, atl) \u2227 f rom(x, pit) \u03bb x.month(x, jul) \u2227 day(x, 20) > NP\\(S|NP) \u03bb f .argmin(\u03bb x. f (x) \u2227 month(x, jul) \u2227 day(x, 20), \u03bb y.cost(y)) < NP argmin(\u03bb x. f rom(x, pit) \u2227 to(x, atl) \u2227 month(x, jul) \u2227 day(x, 20), \u03bb y.cost(y)) Figure 2 : An example learned parse. FUBL can learn this type of analysis with novel combinations of lexemes and templates at test time, even if the individual words, like \"cheapest,\" were never seen in similar syntactic constructions during training, as described in Section 10. form the desired analysis. As well as providing a new way to search the lexicon during training, the factored lexicon provides a way of proposing new, unseen, lexical items at test time. We find that new, non-NP, lexical items are used in 6% of the development set parses. Interestingly, the addition of templates that introduce semantic content (as described in Section 6.2) account for only 1.2% of recall on the Atis development set. This is suprising as elliptical constructions are found in a much larger proportion of the sentences than this. In practice, FUBL learns to model many elliptical constructions with lexemes and templates introduced through maximal factorings. For example, the lexeme (to, [ f rom,to]) can be used with the correct lexical template to deal with our motivating example \"flights Boston to New York\". Templates that introduce content are therefore only used in truly novel elliptical constructions for which an alternative analysis could not be learned. Table 5 shows a selection of lexemes and templates learned for Atis. Examples 2 and 3 show that morphological variants of the same word must still be stored in separate lexemes. However, as these lexemes now share templates, the total number of lexical variants that must be learned is reduced. Discussion We argued that factored CCG lexicons, which include both lexemes and lexical templates, provide a compact representation of lexical knowledge that can have advantages for learning. We also described a complete approach for inducing factored, probabilistic CCGs for semantic parsing, and demon- \u03c9, v) .\u03c9 NP : v 1 2 \u03bb (\u03c9, v).\u03c9 S|NP : \u03bb x.v 1 (x) 3 \u03bb (\u03c9, v).\u03c9 NP|NP : \u03bb x.v 1 (x) 4 \u03bb (\u03c9, v).\u03c9 S|NP/NP\\(S|NP) : \u03bb x\u03bb y.v 1 (x, y) 5 \u03bb (\u03c9, v).\u03c9 NP/(S|NP) : \u03bb f .v 1 (\u03bb x. f (x), \u03bb y, v 2 (y)) 6 \u03bb (\u03c9, v).\u03c9 S|NP\\(S|NP)/NP : \u03bb x\u03bb y\u03bb z.v 1 (v 2 (z), x) \u2227 y(x) strated strong performance across a wider range of benchmark datasets that any previous approach. In the future, it will also be important to explore morphological models, to better model variation within the existing lexemes. The factored lexical representation also has significant potential for lexical transfer learning, where we would need to learn new lexemes for each target application, but much of the information in the templates could, potentially, be ported across domains. Acknowledgements The work was supported in part by EU ERC Advanced Fellowship 249520 GRAMPLUS, and an ESPRC PhD studentship. We would like to thank Yoav Artzi for helpful discussions.",
    "funding": {
        "defense": 0.0,
        "corporate": 0.0,
        "research agency": 0.0,
        "foundation": 0.0,
        "none": 0.9998975348899081
    },
    "reasoning": "Reasoning: The article does not provide any specific information regarding funding sources for the research presented. Without explicit mention of support from defense, corporate entities, research agencies, foundations, or an indication of no funding, it is not possible to accurately determine the funding sources.",
    "abstract": "We consider the problem of learning factored probabilistic CCG grammars for semantic parsing from data containing sentences paired with logical-form meaning representations. Traditional CCG lexicons list lexical items that pair words and phrases with syntactic and semantic content. Such lexicons can be inefficient when words appear repeatedly with closely related lexical content. In this paper, we introduce factored lexicons, which include both lexemes to model word meaning and templates to model systematic variation in word usage. We also present an algorithm for learning factored CCG lexicons, along with a probabilistic parse-selection model. Evaluations on benchmark datasets demonstrate that the approach learns highly accurate parsers, whose generalization performance benefits greatly from the lexical factoring.",
    "countries": [
        "United Kingdom",
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": 219,
    "year": 2011,
    "month": "July",
    "title": "Lexical Generalization in {CCG} Grammar Induction for Semantic Parsing",
    "values": {
        "building on past work": "In this paper, we introduce factored lexicons, which include both lexemes to model word meaning and templates to model systematic variation in word usage. We also present an algorithm for learning factored CCG lexicons, along with a probabilistic parse-selection model. Evaluations on benchmark datasets demonstrate that the approach learns highly accurate parsers, whose generalization performance benefits greatly from the lexical factoring. We develop a factored lexicon that captures this insight by distinguishing lexemes, which pair words with logical constants, from lexical templates, which map lexemes to full lexical items. We extend a line of research that has addressed this problem by developing CCG grammar induction techniques. Therefore it should be represented once and applied to a small set of basic lexical units. We develop a factored lexicon that captures this insight by distinguishing lexemes, which pair words with logical constants, from lexical templates, which map lexemes to full lexical items. Instead, we model them with hidden variables and develop an online learning approach that simultaneously estimates the parameters of a log-linear parsing model, while inducing the factored lexicon.",
        "performance": "On the Atis development set, FUBL outperforms ZC07 by 7.5% of recall but on the Atis test set FUBL lags ZC07 by 2%. The reasons for this discrepancy are not clear, however, it is possible that the syntactic constructions found in the Atis test set do not exhibit the same degree of variation as those seen in the development set. This would negate the need for the very general lexicon learnt by FUBL. Across the evaluations, despite achieving high recall, FUBL achieves significantly lower precision than ZC07 and \u03bb -WASP. This illustrates the tradeoff from having a very general model of proposing lexical structure. With the ability to skip unseen words, FUBL returns a parse for all of the Atis test sentences, since the factored lexicons we are learning can produce a very large number of lexical items. These parses are, however, not always correct. In the future, it will also be important to explore morphological models, to better model variation within the existing lexemes. The factored lexical representation also has significant potential for lexical transfer learning, where we would need to learn new lexemes for each target application, but much of the information in the templates could, potentially, be ported across domains."
    }
}