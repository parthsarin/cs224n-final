{
    "article": "We propose CMSMs, a novel type of generic compositional models for syntactic and semantic aspects of natural language, based on matrix multiplication. We argue for the structural and cognitive plausibility of this model and show that it is able to cover and combine various common compositional NLP approaches ranging from statistical word space models to symbolic grammar formalisms. Introduction In computational linguistics and information retrieval, Vector Space Models (Salton et al., 1975) and its variations -such as Word Space Models (Sch\u00fctze, 1993) , Hyperspace Analogue to Language (Lund and Burgess, 1996) , or Latent Semantic Analysis (Deerwester et al., 1990 ) -have become a mainstream paradigm for text representation. Vector Space Models (VSMs) have been empirically justified by results from cognitive science (G\u00e4rdenfors, 2000) . They embody the distributional hypothesis of meaning (Firth, 1957) , according to which the meaning of words is defined by contexts in which they (co-)occur. Depending on the specific model employed, these contexts can be either local (the co-occurring words), or global (a sentence or a paragraph or the whole document). Indeed, VSMs proved to perform well in a number of tasks requiring computation of semantic relatedness between words, such as synonymy identification (Landauer and Dumais, 1997), automatic thesaurus construction (Grefenstette, 1994) , semantic priming, and word sense disambiguation (Pad\u00f3 and Lapata, 2007) . Until recently, little attention has been paid to the task of modeling more complex conceptual structures with such models, which constitutes a crucial barrier for semantic vector models on the way to model language (Widdows, 2008 ). An emerging area of research receiving more and more attention among the advocates of distributional models addresses the methods, algorithms, and evaluation strategies for representing compositional aspects of language within a VSM framework. This requires novel modeling paradigms, as most VSMs have been predominantly used for meaning representation of single words and the key problem of common bag-of-words-based VSMs is that word order information and thereby the structure of the language is lost. There are approaches under way to work out a combined framework for meaning representation using both the advantages of symbolic and distributional methods. Clark and Pulman (2007) suggest a conceptual model which unites symbolic and distributional representations by means of traversing the parse tree of a sentence and applying a tensor product for combining vectors of the meanings of words with the vectors of their roles. The model is further elaborated by Clark et al. (2008) . To overcome the aforementioned difficulties with VSMs and work towards a tight integration of symbolic and distributional approaches, we propose a Compositional Matrix-Space Model (CMSM) which employs matrices instead of vectors and makes use of matrix multiplication as the one and only composition operation. The paper is structured as follows: We start by providing the necessary basic notions in linear algebra in Section 2. In Section 3, we give a formal account of the concept of compositionality, introduce our model, and argue for the plausibility of CMSMs in the light of structural and cognitive considerations. Section 4 shows how common VSM approaches to compositionality can be captured by CMSMs while Section 5 illustrates the capabilities of our model to likewise cover symbolic approaches. In Section 6, we demonstrate how several CMSMs can be combined into one model. We provide an overview of related work in Section 7 before we conclude and point out avenues for further research in Section 8. Preliminaries In this section, we recap some aspects of linear algebra to the extent needed for our considerations about CMSMs. For a more thorough treatise we refer the reader to a linear algebra textbook (such as Strang (1993) ). Vectors. Given a natural number n, an ndimensional vector v over the reals can be seen as a list (or tuple) containing n real numbers r 1 , . . . , r n \u2208 R, written v = (r 1 r 2 \u2022 \u2022 \u2022 r n ). Vectors will be denoted by lowercase bold font letters and we will use the notation v(i) to refer to the ith entry of vector v. As usual, we write R n to denote the set of all n-dimensional vectors with real entries. Vectors can be added entrywise, i.e., (r 1 \u2022 \u2022 \u2022 r n ) + (r 1 \u2022 \u2022 \u2022 r n ) = (r 1 + r 1 \u2022 \u2022 \u2022 r n +r n ). Likewise, the entry-wise product (also known as Hadamard product) is defined by (r 1 \u2022 \u2022 \u2022 r n ) (r 1 \u2022 \u2022 \u2022 r n ) = (r 1 \u2022r 1 \u2022 \u2022 \u2022 r n \u2022r n ). Matrices. Given two real numbers n, m, an n\u00d7m matrix over the reals is an array of real numbers with n rows and m columns. We will use capital letters to denote matrices and, given a matrix M we will write M(i, j) to refer to the entry in the ith row and the jth column: M = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed M(1, 1) M(1, 2) \u2022 \u2022 \u2022 M(1, j) \u2022 \u2022 \u2022 M(1, m) M(2, 1) M(2, 2) . . . . . . . . . M(i, 1) M(i, j) . . . . . . . . . M(n, 1) M(1, 2) \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 M(n, m) \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 The set of all n \u00d7 m matrices with real number entries is denoted by R n\u00d7m . Obviously, mdimensional vectors can be seen as 1 \u00d7 m matrices. A matrix can be transposed by exchanging columns and rows: given the n \u00d7 m matrix M, its transposed version M T is a m \u00d7 n matrix defined by M T (i, j) = M( j, i). Linear Mappings. Beyond being merely arraylike data structures, matrices correspond to certain type of functions, so-called linear mappings, having vectors as in-and output. More precisely, an n \u00d7 m matrix M applied to an m-dimensional vector v yields an n-dimensional vector v (written: vM = v ) according to v (i) = m j=1 v( j) \u2022 M(i, j) Linear mappings can be concatenated, giving rise to the notion of standard matrix multiplication: we write M 1 M 2 to denote the matrix that corresponds to the linear mapping defined by applying first M 1 and then M 2 . Formally, the matrix product of the n \u00d7 l matrix M 1 and the l \u00d7 m matrix M 2 is an n \u00d7 m matrix M = M 1 M 2 defined by M(i, j) = l k=1 M 1 (i, k) \u2022 M 2 (k, j) Note that the matrix product is associative (i.e., (M 1 M 2 )M 3 = M 1 (M 2 M 3 ) always holds, thus parentheses can be omitted) but not commutative (M 1 M 2 = M 2 M 1 does not hold in general, i.e., the order matters). Permutations. Given a natural number n, a permutation on {1 . . . n} is a bijection (i.e., a mapping that is one-to-one and onto) \u03a6 : {1 . . . n} \u2192 {1 . . . n}. A permutation can be seen as a \"reordering scheme\" on a list with n elements: the element at position i will get the new position \u03a6(i) in the reordered list. Likewise, a permutation can be applied to a vector resulting in a rearrangement of the entries. We write \u03a6 n to denote the permutation corresponding to the n-fold application of \u03a6 and \u03a6 \u22121 to denote the permutation that \"undoes\" \u03a6. Given a permutation \u03a6, the corresponding permutation matrix M \u03a6 is defined by M \u03a6 (i, j) = 1 if \u03a6( j) = i, 0 otherwise. Then, obviously permuting a vector according to \u03a6 can be expressed in terms of matrix multiplication as well as we obtain for any vector v \u2208 R n : \u03a6(v) = vM \u03a6 Likewise, iterated application (\u03a6 n ) and the inverses \u03a6 \u2212n carry over naturally to the corresponding notions in matrices. Compositionality and Matrices The underlying principle of compositional semantics is that the meaning of a sentence (or a word phrase) can be derived from the meaning of its constituent tokens by applying a composition operation. More formally, the underlying idea can be described as follows: given a mapping [[ \u2022 ]] : \u03a3 \u2192 S from a set of tokens (words) \u03a3 into some semantical space S (the elements of which we will simply call \"meanings\"), we find a semantic composition operation : S * \u2192 S mapping sequences of meanings to meanings such that the meaning of a sequence of tokens \u03c3 1 \u03c3 2 . . . \u03c3 n can be obtained by applying to the sequence [[\u03c3 1 ]][[\u03c3 2 ]] . . . [[\u03c3 n ]]. This situation qualifies [[ \u2022 ]] as a homomorphism between (\u03a3 * , \u2022) and (S, ) and can be displayed as follows: \u03c3 1 [[ \u2022 ]] concatenation \u2022 ' ' \u03c3 2 [[ \u2022 ]] ( ( \u2022 \u2022 \u2022 \u03c3 n [[ \u2022 ]] ) ) \u03c3 1 \u03c3 2 . . . \u03c3 n [[ \u2022 ]] [[\u03c3 1 ]] composition 6 6 [[\u03c3 2 ]] 5 5 \u2022 \u2022 \u2022 [[\u03c3 n ]] 5 5 [[\u03c3 1 \u03c3 2 . . . \u03c3 n ]] A great variety of linguistic models are subsumed by this general idea ranging from purely symbolic approaches (like type systems and categorial grammars) to rather statistical models (like vector space and word space models). At the first glance, the underlying encodings of word semantics as well as the composition operations differ significantly. However, we argue that a great variety of them can be incorporated -and even freely inter-combined -into a unified model where the semantics of simple tokens and complex phrases is expressed by matrices and the composition operation is standard matrix multiplication. More precisely, in Compositional Marix-Space Models, we have S = R n\u00d7n , i.e. the semantical space consists of quadratic matrices, and the composition operator coincides with matrix multiplication as introduced in Section 2. In the following, we will provide diverse arguments illustrating that CMSMs are intuitive and natural. Algebraic Plausibility -Structural Operation Properties Most linear-algebra-based operations that have been proposed to model composition in language models are associative and commutative. Thereby, they realize a multiset (or bag-of-words) semantics that makes them insensitive to structural differences of phrases conveyed through word order. While associativity seems somewhat acceptable and could be defended by pointing to the streamlike, sequential nature of language, commutativity seems way less justifiable, arguably. As mentioned before, matrix multiplication is associative but non-commutative, whence we propose it as more adequate for modeling compositional semantics of language. Neurological Plausibility -Progression of Mental States From a very abstract and simplified perspective, CMSMs can also be justified neurologically. Suppose the mental state of a person at one specific moment in time can be encoded by a vector v of numerical values; one might, e.g., think of the level of excitation of neurons. Then, an external stimulus or signal, such as a perceived word, will result in a change of the mental state. Thus, the external stimulus can be seen as a function being applied to v yielding as result the vector v that corresponds to the persons mental state after receiving the signal. Therefore, it seems sensible to associate with every signal (in our case: token \u03c3) a respective function (a linear mapping, represented by a matrix M = [[\u03c3]] that maps mental states to mental states (i.e. vectors v to vectors v = vM). Consequently, the subsequent reception of inputs \u03c3, \u03c3 associated to matrices M and M will transform a mental vector v into the vector (vM)M which by associativity equals v(MM ). Therefore, MM represents the mental state transition triggered by the signal sequence \u03c3\u03c3 . Naturally, this consideration carries over to sequences of arbitrary length. This way, abstracting from specific initial mental state vectors, our semantic space S can be seen as a function space of mental transformations represented by matrices, whereby matrix multiplication realizes subsequent execution of those transformations triggered by the input token sequence. Psychological Plausibility -Operations on Working Memory A structurally very similar argument can be provided on another cognitive explanatory level. There have been extensive studies about human language processing justifying the hypothesis of a working memory (Baddeley, 2003) . The mental state vector can be seen as representation of a person's working memory which gets transformed by external input. Note that matrices can perform standard memory operations such as storing, deleting, copying etc. For instance, the matrix M copy(k,l) defined by M copy(k,l) (i, j) = 1 if i = j l or i = k, j = l, 0 otherwise. applied to a vector v, will copy its kth entry to the lth position. This mechanism of storage and insertion can, e.g., be used to simulate simple forms of anaphora resolution. CMSMs Encode Vector Space Models In VSMs numerous vector operations have been used to model composition (Widdows, 2008) , some of the more advanced ones being related to quantum mechanics. We show how these common composition operators can be modeled by CMSMs. 1 Given a vector composition operation : R n \u00d7R n \u2192 R n , we provide a surjective function \u03c8 : R n \u2192 R n \u00d7n that translates the vector representation into a matrix representation in a way such that for all v 1 , . . . v k \u2208 R n holds v 1 . . . v k = \u03c8 \u22121 (\u03c8 (v 1 ) . . . \u03c8 (v k )) where \u03c8 (v i )\u03c8 (v j ) denotes matrix multiplication of the matrices assigned to v i and v j . Vector Addition As a simple basic model for semantic composition, vector addition has been proposed. Thereby, tokens \u03c3 get assigned (usually high-dimensional) vectors v \u03c3 and to obtain a representation of the meaning of a phrase or a sentence w = \u03c3 1 . . . \u03c3 k , the vector sum of the vectors associated to the constituent tokens is calculated: v w = k i=1 v \u03c3 i . 1 In our investigations we will focus on VSM composition operations which preserve the format (i.e. which yield a vector of the same dimensionality), as our notion of compositionality requires models that allow for iterated composition. In particular, this rules out dot product and tensor product. However the convolution product can be seen as a condensed version of the tensor product. This kind of composition operation is subsumed by CMSMs; suppose in the original model, a token \u03c3 gets assigned the vector v \u03c3 , then by defining \u03c8 + (v \u03c3 ) = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 1 \u2022 \u2022 \u2022 0 0 . . . . . . . . . 0 1 0 v \u03c3 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 (mapping n-dimensional vectors to (n + 1) \u00d7 (n + 1) matrices), we obtain for a phrase w = \u03c3 1 . . . \u03c3 k \u03c8 \u22121 + (\u03c8 + (v \u03c3 1 ) . . . \u03c8 + (v \u03c3 k )) = v \u03c3 1 + . . . + v \u03c3 k = v w . Proof. By induction on k. For k = 1, we have v w = v \u03c3 = \u03c8 \u22121 + (\u03c8 + (v \u03c3 1 )). For k > 1, we have \u03c8 \u22121 + (\u03c8 + (v \u03c3 1 ) . . . \u03c8 + (v \u03c3 k \u22121 )\u03c8 + (v \u03c3 k )) = \u03c8 \u22121 + (\u03c8 + (\u03c8 \u22121 + (\u03c8 + (v \u03c3 1 ) . . . \u03c8 + (v \u03c3 k \u22121 )))\u03c8 + (v \u03c3 k )) i.h. = \u03c8 \u22121 + (\u03c8 + ( k\u22121 i=1 v \u03c3 i )\u03c8 + (v \u03c3 k )) = \u03c8 \u22121 + \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 1 \u2022 \u2022 \u2022 0 0 . . . . . . . . . 0 1 0 k\u22121 i=1 v \u03c3 i (1)\u2022 \u2022 \u2022 k\u22121 i=1 v \u03c3 i (n) 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 1 \u2022 \u2022 \u2022 0 0 . . . . . . . . . 0 1 0 v \u03c3 k (1)\u2022 \u2022 \u2022 v \u03c3 k (n) 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 = \u03c8 \u22121 + \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 1 \u2022 \u2022 \u2022 0 0 . . . . . . . . . 0 1 0 k i=1 v \u03c3 i (1)\u2022 \u2022 \u2022 k i=1 v \u03c3 i (n) 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 = k i=1 v \u03c3 i q.e.d. 2 Component-wise Multiplication On the other hand, the Hadamard product (also called entry-wise product, denoted by ) has been proposed as an alternative way of semantically composing token vectors. By using a different encoding into matrices, CMSMs can simulate this type of composition operation as well. By letting \u03c8 (v \u03c3 ) = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed v \u03c3 (1) 0 \u2022 \u2022 \u2022 0 0 v \u03c3 (2) . . . . . . 0 0 \u2022 \u2022 \u2022 0 v \u03c3 (n) \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 , we obtain an n \u00d7 n matrix representation for which \u03c8 \u22121 (\u03c8 (v \u03c3 1 ) . . . \u03c8 (v \u03c3 k )) = v \u03c3 1 . . . v \u03c3 k = v w . Holographic Reduced Representations Holographic reduced representations as introduced by Plate (1995) can be seen as a refinement of convolution products with the benefit of preserving dimensionality: given two vectors v 1 , v 2 \u2208 R n , their circular convolution product v 1 v 2 is again an n-dimensional vector v 3 defined by v 3 (i + 1) = n\u22121 k=0 v 1 (k + 1) \u2022 v 2 ((i \u2212 k mod n) + 1) for 0 \u2264 i \u2264 n\u22121. Now let \u03c8 (v) be the n\u00d7n matrix M with M(i, j) = v(( j \u2212 i mod n) + 1). In the 3-dimensional case, this would result in \u03c8 (v(1) v(2) v(3)) = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed v(1) v(2) v(3) v(3) v(1) v(2) v(2) v(3) v(1) \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 Then, it can be readily checked that \u03c8 \u22121 (\u03c8 (v \u03c3 1 ) . . . \u03c8 (v \u03c3 k )) = v \u03c3 1 . . . v \u03c3 k = v w . Permutation-based Approaches Sahlgren et al. ( 2008 ) use permutations on vectors to account for word order. In this approach, given a token \u03c3 m occurring in a sentence w = \u03c3 1 . . . \u03c3 k with predefined \"uncontextualized\" vectors v \u03c3 1 . . . v \u03c3 k , we compute the contextualized vector v w,m for \u03c3 m by v w,m = \u03a6 1\u2212m (v \u03c3 1 ) + . . . + \u03a6 k\u2212m (v \u03c3 k ), which can be equivalently transformed into \u03a6 1\u2212m v \u03c3 1 + \u03a6(. . . + \u03a6(v \u03c3 k\u22121 + (\u03a6(v \u03c3 k ))) . . .) . Note that the approach is still token-centered, i.e., a vector representation of a token is endowed with contextual representations of surrounding tokens. Nevertheless, this setting can be transferred to a CMSM setting by recording the position of the focused token as an additional parameter. Now, by assigning every v \u03c3 the matrix \u03c8 \u03a6 (v \u03c3 ) = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 0 M \u03a6 . . . 0 v \u03c3 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 we observe that for M w,m := (M \u2212 \u03a6 ) m\u22121 \u03c8 \u03a6 (v \u03c3 1 ) . . . \u03c8 \u03a6 (v \u03c3 k ) we have M w,m = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 0 M k\u2212m \u03a6 . . . 0 v w,m 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 , whence \u03c8 \u22121 \u03a6 (M \u2212 \u03a6 ) m\u22121 \u03c8 \u03a6 (v \u03c3 1 ) . . . \u03c8 \u03a6 (v \u03c3 k ) = v w,m . CMSMs Encode Symbolic Approaches Now we will elaborate on symbolic approaches to language, i.e., discrete grammar formalisms, and show how they can conveniently be embedded into CMSMs. This might come as a surprise, as the apparent likeness of CMSMs to vector-space models may suggest incompatibility to discrete settings. Group Theory Group theory and grammar formalisms based on groups and pre-groups play an important role in computational linguistics (Dymetman, 1998; Lambek, 1958) . From the perspective of our compositionality framework, those approaches employ a group (or pre-group) (G, \u2022) as semantical space S where the group operation (often written as multiplication) is used as composition operation . According Cayley's Theorem (Cayley, 1854) , every group G is isomorphic to a permutation group on some set S . Hence, assuming finiteness of G and consequently S , we can encode group-based grammar formalisms into CMSMs in a straightforward way by using permutation matrices of size |S | \u00d7 |S |. Regular Languages Regular languages constitute a basic type of languages characterized by a symbolic formalism. We will show how to select the assignment [[ \u2022 ]] for a CMSM such that the matrix associated to a token sequence exhibits whether this sequence belongs to a given regular language, that is if it is accepted by a given finite state automaton. As usual (cf. e.g., Hopcroft and Ullman (1979)) we define a nondeterministic finite automaton A = (Q, \u03a3, \u2206, Q I , Q F ) with Q = {q 0 , . . . , q n\u22121 } being the set of states, \u03a3 the input alphabet, \u2206 \u2286 Q\u00d7\u03a3\u00d7Q the transition relation, and Q I and Q F being the sets of initial and final states, respectively. Then we assign to every token \u03c3 \u2208 \u03a3 the n \u00d7 n matrix [[\u03c3]] = M with M(i, j) = 1 if (q i , \u03c3, q j ) \u2208 \u2206, 0 otherwise. Hence essentially, the matrix M encodes all state transitions which can be caused by the input \u03c3. Likewise, for a word w = \u03c3 1 . . . \u03c3 k \u2208 \u03a3 * , the matrix M w := [[\u03c3 1 ]] . . . [[\u03c3 k ] ] will encode all state transitions mediated by w. Finally, if we define vectors v I and v F by v I (i) = 1 if q i \u2208 Q I , 0 otherwise, v F (i) = 1 if q i \u2208 Q F , 0 otherwise, then we find that w is accepted by A exactly if v I M w v T F \u2265 1. The General Case: Matrix Grammars Motivated by the above findings, we now define a general notion of matrix grammars as follows: Definition 1 Let \u03a3 be an alphabet. A matrix grammar M of degree n is defined as the pair [[ \u2022 ]], AC where [[ \u2022 ]] is a mapping from \u03a3 to n\u00d7n matrices and AC = { v 1 , v 1 , r 1 , . . . , v m , v m , r m } with v 1 , v 1 , . . . , v m , v m \u2208 R n and r 1 , . . . , r m \u2208 R is a finite set of acceptance conditions. The language generated by M (denoted by L(M)) contains a token sequence \u03c3 1 . . . \u03c3 k \u2208 \u03a3 * exactly if v i [[\u03c3 1 ]] . . . [[\u03c3 k ]]v T i \u2265 r i for all i \u2208 {1, . . . , m}. We will call a language L matricible if L = L(M) for some matrix grammar M. Then, the following proposition is a direct consequence from the preceding section. Proposition 1 Regular languages are matricible. However, as demonstrated by the subsequent examples, also many non-regular and even noncontext-free languages are matricible, hinting at the expressivity of our grammar model. Example 1 We define M [[ \u2022 ]], AC with \u03a3 = {a, b, c} [[a]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 3 0 0 0 0 1 0 0 0 0 3 0 0 0 0 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 [[b]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 3 0 0 0 0 1 0 0 0 1 3 0 1 0 0 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 [[c]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 3 0 0 0 0 1 0 0 0 2 3 0 2 0 0 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 AC = { (0 0 1 1), (1 \u22121 0 0), 0 , (0 0 1 1), (\u22121 1 0 0), 0 } Then L(M) contains exactly all palindromes from {a, b, c} * , i.e., the words d 1 d 2 . . . d n\u22121 d n for which d 1 d 2 . . . d n\u22121 d n = d n d n\u22121 . . . d 2 d 1 . Example 2 We define M = [[ \u2022 ]], AC with \u03a3 = {a, b, c} [[a]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 1 0 0 0 0 0 0 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 [[b]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 [[c]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 0 2 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 AC = { (1 0 0 0 0 0), (0 0 1 0 0 0), 1 , (0 0 0 1 1 0), (0 0 0 1 \u22121 0), 0 , (0 0 0 0 1 1), (0 0 0 0 1 \u22121), 0 , (0 0 0 1 1 0), (0 0 0 \u22121 0 1), 0 } Then L(M) is the (non-context-free) language {a m b m c m | m > 0}. The following properties of matrix grammars and matricible language are straightforward. Proposition 2 All languages characterized by a set of linear equations on the letter counts are matricible. Proof. Suppose \u03a3 = {a 1 , . . . a n }. Given a word w, let x i denote the number of occurrences of a i in w. A linear equation on the letter counts has the form k 1 x 1 + . . . + k n x n = k k, k 1 , . . . , k n \u2208 R Now define [[a i ]] = \u03c8 + (e i ) , where e i is the ith unit vector, i.e. it contains a 1 at he ith position and 0 in all other positions. Then, it is easy to see that w will be mapped to M = \u03c8 + (x 1 \u2022 \u2022 \u2022 x n ). Due to the fact that e n+1 M = (x 1 \u2022 \u2022 \u2022 x n 1) we can enforce the above linear equation by defining the acceptance conditions AC = { e n+1 , (k 1 . . . k n \u2212 k), 0 , \u2212e n+1 , (k 1 . . . k n \u2212 k), 0 }. q.e.d. Proposition 3 The intersection of two matricible languages is again a matricible language. Proof. This is a direct consequence of the considerations in Section 6 together with the observation, that the new set of acceptance conditions is trivially obtained from the old ones with adapted dimensionalities. q.e.d. Note that the fact that the language {a m b m c m | m > 0} is matricible, as demonstrated in Example 2 is a straightforward consequence of the Propositions 1, 2, and 3, since the language in question can be described as the intersection of the regular language a + b + c + with the language characterized by the equations x a \u2212 x b = 0 and x b \u2212 x c = 0. We proceed by giving another account of the expressivity of matrix grammars by showing undecidability of the emptiness problem. Proposition 4 The problem whether there is a word which is accepted by a given matrix grammar is undecidable. Proof. The undecidable Post correspondence problem (Post, 1946 ) is described as follows: given two lists of words u 1 , . . . , u n and v 1 , . . . , v n over some alphabet \u03a3 , is there a sequence of numbers h 1 , . . . , h m (1 \u2264 h j \u2264 n) such that u h 1 . . . u h m = v h 1 . . . v h m ? We now reduce this problem to the emptiness problem of a matrix grammar. W.l.o.g., let \u03a3 = {a 1 , . . . , a k }. We define a bijection # from \u03a3 * to N by #(a n 1 a n 2 . . . a n l ) = l i=1 (n i \u2212 1) \u2022 k (l\u2212i) Note that this is indeed a bijection and that for w 1 , w 2 \u2208 \u03a3 * , we have #(w 1 w 2 ) = #(w 1 ) \u2022 k |w 2 | + #(w 2 ). Now, we define M as follows: \u03a3 = {b 1 , . . . b n } [[b i ]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed k |u i | 0 0 0 k |v i | 0 #(u i ) #(v i ) 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 AC = { (0 0 1), (1 \u2212 1 0), 0 , (0 0 1), (\u22121 1 0), 0 } Using the above fact about # and a simple induction on m, we find that [[a h 1 ]] . . . [[a h m ]] = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed k |u h 1 ... u hm | 0 0 0 k |v h 1 ... v hm | 0 #(u h 1 . . .u h m ) #(v h 1 . . .v h m ) 1 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 Evaluating the two acceptance conditions, we find them satisfied exactly if #(u h 1 . . . u h m ) = #(v h 1 . . . v h m ). Since # is a bijection, this is the case if and only if u h 1 . . . u h m = v h 1 . . . v h m . Therefore M accepts b h 1 . . . b h m exactly if the sequence h 1 , . . . , h m is a solution to the given Post Correspondence Problem. Consequently, the question whether such a solution exists is equivalent to the question whether the language L(M) is nonempty. q.e.d. These results demonstrate that matrix grammars cover a wide range of formal languages. Nevertheless some important questions remain open and need to be clarified next: Are all context-free languages matricible? We conjecture that this is not the case. 3 Note that this question is directly related to the question whether Lambek calculus can be modeled by matrix grammars. Are matricible languages closed under concatenation? That is: given two arbitrary matricible languages L 1 , L 2 , is the language L = {w 1 w 2 | w 1 \u2208 L 1 , w 2 \u2208 L 2 } again matricible? Being a property common to all language types from the Chomsky hierarchy, answering this question is surprisingly non-trivial for matrix grammars. In case of a negative answer to one of the above questions it might be worthwhile to introduce an extended notion of context grammars to accommodate those desirable properties. For example, allowing for some nondeterminism by associating several matrices to one token would ensure closure under concatenation. How do the theoretical properties of matrix grammars depend on the underlying algebraic structure? Remember that we considered matrices containing real numbers as entries. In general, matrices can be defined on top of any mathematical structure that is (at least) a semiring (Golan, 1992) . Examples for semirings are the natural numbers, boolean algebras, or polynomials with natural number coefficients. Therefore, it would be interesting to investigate the influence of the choice of the underlying semiring on the properties of the matrix grammars -possibly nonstandard structures turn out to be more appropriate for capturing certain compositional language properties. Combination of Different Approaches Another central advantage of the proposed matrixbased models for word meaning is that several matrix models can be easily combined into one. Again assume a sequence w = \u03c3 1 . . . \u03c3 k of tokens with associated matrices [[\u03c3 1 ]], . . . , [[\u03c3 k ]] according to one specific model and matrices ([\u03c3 1 ]), . . . , ([\u03c3 k ]) according to another. Then we can combine the two models into one {[ \u2022 ]} by assigning to \u03c3 i the matrix {[\u03c3 i ]} = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 0 \u2022 \u2022 \u2022 0 [[\u03c3 i ]] . . . . . . 0 0 0 \u2022 \u2022 \u2022 0 . . . . . . ([\u03c3 i ]) 0 0 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 By doing so, we obtain the correspondence {[\u03c3 1 ]} . . . {[\u03c3 k ]} = \uf8eb \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ec \uf8ed 0 \u2022 \u2022 \u2022 0 [[\u03c3 1 ]] . . . [[\u03c3 k ]] . . . . . . 0 0 0 \u2022 \u2022 \u2022 0 . . . . . . ([\u03c3 1 ]) . . . ([\u03c3 k ]) 0 0 \uf8f6 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f7 \uf8f8 In other words, the semantic compositions belonging to two CMSMs can be executed \"in parallel.\" Mark that by providing non-zero entries for the upper right and lower left matrix part, information exchange between the two models can be easily realized. Related Work We are not the first to suggest an extension of classical VSMs to matrices. Distributional models based on matrices or even higher-dimensional arrays have been proposed in information retrieval (Gao et al., 2004; Antonellis and Gallopoulos, 2006) . However, to the best of our knowledge, the approach of realizing compositionality via matrix multiplication seems to be entirely original. Among the early attempts to provide more compelling combinatory functions to capture word order information and the non-commutativity of linguistic compositional operation in VSMs is the work of Kintsch (2001) who is using a more sophisticated addition function to model predicateargument structures in VSMs. Mitchell and Lapata (2008) formulate semantic composition as a function m = f (w 1 , w 2 , R, K) where R is a relation between w 1 and w 2 and K is additional knowledge. They evaluate the model with a number of addition and multiplication operations for vector combination on a sentence similarity task proposed by Kintsch (2001) . Widdows (2008) proposes a number of more advanced vector operations well-known from quantum mechanics, such as tensor product and convolution, to model composition in vector spaces. He shows the ability of VSMs to reflect the relational and phrasal meanings on a simplified analogy task. Giesbrecht (2009) evaluates four vector composition operations (+, , tensor product, convolution) on the task of identifying multi-word units. The evaluation results of the three studies are not conclusive in terms of which vector operation performs best; the different outcomes might be attributed to the underlying word space models; e.g., the models of Widdows (2008) and Giesbrecht (2009) feature dimensionality reduction while that of Mitchell and Lapata (2008) does not. In the light of these findings, our CMSMs provide the benefit of just one composition operation that is able to mimic all the others as well as combinations thereof. Conclusion and Future Work We have introduced a generic model for compositionality in language where matrices are associated with tokens and the matrix representation of a token sequence is obtained by iterated matrix multiplication. We have given algebraic, neurological, and psychological plausibility indications in favor of this choice. We have shown that the proposed model is expressive enough to cover and combine a variety of distributional and symbolic aspects of natural language. This nourishes the hope that matrix models can serve as a kind of lingua franca for compositional models. This having said, some crucial questions remain before CMSMs can be applied in practice: How to acquire CMSMs for large token sets and specific purposes? We have shown the value and expressivity of CMSMs by providing carefully hand-crafted encodings. In practical cases, however, the number of token-to-matrix assignments will be too large for this manual approach. Therefore, methods to (semi-)automatically acquire those assignments from available data are required. To this end, machine learning techniques need to be investigated with respect to their applicability to this task. Presumably, hybrid approaches have to be considered, where parts of the matrix representation are learned whereas others are stipulated in advance guided by external sources (such as lexical information). In this setting, data sparsity may be overcome through tensor methods: given a set T of tokens together with the matrix assignment [[]] : T \u2192 R n\u00d7n , this datastructure can be conceived as a 3dimensional array (also known as tensor) of size n\u00d7n\u00d7|T | wherein the single token-matrices can be found as slices. Then tensor decomposition techniques can be applied in order to find a compact representation, reduce noise, and cluster together similar tokens (Tucker, 1966; Rendle et al., 2009) . First evaluation results employing this approach to the task of free associations are reported by Giesbrecht (2010). How does linearity limit the applicability of CMSMs? In Section 3, we justified our model by taking the perspective of tokens being functions which realize mental state transitions. Yet, using matrices to represent those functions restricts them to linear mappings. Although this restriction brings about benefits in terms of computability and theoretical accessibility, the limitations introduced by this assumption need to be investigated. Clearly, certain linguistic effects (like aposteriori disambiguation) cannot be modeled via linear mappings. Instead, we might need some in-between application of simple nonlinear functions in the spirit of quantum-collapsing of a \"superposed\" mental state (such as the winner takes it all, survival of the top-k vector entries, and so forth). Thus, another avenue of further research is to generalize from the linear approach. Acknowledgements This work was supported by the German Research Foundation (DFG) under the Multipla project (grant 38457858) as well as by the German Federal Ministry of Economics (BMWi) under the project Theseus (number 01MQ07019).",
    "abstract": "We propose CMSMs, a novel type of generic compositional models for syntactic and semantic aspects of natural language, based on matrix multiplication. We argue for the structural and cognitive plausibility of this model and show that it is able to cover and combine various common compositional NLP approaches ranging from statistical word space models to symbolic grammar formalisms.",
    "countries": [
        "Germany"
    ],
    "languages": [
        "German"
    ],
    "numcitedby": "57",
    "year": "2010",
    "month": "July",
    "title": "Compositional Matrix-Space Models of Language"
}