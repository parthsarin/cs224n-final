{
    "article": "It is usually assumed that the kind of noise existing in annotated data is random classification noise. Yet there is evidence that differences between annotators are not always random attention slips but could result from different biases towards the classification categories, at least for the harder-to-decide cases. Under an annotation generation model that takes this into account, there is a hazard that some of the training instances are actually hard cases with unreliable annotations. We show that these are relatively unproblematic for an algorithm operating under the 0-1 loss model, whereas for the commonly used voted perceptron algorithm, hard training cases could result in incorrect prediction on the uncontroversial cases at test time. Introduction It is assumed, often tacitly, that the kind of noise existing in human-annotated datasets used in computational linguistics is random classification noise (Kearns, 1993; Angluin and Laird, 1988) , resulting from annotator attention slips randomly distributed across instances. For example, Osborne (2002) evaluates noise tolerance of shallow parsers, with random classification noise taken to be \"crudely approximating annotation errors.\" It has been shown, both theoretically and empirically, that this type of noise is tolerated well by the commonly used machine learning algorithms (Cohen, 1997; Blum et al., 1996; Osborne, 2002; Reidsma and Carletta, 2008) . Yet this might be overly optimistic. Reidsma and op den Akker (2008) show that apparent differences between annotators are not random slips of attention but rather result from different biases annotators might have towards the classification categories. When training data comes from one annotator and test data from another, the first annotator's biases are sometimes systematic enough for a machine learner to pick them up, with detrimental results for the algorithm's performance on the test data. A small subset of doubly annotated data (for inter-annotator agreement check) and large chunks of singly annotated data (for training algorithms) is not uncommon in computational linguistics datasets; such a setup is prone to problems if annotators are differently biased. 1  Annotator bias is consistent with a number of noise models. For example, it could be that an annotator's bias is exercised on each and every instance, making his preferred category likelier for any instance than in another person's annotations. Another possibility, recently explored by Beigman Klebanov and Beigman (2009) , is that some items are really quite clear-cut for an annotator with any bias, belonging squarely within one particular category. However, some instances -termed hard cases therein -are harder to decide upon, and this is where various preferences and biases come into play. In a metaphor annotation study reported by Beigman Klebanov et al. (2008) , certain markups received overwhelming annotator support when people were asked to validate annotations after a certain time delay. Other instances saw opinions split; moreover, Beigman Klebanov et al. (2008) observed cases where people retracted their own earlier annotations. To start accounting for such annotator behavior, Beigman Klebanov and Beigman (2009) proposed a model where instances are either easy, and then all annotators agree on them, or hard, and then each annotator flips his or her own coin to de-cide on a label (each annotator can have a different \"coin\" reflecting his or her biases). For annotations generated under such a model, there is a danger of hard instances posing as easy -an observed agreement between annotators being a result of all coins coming up heads by chance. They therefore define the expected proportion of hard instances in agreed items as annotation noise. They provide an example from the literature where an annotation noise rate of about 15% is likely. The question addressed in this article is: How problematic is learning from training data with annotation noise? Specifically, we are interested in estimating the degree to which performance on easy instances at test time can be hurt by the presence of hard instances in training data. Definition 1 The hard case bias, \u03c4 , is the portion of easy instances in the test data that are misclassified as a result of hard instances in the training data. This article proceeds as follows. First, we show that a machine learner operating under a 0-1 loss minimization principle could sustain a hard case bias of \u03b8( 1 \u221a N ) in the worst case. Thus, while annotation noise is hazardous for small datasets, it is better tolerated in larger ones. However, 0-1 loss minimization is computationally intractable for large datasets (Feldman et al., 2006; Guruswami and Raghavendra, 2006) ; substitute loss functions are often used in practice. While their tolerance to random classification noise is as good as for 0-1 loss, their tolerance to annotation noise is worse. For example, the perceptron family of algorithms handle random classification noise well (Cohen, 1997) . We show in section 3.4 that the widely used Freund and Schapire (1999) voted perceptron algorithm could face a constant hard case bias when confronted with annotation noise in training data, irrespective of the size of the dataset. Finally, we discuss the implications of our findings for the practice of annotation studies and for data utilization in machine learning. 0-1 Loss Let a sample be a sequence x 1 , . . . , x N drawn uniformly from the d-dimensional discrete cube I d = {\u22121, 1} d with corresponding labels y 1 , . . . , y N \u2208 {\u22121, 1}. Suppose further that the learning algorithm operates by finding a hyperplane (w, \u03c8), w \u2208 R d , \u03c8 \u2208 R, that minimizes the empirical error L(w, \u03c8) = j=1...N [y j \u2212sgn( i=1...d x i j w i \u2212 \u03c8)] 2 . Let there be H hard cases, such that the annotation noise is \u03b3 = H N . 2 Theorem 1 In the worst case configuration of instances a hard case bias of \u03c4 = \u03b8( 1 \u221a N ) cannot be ruled out with constant confidence. Idea of the proof : We prove by explicit construction of an adversarial case. Suppose there is a plane that perfectly separates the easy instances. The \u03b8(N ) hard instances will be concentrated in a band parallel to the separating plane, that is near enough to the plane so as to trap only about \u03b8( \u221a N ) easy instances between the plane and the band (see figure 1 for an illustration). For a random labeling of the hard instances, the central limit theorem shows there is positive probability that there would be an imbalance between +1 and \u22121 labels in favor of \u22121s on the scale of \u221a N , which, with appropriate constants, would lead to the movement of the empirically minimal separation plane to the right of the hard case band, misclassifying the trapped easy cases. Proof : Let v = v(x) = i=1...d x i denote the sum of the coordinates of an instance in I d and take \u03bb e = \u221a d \u2022 F \u22121 ( \u221a \u03b3 \u2022 2 \u2212 d 2 + 1 2 ) and \u03bb h = \u221a d \u2022 F \u22121 (\u03b3 + \u221a \u03b3 \u2022 2 \u2212 d 2 + 1 2 ) , where F (t) is the cumulative distribution function of the normal distribution. Suppose further that instances x j such that \u03bb e < v j < \u03bb h are all and only hard instances; their labels are coinflips. All other instances are easy, and labeled y = y(x) = sgn(v). In this case, the hyperplane 1 \u221a d (1 . . . 1) is the true separation plane for the easy instances, with \u03c8 = 0. Figure 1 shows this configuration. According to the central limit theorem, for d, N large, the distribution of v is well approximated by N (0, \u221a d). If N = c 1 \u2022 2 d , for some 0 < c 1 < 4, the second application of the central limit theorem ensures that, with high probability, about \u03b3N = c 1 \u03b32 d items would fall between \u03bb e and \u03bb h (all hard), and \u221a \u03b3 \u2022 2 \u2212 d 2 N = c 1 \u03b32 d would fall between 0 and \u03bb e (all easy, all labeled +1). Let Z be the sum of labels of the hard cases, Z = i=1...H y i . Applying the central limit theorem a third time, for large N , Z will, with a high probability, be distributed approximately as N (0, \u221a \u03b3N ). This implies that a value as low as \u22122\u03c3 cannot be ruled out with high (say 95%) confidence. Thus, an imbalance of up to 2 \u221a \u03b3N , or of 2 c 1 \u03b32 d , in favor of \u22121s is possible. There are between 0 and \u03bb h about 2 \u221a c 1 \u03b32 d more \u22121 hard instances than +1 hard instances, as opposed to c 1 \u03b32 d easy instances that are all +1. As long as c 1 < 2 \u221a c 1 , i.e. c 1 < 4, the empirically minimal threshold would move to \u03bb h , resulting in a hard case bias of \u03c4 = \u221a \u03b3 \u221a c 1 2 d (1\u2212\u03b3)\u2022c 1 2 d = \u03b8( 1 \u221a N ). To see that this is the worst case scenario, we note that 0-1 loss sustained on \u03b8(N ) hard cases is the order of magnitude of the possible imbalance between \u22121 and +1 random labels, which is \u03b8( \u221a N ). For hard case loss to outweigh the loss on the misclassified easy instances, there cannot be more than \u03b8( \u221a N ) of the latter 2 Note that the proof requires that N = \u03b8(2 d ) namely, that asymptotically the sample includes a fixed portion of the instances. If the sample is asymptotically smaller, then \u03bb e will have to be adjusted such that \u03bb e = \u221a d \u2022 F \u22121 (\u03b8( 1 \u221a N ) + 1 2 ). According to theorem 1, for a 10K dataset with 15% hard case rate, a hard case bias of about 1% cannot be ruled out with 95% confidence. Theorem 1 suggests that annotation noise as defined here is qualitatively different from more malicious types of noise analyzed in the agnostic learning framework (Kearns and Li, 1988; Haussler, 1992; Kearns et al., 1994) , where an adver-sary can not only choose the placement of the hard cases, but also their labels. In worst case, the 0-1 loss model would sustain a constant rate of error due to malicious noise, whereas annotation noise is tolerated quite well in large datasets. Voted Perceptron Freund and Schapire (1999) describe the voted perceptron. This algorithm and its many variants are widely used in the computational linguistics community (Collins, 2002a; Collins and Duffy, 2002; Collins, 2002b; Collins and Roark, 2004; Henderson and Titov, 2005; Viola and Narasimhan, 2005; Cohen et al., 2004; Carreras et al., 2005; Shen and Joshi, 2005; Ciaramita and Johnson, 2003) . In this section, we show that the voted perceptron can be vulnerable to annotation noise. The algorithm is shown below. Algorithm 1 Voted Perceptron Training Input: a labeled training set (x1, y1), . . . , (xN , yN ) Output: a list of perceptrons w1, . . . , wN Initialize: t \u2190 0; w1 \u2190 0; \u03c81 \u2190 0 for t = 1 . . . N do \u0177t \u2190 sign( wt, xt + \u03c8t) wt+1 \u2190 wt + y t \u2212\u0177 t 2 \u2022 xt \u03c8t+1 \u2190 \u03c8t + y t \u2212\u0177 t 2 \u2022 wt, xt end for Forecasting Input: a list of perceptrons w1, . . . , wN an unlabeled instance x Output: A forecasted label y \u0177 \u2190 P N t=1 sign( wt, xt + \u03c8t) y \u2190 sign(\u0177) The voted perceptron algorithm is a refinement of the perceptron algorithm (Rosenblatt, 1962; Minsky and Papert, 1969) . Perceptron is a dynamic algorithm; starting with an initial hyperplane w 0 , it passes repeatedly through the labeled sample. Whenever an instance is misclassified by w t , the hyperplane is modified to adapt to the instance. The algorithm terminates once it has passed through the sample without making any classification mistakes. The algorithm terminates iff the sample can be separated by a hyperplane, and in this case the algorithm finds a separating hyperplane. Novikoff (1962) gives a bound on the number of iterations the algorithm goes through before termination, when the sample is separable by a margin. The perceptron algorithm is vulnerable to noise, as even a little noise could make the sample inseparable. In this case the algorithm would cycle indefinitely never meeting termination conditions, w t would obtain values within a certain dynamic range but would not converge. In such setting, imposing a stopping time would be equivalent to drawing a random vector from the dynamic range. Freund and Schapire (1999) extend the perceptron to inseparable samples with their voted perceptron algorithm and give theoretical generalization bounds for its performance. The basic idea underlying the algorithm is that if the dynamic range of the perceptron is not too large then w t would classify most instances correctly most of the time (for most values of t). Thus, for a sample x 1 , . . . , x N the new algorithm would keep track of w 0 , . . . , w N , and for an unlabeled instance x it would forecast the classification most prominent amongst these hyperplanes. The bounds given by Freund and Schapire (1999) depend on the hinge loss of the dataset. In section 3.2 we construct a difficult setting for this algorithm. To prove that voted perceptron would suffer from a constant hard case bias in this setting using the exact dynamics of the perceptron is beyond the scope of this article. Instead, in section 3.3 we provide a lower bound on the hinge loss for a simplified model of the perceptron algorithm dynamics, which we argue would be a good approximation to the true dynamics in the setting we constructed. For this simplified model, we show that the hinge loss is large, and the bounds in Freund and Schapire (1999) cannot rule out a constant level of error regardless of the size of the dataset. In section 3.4 we study the dynamics of the model and prove that \u03c4 = \u03b8(1) for the adversarial setting. Hinge Loss Definition 2 The hinge loss of a labeled instance (x, y) with respect to hyperplane (w, \u03c8) and margin \u03b4 > 0 is given by \u03b6 = \u03b6(\u03c8, \u03b4) = max(0, \u03b4 \u2212 y \u2022 ( w, x \u2212 \u03c8)). \u03b6 measures the distance of an instance from being classified correctly with a \u03b4 margin. Figure 2 shows examples of hinge loss for various data points. Theorem 2 (Freund and Schapire (1999) ) After one pass on the sample, the probability that the voted perceptron algorithm does not predict correctly the label of a test instance x N +1 is bounded by 2 N +1 E N +1 d+D \u03b4 2 where D = D(w, \u03c8, \u03b4) = N i=1 \u03b6 2 i . This result is used to explain the convergence of weighted or voted perceptron algorithms (Collins, 2002a) . It is useful as long as the expected value of D is not too large. We show that in an adversarial setting of the annotation noise D is large, hence these bounds are trivial. Adversarial Annotation Noise Let a sample be a sequence x 1 , . . . , x N drawn uniformly from I d with y 1 , . . . , y N \u2208 {\u22121, 1}. Easy cases are labeled y = y(x) = sgn(v) as before, with v = v(x) = i=1...d x i . The true separation plane for the easy instances is w * = 1 \u221a d (1 . . . 1), \u03c8 * = 0. Suppose hard cases are those where v(x) > c 1 \u221a d, where c 1 is chosen so that the hard instances account for \u03b3N of all instances. 3  Figure 3 shows this setting. Lower Bound on Hinge Loss In the simplified case, we assume that the algorithm starts training with the hyperplane w 0 = w * = 1 \u221a d (1 . . . 1), and keeps it throughout the training, only updating \u03c8. In reality, each hard instance can be decomposed into a component that is parallel to w * , and a component that is orthogonal to it. The expected contribution of the orthogonal component to the algorithm's update will be positive due to the systematic positioning of the hard cases, while the contributions of the parallel components are expected to cancel out due to the symmetry of the hard cases around the main diagonal that is orthogonal to w * . Thus, while w t will not necessarily parallel w * , it will be close to parallel for most t > 0. The simplified case is thus a good approximation of the real case, and the bound we obtain is expected to hold for the real case as well. For any initial value \u03c8 0 < 0 all misclassified instances are labeled \u22121 and classified as +1, hence the update will increase \u03c8 0 , and reach 0 soon enough. We can therefore assume that \u03c8 t \u2265 0 for any t > t 0 where t 0 N . Lemma 3 For any t > t 0 , there exist \u03b1 = \u03b1(\u03b3, T ) > 0 such that E(\u03b6 2 ) \u2265 \u03b1 \u2022 \u03b4. Proof : For \u03c8 \u2265 0 there are two main sources of hinge loss: easy +1 instances that are classified as \u22121, and hard -1 instances classified as +1. These correspond to the two components of the following sum (the inequality is due to disregarding the loss incurred by a correct classification with too wide a margin): E(\u03b6 2 ) \u2265 [\u03c8] l=0 1 2 d d l ( \u03c8 \u221a d \u2212 l \u221a d + \u03b4) 2 + 1 2 d l=c 1 \u221a d 1 2 d d l ( l \u221a d \u2212 \u03c8 \u221a d + \u03b4) 2 Let 0 < T < c 1 be a parameter. For \u03c8 > T \u221a d, misclassified easy instances dominate the loss: E(\u03b6 2 ) \u2265 [\u03c8] l=0 1 2 d d l ( \u03c8 \u221a d \u2212 l \u221a d + \u03b4) 2 \u2265 [T \u221a d] l=0 1 2 d d l ( T \u221a d \u221a d \u2212 l \u221a d + \u03b4) 2 \u2265 T \u221a d l=0 1 2 d d l (T \u2212 l \u221a d + \u03b4) 2 \u2265 1 \u221a 2\u03c0 T 0 (T + \u03b4 \u2212 t) 2 e \u2212t 2 /2 dt = H T (\u03b4) The last inequality follows from a normal approximation of the binomial distribution (see, for example, Feller (1968) ). For 0 \u2264 \u03c8 \u2264 T \u221a d, misclassified hard cases dominate: E(\u03b6 2 ) \u2265 1 2 d l=c 1 \u221a d 1 2 d d l ( l \u221a d \u2212 \u03c8 \u221a d + \u03b4) 2 \u2265 1 2 d l=c 1 \u221a d 1 2 d d l ( l \u221a d \u2212 T \u221a d \u221a d + \u03b4) 2 \u2265 1 2 \u2022 1 \u221a 2\u03c0 \u221e \u03a6 \u22121 (\u03b3) (t \u2212 T + \u03b4) 2 e \u2212t 2 /2 dt = H \u03b3 (\u03b4) where \u03a6 \u22121 (\u03b3) is the inverse of the normal distribution density. Thus E(\u03b6 2 ) \u2265 min{H T (\u03b4), H \u03b3 (\u03b4)}, and there exists \u03b1 = \u03b1(\u03b3, T ) > 0 such that min{H T (\u03b4), H \u03b3 (\u03b4)} \u2265 \u03b1 \u2022 \u03b4 2 Corollary 4 The bound in theorem 2 does not converge to zero for large N . We recall that Freund and Schapire (1999) bound is proportional to D 2 = N i=1 \u03b6 2 i . It follows from lemma 3 that D 2 = \u03b8(N ), hence the bound is in- effective. Lower Bound on \u03c4 for Voted Perceptron Under Simplified Dynamics Corollary 4 does not give an estimate on the hard case bias. Indeed, it could be that w t = w * for almost every t. There would still be significant hinge in this case, but the hard case bias for the voted forecast would be zero. To assess the hard case bias we need a model of perceptron dynamics that would account for the history of hyperplanes w 0 , . . . , w N the perceptron goes through on a sample x 1 , . . . , x N . The key simplification in our model is assuming that w t parallels w * for all t, hence the next hyperplane depends only on the offset \u03c8 t . This is a one dimensional Markov random walk governed by the distribution P(\u03c8 t+1 \u2212\u03c8 t = r|\u03c8 t ) = P(x| y t \u2212 \u0177t 2 \u2022 w * , x = r) In general \u2212d \u2264 \u03c8 t \u2264 d but as mentioned before lemma 3, we may assume \u03c8 t > 0. Lemma 5 There exists c > 0 such that with a high probability \u03c8 t > c \u2022 \u221a d for most 0 \u2264 t \u2264 N . Proof : Let c 0 = F \u22121 ( \u03b3 2 + 1 2 ); c 1 = F \u22121 (1\u2212\u03b3). We designate the intervals I 0 = [0, c 0 \u2022 \u221a d]; I 1 = [c 0 \u2022 \u221a d, c 1 \u2022 \u221a d] and I 2 = [c 1 \u2022 \u221a d, d ] and define A i = {x : v(x) \u2208 I i } for i = 0, 1, 2. Note that the constants c 0 and c 1 are chosen so that P(A 0 ) = \u03b3 2 and P(A 2 ) = \u03b3. It follows from the construction in section 3.2 that A 0 and A 1 are easy instances and A 2 are hard. Given a sample x 1 , . . . , x N , a misclassification of x t \u2208 A 0 by \u03c8 t could only happen when an easy +1 instance is classified as \u22121. Thus the algorithm would shift \u03c8 t to the left by no more than |v t \u2212 \u03c8 t | since v t = w * , x t . This shows that \u03c8 t \u2208 I 0 implies \u03c8 t+1 \u2208 I 0 . In the same manner, it is easy to verify that if \u03c8 t \u2208 I j and x t \u2208 A k then \u03c8 t+1 \u2208 I k , unless j = 0 and k = 1, in which case \u03c8 t+1 \u2208 I 0 because x t \u2208 A 1 would be classified correctly by \u03c8 t \u2208 I 0 . We construct a Markov chain with three states a 0 = 0, a 1 = c 0 \u2022 \u221a d and a 2 = c 1 \u2022 \u221a d governed by the following transition distribution: \uf8eb \uf8ec \uf8ec \uf8ed 1 \u2212 \u03b3 2 0 \u03b3 2 \u03b3 2 1 \u2212 \u03b3 \u03b3 2 \u03b3 2 1 2 \u2212 3\u03b3 2 1 2 + \u03b3 \uf8f6 \uf8f7 \uf8f7 \uf8f8 Let X t be the state at time t. The principal eigenvector of the transition matrix ( 1 3 , 1 3 , 1 3 ) gives the stationary probability distribution of X t . Thus X t \u2208 {a 1 , a 2 } with probability 2 3 . Since the transition distribution of X t mirrors that of \u03c8 t , and since a j are at the leftmost borders of I j , respectively, it follows that X t \u2264 \u03c8 t for all t, thus X t \u2208 {a 1 , a 2 } implies \u03c8 t \u2208 I 1 \u222aI 2 . It follows that \u03c8 t > c 0 \u2022 \u221a d with probability 2 3 , and the lemma follows from the law of large numbers 2 Corollary 6 With high probability \u03c4 = \u03b8(1). Proof : Lemma 5 shows that for a sample x 1 , . . . , x N with high probability \u03c8 t is most of the time to the right of c \u2022 \u221a d. Consequently for any x in the band 0 \u2264 v \u2264 c \u2022 \u221a d we get sign( w * , x + \u03c8 t ) = \u22121 for most t hence by definition, the voted perceptron would classify such an instance as \u22121, although it is in fact a +1 easy instance. Since there are \u03b8(N ) misclassified easy instances, \u03c4 = \u03b8(1) 2 Discussion In this article we show that training with annotation noise can be detrimental for test-time results on easy, uncontroversial instances; we termed this phenomenon hard case bias. Although under the 0-1 loss model annotation noise can be tolerated for larger datasets (theorem 1), minimizing such loss becomes intractable for larger datasets. Freund and Schapire (1999) voted perceptron algorithm and its variants are widely used in computational linguistics practice; our results show that it could suffer a constant rate of hard case bias irrespective of the size of the dataset (section 3.4). How can hard case bias be reduced? One possibility is removing as many hard cases as one can not only from the test data, as suggested in Beigman Klebanov and Beigman ( 2009 ), but from the training data as well. Adding the second annotator is expected to detect about half the hard cases, as they would surface as disagreements between the annotators. Subsequently, a machine learner can be told to ignore those cases during training, reducing the risk of hard case bias. While this is certainly a daunting task, it is possible that for annotation studies that do not require expert annotators and extensive annotator training, the newly available access to a large pool of inexpensive annotators, such as the Amazon Mechanical Turk scheme (Snow et al., 2008), 4 or embedding the task in an online game played by volunteers (Poesio et al., 2008; von Ahn, 2006) could provide some solutions. Reidsma and op den Akker (2008) suggest a different option. When non-overlapping parts of the dataset are annotated by different annotators, each classifier can be trained to reflect the opinion (albeit biased) of a specific annotator, using different parts of the datasets. Such \"subjective machines\" can be applied to a new set of data; an item that causes disagreement between classifiers is then extrapolated to be a case of potential disagreement between the humans they replicate, i.e. a hard case. Our results suggest that, regardless of the success of such an extrapolation scheme in detecting hard cases, it could erroneously invalidate easy cases: Each classifier would presumably suffer from a certain hard case bias, i.e. classify incorrectly things that are in fact uncontroversial for any human annotator. If each such classifier has a different hard case bias, some inter-classifier disagreements would occur on easy cases. Depending on the distribution of those easy cases in the feature space, this could invalidate valuable cases. If the situation depicted in figure 1 corresponds to the pattern learned by one of the classifiers, it would lead to marking the easy cases closest to the real separation boundary (those between 0 and \u03bb e ) as hard, and hence unsuitable for learning, eliminating the most informative material from the training data. Reidsma and Carletta (2008) recently showed by simulation that different types of annotator behavior have different impact on the outcomes of machine learning from the annotated data. Our results provide a theoretical analysis that points in the same direction: While random classification noise is tolerable, other types of noise -such as annotation noise handled here -are more problematic. It is therefore important to develop models of annotator behavior and of the resulting imperfections of the annotated datasets, in order to diagnose the potential learning problem and suggest mitigation strategies.",
    "abstract": "It is usually assumed that the kind of noise existing in annotated data is random classification noise. Yet there is evidence that differences between annotators are not always random attention slips but could result from different biases towards the classification categories, at least for the harder-to-decide cases. Under an annotation generation model that takes this into account, there is a hazard that some of the training instances are actually hard cases with unreliable annotations. We show that these are relatively unproblematic for an algorithm operating under the 0-1 loss model, whereas for the commonly used voted perceptron algorithm, hard training cases could result in incorrect prediction on the uncontroversial cases at test time.",
    "countries": [
        "United States"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "78",
    "year": "2009",
    "month": "August",
    "title": "Learning with Annotation Noise"
}