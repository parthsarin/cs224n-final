{
    "article": "We show that under certain conditions, a language model can be trained on the basis of a second language model. The main instance of the technique trains a finite automaton on the basis of a probabilistic context-free grammar, such that the Kullback-Leibler distance between grammar and trained automaton is provably minimal. This is a substantial generalization of an existing algorithm to train an n-gram model on the basis of a probabilistic context-free grammar. Introduction In this article, the term language model is used to refer to any description that assigns probabilities to strings over a certain alphabet. Language models have important applications in natural language processing, and in particular, in speech recognition systems (Manning and Sch \u00fctze 1999) . Language models often consist of a symbolic description of a language, such as a finite automaton (FA) or a context-free grammar (CFG), extended by a probability assignment to, for example, the transitions of the FA or the rules of the CFG, by which we obtain a probabilistic finite automaton (PFA) or probabilistic context-free grammar (PCFG), respectively. For certain applications, one may first determine the symbolic part of the automaton or grammar and in a second phase try to find reliable probability estimates for the transitions or rules. The current article is involved with the second problem, that of extending FAs or CFGs to become PFAs or PCFGs. We refer to this process as training. Training is often done on the basis of a corpus of actual language use in a certain domain. If each sentence in this corpus is annotated by a list of transitions of an FA recognizing the sentence or a parse tree for a CFG generating the sentence, then training may consist simply in relative frequency estimation. This means that we estimate probabilities of transitions or rules by counting their frequencies in the corpus, relative to the frequencies of the start states of transitions or to the frequencies of the left-hand side nonterminals of rules, respectively. By this estimation, the likelihood of the corpus is maximized. The technique we introduce in this article is different in that training is done on the basis not of a finite corpus, but of an input language model. Our goal is to find estimations for the probabilities of transitions or rules of the input FA or CFG such that the resulting PFA or PCFG approximates the input language model as well as possible, or more specifically, such that the Kullback-Leibler (KL) distance (or relative entropy) between the input model and the trained model is minimized. The input FA or CFG to be trained may be structurally unrelated to the input language model. This technique has several applications. One is an extension with probabilities of existing work on approximation of CFGs by means of FAs (Nederhof 2000) . The motivation for this work was that application of FAs is generally less costly than application of CFGs, which is an important benefit when the input is very large, as is often the case in, for example, speech recognition systems. The practical relevance of this work was limited, however, by the fact that in practice one is more interested in the probabilities of sentences than in a purely Boolean distinction between grammatical and ungrammatical sentences. Several approaches were discussed by Mohri and Nederhof (2001) to extend this work to approximation of PCFGs by means of PFAs. A first approach is to directly map rules with attached probabilities to transitions with attached probabilities. Although this is computationally the easiest approach, the resulting PFA may be a very inaccurate approximation of the probability distribution described by the input PCFG. In particular, there may be assignments of probabilities to the transitions of the same FA that lead to more accurate approximating language models. A second approach is to train the approximating FA by means of a corpus. If the input PCFG was itself obtained by training on a corpus, then we already possess training material. However, this may not always be the case, and no training material may be available. Furthermore, as a determinized approximating FA may be much larger than the input PCFG, the sparse-data problem may be more severe for the automaton than it was for the grammar. 1 Hence, even if sufficient material was available to train the CFG, it may not be sufficient to accurately train the FA. A third approach is to construct a training corpus from the PCFG by means of a (pseudo)random generator of sentences, such that sentences that are more likely according to the PCFG are generated with greater likelihood. This has been proposed by Jurafsky et al. (1994) , for the special case of bigrams, extending a nonprobabilistic technique by Zue et al. (1991) . It is not clear, however, whether this idea is feasible for training of finite-state models that are larger than bigrams. The reason is that very large corpora would have to be generated in order to obtain accurate probability estimates for the PFA. Note that the number of parameters of a bigram model is bounded by the square of the size of the lexicon; such a bound does not exist for general PFAs. The current article discusses a fourth approach. In the limit, it is equivalent to the third approach above, as if an infinite corpus were constructed on which the PFA is trained, but we have found a way to avoid considering sentences individually. The key idea that allows us to handle an infinite set of strings generated by the PCFG is that we construct a new grammar that represents the intersection of the languages described by the input PCFG and the FA. Within this new grammar, we can compute the expected frequencies of transitions of the FA, using a fairly standard analysis of PCFGs. These expected frequencies then allow us to determine the assignment of probabilities to transitions of the FA that minimizes the KL distance between the PCFG and the resulting PFA. The only requirement is that the FA to be trained be unambiguous, by which we mean that each input string can be recognized by at most one computation of the FA. The special case of n-grams has already been formulated by Stolcke and Segal (1994) , realizing an idea previously envisioned by Rimon and Herz (1991) . An n-gram model is here seen as a (P)FA that contains exactly one state for each possible history of the n \u2212 1 previously read symbols. It is clear that such an FA is unambiguous (even deterministic) and that our technique therefore properly subsumes the technique by Stolcke and Segal (1994) , although the way that the two techniques are formulated is rather different. Also note that the FA underlying an n-gram model accepts any input string over the alphabet, which does not hold for general (unambiguous) FAs. Another application of our work involves determinization and minimization of PFAs. As shown by Mohri (1997) , PFAs cannot always be determinized, and no practical algorithms are known to minimize arbitrary nondeterministic (P)FAs. This can be a problem when deterministic or small PFAs are required. We can, however, always compute a minimal deterministic FA equivalent to an input FA. The new results in this article offer a way to extend this determinized FA to a PFA such that it approximates the probability distribution described by the input PFA as well as possible, in terms of the KL distance. Although the proposed technique has some limitations, in particular, that the model to be trained is unambiguous, it is by no means restricted to language models based on finite automata or context-free grammars, as several other probabilistic grammatical formalisms can be treated in a similar manner. The structure of this article is as follows. We provide some preliminary definitions in Section 2. Section 3 discusses how the expected frequency of a rule in a PCFG can be computed. This is an auxiliary step in the algorithms to be discussed below. Section 4 defines a way to combine a PFA and a PCFG into a new PCFG that extends a well-known representation of the intersection of a regular and a context-free language. Thereby we merge the input model and the model to be trained into a single structure. This structure is the foundation for a number of algorithms, presented in section 5, which allow, respectively, training of an unambiguous FA on the basis of a PCFG (section 5.1), training of an unambiguous CFG on the basis of a PFA (section 5.2), and training of an unambiguous FA on the basis of a PFA (section 5.3). Preliminaries Many of the definitions on probabilistic context-free grammars are based on Santos (1972) and Booth and Thompson (1973) , and the definitions on probabilistic finite automata are based on Paz (1971) and Starke (1972) . A context-free grammar G is a 4-tuple (\u03a3, N, S, R), where \u03a3 and N are two finite disjoint sets of terminals and nonterminals, respectively, S \u2208 N is the start symbol, and R is a finite set of rules, each of the form A \u2192 \u03b1, where A \u2208 N and \u03b1 \u2208 (\u03a3 \u222a N) * . A probabilistic context-free grammar G is a 5-tuple (\u03a3, N, S, R, p G ), where \u03a3, N, S and R are as above, and p G is a function from rules in R to probabilities. In what follows, symbol a ranges over the set \u03a3, symbols w, v range over the set \u03a3 * , symbols A, B range over the set N, symbol X ranges over the set \u03a3 \u222a N, symbols \u03b1, \u03b2, \u03b3 range over the set (\u03a3 \u222a N) * , symbol \u03c1 ranges over the set R, and symbols d, e range over the set R * . With slight abuse of notation, we treat a rule \u03c1 = (A \u2192 \u03b1) \u2208 R as an atomic symbol when it occurs within a string d\u03c1e \u2208 R * . The symbol denotes the empty string. String concatenation is represented by operator \u2022 or by empty space. For a fixed (P)CFG G, we define the relation \u21d2 on triples consisting of two strings \u03b1, \u03b2 \u2208 (\u03a3 \u222a N) * and a rule \u03c1 \u2208 R by \u03b1 \u03c1 \u21d2 \u03b2, if and only if \u03b1 is of the form wA\u03b4 and \u03b2 is of the form w\u03b3\u03b4, for some w \u2208 \u03a3 * and \u03b4 \u2208 (\u03a3 \u222a N) * , and \u03c1 = (A \u2192 \u03b3). A leftmost derivation (in G) is a string d = \u03c1 1 \u2022 \u2022 \u2022 \u03c1 m , m \u2265 0, such that \u03b1 0 \u03c1 1 \u21d2 \u03b1 1 \u03c1 2 \u21d2 \u2022 \u2022 \u2022 \u03c1m \u21d2 \u03b1 m , for some \u03b1 0 , . . . , \u03b1 m \u2208 (\u03a3 \u222a N) * ; d = is always a leftmost derivation. In the remainder of this article, we let the term derivation refer to leftmost derivation, unless specified otherwise. If \u03b1 0 \u03c1 1 \u21d2 \u2022 \u2022 \u2022 \u03c1m \u21d2 \u03b1 m for some \u03b1 0 , . . . , \u03b1 m \u2208 (\u03a3 \u222a N) * , then we say that d = \u03c1 1 \u2022 \u2022 \u2022 \u03c1 m derives \u03b1 m from \u03b1 0 , and we write \u03b1 0 d \u21d2 \u03b1 m ; derives any \u03b1 0 \u2208 (\u03a3 \u222a N) * from itself. A derivation d such that S d \u21d2 w, for some w \u2208 \u03a3 * , is called a complete derivation. We say that G is unambiguous if for each w \u2208 \u03a3 * , S d \u21d2 w for at most one d \u2208 R * . Let G be a fixed PCFG (\u03a3, N, S, R, p G ). For \u03b1, \u03b2 \u2208 (\u03a3 \u222a N) * and d = \u03c1 1 \u2022 \u2022 \u2022 \u03c1 m \u2208 R * , m \u2265 0, we define p G (\u03b1 d \u21d2 \u03b2) = m i=1 p G (\u03c1 i ) if \u03b1 d \u21d2 \u03b2, and p G (\u03b1 d \u21d2 \u03b2) = 0 otherwise. The probability p G (w) of a string w \u2208 \u03a3 * is defined to be d p G (S d \u21d2 w). PCFG G is said to be proper if \u03c1,\u03b1 p G (A \u03c1 \u21d2 \u03b1) = 1 for all A \u2208 N, that is, if the probabilities of all rules \u03c1 = (A \u2192 \u03b1) with left-hand side A sum to one. PCFG G is said to be consistent if w p G (w) = 1. Consistency implies that the PCFG defines a probability distribution on the set of terminal strings. There is a practical sufficient condition for consistency that is decidable (Booth and Thompson 1973) . A PCFG is said to be reduced if for each nonterminal A, there are d 1 , d 2 \u2208 R * , w 1 , w 2 \u2208 \u03a3 * , and \u03b2 \u2208 (\u03a3 \u222a N) * such that p G (S d 1 \u21d2 w 1 A\u03b2) \u2022 p G (w 1 A\u03b2 d 2 \u21d2 w 1 w 2 ) > 0. In words, if a PCFG is reduced, then for each nonterminal A, there is at least one derivation d 1 d 2 with nonzero probability that derives a string w 1 w 2 from S and that includes some rule with left-hand side A. A PCFG G that is not reduced can be turned into one that is reduced and that describes the same probability distribution, provided that w p G (w) > 0. This reduction consists in removing from the grammar any nonterminal A for which the above conditions do not hold, together with any rule that contains such a nonterminal; see Aho and Ullman (1972) for reduction of CFGs, which is very similar. A finite automaton M is a 5-tuple (\u03a3, Q, q 0 , q f , T), where \u03a3 and Q are two finite sets of terminals and states, respectively, q 0 , q f \u2208 Q are the initial and final states, respectively, and T is a finite set of transitions, each of the form r a \u2192 s, where r \u2208 Q \u2212 {q f }, s \u2208 Q, and a \u2208 \u03a3. 2 A probabilistic finite automaton M is a 6-tuple (\u03a3, Q, q 0 , q f , T, p M ), where \u03a3, Q, q 0 , q f , and T are as above, and p M is a function from transitions in T to probabilities. In what follows, symbols q, r, s range over the set Q, symbol \u03c4 ranges over the set T, and symbol c ranges over the set T * . For a fixed (P)FA M, we define a configuration to be an element of Q \u00d7 \u03a3 * , and we define the relation on triples consisting of two configurations and a transition \u03c4 \u2208 T by (r, w) \u03c4 (s, w ) if and only if w is of the form aw , for some a \u2208 \u03a3, and \u03c4 = (r a \u2192 s). A computation (in M) is a string c = \u03c4 1 \u2022 \u2022 \u2022 \u03c4 m , m \u2265 0, such that (r 0 , w 0 ) \u03c4 1 (r 1 , w 1 ) \u03c4 2 \u2022 \u2022 \u2022 \u03c4m (r m , w m ), for some (r 0 , w 0 ), . . . , (r m , w m ) \u2208 Q \u00d7 \u03a3 * ; c = is always a compu- tation. If (r 0 , w 0 ) \u03c4 1 \u2022 \u2022 \u2022 \u03c4m (r m , w m ) for some (r 0 , w 0 ), . . . , (r m , w m ) \u2208 Q \u00d7 \u03a3 * and c = \u03c4 1 \u2022 \u2022 \u2022 \u03c4 m \u2208 T * , then we write (r 0 , w 0 ) c (r m , w m ). We say that c recognizes w if (q 0 , w) c (q f , ). Let M be a fixed FA (\u03a3, Q, q 0 , q f , T). The language L(M) accepted by M is defined to be {w \u2208 \u03a3 * | \u2203 c [(q \uf730 , w) c (q f , )]}. We say M is unambiguous if for each w \u2208 \u03a3 * , (q 0 , w) c (q f , ) for at most one c \u2208 T * . We say M is deterministic if for each (r, w) \u2208 Q \u00d7 \u03a3 * , there is at most one combination of \u03c4 \u2208 T and (s, w ) \u2208 Q \u00d7 \u03a3 * such that (r, w) \u03c4 (s, w ). Turning a given FA into one that is deterministic and accepts the same language is called determinization. All FAs can be determinized. Turning a given (deterministic) FA into the smallest (deterministic) FA that accepts the same language is called minimization. There are effective algorithms for minimization of deterministic FAs. Let M be a fixed PFA (\u03a3, Q, q 0 , q f , T, p M ). For (r, w), (s, v) v) , and p M ((r, w) c (s, v)) = 0 otherwise. The probability p M (w) of a string w \u2208 \u03a3 * is defined to be c p M ((q 0 , w) c (q f , )). \u2208 Q \u00d7 \u03a3 * and c = \u03c4 1 \u2022 \u2022 \u2022 \u03c4 m \u2208 T * , we define p M ((r, w) c (s, v)) = m i=1 p M (\u03c4 i ) if (r, w) c (s, PFA M is said to be proper if \u03c4,a,s: \u03c4=(r a \u2192s)\u2208T p M (\u03c4) = 1 for all r \u2208 Q \u2212 {q f }. Expected Frequencies of Rules Let G be a PCFG (\u03a3, N, S, R, p G ). We assume without loss of generality that S does not occur in the right-hand side of any rule from R. For each rule \u03c1, we define E(\u03c1) = d,d ,w p G (S d\u03c1d \u21d2 w) ( 1 ) If G is proper and consistent, ( 1 ) is the expected frequency of \u03c1 in a complete derivation. Each complete derivation d\u03c1d can be written as d\u03c1d d , with d = d d , where S d \u21d2 w A\u03b2, A \u03c1 \u21d2 \u03b1, \u03b1 d \u21d2 w , \u03b2 d \u21d2 w (2) for some A, \u03b1, \u03b2, w , w , and w . Therefore E(\u03c1) = outer(A) \u2022 p G (\u03c1) \u2022 inner(\u03b1) ( 3 ) where we define outer(A) = d,w ,\u03b2,d ,w p G (S d \u21d2 w A\u03b2) \u2022 p G (\u03b2 d \u21d2 w ) ( 4 ) inner(\u03b1) = d ,w p G (\u03b1 d \u21d2 w ) ( 5 ) for each A \u2208 N and \u03b1 \u2208 (\u03a3 \u222a N) * . From the definition of inner, we can easily derive the following equations: inner(a) = 1 ( 6 ) inner(A) = \u03c1,\u03b1: \u03c1=(A\u2192\u03b1) p G (\u03c1) \u2022 inner(\u03b1) ( 7 ) inner(X\u03b2) = inner(X) \u2022 inner(\u03b2) ( 8 ) This can be taken as a recursive definition of inner, assuming \u03b2 = in (8). Similarly, we can derive a recursive definition of outer: outer(S) = 1 ( 9 ) outer(A) = \u03c1,B,\u03b1,\u03b2: \u03c1=(B\u2192\u03b1A\u03b2) outer(B) \u2022 p G (\u03c1) \u2022 inner(\u03b1) \u2022 inner(\u03b2) (10) for A = S. In general, there may be cyclic dependencies in the equations for inner and outer; that is, for certain nonterminals A, inner(A) and outer(A) may be defined in terms of themselves. There may even be no closed-form expression for inner(A). However, one may approximate the solutions to arbitrary precision by means of fixed-point iteration. Intersection of Context-Free and Regular Languages We recall a construction from Bar-Hillel, Perles, and Shamir (1964) that computes the intersection of a context-free language and a regular language. The input consists of a CFG G = (\u03a3, N, S, R) and an FA M = (\u03a3, Q, q 0 , q f , T); note that we assume, without loss of generality, that G and M share the same set of terminals \u03a3. The output of the construction is CFG G \u2229 = (\u03a3, N \u2229 , S \u2229 , R \u2229 ), where N \u2229 = Q \u00d7 (\u03a3 \u222a N) \u00d7 Q, S \u2229 = (q 0 , S, q f ), and R \u2229 consists of the set of rules that is obtained as follows: r For each rule \u03c1 = (A \u2192 X 1 \u2022 \u2022 \u2022 X m ) \u2208 R, m \u2265 0, and each sequence of states r 0 , . . . , r m \u2208 Q, let the rule \u03c1 \u2229 = ((r 0 , A, r m ) \u2192 (r 0 , X 1 , r 1 ) \u2022 \u2022 \u2022 (r m\u22121 , X m , r m )) be in R \u2229 ; for m = 0, R \u2229 contains a rule \u03c1 \u2229 = ((r 0 , A, r 0 ) \u2192 ) for each state r 0 . r For each transition \u03c4 = (r a \u2192 s) \u2208 T, let the rule \u03c1 \u2229 = ((r, a, s) \u2192 a) be in R \u2229 . Note that for each rule (r 0 , A, r m ) \u2192 (r 0 , X 1 , r 1 ) \u2022 \u2022 \u2022 (r m\u22121 , X m , r m ) from R \u2229 , there is a unique rule A \u2192 X 1 \u2022 \u2022 \u2022 X m from R from which it has been constructed by the above. Similarly, each rule (r, a, s) \u2192 a uniquely identifies a transition r a \u2192 s. This means that if we take a derivation d \u2229 in G \u2229 , we can extract a sequence h 1 (d \u2229 ) of rules from G and a sequence h 2 (d \u2229 ) of transitions from M, where h 1 and h 2 are string homomorphisms that we define pointwise as h 1 (\u03c1 \u2229 ) = \u03c1 if \u03c1 \u2229 = ((r 0 , A, r m ) \u2192 (r 0 , X 1 , r 1 ) \u2022 \u2022 \u2022 (r m\u22121 , X m , r m )) and \u03c1 = (A \u2192 X 1 \u2022 \u2022 \u2022 X m ) (11) if \u03c1 \u2229 = ((r, a, s) \u2192 a) (12) h 2 (\u03c1 \u2229 ) = \u03c4 if \u03c1 \u2229 = ((r, a, s) \u2192 a) and \u03c4 = (r a \u2192 s) (13) if \u03c1 \u2229 = ((r 0 , A, r m ) \u2192 (r 0 , X 1 , r 1 ) \u2022 \u2022 \u2022 (r m\u22121 , X m , r m )) (14) We define h(d \u2229 ) = (h 1 (d \u2229 ), h 2 (d \u2229 )). It can be easily shown that if h(d \u2229 ) = (d, c) and S \u2229 d \u2229 \u21d2 w, then for the same w, we have S d \u21d2 w and (q 0 , w) c (q f , ). Conversely, if for some w, d, and c we have S d \u21d2 w and (q 0 , w) c (q f , ), then there is precisely one derivation d \u2229 such that h(d \u2229 ) = (d, c) and S \u2229 d \u2229 \u21d2 w. It was observed by Lang (1994) that G \u2229 can be seen as a parse forest, that is, a compact representation of all parse trees according to G that derive strings recognized by M. The construction can be generalized to, for example, tree-adjoining grammars (Vijay-Shanker and Weir 1993) and range concatenation grammars (Boullier 2000; Bertsch and Nederhof 2001) . The construction for the latter also has implications for linear context-free rewriting systems (Seki et al. 1991) . The construction has been extended by Nederhof and Satta (2003) to apply to a PCFG G = (\u03a3, N, S, R, p G ) and a PFA M = (\u03a3, Q, q 0 , q f , T, p M ). The output is a PCFG G \u2229 = (\u03a3, N \u2229 , S \u2229 , R \u2229 , p \u2229 ), where N \u2229 , S \u2229 , and R \u2229 are as before, and p \u2229 is defined by p \u2229 ((r 0 , A, r m ) \u2192 (r 0 , X 1 , r 1 ) \u2022 \u2022 \u2022 (r m\u22121 , X m , r m )) = p G (A \u2192 X 1 \u2022 \u2022 \u2022 X m ) (15) p \u2229 ((r, a, s) \u2192 a) = p M (r a \u2192 s) (16) If d \u2229 , d, and c are such that h(d \u2229 ) = (d, c), then clearly p \u2229 (d \u2229 ) = p G (d) \u2022 p M (c). Training Models on Models We restrict ourselves to a few cases of the general technique of training a model on the basis of another model. Training a PFA on a PCFG Let us assume we have a proper and consistent PCFG G = (\u03a3, N, S, R, p G ) and an FA M = (\u03a3, Q, q 0 , q f , T) that is unambiguous. This FA may have resulted from (nonprobabilistic) approximation of CFG (\u03a3, N, S, R), but it may also be totally unrelated to G. Note that an FA is guaranteed to be unambiguous if it is deterministic; any FA can be determinized. Our goal is now to assign probabilities to the transitions from FA M to obtain a proper PFA that approximates the probability distribution described by G as well as possible. Let us define 1 as the function that maps each transition from T to one. This means that for each r, w, c and s, 1((r, w) c (s, )) = 1 if (r, w) c (s, ), and 1((r, w) c (s, )) = 0 otherwise. Of the set of strings generated by G, a subset is recognized by computations of M; note again that there can be at most one such computation for each string. The expected frequency of a transition \u03c4 in such computations is given by E(\u03c4) = w,c,c p G (w) \u2022 1((q 0 , w) c\u03c4c (q f , )) (17) Now we construct the PCFG G \u2229 as explained in section 4 from the PCFG G and the PFA (\u03a3, Q, q 0 , q f , T, 1). Let \u03c4 = (r a \u2192 s) \u2208 T and \u03c1 = ((r, a, s) \u2192 a). On the basis of the properties of function h, we can now rewrite E(\u03c4) as E(\u03c4) = d,w,c,c p G (S d \u21d2 w) \u2022 1((q 0 , w) c\u03c4c (q f , )) = e,d,w,c,c : h(e)=(d,c\u03c4c ) p G (S d \u21d2 w) \u2022 1((q 0 , w) c\u03c4c (q f , )) = e,e ,w p \u2229 (S \u2229 e\u03c1e \u21d2 w) = E(\u03c1) (18) Hereby we have expressed the expected frequency of a transition \u03c4 = (r a \u2192 s) in terms of the expected frequency of rule \u03c1 = ((r, a, s) \u2192 a) in derivations in PCFG G \u2229 . It was explained in section 3 how such a value can be computed. Note that since by definition 1(\u03c4) = 1, also p \u2229 (\u03c1) = 1. Furthermore, for the right-hand side a of \u03c1, inner(a) = 1. Therefore, E(\u03c4) = outer((r, a, s)) \u2022 p \u2229 (\u03c1) \u2022 inner(a) = outer((r, a, s)) (19) To obtain the required PFA (\u03a3, Q, q 0 , q f , T, p M ), we now define the probability function p M for each \u03c4 = (r a \u2192 s) \u2208 T as p M (\u03c4) = outer((r, a, s)) a ,s :(r a \u2192s )\u2208T a , s )) (20) That such a relative frequency estimator p M minimizes the KL distance between p G and p M on the domain L(M) is proven in the appendix. An example with finite languages is given in Figure 1 . We have, for example, p M (q 0 a \u2192 q 1 ) = outer((q 0 , a, q 1 )) outer((q 0 , a, q 1 )) + outer((q 0 , c, q 1 )) = 1 3 1 3 + 2 3 = 1 3 (21) Training a PCFG on a PFA Similarly to section 5.1, we now assume we have a proper PFA M = (\u03a3, Q, q 0 , q f , T, p M ) and a CFG G = (\u03a3, N, S, R) that is unambiguous. Our goal is to find a function p G that lets proper and consistent PCFG (\u03a3, N, S, R, p G ) approximate M as well as possible. Although CFGs used for natural language processing are usually ambiguous, there may be cases in other fields in which we may assume grammars are unambiguous. Let us define 1 as the function that maps each rule from R to one. Of the set of strings recognized by M, a subset can be derived in G. The expected frequency of a rule \u03c1 in those derivations is given by E(\u03c1) = d,d ,w p M (w) \u2022 1(S d\u03c1d \u21d2 w) (22) Now we construct the PCFG G \u2229 from the PCFG G = (\u03a3, N, S, R, 1) and the PFA M as explained in section 4. Analogously to section 5.1, we obtain for each \u03c1 = (A \u2192 X 1 \u2022 \u2022 \u2022 X m ) E(\u03c1) = r 0 ,r 1 ,...,r m E((r 0 , A, r m ) \u2192 (r 0 , X 1 , r 1 ) \u2022 \u2022 \u2022 (r m\u22121 , X m , r m )) = r 0 ,r 1 ,...,r m outer((r 0 , A, r m )) \u2022 inner((r 0 , X 1 , r 1 ) \u2022 \u2022 \u2022 (r m\u22121 , X m , r m )) (23) To obtain the required PCFG (\u03a3, N, S, R, p G ), we now define the probability function p G for each \u03c1 = (A \u2192 \u03b1) as p G (\u03c1) = E(\u03c1) \u03c1 =(A\u2192\u03b1 )\u2208R E(\u03c1 ) (24) The proof that this relative frequency estimator p G minimizes the KL distance between p M and p G on the domain L(G) is almost identical to the proof in the appendix for a similar claim from section 5.1. Training a PFA on a PFA We now assume we have a proper PFA M 1 = (\u03a3, Q 1 , q 0,1 , q f,1 , T 1 , p 1 ) and an FA M 2 = (\u03a3, Q 2 , q 0,2 , q f,2 , T 2 ) that is unambiguous. Our goal is to find a function p 2 so that proper PFA (\u03a3, Q 2 , q 0,2 , q f,2 , T 2 , p 2 ) approximates M 1 as well as possible, minimizing the KL distance between p 1 and p 2 on the domain L(M 2 ). One way to solve this problem is to map M 2 to an equivalent right-linear CFG G and then to apply the algorithm from section 5.2. The obtained probability function p G can be translated back to an appropriate function p 2 . For this special case, the construction from section 4 can be simplified to the \"cross-product\" construction of finite automata (see, e.g., Aho and Ullman 1972) . The simplified forms of the functions inner and outer from section 3 are commonly called forward and backward, respectively, and they are defined by systems of linear equations. As a result, we can compute exact solutions, as opposed to approximate solutions by iteration. Acknowledgments Comments by Khalil Sima'an, Giorgio Satta, Yuval Krymolowski, and anonymous reviewers are gratefully acknowledged. The author is supported by the PIONIER Project Algorithms for Linguistic Processing, funded by NWO (Dutch Organization for Scientific Research). Appendix We now prove that the choice of p M in section 5.1 is such that it minimizes the Kullback-Leibler distance between p G and p M , restricted to the domain L(M). Without this restriction, the KL distance is given by This can be used for many applications mentioned in section 1. For example, an FA M approximating a CFG G is guaranteed to be such that L(M) \u2287 L(G) in the case of most practical approximation algorithms. However, if there are strings w such that w / \u2208 L(M) and p G (w) > 0, then (25) is infinite, regardless of the choice of p M . We therefore restrict p G to the domain L(M) and normalize it to obtain where Z = w:w\u2208L(M) p G (w). Note that Our goal is now to show that our choice of p M minimizes As Z is independent of p M , it is sufficient to show that our choice of p M minimizes Now consider the expression By the usual proof technique with Lagrange multipliers, it is easy to show that our choice of p M in section 5.1, given by for each \u03c4 = (r a \u2192 s) \u2208 T, is such that it maximizes (30), under the constraint of properness. For \u03c4 \u2208 T and w \u2208 \u03a3 * , we define # \u03c4 (w) to be zero, if w / \u2208 L(M), and otherwise to be the number of occurrences of \u03c4 in the (unique) computation that recognizes w. Formally, # \u03c4 (w) = c,c 1((q 0 , w) c\u03c4c (q f , )). We rewrite (30) as We have already seen that the choice of p M that maximizes (30) is given by (31), and (31) implies p M (w) > 0 for all w such that w \u2208 L(M) and p G (w) > 0. Since p M (w) > 0 is impossible for w / \u2208 L(M), the value of is determined solely by p G and by the condition that p M (w) > 0 for all w such that w \u2208 L(M) and p G (w) > 0. This implies that (30) is maximized by choosing p M such that 2 is maximized, or alternatively that is minimized, under the constraint that p M (w) > 0 for all w such that w \u2208 L(M) and p G (w) > 0. For this choice of p M , (29) equals (35). Conversely, if a choice of p M minimizes (29), we may assume that p M (w) > 0 for all w such that w \u2208 L(M) and p G (w) > 0, since otherwise (29) is infinite. Again, for this choice of p M , (29) equals (35). It follows that the choice of p M that minimizes (29) concurs with the choice of p M that maximizes (30), which concludes our proof.",
    "abstract": "We show that under certain conditions, a language model can be trained on the basis of a second language model. The main instance of the technique trains a finite automaton on the basis of a probabilistic context-free grammar, such that the Kullback-Leibler distance between grammar and trained automaton is provably minimal. This is a substantial generalization of an existing algorithm to train an n-gram model on the basis of a probabilistic context-free grammar.",
    "countries": [
        "Netherlands"
    ],
    "languages": [],
    "numcitedby": "24",
    "year": "2005",
    "month": "",
    "title": "A General Technique to Train Language Models on Language Models"
}