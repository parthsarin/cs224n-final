{
    "article": "This paper describes algorithms which rerank the top N hypotheses from a maximum-entropy tagger, the application being the recovery of named-entity boundaries in a corpus of web data. The first approach uses a boosting algorithm for ranking problems. The second approach uses the voted perceptron algorithm. Both algorithms give comparable, significant improvements over the maximum-entropy baseline. The voted perceptron algorithm can be considerably more efficient to train, at some cost in computation on test examples. Introduction Recent work in statistical approaches to parsing and tagging has begun to consider methods which incorporate global features of candidate structures. Examples of such techniques are Markov Random Fields (Abney 1997; Della Pietra et al. 1997; Johnson et al. 1999) , and boosting algorithms (Freund et al. 1998; Collins 2000; Walker et al. 2001) . One appeal of these methods is their flexibility in incorporating features into a model: essentially any features which might be useful in discriminating good from bad structures can be included. A second appeal of these methods is that their training criterion is often discriminative, attempting to explicitly push the score or probability of the correct structure for each training sentence above the score of competing structures. This discriminative property is shared by the methods of (Johnson et al. 1999; Collins 2000) , and also the Conditional Random Field methods of (Lafferty et al. 2001) . In a previous paper (Collins 2000) , a boosting algorithm was used to rerank the output from an ex-isting statistical parser, giving significant improvements in parsing accuracy on Wall Street Journal data. Similar boosting algorithms have been applied to natural language generation, with good results, in (Walker et al. 2001) . In this paper we apply reranking methods to named-entity extraction. A state-ofthe-art (maximum-entropy) tagger is used to generate 20 possible segmentations for each input sentence, along with their probabilities. We describe a number of additional global features of these candidate segmentations. These additional features are used as evidence in reranking the hypotheses from the max-ent tagger. We describe two learning algorithms: the boosting method of (Collins 2000) , and a variant of the voted perceptron algorithm, which was initially described in (Freund & Schapire 1999) . We applied the methods to a corpus of over one million words of tagged web data. The methods give significant improvements over the maximum-entropy tagger (a 17.7% relative reduction in error-rate for the voted perceptron, and a 15.6% relative improvement for the boosting method). One contribution of this paper is to show that existing reranking methods are useful for a new domain, named-entity tagging, and to suggest global features which give improvements on this task. We should stress that another contribution is to show that a new algorithm, the voted perceptron, gives very credible results on a natural language task. It is an extremely simple algorithm to implement, and is very fast to train (the testing phase is slower, but by no means sluggish). It should be a viable alternative to methods such as the boosting or Markov Random Field algorithms described in previous work. Background The data Over a period of a year or so we have had over one million words of named-entity data annotated. The data is drawn from web pages, the aim being to support a question-answering system over web data. A number of categories are annotated: the usual people, organization and location categories, as well as less frequent categories such as brand-names, scientific terms, event titles (such as concerts) and so on. From this data we created a training set of 53,609 sentences (1,047,491 words), and a test set of 14,717 sentences (291,898 words) . The task we consider is to recover named-entity boundaries. We leave the recovery of the categories of entities to a separate stage of processing. 1 We evaluate different methods on the task through precision and recall. If a method proposes entities on the test set, and \u00a1 of these are correct (i.e., an entity is marked by the annotator with exactly the same span as that proposed) then the precision of a method is \u00a2 \u00a4\u00a3 \u00a5\u00a3 \u00a7\u00a6 \u00a9\u00a8\u00a1 . Similarly, if is the total number of entities in the human annotated version of the test set, then the recall is \u00a2 \u00a4\u00a3 \u00a5\u00a3 \u00a7\u00a6 \u00a8\u00a1 . The baseline tagger The problem can be framed as a tagging task -to tag each word as being either the start of an entity, a continuation of an entity, or not to be part of an entity at all (we will use the tags S, C and N respectively for these three cases). As a baseline model we used a maximum entropy tagger, very similar to the ones described in (Ratnaparkhi 1996; Borthwick et. al 1998; McCallum et al. 2000) . Max-ent taggers have been shown to be highly competitive on a number of tagging tasks, such as part-of-speech tagging (Ratnaparkhi 1996) , named-entity recognition (Borthwick et. al 1998) , and information extraction tasks (McCallum et al. 2000) . Thus the maximumentropy tagger we used represents a serious baseline for the task. We used the following features (several of the features were inspired by the approach of (Bikel et. al 1999) , an HMM model which gives excellent results on named entity extraction): The word being tagged, the previous word, and the next word. The previous tag, and the previous two tags (bigram and trigram features). A compound feature of three fields: (a) Is the word at the start of a sentence?; (b) does the word occur in a list of words which occur more frequently as lower case rather than upper case words in a large corpus of text? (c) the type of the first letter of the word, where ! #\" %$ is defined as 'A' if is a capitalized letter, 'a' if is a lower-case letter, '0' if is a digit, and otherwise. For example, if the word Animal is seen at the start of a sentence, and it occurs in the list of frequent lower-cased words, then it would be mapped to the feature 1-1-A. The word with each character mapped to its ! . For example, G.M. would be mapped to A.A., and Animal would be mapped to Aaaaaa. The word with each character mapped to its type, but repeated consecutive character types are not repeated in the mapped string. For example, Animal would be mapped to Aa, G.M. would again be mapped to A.A.. The tagger was applied and trained in the same way as described in (Ratnaparkhi 1996 ). The feature templates described above are used to create a set of & binary features ' )( \" 10 32 !$ , where is the tag, and 2 is the \"history\", or context. An example is The parameters are trained using Generalized Iterative Scaling. Following (Ratnaparkhi 1996) , we only include features which occur 5 times or more in training data. In decoding, we use a beam search to recover 20 candidate tag sequences for each sentence (the sentence is decoded from left to right, with the top 20 most probable hypotheses being stored at each point). Applying the baseline tagger As a baseline we trained a model on the full 53,609 sentences of training data, and decoded the 14,717 sentences of test data. This gave 20 candidates per test sentence, along with their probabilities. The baseline method is to take the most probable candidate for each test data sentence, and then to calculate precision and recall figures. Our aim is to come up with strategies for reranking the test data candidates, in such a way that precision and recall is improved. In developing a reranking strategy, the 53,609 sentences of training data were split into a 41,992 sentence training portion, and a 11,617 sentence development set. The training portion was split into 5 sections, and in each case the maximum-entropy tagger was trained on 4/5 of the data, then used to decode the remaining 1/5. The top 20 hypotheses under a beam search, together with their log probabilities, were recovered for each training sentence. In a similar way, a model trained on the 41,992 sentence set was used to produce 20 hypotheses for each sentence in the development set. Global features The global-feature generator The module we describe in this section generates global features for each candidate tagged sequence. As input it takes a sentence, along with a proposed segmentation (i.e., an assignment of a tag for each word in the sentence). As output, it produces a set of feature strings. We will use the following tagged sentence as a running example in this section: An example feature type is simply to list the full strings of entities that appear in the tagged input. In this example, this would give the three features WE=Gen Xer WE=The Day They Shot John Lennon WE=Dougherty Arts Center Here WE stands for \"whole entity\". Throughout this section, we will write the features in this format. The start of the feature string indicates the feature type (in this case WE), followed by =. Following the type, there are generally 1 or more words or other symbols, which we will separate with the symbol . A seperate module in our implementation takes the strings produced by the global-feature generator, and hashes them to integers. For example, suppose the three strings WE=Gen Xer, WE=The Day They Shot John Lennon, WE=Dougherty Arts Center were hashed to 100, 250, and 500 respectively. Conceptually, the candidate is represented by a large number of features 2 pi \" %$ for q r8 \u00a2 HG \u00a4G \u00a4G & where & is the number of distinct feature strings in training data. In this example, only 2 s4 65 75 \" %$ , 2 ut 7v 75 \" %$ and 2 wv 75 75 \" s$ take the value \u00a2 , all other features being zero. Feature templates We now introduce some notation with which to describe the full set of global features. First, we assume the following primitives of an input candidate: ( for F x8 \u00a2 HG \u00a4G \u00a4G 1y is the F 'th tag in the tagged sequence. ( for F H8 \u00a2 HG \u00a4G \u00a4G 3y is the F 'th word. ( for F H8 \u00a2 HG \u00a4G \u00a4G 3y is \u00a2 if ( begins with a lowercase letter, \u00a3 otherwise. ' )( for F 8 \u00a2 HG \u00a4G \u00a4G 3y is a transformation of ( , where the transformation is applied in the same way as the final feature type in the maximum entropy tagger. Each character in the word is mapped to its ! , but repeated consecutive character types are not repeated in the mapped string. For example, Animal would be mapped to Aa in this feature, G.M. would again be mapped to A.A.. ( for F 8 \u00a2 HG \u00a4G \u00a4G 3y is the same as ' )( , but has an additional flag appended. The flag indicates whether or not the word appears in a dictionary of words which appeared more often lower-cased than capitalized in a large corpus of text. In our example, Animal appears in the lexicon, but G.M. does not, so the two values for ( would be Aa1 and A.A.0 respectively. In addition, ( 0 ( 0 3' )( and ( are all defined to be NULL if F \u00a2 or F y . Most of the features we describe are anchored on entity boundaries in the candidate segmentation. We will use \"feature templates\" to describe the features that we used. As an example, suppose that an entity TE111=g e j # g ge g e h TE2000= e j \u00a5m e 6j k e d TE2111=g e j \u00a5m g e j # g e Prefix features PF=f n PF2=g g PF=f 3 f g h PF2=g l g R 7 d PF=f f h d d f e PF2=g g h 7 g e Suffix features SF=f ne SF2=g ge SF=f 3e f g e j # SF2=g ge g e j # 7 d SF=f e f e j k 7 d f SF2=g e g e j k d d g Figure 1: The full set of entity-anchored feature templates. One of these features is generated for each entity seen in a candidate. We take the entity to span words q G \u00a4G \u00a4G inclusive in the candidate. is seen from words q to inclusive in a segmentation. Then the WE feature described in the previous section can be generated by the template WE= i i o p4 G \u00a4G \u00a4G rq Applying this template to the three entities in the running example generates the three feature strings described in the previous section. As another example, consider the template FF=' \u00a5i ' \u00a5i o p4 G \u00a4G \u00a4G ' q . This will generate a feature string for each of the entities in a candidate, this time using the values ' \u00a5i G \u00a4G \u00a4G ' q rather than i G \u00a4G \u00a4G q . For the full set of feature templates that are anchored around entities, see figure 1 . A second set of feature templates is anchored around quotation marks. In our corpus, entities (typically with long names) are often seen surrounded by quotes. For example, \"The Day They Shot John Lennon\", the name of a band, appears in the running example. Define q to be the index of any double quotation marks in the candidate, to be the index of the next (matching) double quotation marks if they appear in the candidate. Additionally, define s to be the index of the last word beginning with a lower case letter, upper case letter, or digit within the quotation marks. The first set of feature templates tracks the values of ( for the words within quotes: 2 Q= \u00a5i 7i X i o p4 d X i o p4 d G \u00a4G \u00a4G q q Q2= X i 7t s4 d X i nt s4 d ui 7i G \u00a4G \u00a4G X q o p4 d X q o p4 d 2 We only included these features if v xw zy |{ n} z , to prevent an explosion in the length of feature strings. The next set of feature templates are sensitive to whether the entire sequence between quotes is tagged as a named entity. Define s to be \u00a2 if 7i o p4 8 S, and ( =C for F 8 q s G \u00a4G \u00a4G s (i.e., s 8 \u00a2 if the sequence of words within the quotes is tagged as a single entity). Also define to be the number of upper cased words within the quotes, to be the number of lower case words, and to be \u00a2 if \u00a9 , \u00a3 otherwise. Then two other templates are: QF= s X i o p4 d q t QF2= s X i o p4 d q t In the \"The Day They Shot John Lennon\" example we would have s 8 \u00a2 provided that the entire sequence within quotes was tagged as an entity. Additionally, 8 , 8 \u00a3 , and 8 \u00a2 . The values for X i o p4 d and q t would be \u00a2 and \u00a3 (these features are derived from The and Lennon, which respectively do and don't appear in the capitalization lexicon). This would give QF= \u00a2 \u00a3 \u00a2 \u00a3 and QF2= \u00a2 \u00a2 \u00a2 \u00a3 . At this point, we have fully described the representation used as input to the reranking algorithms. The maximum-entropy tagger gives 20 proposed segmentations for each input sentence. Each candidate is represented by the log probability \" s$ from the tagger, as well as the values of the global features 2 ui \" %$ for q 8 \u00a2 HG \u00a4G \u00a4G & . In the next section we describe algorithms which blend these two sources of information, the aim being to improve upon a strategy which just takes the candidate from the tagger with the highest score for \" %$ . Ranking Algorithms Notation This section introduces notation for the reranking task. The framework is derived by the transformation from ranking problems to a margin-based classification problem in (Freund et al. 1998) . It is also related to the Markov Random Field methods for parsing suggested in (Johnson et al. 1999) , and the boosting methods for parsing in (Collins 2000) . We consider the following set-up: Training data is a set of example input/output pairs. In tagging we would have training examples q ( 0 7 ( where each q ( is a sentence and each ( is the correct sequence of tags for that sentence. We assume some way of enumerating a set of candidates for a particular sentence. We use u( to denote the 'th candidate for the F 'th sentence in training data, and \" q ( $ 8 ( 4 0 7 ( ft G \u00a4G \u00a4G to denote the set of candidates for q ( . In this paper, the top outputs from a maximum entropy tagger are used as the set of candidates. Without loss of generality we take u( W4 to be the candidate for q ( which has the most correct tags, i.e., is closest to being correct. 3  |\" ( b $ is the probability that the base model assigns to u( b . We define \" u( b )$ 8 f \u00a5 \" u( b $ . We assume a set of & additional features, 2 ui \" s$ for q 8 \u00a2 HG \u00a4G \u00a4G & . The features could be arbitrary functions of the candidates; our hope is to include features which help in discriminating good candidates from bad ones. Finally, the parameters of the model are a vector of & \u00a2 parameters, \u00a1 \u00a28 5 0 4 G \u00a4G \u00a4G \u00a4\u00a3 . The ranking function is defined as \" p0 7\u00a1 $ 8 5 \u00a4 \" %$ s \u00a3 \u00a5 i \u00a6 p4 i 32 pi \" s$ This function assigns a real-valued number to a candidate . It will be taken to be a measure of the plausibility of a candidate, higher scores meaning higher plausibility. As such, it assigns a ranking to different candidate structures for the same sentence, and in particular the output on a training or test example q is \u00aa \u00ab n \u00ac |\u00aa )\u00ae k\u00b0R\u00b1 X i d \" z0 7\u00a1 $ . In this paper we take the features 2 ui to be fixed, the learning problem being to choose a good setting for the parameters \u00a1 . In some parts of this paper we will use vector notation. Define \u00b2 \" s$ to be the vector \" s$ 10 32 %4 \" s$ G \u00a4G \u00a4G 2 \u00a3 \u00b3\" %$ . Then the ranking score can also be written as \" z0 7\u00a1 \u00b4$ x8 \u00a1 \u00b5 #\u00b2 \" %$ where \u00b6 \u00b5 \u2022 is the dot product between vectors \u00b6 and \u2022 . The boosting algorithm The first algorithm we consider is the boosting algorithm for ranking described in (Collins 2000) . The algorithm is a modification of the method in (Freund et al. 1998) . The method can be considered to be a greedy algorithm for finding the parameters \u00a1 that minimize the loss function 9\u00a5q )q \" \u00a1 \u00b4$ 8 \u00a5 ( \u00a5 \u00b9 ut \u00ba X \u00afS x\u00a9 \u00bb b \u00bc 9d t \u00ba X \u00afS f\u00a9 b \u00bc 9d where as before, \" p0 7\u00a1 $ \u00bd8 \u00be\u00a1 \u00bf\u00b5 h\u00b2 \" %$ . The theoretical motivation for this algorithm goes back to the PAC model of learning. Intuitively, it is useful to note that this loss function is an upper bound on the number of \"ranking errors\", a ranking error being a case where an incorrect candidate gets a higher value for than a correct candidate. This follows because for all , t \u00af \u00c1\u00c0 p\u00c2 u\u00c3 , where we define \u00c0 p\u00c2 u\u00c3 to be \u00a2 for \u00c5\u00c4 \u00a3 , and \u00a3 otherwise. Hence q )q \" \u00a1 $ \u00a5 ( \u00a5 \u00b9 ut \u00c0 p\u00c2 \u00c7AE ( b \u00c3 where AE T( b 8 \" u( b 4 \u00a40 7\u00a1 $ \u00c9\u00c8 \u00ca \" u( b 0 7\u00a1 \u00b4$ . Note that the number of ranking errors is Q ( Q \u00b9 ut \u00c0 !\u00c2 \u00c7AE ( b l\u00c3 . As an initial step, 5 is set to be 5 \u00cb8 \u00aa \u00ab n \u00ac |\u00cc x\u00cd \u00ce \u00a5 ( \u00a5 \u00b9 ut \u00ce X f\u00cf uX \u00afS f\u00a9 \u00bb 1d t \u00cf uX \u00afS f\u00a9 d d and all other parameters i for q \u00d08 \u00a2 HG \u00a4G \u00a4G & are set to be zero. The algorithm then proceeds for iterations ( is usually chosen by cross validation on a development set). At each iteration, a single feature is chosen, and its weight is updated. Suppose the current parameter values are \u00a1 , and a single feature \u00d1 is chosen, its weight being updated through an increment \u00d2 , i.e., r\u00d3 8 r\u00d3 \u00d2 . Then the new loss, after this parameter update, will be \" \u00d1 0 3\u00d2 )$ 8 \u00a5 ( b \u00a4\u00b9 ut t p\u00d4 S x\u00a9 \u00bb o %\u00d5 X \u00d6c \u00d7 X \u00afS x\u00a9 \u00bb 3d t c R\u00d7 \u00a4X \u00afS f\u00a9 d hd where AE T( b \u00d88 \u00d9 \" u( b 4 0 7\u00a1 $ \u00c8 T \" p( b \u00a50 7\u00a1 $ . The boosting algorithm chooses the feature/update pair \u00d1 \u00da 0 3\u00d2 \u00da which is optimal in terms of minimizing the loss function, i.e., \" \u00d1 \u00da 0 3\u00d2 \u00da $ 8 \u00aa \u00ab n \u00ac \u00cc x\u00cd \u00d3 b \u00d5 \" \u00d1 0 3\u00d2 $ (1) and then makes the update r\u00d3 \u00db 8 r\u00d3 \u00db \u00dc\u00d2 \u00da . Figure 2 shows an algorithm which implements this greedy procedure. See (Collins 2000) for a full description of the method, including justification that the algorithm does in fact implement the update in Eq. 1 at each iteration. 4 The algorithm relies on the following arrays: o \u00d3 8 \" F n0 6 #$ r\u00dd p\u00c2 \u00c72 \u00d3 h\" ( b 4 $ H\u00c8 T2 \u00d3 k\" ( b $ 6\u00c3 %8 \u00a2 t \u00d3 8 \" F n0 6 #$ r\u00dd p\u00c2 \u00c72 \u00d3 h\" u( b 4 1$ H\u00c8 T2 \u00d3 k\" p( b $ 6\u00c3 %8 \u00c8 \u00a2 \u00de o ( b 8 \u00d1 \u00dd p\u00c2 \u00c72 \u00d3 h\" u( b 4 1$ H\u00c8 T2 \u00d3 k\" p( b $ 6\u00c3 %8 \u00a2 \u00de t ( b 8 \u00d1 \u00dd p\u00c2 \u00c72 \u00d3 h\" u( b 4 1$ H\u00c8 T2 \u00d3 k\" p( b $ 6\u00c3 %8 \u00c8 \u00a2 Thus o \u00d3 is an index from features to correct/incorrect candidate pairs where the The voted perceptron Figure 3 shows the training phase of the perceptron algorithm, originally introduced in (Rosenblatt 1958) . The algorithm maintains a parameter vector \u00a1 , which is initially set to be all zeros. The algorithm then makes a pass over the training set, at each training example storing a parameter vector \u00a1 ( for   in 93,777 distinct features. The two methods were trained on the training portion (41,992 sentences) of the training set. We used the development set to pick the best values for tunable parameters in each algorithm. For boosting, the main parameter to pick is the number of rounds, . We ran the algorithm for a total of 300,000 rounds, and found that the optimal value for F-measure on the development set occurred after 83,233 rounds. For the voted perceptron, the representation \u00b2 \" s$ was taken to be a vector \u00a4\u00a3 \" %$ 10 32 4 \" %$ G \u00a4G \u00a4G 2 -\u00e7 o \u00d3 8 Q X ( b d \u00b0\u00e8 \u00d7 t p\u00d4 S x\u00a9 \u00bb -\u00e7 t \u00d3 8 Q X ( b d \u00b0\u00e8 j \u00d7 t p\u00d4 S x\u00a9 \u00bb - \u00de q q )q \" \u00d1 $ \u00e98 \u00eb\u00ea \u00ea \u00ea \u00ea \u00ec \u00e7 o \u00d3 \u00c8 \u00ec \u00e7 t \u00d3 \u00ea \u00ea \u00ea \u00ea Repeat for = 1 to Choose \u00d1 \u00da 8 \u00aa \u00ab n \u00ac |\u00aa )\u00ae \u00d3 \u00de q d 9\u00a5q )q \" \u00d1 $ Set \u00d2 \u00da 8 4 t f \u00a5 \u00b3\u00ed \u00d7 \u00db o %\u00ee \u00ef \u00ed j \u00d7 \u00db o %\u00ee \u00ef Update one parameter, r\u00d3 \u00db 8 r\u00d3 \u00db \u00dc\u00d2 \u00da for \" F n0 6 k$ \u00a4\u00f0 o \u00d3 \u00db -\u00f1 \u00df8 t p\u00d4 S x\u00a9 \u00bb t u\u00d5 \u00db \u00c8 t p\u00d4 S f\u00a9 \u00bb -AE ( b \u00cb8 AE ( b \u00a9\u00d2 \u00da -for \u00d1 \u00f0 \u00de o ( b , \u00e7 o \u00d3 8 \u00e7 o \u00d3 \u00dc\u00f1 -for \u00d1 \u00f0 \u00de t ( b , \u00e7 t \u00d3 8 \u00e7 t \u00d3 \u00dc\u00f1 -ae \u00ca8 \u00d9ae \u00f2 \u00a9\u00f1 for \" F n0 6 k$ \u00a4\u00f0 t \u00d3 \u00db -\u00f1 \u00df8 t p\u00d4 S x\u00a9 \u00bb o %\u00d5 \u00db \u00c8 t p\u00d4 S f\u00a9 \u00bb -AE ( b \u00cb8 AE ( b r\u00c8 \u00f3\u00d2 \u00da -for \u00d1 \u00f0 \u00de o ( b , \u00e7 o \u00d3 8 \u00e7 o \u00d3 \u00dc\u00f1 -for \u00d1 \u00f0 \u00de t ( b , \u00e7 t \u00d3 \u00a3 \" s$ where \u00a3 is a parameter that influences the relative contribution of the log-likelihood term versus the other features. A value of \u00a3 8 \u00a3 hG \u00a6\u00a5 was found to give the best results on the development set. Figure 5 shows the results for the three methods on the test set. Both of the reranking algorithms show significant improvements over the baseline: a 15.6% relative reduction in error for boosting, and a 17.7% relative error reduction for the voted perceptron. In our experiments we found the voted perceptron algorithm to be considerably more efficient in training, at some cost in computation on test examples. Another attractive property of the voted perceptron is that it can be used with kernels, for example the kernels over parse trees described in (Collins and Duffy 2001; Collins and Duffy 2002) . (Collins and Duffy 2002) describe the voted perceptron applied to the named-entity data in this paper, but using kernel-based features rather than the explicit features described in this paper. See (Collins 2002) for additional work using perceptron algorithms to train tagging models, and a more thorough description of the theory underlying the perceptron algorithm applied to ranking problems. Acknowledgements Many thanks to Jack Minisi for annotating the named-entity data used in the exper-iments. Thanks also to Nigel Duffy, Rob Schapire and Yoram Singer for several useful discussions. Discussion A question regarding the approaches in this paper is whether the features we have described could be incorporated in a maximum-entropy tagger, giving similar improvements in accuracy. This section discusses why this is unlikely to be the case. The problem described here is closely related to the label bias problem described in (Lafferty et al. 2001) . One straightforward way to incorporate global features into the maximum-entropy model would be to introduce new features ' \" 2 E0 7 7$ which indicated whether the tagging decision in the history 2 creates a particular global feature. For example, we could introduce a feature because tagging its as N in this context would create an entity whose last word was not capitalized, i.e., University for. Similar features could be created for all of the global features introduced in this paper. This example also illustrates why this approach is unlikely to improve the performance of the maximum-entropy tagger. The parameter D 4 \u00a8 \u00a7 75 associated with this new feature can only affect the score for a proposed sequence by modifying \u00e9\" \u00a4P 2 !$ at the point at which ' 4 \u00a8 \u00a7 75 \" l0 32 p$ \u00f58 \u00a2 . In the example, this means that the LWLC=1 feature can only lower the score for the segmentation by lowering the probability of tagging its as N. But its has almost probably \u00a2 of not appearing as part of an entity, so \u00e9\" \u00dcP 2 p$ should be almost \u00a2 whether ' 4 \u00a8 \u00a7 75 is \u00a2 or \u00a3 in this context! The decision which effectively created the entity University for was the decision to tag for as C, and this has already been made. The independence assumptions in maximum-entropy taggers of this form often lead points of local ambiguity (in this example the tag for the word for) to create globally implausible structures with unreasonably high scores. See (Collins 1999 ) section 8.4.2 for a discussion of this problem in the context of parsing.",
    "abstract": "This paper describes algorithms which rerank the top N hypotheses from a maximum-entropy tagger, the application being the recovery of named-entity boundaries in a corpus of web data. The first approach uses a boosting algorithm for ranking problems. The second approach uses the voted perceptron algorithm. Both algorithms give comparable, significant improvements over the maximum-entropy baseline. The voted perceptron algorithm can be considerably more efficient to train, at some cost in computation on test examples.",
    "countries": [
        "Jersey"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "300",
    "year": "2002",
    "month": "July",
    "title": "Ranking Algorithms for Named Entity Extraction: Boosting and the {V}oted{P}erceptron"
}