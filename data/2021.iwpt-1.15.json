{
    "article": "We describe the second IWPT task on end-toend parsing from raw text to Enhanced Universal Dependencies. We provide details about the evaluation metrics and the datasets used for training and evaluation. We compare the approaches taken by participating teams and discuss the results of the shared task, also in comparison with the first edition of this task. Introduction Universal Dependencies (UD) (Nivre et al., 2020) is a framework for cross-linguistically consistent treebank annotation that has so far been applied to 114 languages. UD defines two levels of annotation, the basic trees and the enhanced graphs (EUD) (Schuster and Manning, 2016) . There are several good parsers that can predict the basic trees (including tokenization and morphology) for previously unseen text (Straka et al., 2016; Qi et al., 2020) . Two large shared tasks on basic UD parsing were organized at CoNLL (Zeman et al., 2017 (Zeman et al., , 2018)) . Enhanced UD parsing attracted comparatively less attention until the shared task organized at IWPT 2020 (Bouma et al., 2020) . The present paper describes a second instance of that task, organized as a part of the 17th International Conference on Parsing Technologies 1 (IWPT), collocated with ACL-IJCNLP 2021. Like in the previous year, the evaluation was done on datasets covering 17 languages from four language familiies. This paper is a follow-up of the overview paper of the previous instance of the shared task (Bouma et al., 2020) . To make the paper self-contained, we include updated versions of some sections of that paper, in particular describing the enhanced annotation format, the task, and the evaluation metric. The data section now documents the modifications we made to the data from UD release 2.7. Motivation The basic dependency annotation in the Universal Dependencies format introduces labeled edges between nodes that represent tokens in the input string, where each node is a dependent of exactly one other node, with the exception of the node token. While this tree structure supports many downstream tasks, there are also phenomena that are hard to capture using single-parent edges only. The enhanced dependency layer therefore supports richer annotation where nodes may have more than one parent, and where additional 'empty' nodes represent elided material that is not overtly expressed in the input string. The enhanced level can be used to account for a range of linguistic phenomena (see Section 3) and to support downstream applications that rely on the semantic interpretation of the input. There are now a number of treebanks that include enhanced dependency annotation. Furthermore, the recent shared tasks on dependency parsing and subsequent work have shown that considerable progress has been made in multilingual dependency parsing. For enhanced dependency parsing, there are additional challenges. The enhanced representation is a connected directed graph, possibly containing cycles, while the bulk of dependency parsing work still focuses on rooted trees. The set of labels to be predicted is also much larger, as some enhanced dependency labels incorporate the lemma of certain dependents. On the other hand, it has been shown that much of the enhanced annotation can be predicted on the basis of the basic UD annotation (Nyblom et al., 2013; Schuster et al., 2017; Nivre et al., 2018) . Moreover, most state-of-the-art work in dependency parsing uses a graph-based approach, where the assumption that the output must form a tree is only used in the final step from predicted links to final output. And finally, work on deep-syntax and semantic parsing has shown that accurate mapping of strings into rich graph representations is possible (Oepen et al., 2014 (Oepen et al., , 2015 (Oepen et al., , 2019 (Oepen et al., , 2020) ) and could even lead to state-of-the-art performance for downstream applications as shown by the results of the Extrinsic Parsing Evaluation shared task (Oepen et al., 2017) . The previous IWPT shared task (Bouma et al., 2020) reflected this development quite well: some submissions took the way of direct text-to-graph mapping, some of them predicted a rooted tree and then employed heuristics to enhance it; and one submission encoded graphs as trees, then used a tree parser to predict them. Since it was the first task of its kind on large scale multilingual Enhanced Dependencies parsing and some teams may not have been able to successfully implement all their ideas in time (or new ideas may have occurred after seeing what other teams had done), a second round of the task is a natural next step to see whether we can do even better. Enhanced Universal Dependencies UD version 2 2 states that apart from the morphological and basic dependency annotation layers, strings may be annotated with an additional, enhanced, dependency layer, where the following phenomena can be captured: \u2022 Gapping. To support a linguistically more satisfying treatment of ellipsis, empty nodes can be introduced to represent missing predicates in gapping constructions. \u2022 Parent of coordination. Incoming relations are propagated from the parent of the coordination structure to each conjunct. \u2022 Shared dependent of coordination. Outgoing relations are propagated from each conjunct to a shared dependent, e.g., a shared subject or object of coordinate verbs. \u2022 Control and raising constructions. The external subject of xcomp dependents, if present, can be explicitly marked. \u2022 Relative clauses. The antecedent noun of a relative clause is annotated as a dependent of a node within the relative clause (thus introducing a cycle) and the relative pronoun is annotated as a ref dependent of the antecedent noun. \u2022 Case information. Selected dependents (in particular obl and nmod), if they are marked by morphological case and/or by an adpositional case dependent, can now be labeled as obl:marker or nmod:marker where marker is the lemma of the case dependent and/or the value of the morphological feature Case. All enhancements are optional, so a UD treebank may contain enhanced graphs with one type of enhancement and still lack the other types. Data The evaluation was done on 17 languages from 4 language families: Arabic, Bulgarian, Czech, Dutch, English, Estonian, Finnish, French, Italian, Latvian, Lithuanian, Polish, Russian, Slovak, Swedish, Tamil, Ukrainian. The language selection is driven simply by the fact that at least partial enhanced representation is available for the given language. Training and development data were based on the UD release 2.7 (Zeman et al., 2020) but for several treebanks the enhanced annotation is richer than in UD 2.7. Besides improvements in the officially released versions of the individual treebanks, a few other things have changed in comparison to the IWPT 2020 task. The English data now includes the GUM treebank (its enhanced annotation was not present in UD 2.7 but it was being prepared for UD 2.8 and it was ready in time for the shared task). As in 2020, we include two French treebanks whose enhanced annotation is still not included in the official UD releases, but the annotation is more conservative this year, omitting the extra labels for diathesis neutralization (Candito et al., 2017) and surface vs deep syntax markers. Still, some enhancements in French go slightly beyond the official UD guidelines (see below for details). In Polish, we now harmonize the relation subtypes in the three treebanks so that merging them into one dataset is no longer an issue. Finally, we omit the Chukchi treebank, which is new in UD 2.7 and has enhanced graphs, but the graphs are there only to provide empty nodes to capture incorporated modifiers (rather than gapping); furthermore, the treebank is too small and has no training data. There are 13 treebanks of 7 languages in UD 2.7 that contain all types of enhancements: Czech (CAC, FicTree, PDT, and PUD), Dutch (Alpino and LassySmall), English (EWT and PUD), Italian (ISDT), Lithuanian (ALKSNIS), Slovak (SNK), and Swedish (Talbanken and PUD). For the remaining languages, we applied simple heuristics and added at least some enhancements for the purpose of the shared task, but these annotations are not yet part of the regular UD releases. We only applied our heuristics to the missing enhancement types; we did not attempt to modify the enhancements provided by the data providers. Table 1 gives an overview of enhancements in individual treebanks. The enhancements differ in how easily and accurately they can be inferred from the basic UD annotation: \u2022 Enhancing relation labels with case information is deterministic. We apply it to the relations obl, nmod, advcl and acl. If they have a case or mark dependent, we add its lowercased lemma (for fixed multiword expressions or for multiple case/mark dependents we glue the lemmas with the \"_\" character). For obl and nmod we further examine the Case feature and add its lowercased value, if present. \u2022 Linking the parent of coordination to all con- juncts is deterministic. Treebank UD 2.7 Task Arabic PADT GPS RC GPS RC Bulgarian BTB PSXRC PSXRC Czech CAC GPSXRC GPSXRC Czech FicTree GPSXRC GPSXRC Czech PDT GPSXRC GPSXRC Czech PUD GPSXRC GP XRC Dutch Alpino GPSXRC GPSXRC Dutch LassySmall GPSXRC GPSXRC English EWT GPSXRC GPSXRC English GUM GPSXRC English PUD GPSXRC GPSXRC Estonian EDT GPS R GPS RC Estonian EWT G GP RC Finnish PUD GP GP RC Finnish TDT GPSX GPSXRC French FQB PSXR French Sequoia PSXR Italian ISDT GPSXRC GPSXRC Latvian LVTB GPSX C GPSXRC Lithuanian ALKS. GPSXRC GPSXRC Polish LFG PSX C PSXRC Polish PDB PS GPSXRC Polish PUD PS GPSXRC Russian SynTagRus G GP XRC Slovak SNK GPSXRC GPSXRC Swedish PUD GPSXRC GPSXRC Swedish Talbanken GPSXRC GPSXRC Tamil TTB PS PS RC Ukrainian IU GPSXR GPSXRC \u2022 Recognizing and transforming relative clauses is easy if relative pronouns can be recognized. This can be tricky in languages where the same pronouns can be used relatively (Figure 3 ) and interrogatively (Figure 4 ). We cannot recognize all instances of the latter case reliably; fortunately they do not seem to be too frequent. \u2022 External subjects of xcomp clauses are subjects, objects or oblique dependents of the matrix clause. To find them, we need to know whether the governing verb has subject or ob-the man who will come ject control. We use language-specific verb lists, which can resolve many cases, but not all. If a verb is not on any list, we skip it. \u2022 Gapping can be easily identified by the presence of the orphan relation in the basic tree, insertion of empty nodes is thus trivial. However, we do not know the type of the relation between the empty node and the orphaned dependents. Figure 2 shows a graph where each empty node has one nsubj and one obj dependent. We cannot infer these labels from the basic tree (Figure 1 ), so we use dep instead. \u2022 Linking conjuncts to shared dependents cannot be done reliably because we cannot know whether a dependent should be shared (this may be sometimes difficult even for a human annotator!) Therefore we do not attempt to add this enhancement to the datasets that do not have it. Although the UD releases distinguish several different treebanks for some languages, for the purpose of the shared task evaluation we merged all test sets of each language. We wanted to promote robust parsers that are not tightly tied to one particular dataset. Merging treebanks of one language was possible because for almost all languages it holds that treebanks participating in the present task are maintained by the same team, hence no significant treebank-specific annotation decisions are expected. The exceptions are English and Polish but there should not be any significant divergence in these languages either. In English, the GUM corpus is maintained by other people than EWT and PUD; nevertheless, the corpora use the same set of relations, and there are ongoing efforts to harmonize the way the relations are used. In Polish, the LFG treebank uses a different set of relation subtypes than PDB and PUD; however, this year we removed the subtypes that are not used in all three treebanks, so it should be possible to train a parser on one treebank and successfully apply it to another. Table 2 shows that the effect of enhancements differs quite a bit between the various languages. For instance, the percentage of basic dependencies that have a different label in the enhanced graph (mostly because of adding the case information to obl and other relations), ranges from 0 to 27%. Enhanced dependencies that introduce truly novel edges are rarer. In the table they are again expressed relatively to the number of basic dependencies, and the figure varies between 2 and 13%. Up to 2% basic edges are omitted in the enhanced graph. There are slight differences in how individual languages implement particular enhancement types. Some languages follow earlier proposals for enhanced relation subtypes that are not supported by the current UD guidelines, e.g., external subjects are labeled nsubj:xsubj, antecedents of relative clauses are nsubj:relsubj or obj:relobj, the \"case\" information is extended to showing conjunction lemma with conjuncts (conj:and, conj:or etc.) Empty nodes are occasionally used for other ellipsis types than gapping or stripping. The adding of relations from relative clauses to modified nouns is further extended in French to infinitival and participial adnominal clauses, as in Figure 5 . 3  Upon completion of the shared task, the data has been made publicly available at the permanent address http://hdl.handle.net/11234/1-3728. Task As in the previous dependency parsing shared tasks, participants were expected to go from raw, untokenized strings to full dependency annotation. The evaluation focused on the enhanced annotation layer, but the participants were encouraged to pre-dict all annotation layers, and the evaluation of the other layers is available on the shared task website. 4  The task was open, in the sense that participants were allowed to use any additional resources they deemed fit (with the exception of UD 2.7 test data) as long as this was announced in advance and the additional resource was freely available to everybody. The submitted system outputs had to be valid CoNLL-U files; if a file was invalid, its score would be zero. 5 The official UD validation script 6 was used to check validity, although only at 'level 2', which means that only basic file format was checked and not the annotation guidelines (e.g., an unknown relation label would not render the file invalid). Constraints that have to be met at this level are that there must be at least one root node and every node must be reachable via a directed path from at least one root node (rootedness and connectedness), that the enhanced graph can contain cycles, but not self-loops (a node depending on itself), and that dependency labels can only contain characters from a limited set. In addition to CoNLL-U validity, we also required that systems do not alter any non-whitespace characters when processing the input. This is a pre-requisite for the evaluation, where systempredicted tokens must be aligned with goldstandard tokens; files with modified word forms would be rejected. Evaluation Metrics The main evaluation metric is ELAS (labeled attachment score on enhanced dependencies), where ELAS is defined as F 1 -score over the set of enhanced dependencies in the system output and the gold standard. Complete edge labels are taken into account, i.e. obl:on differs from obl. A second metric is EULAS, which differs from ELAS in that only the universal part of the dependency relation label is taken into account. Relation subtypes are ignored, i.e., obl:on, obl:auf, and obl are treated as identical. Another issue we address is the evaluation of empty nodes. A consequence of the treatment of gapping and ellipsis is that some sentences contain additional nodes (numbered 1.1 etc.). It is not guaranteed that gold and system agree on the position in the string where these should appear, but the information encoded by these additional nodes might nevertheless be identical. Thus, such empty nodes should be considered equal even if their string index differs. To ensure that this is the case, we have opted for a solution that basically compiles the information expressed by empty nodes into the dependency label of its dependents. I.e. if a dependent with dependency label L2 has an empty node i2.1 as parent which itself is an L1 dependent of i1, its dependency label will be expanded into a path i1:L1>L2. This preserves the information that the dependent was an L2 dependent of 'something' that was itself an L1 dependent of i1, while at the same time removing the potentially conflicting i2.1 (Figure 6 ). 7  Finally, to analyze results, we computed ELAS scores per phenomenon. This should be seen as a diagnostic only, and is intended to gain further insights into the capability of various systems to deal with challenging phenomena, such as the proper analysis of phenomena occurring in the context of coordination and ellipsis. Approaches The predominant approach to obtaining the enhanced dependency graph is to use a biaffine function, i.e., predicting for each pair of nodes how likely it is that they are in a parent-child relation. There is wide variety in the way the final annota-tion graph is obtained, and ensuring that the result is valid (i.e. connected). GREW (Guillaume and Perrier, 2021) uses manually constructed rewrite rules to map basic UD into EUD, while FAST-PARSE (Anderson and G\u00f3mez-Rodr\u00edguez, 2021) and NUIG (Choudhary and O'riordan, 2021) reformulate the task as a sequence-labeling task. For the initial stages of the analysis (sentence splitting, tokenization, lemmatization, POStagging) most teams use Stanza (Qi et al., 2020) or Trankit (Van Nguyen et al., 2021) or similar methods. In a post-evaluation experiment, the DCU-EPFL team (Barry et al., 2021) obtained improved scores using Trankit instead of Stanza, while the TGIF team (Shi and Lee, 2021) uses a variation of the Trankit and Stanza systems to obtain the best pre-processing results, especially for sentencesplitting. A wide variety of monolingual and multilingual pre-trained language models is used, with XML-R (Conneau et al., 2020) being the most popular. The ShanghaiTech system (Wang et al., 2021) learns an input representation from a combination of pretrained language models where the various representations are concatenated into a single vector and masking is used to learn a weighting for various components of the combined vector. Both COMBO (Klimaszewski and Wr\u00f3blewska, 2021) and UNIPI (Attardi et al., 2021) use a method that learns weights for the scores obtained from various layers of the BERT model to be used as input for the biaffine parser. Most teams reduce the number of edge labels during training by de-lexicalizing edge labels. Dependency paths involving an empty node are usually also replaced by concatenating the path labels into a single path, as is also done in the evaluation script, thereby removing the need to predict empty nodes. Results Table 3 gives scores for LAS, EULAS, and ELAS macro-averaged over languages. 8 The 'baseline' is simply copying the UD annotation to EUD, but note that this is a strong baseline as it assumes perfect UD input, something that clearly is not the case for automated systems. Nevertheless, most systems perform well above the baseline for ELAS. The NUIG submission was incomplete, in that the results for some languages were missing. The submissions of TGIF and ShanghaiTech contain dummy annotations for all annotation layers except EUD, so no LAS is provided. LAS and ELAS correlate strongly, with ELAS generally being 3-4% lower than LAS, except for DCU-EPFL, whose ELAS beats LAS. The best system in the first edition of this shared task (Bouma et al., 2020) obtained a ELAS of 84.50, while the current highest scoring system obtains an ELAS of 89.24. The average of ELAS of the top-5 was 78.75 for the first edition, while the current top-5 has an average of 86.14. The higher scores are most likely both due to more uniform annotations across treebanks as described in section 4 and improvements in approaches.  Table 4 gives the highest ELAS per language. Again, we see considerable improvements for all languages compared to the best ELAS for that language in the first edition of the shared task. The only exception is English, but it should be noted that for English the GUM treebank was added to this years data, so that results are not really comparable. Team For the first edition of this task (Bouma et al., 2020) we provided a qualitative evaluation, where scores were computed per treebank, while taking into account that some treebanks do not include all enhancements stated in the guidelines in their enhanced layer. This year, as the annotation is considerable more uniform across treebanks, we decided to concentrate on performance per enhancement type. We used a script that labeled each edge in EWT and PUD treebanks (2020) with EWT+PUD+GUM (2021). 2 : French compares the scores between the 2021 more simple annotation scheme and the 2020 more complex original proposal. the enhanced annotation as belonging to one of the phenomena or enhancement types listed in Table 5. ELAS per phenomenon are given in Table 6 . Note that the classification script assumes that basic UD annotation is also provided. For systems that only provide dummy labels and relations in their basic annotation (TGIF and ShanghaiTech), scores for some of the phenomena can therefore not be computed in a meaningful way and we replaced the score with 'n/a'. Table 6 illustrates that some systems do not take gapping (G) and treatment of orphans (O) into account. Also, scores for coordination (P and S), controlled subjects (X) and relatives (R) differ quite a bit among systems. While some of the phenomena are relatively rare in the data, it seems that to do well on the task, a system needs to perform reasonably well on all the phenomena listed here. Conclusions The second edition of the shared task for parsing into enhanced universal dependencies shows improvements at various levels. First of all, the same set of languages was included as for the first edition, B basic this enhanced edge is identical to an edge in the basic tree (including the label) C cased case-enhanced relation (the relation with the shorter label may or may not exist in the basic tree) L relabeled the same two nodes are also connected in the basic tree but the label is different and the difference does not look like a case enhancement G gapping the parent or the child is an empty node;  Note that for systems that only provide dummy annotations for basic UD, some of the scores cannot be computed in a meaningful way. The NUIG system was not included as it lacked results for some languages. but now we were using treebanks of UD release 2.7 (Zeman et al., 2020) . This EUD annotation of this release is more consistent and according to guidelines than the data of release 2.5, but we still had to harmonize some of the annotations so that differences in annotation would not have a negative effect on system performance. Second, the requirement that submitted annotations should be minimally valid according to the guidelines, was now more easily met by all participating teams. Teams ensured that graphs would be connected, for instance, by applying several heuristics that introduce the minimal amount of additional edges to meet connectedness. Third, while the best performing system in the first shared task used a method that pre-compiled the enhanced annotation graph into a tree, compatible with basic UD, and used a standard dependency parsing algorithm for learning to produce such annotations, almost all systems in this years shared task went for a graph-based approach. There still is quite a bit of variation in the way the graph is constructed though, with some systems first producing a tree, and then adding additional edges, where others try to produce the graph directly. At the same time, most systems do apply some form of pre-compilation to make the data more suitable for learning. In particular, case-enhanced dependency labels are replaced by de-lexicalized labels that can be easily reconstructed in postprocessing. Similarly, most teams adopt a method that removes 'empty' nodes and instead expresses the information in incoming and outgoing edges from these nodes in the form of complex dependency labels (as is done in the evaluation script as well). Finally, a very positive outcome of this evaluation is that scores have increased considerably, not only for the top performing system, but also for the top-5 systems. In particular, lower performance now seems to be restricted to languages for which very limited amounts of data is available, and, as Table 4 shows, the best system obtains an ELAS of over 90% for 11 of the 17 languages included in the evaluation. Acknowledgments We heartily thank everyone involved in the development of the Enhanced UD treebanks and who made this shared task possible. This work has been partially supported by the LUSyD project, grant 20-16819X of the Czech Science Foundation (GA \u010cR). The second author was partly funded by two French National Research Agency projects, PARSITI (ANR-16-CE33-0021) and SoSweet (ANR-15-CE38-0011). iano Cecchini, Giuseppe G. A. Celano, Slavom\u00edr \u010c\u00e9pl\u00f6, Savas Cetin, \u00d6zlem \u00c7etinoglu, Fabricio Chalub,  Ethan Chi, Yongseok Cho, Jinho",
    "abstract": "We describe the second IWPT task on end-toend parsing from raw text to Enhanced Universal Dependencies. We provide details about the evaluation metrics and the datasets used for training and evaluation. We compare the approaches taken by participating teams and discuss the results of the shared task, also in comparison with the first edition of this task.",
    "countries": [
        "Netherlands",
        "France",
        "Czech Republic"
    ],
    "languages": [
        "Russian",
        "Dutch",
        "English",
        "Latvian",
        "Bulgarian",
        "Lithuanian",
        "Tamil",
        "Polish",
        "Swedish",
        "Estonian",
        "Ukrainian",
        "Slovak",
        "Arabic",
        "Italian",
        "Czech",
        "French",
        "Finnish"
    ],
    "numcitedby": "12",
    "year": "2021",
    "month": "August",
    "title": "From Raw Text to Enhanced {U}niversal {D}ependencies: The Parsing Shared Task at {IWPT} 2021"
}