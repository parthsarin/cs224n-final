{
    "article": "Relation extraction is the task of recognizing semantic relations among entities. Given a particular sentence supervised approaches to Relation Extraction employed feature or kernel functions which usually have a single sentence in their scope. The overall aim of this paper is to propose methods for using knowledge and resources that are external to the target sentence, as a way to improve relation extraction. We demonstrate this by exploiting background knowledge such as relationships among the target relations, as well as by considering how target relations relate to some existing knowledge resources. Our methods are general and we suggest that some of them could be applied to other NLP tasks. Introduction Relation extraction (RE) is the task of detecting and characterizing semantic relations expressed between entities in text. For instance, given the sentence \"Cone, a Kansas City native, was originally signed by the Royals and broke into the majors with the team.\", one of the relations we might want to extract is the employment relation between the pair of entity mentions \"Cone\" and \"Royals\". RE is important for many NLP applications such as building an ontology of entities, biomedical information extraction, and question answering. Prior work have employed diverse approaches towards resolving the task. One approach is to build supervised RE systems using sentences annotated with entity mentions and predefined target relations. When given a new sentence, the RE system has to detect and disambiguate the presence of any predefined relations that might exist between each of the mention pairs in the sentence. In building these systems, researchers used a wide variety of features (Kambhatla, 2004; Zhou et al., 2005; Jiang and Zhai, 2007) . Some of the common features used to analyze the target sentence include the words appearing in the sentence, their part-ofspeech (POS) tags, the syntactic parse of the sentence, and the dependency path between the pair of mentions. In a related line of work, researchers have also proposed various kernel functions based on different structured representations (e.g. dependency or syntactic tree parses) of the target sentences (Bunescu and Mooney, 2005; Zhou et al., 2007; Zelenko et al., 2003; Zhang et al., 2006) . Additionally, researchers have tried to automatically extract examples for supervised learning from resources such as Wikipedia (Weld et al., 2008) and databases (Mintz et al., 2009) , or attempted open information extraction (IE) (Banko et al., 2007) to extract all possible relations. In this work, we focus on supervised RE. In prior work, the feature and kernel functions employed are usually restricted to being defined on the various representations (e.g. lexical or structural) of the target sentences. However, in recognizing relations, humans are not thus constrained and rely on an abundance of implicit world knowledge or background information. What quantifies as world or background knowledge is rarely explored in the RE literature and we do not attempt to provide complete nor precise definitions in this paper. However, we show that by considering the relationship between our relations of interest, as well as how they relate to some existing knowledge resources, we improve the performance of RE. Specifically, the contributions of this paper are the following: \u2022 When our relations of interest are clustered or organized in a hierarchical ontology, we show how to use this information to improve performance. By defining appropriate constraints between the predictions of relations at different levels of the hierarchy, we obtain globally coherent predictions as well as improved performance. \u2022 Coreference is a generic relationship that might exists among entity mentions and we show how to exploit this information by assuming that co-referring mentions have no other interesting relations. We capture this intuition by using coreference information to constraint the predictions of a RE system. \u2022 When characterizing the relationship between a pair of mentions, one can use a large encyclopedia such as Wikipedia to infer more knowledge about the two mentions. In this work, after probabilistically mapping mentions to their respective Wikipedia pages, we check whether the mentions are related. Another generic relationship that might exists between a pair of mentions is whether they have a parent-child relation and we use this as additional information. \u2022 The sparsity of features (especially lexical features) is a common problem for supervised systems. In this work, we show that one can make fruitful use of unlabeled data, by using word clusters automatically gathered from unlabeled texts as a way of generalizing the lexical features. \u2022 We combine the various relational predictions and background knowledge through a global inference procedure, which we formalize via an Integer Linear Programming (ILP) framework as a constraint optimization problem (Roth and Yih, 2007) . This allows us to easily incorporate various constraints that encode the background knowledge. Roth and Yih (2004) develop a relation extraction approach that exploits constraints among entity types and the relations allowed among them. We extend this view significantly, within a similar computational framework, to exploit relations among target relations, background information and world knowledge, as a way to improve relation extraction and make globally coherent predictions. In the rest of this paper, we first describe the features used in our basic RE system in Section 2. We then describe how we make use of background knowledge in Section 3. In Section 4, we show our experimental results and perform analysis in Section 5. In Section 6, we discuss related work, before concluding in Section 7. Relation Extraction System In this section, we describe the features used in our basic relation extraction (RE) system. Given a pair of mentions m 1 and m 2 occurring within the same sentence, the system predicts whether any of the predefined relation holds between the two mentions. Since relations are usually asymmetric in nature, hence in all of our experiments, unless otherwise stated, we distinguish between the argument ordering of the two mentions. For instance, we consider m 1 :emp-org:m 2 and m 2 :emp-org:m 1 to be distinct relation types. Most of the features used in our system are based on the work in (Zhou et al., 2005) . In this paper, we propose some new collocation features inspired by word sense disambiguation (WSD). We give an overview of the features in Table 1 . Due to space limitations, we only describe the collocation features and refer the reader to (Zhou et al., 2005) for the rest of the features. Collocation Features Following (Zhou et al., 2005) , we use a single word to represent the head word of a mention. Since single words might be ambiguous or polysemous, we incorporate local collocation features which were found to be very useful for WSD. Given the head word hw m of a mention m, the collocation feature C i,j refers to the sequence of tokens in the immediate context of hw m . The offsets i and j denote the position (relative to hw m ) of the first and last token of the sequence respectively. For instance, C \u22121,+1 denotes a sequence of three tokens, consisting of the single token on the immediate left of hw m , the token hw m itself, and the single token on the immediate right of hw m . For each mention, we extract 5 features: C \u22121,\u22121 , C +1,+1 , C \u22122,\u22121 , C \u22121,+1 , and C +1,+2 . Using Background Knowledge Now we describe how we inject additional knowledge into our relation extraction system. Hierarchy of Relations When our relations of interest are arranged in a hierarchical structure, one should leverage this information to learn more accurate relation predictors. For instance, assume that our relations are arranged in a two-level hierarchy and we learn two classifiers, one for disambiguating between the first level coarse-grained relations, and another for disambiguating between the second level fine-grained relations. Since there are a lot more fine-grained relation types than coarse-grained relation types, we propose using the coarse-grained predictions which should intuitively be more reliable, to improve the fine-grained predictions. We show how to achieve this through defining appropriate constraints between the coarse-grained and fine-grained relations, which can be enforced through the Constrained Conditional Models framework (aka ILP) (Roth and Yih, 2007; Chang et al., 2008) . Due to space limitations, we refer interested readers to the papers for more information on the CCM framework. By doing this, not only are the predictions of both classifiers coherent with each other (thus obtaining better predictions from both classifiers), but more importantly, we are effectively using the (more reliable) predictions of the coarse-grained classifier to constrain the predictions of the finegrained classifier. To the best of our knowledge, this approach for RE is novel. In this paper, we work on the NIST Automatic Content Extraction (ACE) 2004 corpus. ACE defines several coarse-grained relations such as employment/membership, geo-political entity (GPE) affiliation, etc. Each coarse-grained relation is further refined into several fine-grained relations 1 and each fine-grained relation has a unique parent coarse-grained relation. For instance, the finegrained relations employed as ordinary staff, employed as an executive, etc. are children relations of employment/membership. Let m i and m j denote a pair of mentions i and j drawn from a document containing N mentions. Let R i,j denote a relation between m i and m j , and let R = {R i,j }, where 1\u2264i, j\u2264N ; i =j denote the set of relations in the document. Also, we denote the set of predefined coarse-grained relation types and fine-grained relation types as L Rc and L Rf respectively. Since there could possibly be no relation between a mention pair, we add the null label to L Rc and L Rf , allowing our classifiers to predict null for R i,j . Finally, for a fine-grained relation type rf , let V(rf ) denote its parent coarsegrained relation type. We learn two classifiers, one for disambiguating between the coarse-grained relations and one for disambiguating between the fine-grained relations. Let \u03b8 c and \u03b8 f denote the feature weights learned for predicting coarse-grained and finegrained relations respectively. Let p R (rc) = logP c (rc|m i , m j ; \u03b8 c ) be the log probability that relation R is predicted to be of coarse-grained relation type rc. Similarly, let p R (rf ) = logP f (rf |m i , m j ; \u03b8 f ) be the log probability that relation R is predicted to be of fine-grained relation type rf . Let x R,rc be a binary variable which takes on the value of 1 if relation R is labeled with the coarse-grained label rc. Similarly, let y R,rf be a binary variable which takes on the value of 1 if relation R is labeled with the finegrained label rf . Our objective function is then: max R\u2208R rc\u2208L Rc p R (rc) \u2022 x R,rc + R\u2208R rf \u2208L Rf p R (rf ) \u2022 y R,rf (1) subject to the following constraints: rc\u2208L Rc x R,rc = 1 \u2200R \u2208 R (2) rf \u2208L Rf y R,rf = 1 \u2200R \u2208 R (3) x R,rc \u2208 {0, 1} \u2200R \u2208 R, rc \u2208 L Rc (4) y R,rf \u2208 {0, 1} \u2200R \u2208 R, rf \u2208 L Rf (5) Equations ( 2 ) and (3) require that each relation can only be assigned one coarse-grained label and one fine-grained label. Equations ( 4 ) and ( 5 ) indicate that x R,rc and y R,rf are binary variables. Two more constraints follow: x R,rc \u2264 {rf \u2208L Rf |V(rf )=rc} y R,rf \u2200R \u2208 R , rc \u2208 L Rc (6) y R,rf \u2264 x R,V(rf ) \u2200R \u2208 R, rf \u2208 L Rf (7) The logical form of Equation ( 6 ) can be written as: x R,rc \u21d2 y R,rf 1 \u2228 y R,rf 2 . . . \u2228 y R,rfn , where rf 1 , rf 2 , . . . , rf n are (child) fine-grained relations of the coarse-grained relation rc. This states that if we assign rc to relation R, then we must also assign to R a fine-grained relation rf which is a child of rc. The logical form of Equation ( 7 ) can be written as: y R,rf \u21d2 x R,V(rf ) . This captures the inverse relation and states that if we assign rf to R, then we must also assign to R the relation type V(rf ), which is the parent of rf . Together, Equations ( 6 ) and ( 7 ) constrain the predictions of the coarse-grained and fine-grained classifiers to be coherent with each other. Finally, we note that one could automatically translate logical constraints into linear inequalities (Chang et al., 2008) . This method is general and is applicable to other NLP tasks where a hierarchy exists, such as WSD and question answering. For instance, in WSD, one can predict coarse-grained and finegrained senses using suitably defined sense inventories and then perform inference via ILP to obtain coherent predictions. Entity Type Constraints Each mention in ACE-2004 is annotated with one of seven coarse-grained entity types: person (per), organization (org), location (loc), geo-political entity (gpe), facility (fac), vehicle (veh), and weapon (wea). Roth and Yih (2007) had shown that entity type information is useful for constraining the possible labels that a relation R can assume. For instance, both mentions involved in a personal/social relation must be of entity type per. In this work, we gather such information from the ACE-2004 documentation and inject it as constraints (on the coarse-grained relations) into our system. Due to space limitations, we do not state the constraint equations or objective function here, but we list the entity type constraints we imposed for each coarse-grained relation m i -R-m j in Table 2 2 , where E i (E j ) denotes the allowed set of entity types for mention m i (m j ). Applying the entity type information improves the predictions of the coarse-grained classifier and this in turn could improve the predictions of the fine-grained classifier. Using Coreference Information We can also utilize the coreference relations among entity mentions. Assuming that we know mentions m i and m j are coreferent with each other, then there should be no relation between them 3 . Let z i,j be a binary variable which takes on the value of 1 if mentions m i and m j are coreferent, and 0 if they are not. When z i,j =1, we capture the above intuition with the following constraints: z i,j \u2264 x R i,j ,null (8) z i,j \u2264 y R i,j ,null (9) which can be written in logical form as: z i,j \u21d2 x R i,j ,null , and z i,j \u21d2 y R i,j ,null . We add the following to our objective function in Equation ( 1 ): m i ,m j \u2208m 2 co i,j \u2022 z i,j + co i,j \u2022 (1 \u2212 z i,j ) (10) where m is the set of mentions in a document, co i,j and co i,j are the log probabilities of predicting that m i and m j are coreferent and not coreferent respectively. In this work, we assume we are given coreference information, which is available from the ACE annotation. Using Knowledge from Wikipedia We propose two ways of using Wikipedia to gather features for relation extraction. Wikipedia is a huge online encyclopedia and mainly contains articles describing entities or concepts. The first intuition is that if we are able to correctly map a pair of mentions m i and m j to their corresponding Wikipedia article (assuming they are represented in Wikipedia), we could use the content on their Wikipedia pages to check whether they are related. In this work, we use a Wiki system (Ratinov et al., 2010) which performs context-sensitive mapping of mentions to Wikipedia pages. In their work, the authors first identify phrases or mentions that could be mapped. The correct Wikipedia article for each mention is then probabilistically predicted using a combination of features based on Wikipedia hyperlink structure, semantic coherence, etc. The authors' own evaluation results indicate that the performance of their system ranges from 70-80%. When given a pair of mentions and the system returns the Wikipedia page for either one of the mentions, we introduce a feature: w 1 (m i , m j ) = \uf8f1 \uf8f2 \uf8f3 1, if A m i (m j ) or A m j (m i ) 0, otherwise where A m i (m j ) returns true if the head extent of m j is found (via simple string matching) in the predicted Wikipedia article of m i . The interpretation of A m j (m i ) is similar. We introduce a new feature into the RE system by combining w 1 (m i , m j ) with m i , m j E-maintype (defined as in Table 1 ). The second feature based on Wikipedia is as follows. It will be useful to check whether there is any parent-child relationship between two mentions. Intuitively, this will be useful for recognizing several relations such as physical part-whole (e.g. a city is part of a state), subsidiary (a company is a child-company of another), citizenship (a person is a citizen of a country), etc. Given a pair of mentions m i and m j , we use a Parent-Child system (Do and Roth, 2010) to predict whether they have a parent-child relation. To achieve this, the system first gathers all Wikipedia articles that are related to m i and m j . It then uses the words in these pages and the category ontology of Wikipedia to make its parent-child predictions, while respecting certain defined constraints. In this work, we use its prediction as follows: w 2 (m i , m j ) = 1, if parent-child(m i , m j ) 0, otherwise Figure 1 : An example of Brown word cluster hierarchy from (Koo et al., 2008) . where we combine w 2 (m i , m j ) with m i , m j Emaintype, introducing this as a new feature into our RE system. Using Word Clusters An inherent problem faced by supervised systems is that of data sparseness. To mitigate such issues in the lexical features, we use word clusters which are automatically generated from unlabeled texts. In this work, we use the Brown clustering algorithm (Brown et al., 1992) , which has been shown to improve performance in various NLP applications such as dependency parsing (Koo et al., 2008) , named entity recognition (Ratinov and Roth, 2009) , and relation extraction (Boschee et al., 2005) . The algorithm performs a hierarchical clustering of the words and represents them as a binary tree. Each word is uniquely identified by its path from the root and every path is represented with a bit string. Figure 1 shows an example clustering where the maximum path length is 3. By using path prefixes of different lengths, one can obtain clusterings at different granularity. For instance, using prefixes of length 2 will put apple and pear into the same cluster, Apple and IBM into the same cluster, etc. In our work, we use clusters generated from New York Times text and simply use a path prefix of length 10. When Brown clusters are used in our system, all lexical features consisting of single words will be duplicated. For instance, for the feature hw of m1, one new feature which is the length-10 bit string path representing the original lexical head word of m1, will be introduced and presented to the classifier as a string feature. Experiments We used the ACE-2004 dataset (catalog LDC2005T09 from the Linguistic Data Consortium) to conduct our experiments. ACE-2004 defines 7 coarse-grained relations and 23 finegrained relations. In all of our experiments, unless otherwise stated, we explicitly model the argument order (of the mentions) when asked to disambiguate the relation between a pair of mentions. Hence, we built our coarse-grained classifier with 15 relation labels to disambiguate between (two for each coarse-grained relation type and a null label when the two mentions are not related). Likewise, our fine-grained classifier has to disambiguate between 47 relation labels. In the dataset, relations do not cross sentence boundaries. For our experiments, we trained regularized averaged perceptrons (Freund and Schapire, 1999) , implemented within the Sparse Network of Winnow framework (Carlson et al., 1999) , one for predicting the coarse-grained relations and another for predicting the fine-grained relations. Since the dataset has no split of training, development, and test sets, we followed prior work (Jiang and Zhai, 2007) and performed 5-fold cross validation to obtain our performance results. For simplicity, we used 5 rounds of training and a regularization parameter of 1.5 for the perceptrons in all our experiments. Finally, we concentrate on the evaluation of fine-grained relations. Performance of the Basic RE system As a gauge on the performance of our basic relation extraction system BasicRE using only the features described in Section 2, we compare against the state-of-the-art feature-based RE system of Jiang and Zhai (2007) . However, we note that in that work, the authors performed their evaluation using undirected coarse-grained relations. That is, they do not distinguish on argument order of mentions and the classifier has to decide among 8 relation labels (7 coarse-grained relation types and a null label). Performing 5-fold cross validation on the news wire (nwire) and broadcast news (bnews) corpora in the ACE-2004 dataset, they reported a F-measure of 71.5 using a maximum entropy classifier 4 . Evaluating BasicRE on the same setting, Table 3 : BasicRE gives the performance of our basic RE system on predicting fine-grained relations, obtained by performing 5-fold cross validation on only the news wire corpus of ACE-2004. Each subsequent row +Hier, +Hier+relEntC, +Coref, +Wiki, and +Cluster gives the individual contribution from using each knowledge. The bottom row +ALL gives the performance improvements from adding +Hier+relEntC+Coref+Wiki+Cluster. \u223c indicates no change in score. we obtained a competitive F-measure of 71.2 5 . Experimental Settings for Evaluating Fine-grained Relations Two of our knowledge sources, the Wiki system described in Section 3.4 and the word clusters described in Section 3.5, assume inputs of mixedcased text. We note that the bnews corpus of ACE-2004 is entirely in lower-cased text. Hence, we use only the nwire corpus for our experiments here, from which we gathered 28,943 relation instances and 2,226 of those have a valid (non-null) relation 6 . We also propose the following experimental setting. First, since we made use of coreference information, we made sure that while performing our experiments, all instances from the same document are either all used as training data or all used as test data. Prior work in RE had not ensured this, but we argue that this provides a more realistic setting. Our own experiments indicate that this results in a 1-2% lower performance on fine-grained relations. Secondly, prior work calculate their performance on relation extraction at the level of mentions. That is, each mention pair extracted is scored individually. An issue with this way of scoring on the ACE corpus is that ACE annota-5 Using 10 rounds of training and a regularization parameter of 2.5 improves the result to 72.2. In general, we found that more rounds of training and a higher regularization value benefits coarse-grained relation classification, but not finegrained relation classification. 6 The number of relation instances in the nwire and bnews corpora are about the same. tors rarely duplicate a relation link for coreferent mentions. For instance, assume that mentions m i , m j , and m k exist in a given sentence, mentions m i and m j are coreferent, and the annotator establishes a particular relation type r between m j and m k . The annotator will not usually duplicate the same relation r between m i and m k and thus the label between these two mentions is then null. We are not suggesting that this is an incorrect approach, but clearly there is an issue since an important goal of performing RE is to populate or build an ontology of entities and establish the relations existing among the entities. Thus, we evaluate our performance at the entity-level. 7 That is, given a pair of entities, we establish the set of relation types existing between them, based on their mention annotations. Then we calculate recall and precision based on these established relations. Of course, performing such an evaluation requires knowledge about the coreference relations and in this work, we assume we are given this information. Knowledge-Enriched System Evaluating our system BasicRE (trained only on the features described in Section 2) on the nwire corpus, we obtained a F1 score of 50.5, as shown in Table 3 . Next, we exploited the relation hierarchy as in Section 3.1 and obtained an improvement of 1.3, as shown in the row +Hier. Next, we added the entity type constraints of Section 3.2. Remember that these constraints are imposed on the coarse-grained relations. Thus, they would only affect the fine-grained relation predictions if we also exploit the relation hierarchy. In the table, we show that all the background knowledge helped to improve performance, providing a total improvement of 3.9 to our basic RE system. Though the focus of this work is on fine-grained relations, our approach also improves the performance of coarse-grained relation predictions. Ba-sicRE obtains a F1 score of 65.3 on coarse-grained relations and exploiting background knowledge gives a total improvement of 2.9. Analysis We explore the situation where we have very little training data. We assume during each cross validation fold, we are given only 10% of the training data we originally had. Previously, when performing 5-fold cross validation on 2,226 valid relation instances, had about 1780 as training instances in each fold. Now, we assume we are only given about 178 training instances in each fold. Under this condition, BasicRE gives a F1 score of 31.0 on fine-grained relations. Adding all the background knowledge gives an improvement of 7.6 and this represents an error reduction of 39% when measured against the performance difference of 50.5 (31.0) when we have 1780 training instances vs. 178 training instances. On the coarse-grained relations, BasicRE gives a F1 score of 51.1 and exploiting background knowledge gives a total improvement of 5.0. We also tabulated the list of fine-grained relations that improved by more than 1 F1 score when we incorporated +Wiki, on the experiment using all of nwire data: phys:near (physically near), other-aff:ideology (ideology affiliation), art:user-or-owner (user or owner of artifact), persoc:business (business relationship), phys:partwhole (physical part-whole), emp-org:subsidiary (organization subsidiary), and gpe-aff:citizen-orresident (citizen or resident). Most of these intuitively seemed to be information one would find being mentioned in an encyclopedia. Related Work Few prior work has explored using background knowledge to improve relation extraction performance. Zhou et al. (2008) took advantage of the hierarchical ontology of relations by proposing methods customized for the perceptron learning algorithm and support vector machines. In contrast, we propose a generic way of using the relation hierarchy which at the same time, gives globally coherent predictions and allows for easy injection of knowledge as constraints. Recently, Jiang (2009) proposed using features which are common across all relations. Her method is complementary to our approach, as she does not consider information such as the relatedness between different relations. On using semantic resources, Zhou et al. (2005) gathered two gazettes, one containing country names and another containing words indicating personal relationships. In relating the tasks of RE and coreference resolution, Ji et al. (2005) used the output of a RE system to rescore coreference hypotheses. In our work, we reverse the setting and explore using coreference to improve RE. Conclusion In this paper, we proposed a broad range of methods to inject background knowledge into a relation extraction system. Some of these methods, such as exploiting the relation hierarchy, are general in nature and could be easily applied to other NLP tasks. To combine the various relation predictions and knowledge, we perform global inference within an ILP framework. Besides allowing for easy injection of knowledge as constraints, this ensures globally coherent models and predictions. Acknowledgements This research was partly sponsored by Air Force Research Laboratory (AFRL) under prime contract no. FA8750-09-C-0181. We thank Ming-Wei Chang and James Clarke for discussions on this research.",
    "abstract": "Relation extraction is the task of recognizing semantic relations among entities. Given a particular sentence supervised approaches to Relation Extraction employed feature or kernel functions which usually have a single sentence in their scope. The overall aim of this paper is to propose methods for using knowledge and resources that are external to the target sentence, as a way to improve relation extraction. We demonstrate this by exploiting background knowledge such as relationships among the target relations, as well as by considering how target relations relate to some existing knowledge resources. Our methods are general and we suggest that some of them could be applied to other NLP tasks.",
    "countries": [
        "United States"
    ],
    "languages": [],
    "numcitedby": "93",
    "year": "2010",
    "month": "August",
    "title": "Exploiting Background Knowledge for Relation Extraction"
}