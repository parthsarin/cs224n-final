{
    "article": "This paper proposes a novel class of PCFG parameterizations that support linguistically reasonable priors over PCFGs. To estimate the parameters is to discover a notion of relatedness among context-free rules such that related rules tend to have related probabilities. The prior favors grammars in which the relationships are simple to describe and have few major exceptions. A basic version that bases relatedness on weighted edit distance yields superior smoothing of grammars learned from the Penn Treebank (20% reduction of rule perplexity over the best previous method). A Sketch of the Concrete Problem This paper uses a new kind of statistical model to smooth the probabilities of PCFG rules. It focuses on \"flat\" or \"dependency-style\" rules. These resemble subcategorization frames, but include adjuncts as well as arguments. The verb put typically generates 3 dependents-a subject NP at left, and an object NP and goal PP at right: \u2022 S \u2192 NP put NP PP: Jim put [the pizza] [in the oven] But put may also take other dependents, in other rules: Background and Other Approaches A PCFG is a conditional probability function p(RHS | LHS). 1 For example, p(V NP PP | VP) gives the probability of the rule VP \u2192 V NP PP. With lexicalized nonterminals, it has form p(V put NP pizza PP in | VP put ). Usually one makes an independence assumption and defines this as p(V put NP PP | VP put ) times factors that choose dependent headwords pizza and in according to the selectional preferences of put. This paper is about estimating the first factor, p(V put NP PP | VP put ). In supervised learning, it is simplest to use a maximum likelihood estimate (perhaps with backoff from put). Charniak (1997) calls this a \"Treebank grammar\" and gambles that assigning 0 probability to rules unseen in training data will not hurt parsing accuracy too much. However, there are four reasons not to use a Treebank grammar. First, ignoring unseen rules necessarily sacrifices some accuracy. Second, we will show that it improves accuracy to flatten the parse trees and use flat, dependency-style rules like p(NP put NP PP | S put ); this avoids overly strong independence assumptions, but it increases the number of unseen rules and so makes Treebank grammars less tenable. Third, backing off from the word is a crude technique that does not distinguish among words. 2 Fourth, one would eventually like to reduce or eliminate supervision, and then generalization is important to constrain the search to reasonable grammars. To smooth the distribution p(RHS | LHS), one can define it in terms of a set of parameters and then estimate those parameters. Most researchers have used an n-gram model (Eisner, 1996; Charniak, 2000) or more general Markov model (Alshawi, 1996) to model the sequence of nonterminals in the RHS. The sequence V put NP PP in our example is then assumed to be emitted by some Markov model of VP put rules (again with backoff from put). Collins (1997, model 2) uses a more sophisticated model in which all arguments in this sequence are generated jointly, as in a Treebank grammar, and then a Markov process is used to insert adjuncts among the arguments. While Treebank models overfit the training data, Markov models underfit. A simple compromise (novel to this paper) is a hybrid Treebank/Markov model, which backs off from a Treebank model to a Markov. Like this paper's main proposal, it can learn well-observed idiosyncratic rules but generalizes when data are sparse. 3 These models are beaten by our rather different model, transformational smoothing, which learns common rules and common edits to them. The comparison is a direct one, based on the perplexity or cross-entropy of the trained models on a test set of S \u2192 \u2022 \u2022 \u2022 rules. 4 A subtlety is that two annotation styles are possible. In the Penn Treebank, put is the head of three constituents (V, VP, and S, where underlining denotes a head child) and joins with different dependents at different levels: \u2022 [ S [ NP Jim] [ VP [ V put] [ NP pizza] [ PP in the oven]]] In the flattened or dependency version that we prefer, each word joins with all of its dependents at once: \u2022 [ S [ NP Jim] put [ NP pizza] [ PP in the oven]] A PCFG generating the flat structure must estimate p(NP put NP PP | S put ). A non-flat PCFG adds the dependents of put in 3 independent steps, so in effect it factors the flat rule's probability into 3 supposedly independent \"subrule probabilities,\" p(NP VP put | S put ) \u2022 p(V put NP PP | VP put ) \u2022 p(put | V put ). Our evaluation judges the estimates of flat-rule probabilities. Is it better to estimate these directly, or as a product of estimated subrule probabilities? 5 Transformational smoothing is best applied to the former, so that the edit operations can freely rearrange all of a word's dependents. We will see that the Markov and Treebank/Markov models also work much better this way-a useful finding. The Abstract Problem: Designing Priors This section outlines the Bayesian approach to learning probabilistic grammars (for us, estimating a distribution over flat CFG rules). By choosing among the many grammars that could have generated the training data, the learner is choosing how to generalize to novel sentences. To guide the learner's choice, one can explicitly specify a prior probability distribution p(\u03b8) over possible grammars \u03b8, which themselves specify probability distributions over strings, rules, or trees. A learner should seek \u03b8 that maximizes p(\u03b8) \u2022 p(D | \u03b8), where D is the set of strings, rules, or trees observed by the learner. The first factor favors regularity (\"pick an a priori plausible grammar\"), while the second favors fitting the idiosyncrasies of the data, especially the commonest data. 6 to evaluate rule distributions that they acquired from an automatically-parsed treebank. Priors can help both unsupervised and supervised learning. (In the semi-supervised experiments here, training data is not raw text but a sparse sample of flat rules.) Indeed a good deal of syntax induction work has been carried out in just this framework (Stolcke and Omohundro, 1994; Chen, 1996; De Marcken, 1996; Gr\u00fcnwald,  1996; Osborne and Briscoe, 1997). However, all such work to date has adopted rather simple prior distributions. Typically, it has defined p(\u03b8) to favor PCFGs whose rules are few, short, nearly equiprobable, and defined over a small set of nonterminals. Such definitions are convenient, especially when specifying an encoding for MDL, but since they treat all rules alike, they may not be good descriptions of linguistic plausibility. For example, they will never penalize the absence of a predictable rule. A prior distribution can, however, be used to encode various kinds of linguistic notions. After all, a prior is really a soft form of Universal Grammar: it gives the learner enough prior knowledge of grammar to overcome Chomsky's \"poverty of the stimulus\" (i.e., sparse data). \u2022 A preference for small or simple grammars, as above. \u2022 Substantive preferences, such as a preference for verbs to take 2 nominal arguments, or to allow PP adjuncts. \u2022 Preferences for systematicity, such as a preference for the rules to be consistently head-initial or head-final. This paper shows how to design a prior that favors a certain kind of systematicity. Lexicalized grammars for natural languages are very large-each word specifies a distribution over all possible dependency rules it could head-but they tend to have internal structure. The new prior prefers grammars in which a rule's probability can be well-predicted from the probabilities of other rules, using linguistic transformations such as edit operations. For example, p(NP Adv w put NP PP | S w ) correlates with p(NP w NP PP | S w ). Both numbers are high for w = put, medium for w = fund, and low for w = sleep. The slope of the regression line has to do with the rate of preverbal Adv-insertion in English. The correlation is not perfect (some verbs are especially prone to adverbial modification), which is why we will only model it with a prior. To just the extent that evidence about w is sparse, the prior will cause the learner to smooth the two probabilities toward the regression line. Patterns Worth Modeling Before spelling out our approach, let us do a sanity check. A frame is a flat rule whose headword is replaced with teriori learning, since it is equivalent to maximizing p(\u03b8 | D). It is also equivalent to Minimum Description Length (MDL) learning, which minimizes the total number of bits (\u03b8)+ (D | \u03b8) needed to encode grammar and data, because one can choose an encoding scheme where (x) = \u2212 log 2 p(x), or conversely, define probability distributions by p(x) = 2 Table 1 : The most predictive pairs of sentential frames. If S \u2192 \u03b1 occurs in training data at least 5 times with a given headword in the position, then S \u2192 \u03b2 also tends to appear at least once with that headword. MI measures the mutual information of these two events, computed over all words. When MI is large, as here, the edit distance between \u03b1 and \u03b2 tends to be strikingly small (1 or 2), and certain linguistically plausible edits are extremely common. the variable \" \" (corresponding to w above). Table 1 illustrates that in the Penn Treebank, if frequent rules with frame \u03b1 imply matching rules with frame \u03b2, there are usually edit operations (section 1) to easily turn \u03b1 into \u03b2. How about rare rules, whose probabilities are most in need of smoothing? Are the same edit transformations that we can learn from frequent cases (Table 1 ) appropriate for predicting the rare cases? The very rarity of these rules makes it impossible to create a table like Table 1 . However, rare rules can be measured in the aggregate, and the result suggests that the same kinds of transformations are indeed useful-perhaps even more useful-in predicting them. Let us consider the set R of 2,809,545 possible flat rules that stand at edit distance 1 from the set of S \u2192 \u2022 \u2022 \u2022 rules observed in our English training data. That is, a rule such as S put \u2192 NP put NP is in R if it did not appear in training data itself, but could be derived by a single edit from some rule that did appear. A bigram Markov model (section 2) was used to identify 2,714,763 rare rules in R-those that were predicted to occur with probability < 0.0001 given their headwords. 79 of these rare rules actually appeared in a development-data set of 1423 rules. The bigram model would have expected only 26.2 appearances, given the lexical headwords in the test data set. The difference is statistically significant (p < 0.001, bootstrap test). In other words, the bigram model underpredicts the edit-distance \"neighbors\" of observed rules by a factor of 3. 7 One can therefore hope to use the edit transformations to improve on the bigram model. For example, the 7 Similar results are obtained when we examine just one particular kind of edit operation, or rules of one particular length. Delete Y transformation recognizes that if \u2022 \u2022 \u2022 X Y Z \u2022 \u2022 \u2022 has been observed, then \u2022 \u2022 \u2022 X Z \u2022 \u2022 \u2022 is plausible even if the bigram X Z has not previously been observed. Presumably, edit operations are common because they modify a rule in semantically useful ways, allowing the filler of a semantic role to be expressed (Insert), suppressed (Delete), retyped (Substitute), or heavy-shifted (Swap). Such \"valency-affecting operations\" have repeatedly been invoked by linguists; they are not confined to English. 8 So a learner of an unknown language can reasonably expect a priori that flat rules related by edit operations may have related probabilities. However, which edit operations varies by language. Each language defines its own weighted, contextual, asymmetric edit distance. So the learner will have to discover how likely particular edits are in particular contexts. For example, it must learn the rates of preverbal Adv-insertion and right-edge PP-insertion. Evidence about these rates comes mainly from the frequent rules. A Transformation Model The form of our new model is shown in Figure 1 . The vertices are flat context-free rules, and the arcs between them represent edit transformations. The set of arcs leav- 1 : A fragment of a transformation model. Vertices are possible context-free rules (their left-hand sides, Sfund \u2192 and Smerge \u2192 , are omitted to avoid visual clutter). Arc probabilities are determined log-linearly, as shown, from a real-valued vector \u03b8 of feature weights. The Z values are chosen so that the arcs leaving each vertex have total probability 1. Dashed arrows represent arcs not shown here (there are hundreds from each vertex, mainly insertions). Also, not all features are shown (see Table 2 ). ing any given vertex has total probability 1. The learner's job is to discover the probabilities. Fortunately, the learner does not have to learn a separate probability for each of the (infinitely) many arcs, since many of the arcs represent identical or similar edits. As shown in Figure 1 , an arc's probability is determined from meaningful features of the arc, using a conditional log-linear model of p(arc | source vertex). The learner only has to learn the finite vector \u03b8 of feature weights. Arcs that represent similar transformations have similar features, so they tend to have similar probabilities. This transformation model is really a PCFG with unusual parameterization. That is, for any value of \u03b8, it defines a language-specific probability distribution over all possible context-free rules (graph vertices). To sample from this distribution, take a random walk from the special vertex START to the special vertex HALT. The rule at the last vertex reached before HALT is the sample. This sampling procedure models a process where the speaker chooses an initial rule and edits it repeatedly. The random walk might reach S fund \u2192 To fund NP in two steps and simply halt there. This happens with probability 0.0011 \u2022 exp \u03b81 Z1 \u2022 exp \u03b80 Z2 . Or, having arrived at S fund \u2192 To fund NP, it might transform it into S fund \u2192 To fund PP NP and then further to S fund \u2192 To fund NP PP before halting. Thus, p \u03b8 (S fund \u2192 To fund NP PP) denotes the probability that the random walk somehow reaches S fund \u2192 To fund NP PP and halts there. Conditionalizing this probability gives p \u03b8 (To NP PP | S fund ), as needed for the PCFG. 9 9 The experiments of this paper do not allow transformations Given \u03b8, it is nontrivial to solve for the probability distribution over grammar rules e. Let I \u03b8 (e) denote the flow to vertex e. This is defined to be the total probability of all paths from START to e. Equivalently, it is the expected number of times e would be visited by a random walk from START. The following recurrence defines p \u03b8 (e): 10 (2) Since solving the large linear system (1) would be prohibitively expensive, in practice we use an approximate relaxation algorithm (Eisner, 2001) that propagates flow through the graph until near-convergence. In general this may underestimate the true probabilities somewhat. Now consider how the parameter vector \u03b8 affects the distribution over rules, p \u03b8 (e), in Figure 1: \u2022 By raising the initial weight \u03b8 1 , one can increase the flow to S fund \u2192 To fund NP, S merge \u2192 To merge NP, and the like. By equation (2), this also increases the probability of these rules. But the effect also feeds through the graph to increase the flow and probability at those rules' descendants in the graph, such as S merge \u2192 To merge NP PP. So a single parameter \u03b8 1 controls a whole complex of rule probabilities (roughly speaking, the infinitival transitives). The model thereby captures the fact that, although rules are mutually exclusive events whose probabilities sum to 1, transformationally related rules have positively correlated probabilities that rise and fall together. \u2022 The exception weight \u03b8 9 appears on all and only the arcs to S merge \u2192 To merge NP PP. That rule has even higher probability than predicted by PP-insertion as above (since merge, unlike fund, actually tends to subcategorize for PP with ). To model its idiosyncratic probability, one can raise \u03b8 9 . This \"lists\" the rule specially in the grammar. Rules derived from it also increase in probability (e.g., S merge \u2192 To Adv merge NP PP), since again the effect feeds through the graph. \u2022 The generalization weight \u03b8 3 models the strength of the PP-insertion relationship. Equations ( 1 ) and ( 2 ) imply that p \u03b8 (S fund \u2192 To fund NP PP) is modeled as a linear combination of the probabilities of that rule's parents in the graph. \u03b8 3 controls the coefficient of p \u03b8 (S fund \u2192 To fund NP) in this linear combination, with the coefficient approaching zero as \u03b8 3 \u2192 \u2212\u221e. \u2022 Narrower generalization weights such as \u03b8 4 and \u03b8 5 control where PP is likely to be inserted. To learn the feature weights is to learn which features of a transformation make it probable or improbable in the language. Note that the vertex labels, graph topology, and arc parameters are language independent. That is, Figure 1 is supposed to represent Universal Grammar: it tells a learner what kinds of generalizations to look for. The language-specific part is \u03b8, which specifies which generalizations and exceptions help to model the data. The Prior The model has more parameters than data. Why? Beyond the initial weights and generalization weights, in practice we allow one exception weight (e.g., \u03b8 8 , \u03b8 9 ) for each rule that appeared in training data. (This makes it possible to learn arbitrary exceptions, as in a Treebank grammar.) Parameter estimation is nonetheless possible, using a prior to help choose among the many values of \u03b8 that do a reasonable job of explaining the training data. The prior constrains the degrees of freedom: while many parameters are available in principle, the prior will ensure that the data are described using as few of them as The point of reparameterizing a PCFG in terms of \u03b8, as in Figure 1 , is precisely that only one parameter is needed per linguistically salient property of the PCFG. Making \u03b8 3 > 0 creates a broadly targeted transformation. Making \u03b8 9 = 0 or \u03b8 1 = 0 lists an idiosyncratic rule, or class of rules, together with other rules derived from them. But it takes more parameters to encode less systematic properties, such as narrowly targeted edit transformations (\u03b8 4 , \u03b8 5 ) or families of unrelated exceptions. A natural prior for the parameter vector \u03b8 \u2208 R k is therefore specified in terms of a variance \u03c3 2 . We simply say that the weights \u03b8 1 , \u03b8 2 , . . . \u03b8 k are independent samples from the normal distribution with mean 0 and variance \u03c3 2 > 0 (Chen and Rosenfeld, 1999): \u0398 \u223c N (0, \u03c3 2 ) \u00d7 N (0, \u03c3 2 ) \u00d7 \u2022 \u2022 \u2022 \u00d7 N (0, \u03c3 2 ) (3) or equivalently, that \u03b8 is drawn from a multivariate Gaussian with mean 0 and diagonal covariance matrix \u03c3 2 I, i.e., \u0398 \u223c N ( 0, \u03c3 2 I). This says that a priori, the learner expects most features in Figure 1 to have weights close to zero, i.e., to be irrelevant. Maximizing p(\u03b8) \u2022 p(D | \u03b8) means finding a relatively small set of features that adequately describe the rules and exceptions of the grammar. Reducing the variance \u03c3 2 strengthens this bias toward simplicity. For example, if S fund \u2192 To fund NP PP and S merge \u2192 To fund NP PP are both observed more often than the current p \u03b8 distribution predicts, then the learner can follow either (or both) of two strategies: raise \u03b8 8 and \u03b8 9 , or raise \u03b8 3 . The former strategy fits the training data only; the latter affects many disparate arcs and leads to generalization. The latter strategy may harm p(D | \u03b8) but is preferred by the prior p(\u03b8) because it uses one parameter instead of two. If more than two words act like merge and fund, the pressure to generalize is stronger. Perturbation Parameters In experiments, we have found that a slight variation on this model gets slightly better results. Let \u03b8 e denote the exception weight (if any) that allows one to tune the probability of rule e. We eliminate \u03b8 e and introduce a different parameter \u03c0 e , called a perturbation, which is used in the following replacements for equations ( 1 ) and ( 2 where Z is a global normalizing factor chosen so that e p \u03b8 (e) = 1. The new prior on \u03c0 e is the same as the old prior on \u03b8 e . Increasing either \u03b8 e or \u03c0 e will raise p \u03b8 (e); the learner may do this to account for observations of e in training data. The probabilities of other rules consequently decrease so that e p \u03b8 (e) = 1. When \u03c0 e is raised, all rules' probabilities are scaled down slightly and equally (because Z increases). When \u03b8 e is raised, e steals probability from its siblings, 11 but these are similar to e so tend to appear in test data if e is in training data. Raising \u03b8 e without disproportionately harming e's siblings requires manipulation of many other parameters, which is discouraged by the prior and may also suffer from search error. We speculate that this is why \u03c0 e works better. Evaluation 12 To evaluate the quality of generalization, we used preparsed training data D and testing data E (Table 3 ). Each dataset consisted of a collection of flat rules such as S put \u2192 NP put NP PP extracted from the Penn Treebank (Marcus et al., 1993). Thus, p(D | \u03b8, \u03c0) and p(E | \u03b8, \u03c0) were each defined as a product of rule probabilities of the form p \u03b8,\u03c0 (NP put NP PP | S put ). The learner attempted to maximize p(\u03b8, \u03c0) \u2022 p(D | \u03b8, \u03c0) by gradient ascent. This amounts to learning the generalizations and exceptions that related the training rules D. The evaluation measure was then the perplexity on test data, \u2212 log 2 p(E | \u03b8, \u03c0)/|E| . To get a good (low) perplexity score, the model had to assign reasonable probabilities to the many novel rules in E (Table 3 ). For many of these rules, even the frame was novel. Note that although the training data was preparsed into rules, it was not annotated with the paths in Figure 1 that generated those rules, so estimating \u03b8 and \u03c0 was still an unsupervised learning problem. The transformation graph had about 14 features per arc (Table 2 ). In the finite part of the transformation graph that was actually explored (including bad arcs that compete with good ones), about 70000 distinct features were encountered, though after training, only a few hundred feature weights were substantial, and only a few thousand were even far enough from zero to affect performance. There was also a parameter \u03c0 e for each observed rule e. Results are given in Table 4a , which compares the transformation model to various competing models discussed in section 2. The best (smallest) perplexities appear in boldface. The key results: \u2022 The transformation model was the winner, reducing perplexity by 20% over the best model replicated from previous literature (a bigram model). \u2022 Much of this improvement could be explained by the transformation model's ability to model exceptions. Adding this ability more directly to the bigram model, using the new Treebank/Markov approach of section 2, also reduced perplexity from the bigram model, by 6% or 14% depending on whether Katz or one-count backoff was used, versus the transformation model's 20%. \u2022 Averaging the transformation model with the best competing model (Treebank/bigram) improved it by an additional 6%. So using transformations yields a total perplexity reduction of 12% over Treebank/bigram, and 24% over the best previous model from the literature (bigram). \u2022 What would be the cost of achieving such a perplexity improvement by additional annotation? Training the averaged model on only the first half of the training set, with no further tuning of any options (Table 4b ), yielded a test set perplexity of 118.0. So by using transformations, we can achieve about the same perplexity as the best model without transformations (Treebank/bigram, 116.2), using only half as much training data. \u2022 Furthermore, comparing Tables 4a and 4b shows that the transformation model had the most graceful performance degradation when the dataset was reduced in size. This is an encouraging result for the use of the method in less supervised contexts (although results on a noisy dataset would be more convincing in this regard). \u2022 The competing models from the literature are best used to predict flat rules directly, rather than by summing over their possible non-flat internal structures, as has been done in the past. This result is significant in itself. Extending Johnson (1998), it shows the inappropriateness of the traditional independence assumptions that build up a frame by several rule expansions (section 2). Figure 2 shows that averaging the transformation model with the Treebank/bigram model improves the latter not merely on balance, but across the board. In other words, there is no evident class of phenomena for which incorporating transformations would be a bad idea. \u2022 Transformations particularly helped raise the estimates of the low-probability novel rules in test data, as hoped. \u2022 Transformations also helped on test rules that had been observed once in training with relatively infrequent words. (In other words, the transformation model does not discount singletons too much.) \u2022 Transformations hurt slightly on balance for rules observed more than once in training, but the effect was tiny. All these differences are slightly exaggerated if one compares the transformation model directly with the Treebank/bigram model, without averaging. The transformation model was designed to use edit operations in order to generalize appropriately from a word's observed frames to new frames that are likely to appear with that word in test data. To directly test the model's success at such generalization, we compared it to the bigram model on a pseudo-disambiguation task. Each instance of the task consisted of a pair of rules from test data, expressed as (word, frame) pairs (w 1 , f 1 ) and (w 2 , f 2 ), such that f 1 and f 2 are \"novel\" frames that did not appear in training data (with any headword). Each model was then asked: Does f 1 go with w 1 and f 2 with w 2 , or vice-versa? In other words, which is bigger , p(f 1 | w 1 ) \u2022 p(f 2 | w 2 ) or p(f 2 | w 1 ) \u2022 p(f 1 | w 2 )? Since the frames were novel, the model had to make the choice according to whether f 1 or f 2 looked more like the frames that had actually been observed with w 1 in the past, and likewise w 2 . What this means depends on the model. The bigram model takes two frames to look alike if they contain many bigrams in common. The transformation model takes two frames to look alike if they are connected by a path of probable transformations. The test data contained 62 distinct rules (w, f ) in which f was a novel frame. This yielded 62\u202261 2 = 1891 pairs of rules, leading to 1811 task instances after obvious ties were discarded. 13 Baseline performance on this difficult task is 50% (random guess). The bigram model chose correctly in 1595 of the 1811 instances (88.1%). Parameters for \"memorizing\" specific frames do not help on this task, which involves only novel frames, so the Treebank/bigram model had the same performance. By contrast, the transformation model got 1669 of 1811 correct (92.2%), for a morethan-34% reduction in error rate. (The development set showed similar results.) However, since the 1811 task instances were derived non-independently from just 62 novel rules, this result is based on a rather small sample. Discussion This paper has presented a nontrivial way to reparameterize a PCFG in terms of \"deep\" parameters representing transformations and exceptions. A linguistically sensible prior was natural to define over these deep parameters. Famous examples of \"deep reparameterization\" are the Fourier transform in speech recognition and the SVD transform for Latent Semantic Analysis in IR. Like our technique, they are intended to reveal significant structure through the leading parameters while relegating noise and exceptions to minor parameters. Such representations make it easier to model the similarity or probability of the objects at hand (waveforms, documents, or grammars). Beyond the fact that it shows at least a good perplexity improvement (it has not yet been applied to a real task), an exciting \"big idea\" aspect of this work is its flexibility in defining linguistically sensible priors over grammars. Our reparameterization is made with reference to a user-designed transformation graph (Figure 1 ). The graph need not be confined to edit distance transformations, or to the simple features of Table 2 (used here for comparability with the Markov models), which condition a transformation's probability on local context. In principle, the approach could be used to capture a great many linguistic phenomena. Figure 1 could be extended with more ambitious transformations, such as gapping, gap-threading, and passivization. The flat rules could be annotated with internal structure (as in TAG) and thematic roles. Finally, the arcs could bear further features. For example, the probability of unaccusative movement (someone sank the boat \u2192 the boat sank) should depend on whether the headword is a change-of-state verb. Indeed, Figure 1 can be converted to any lexicalized theory of grammar, such as categorial grammar, TAG, LFG, HPSG, or Minimalism. The vertices represent lexical entries and the arcs represent probabilistic lexical redundancy rules or metarules (see footnote 8). The transformation model approach is therefore a full stochastic treatment of lexicalized syntax-apparently the first to treat lexical redundancy rules, although (Briscoe and  Copestake, 1999) give an ad hoc approach. See (Eisner,  2001; Eisner, 2002a) for more discussion. It is worthwhile to compare the statistical approach here with some other approaches: \u2022 Transformation models are similar to graphical models: they allow similar patterns of deductive and abductive inference from observations. However, the vertices of a transformation graph do not represent different random variables, but rather mutually exclusive values of the same random variable, whose probabilities sum to 1. \u2022 Transformation models incorporate conditional loglinear (maximum entropy) models. As an alternative, one could directly build a conditional log-linear model of p(RHS | LHS). However, such a model would learn probabilities, not relationships. A feature weight would not really model the strength of the relationship between two frames e, e that share that feature. It would only influence both frames' probabilities. If the probability of e were altered by some unrelated factor (e.g., an exception weight), then the probability of e would not respond. \u2022 A transformation model can be regarded as a probabilistic FSA that consists mostly of -transitions. (Rules are only emitted on the arcs to HALT.) This perspective allows use of generic methods for finite-state parameter estimation (Eisner, 2002b). We are strongly interested in improving the speed of such methods and their ability to avoid local maxima, which are currently the major difficulty with our system, as they are for many unsupervised learning techniques. We expect to further pursue transformation models (and simpler variants that are easier to estimate) within this flexible finite-state framework. The interested reader is encouraged to look at (Eisner,  2001) for a much more careful and wide-ranging discussion of transformation models, their algorithms, and their relation to linguistic theory, statistics, and parsing. Chapter 1 provides a good overview. For a brief article highlighting the connection to linguistics, see (Eisner, 2002a).",
    "abstract": "This paper proposes a novel class of PCFG parameterizations that support linguistically reasonable priors over PCFGs. To estimate the parameters is to discover a notion of relatedness among context-free rules such that related rules tend to have related probabilities. The prior favors grammars in which the relationships are simple to describe and have few major exceptions. A basic version that bases relatedness on weighted edit distance yields superior smoothing of grammars learned from the Penn Treebank (20% reduction of rule perplexity over the best previous method). A Sketch of the Concrete Problem This paper uses a new kind of statistical model to smooth the probabilities of PCFG rules. It focuses on \"flat\" or \"dependency-style\" rules. These resemble subcategorization frames, but include adjuncts as well as arguments. The verb put typically generates 3 dependents-a subject NP at left, and an object NP and goal PP at right: \u2022 S \u2192 NP put NP PP: Jim put [the pizza] [in the oven] But put may also take other dependents, in other rules:",
    "countries": [
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "16",
    "year": "2002",
    "month": "July",
    "title": "Transformational Priors Over Grammars"
}