{
    "article": "In a proposal, Vijay-Shanker and Joshi presented a definition for combining ttw two formalisms Tree Adjoining Grammars and PATR unification. The essential idea for that combination is the separation of the two recursion operations -adjoining and unification -to preserve all properties of both formalisms which is not desirable for natural language applications. In this paper, a definition for the integrated use of both processes is given and the remaining properties of the resulting formalism are discussed -especially weighing the appropriateness of this d~finition for natural language processing. i1 Introduction iln the field of natural language analysis, Unification Grammars are a main research topic. Presently, Unification is defined as extension of context-flee grmnm~s. Knowing th, e formalism of Tree Adjoining Grammars (in the following called TAGs in short), which is closely related to context-free gr,'tmmars (in the I611owing abbreviated CFG), the idea arises to replace the context-free grammar in a Unification Grammar by ;t TAG. The advantage of TAGs is that complete context-fl'ee derivation trees or parts of them build the rqles of that grammar type (e.=.,, with the intention of ~epresenting a whole linguistic phenomenon). The ~ecursion operation for TAGs allows the replacement of nodes by a tree (defined by a TAG-rule), so that larger t;tructure u'ees are processed. In the literature, a first definition for combining these two formalisms was proposed, where the main idea is Io sepwate the two recursion processes -adjoining and unificationto preserve all properties of both Here a different approach is chosen, where both recursion processes are integrated. The main point to emphasize here is that the different approaches not only represent a .';witch between two modes of interpreting the same definition, but a change in the properties of the resulting formalism. This can be sirnply demonstrated by the property of monotonicity of the unification. Associated with each lree of a TAG all sp\u00a2ification rules for the unification are interpreted at once (e.g., represented as links between the DAG representation of the specification rules at each node in the tree). If now the recursion process of TAGs, the adjoining operation, combines two trees, which both have DAGs, a strategy for reinterpretation of specification information must be defined, because an adjoining modifies inner nodes, where links still are installed. la the following, the two formalisms are briefly revisited to have a common terminological basis with rite reader, before the existing definition of Tree Adjoining Grammars with Unification is presented. In contrast to this approach, the new definition is motivated and its properties are discussed. Finally, our experience with an implementation of that definition in the application domain of syntax analysis (e.g., in a natural language dialogue system) is summarized. 2 The Two Basic Formalisms TAG and PATR In this section, the formalism of TAGs is motivated to be appropriate to replace a context-free grammar in natural language description. Weighing the disadvantages remaining for TAGs, which are the seane as for CFGs, the same extending formalism as for CFGs -Unification Grammars -has been chosen to resolve these disadvantages for TAGs. 2.1 A Short Outline of Tree Adjoining Grammars In 1975, the formalism of Tree Adjoining Grammars (TAGs) was introduced by Aravind K. Joshi, Leon S. Levy and Masako Takahashi (see [Joshi et al. 75] ). Since then, a wide variety of properties -formal properties as well as linguistically relevant ones -were studied (see, e.g., [Joshi 85 ] for a good overview). The following example describing the crossed dependencies in Dutch should illustrate the formalism (see Figure 1 , where the node numbers written in slanted font should be ignored here, they make sense in combination with Figure 3 ). A TAG is a tree generation system. It consists of two different sets of trees, which are combinable. Intuitively, the set of initial trees can be seen as context-free derivation trees. This means, the start symbol is the root node, all inner nodes are nonterminals and all leaves are terminals (e.g., in Figure 1 tree ~). The second set, the auxiliary trees, which can replace a node in an initial tree (which is possibly modified by further adjoinings) during the process of adjoining, must have a form that again a derivation tree results. The trees ~31 and [~2 demonstrate that restriction. A special leaf (the foot node) must exist, labelled with the same nonterminal as the root node is labelled with. Further, it is obligatory that an auxiliary tree derives at least one terminal. The union of the initial mid the auxili~u:y trees, so to speak the set of rules of a 'FAG, is called lhe set of elementary trees. Tree y in Figure 1 shows a TAG derivation tree, which is an initial tree with an arbitrary number of adjoinings (here [51 is adjoined at the node S* in ct and ~2 in the node S* in the adjoined tree 131 (for a good introduction to Unification Grammars, e.g., see [Shieber 87]). Such a rule consists of two paths which ,are unified. A path consists of a number uniquely referring to a constituent in the context-free rule together with a list of feature names and/or an atomic value. A pair (context-free rule, list of specification rules) is called unification rule. E.g.,((S NP VP)) ((( 0 fset)(1 fset))((lfset syntax)(2 fset syntax))((2 fset syntax verbform) active))) ) is such a rule. Another representation of the specification rules is a DAG (directed acyclic graph). Figure 2 shows this representation for the above described exauaple rule. It is built by representing the numbers, feature names and values as nodes which are connected in the way riley are put together in the string representation. Common prefixes are represented only once. The pro~'ess of recursion -called unification -is defined as an operation of union on all specification rules according to a context-free derivation, loosely spoken. More h)rmally, the result of the unification of two DAGs x and y (UNIFY(x,y)) is defined inductively as a new DAG z, where -z=x, ifx=y, -z = x, if x is atomic and y is empty, and vice versa z = y, if y is atomic and x is empty, -if neither x nor y is atomic, then V features I such that II,ul ~ x, II,vl e y, I1,UNIFY(u,v)I e z and V features I such that II,wl ~ (u u v) -(u r~ v), II,wl e z. 0 ---\u00a3set ~,) 1 --fset -Lsyntax~ 2 --fset --syntax-X-ver bform --'active It is easy to see that this extension of the context-free formalism allows us to introduce various additional information by specification rules. The main problem of the formalism is that it has Turing capacity -and so all disadvan 'tages inherited with this power. Informally, this paper shows that the combination with TAGs restricts the power of unification. The Two Different Definitions of TAGs with Unification Although Turing capacity is not a wishful property, unification seems to be a good extension for TAGs as speeifiation rules : ((( 10 (11 ((11 well. In this section, two different definitions for TAGs with Unification (UTAGs) are presented in a common terminology to simplify their comparison. Tile Definition of tile Grammar for TAGs with Unification Same as to define specification rules according to a context-free rule, where the relation between both sets is represented by unique node numbers to refer to the different constituents in a rule. Here, according to an initial or an auxiliary tree, these specifications are defined between father and sons or between brothers via unique node numbers all over the trees. The trees c~, 131 and ~2 in Figure 1 (now interpreting the unique node numbers of the elementary trees) together with the according specifications in Figure 3 describe an example TAG with Unification, which produces the propagation of some syntactic and senmntic information from the lexical items to the root node of the different subsentences. Note that the unique node numbers are also helpful to identify the individual adjoined trees in the derivation tree. To prevent the ambiguity resulting from adjoining the same tree more than once, the node number of the eliminated node is taken as a prefix for all new nodes. (((00 fset)(01 fset)) (( 01 To get an impression of what that grammar does, one can read all relations between father and sons in all initial and auxiliary trees as context-free rules annotated with the corresponding specification rules. To realize this partial interpretation of specification rules, the following sets for each node x are defined: l\"x := the set of all specification rules with x father or brother of the other mentioned node in that rule, Sx := the set of all specification rules, where x is a son of the further mentioned node in that rule and 0x := the set of all specification rules, where a value of x is defined. It is easy to see that for each node these sets can be automatically computed. E.g, for the node 01 in c~, 1\"01 := {(((00 fset)(01 fset)), ((01 fset)(02 fset))}, $01 := {(((01 fest)(012 fset))}, 001 := ~. Vijay-Shanker and Joshi prefer to write the grammar in the 1\" (TOP, or briefly called t) and $ (BOTTOM, b) terminology, which allows slide differences in expressiveness, e.g., a non-empty TOP set of the root node of an auxiliary tree can be specified. The Unification Grammar, consisting of all rules built by interpreting each father and all its sons in all elementary trees as context-free rules, together with all TOP sets, can be interpreted as described in section 2.2. But it is important to note, the two resulting grammars are not equivalent, because the context-free grammar doesn't require the derivation of the whole tree, if one context-free rule out of it is in use. Considering this simple and intuitive interpretation of a UTAG, the problem of defining adjoining and unification directly for such a grammar becomes obvious. Only the relations between father and sons or brothers are interpreted directly, although there are links defined over a whole tree. This is exactly the point, where the two defin~.tions differ. The Definition of Vijay-Shanker and Joshi The definition of Vijay-Shanker and Joshi separates this local information (for a description of their approach see, e.g., [Vijay-Shanker 87]). It reminds us of the interpretation of attributes after computing the contextfree derivation tree for an Attribute Grammar (e.g., see [Aho et al. 86] ). In their approach, the 1\" and $ sets remain isolated until all adjoinings are made. With this strategy it is clear that the unification cannot be used to reduce the number of structure trees, which are unificationally ill-formed. More formally spoken, the adjoining is defined as described in Figure 4 (for the reason of uniquely referencing to the 1\" and $ sets at each node X, t and b with different bar levels are used). After all adjoinings were made, all 1\" and $ sets at each node are unified. The disadvantage of this sequential interpretation of adjoining and unification can be demonstrated by the example grammar. In the lexicon, all names, \"Marie\", \"Piet\" and \"Jan\", have three different cases (nominative, dative and accusative). Therefore, three structurally equivalent trees are produced for each tree c\u00a2, [~1 and ~2. These are structurally combined by adjoining. Out of this collection, by the specification rule, which demands a subject, unification selects one correct reading. But this is checked after building nine different derivation trees. Vijay-Shanker and Joshi One way to handle that problem is to use unification with disjunction to reduce the set of structurally equivalent trees. But this doesn't tackle the problem fundamentally, because it cannot reduce ambiguities, which only can be eliminated by interpreting the specification rules at once. This integration is realized in our new approach. The different approaches are abbreviated with SUTAG for the more sequential approach of Vijay-Shanker and Joshi, and IUTAG for a more integrated approach, which is presented now. All Integrated Definition for TAG and Unification The basis for our definition is a UTAG given in the notation as described in section 3.1. For each elementary tree, a set of specification rules is defined, which can be interpreted as unified DAGs over the whole tree. E.g., the path \"fset sem_role action\" of node 01 has the value \"zwemmen\". If an adjoining should happen in a node X, for this node the sets '['X, SX and <)X are computed because this node and with it \"all links from its DAG to other DAGs are replaced by an auxiliary tree. Structurally, the adjoining looks like the original one for TAGs (and same as for SUTAGs). In the case of an adjoining, a node in an (possibly modified) initial tree should be replaced by a whole auxiliary tree [3, and all links that node had have to be modified by the information of ~. You can imagine the new linked DAGs all over the adjoined Iree as being a filter for the former propagated information. E.g., information passing a node X, where an adjoining will take place, must not be supported by the path from the root to the foot node of the adjoined auxiliary tree. So the propagation is stopped somewhere in the tree. More formally spoken, the definition of adjoining can be given as described in Figure 5 . The DAG of the node, in which the adjoining will take place, is represented by $ and $ sets. Here, r and f stand for the whole DAG of the root and foot node of the auxiliary tree, which will be adjoined. But it is obvious that the 1\" set of r is empty as well as the $ set of f. This is clear because there exists no father of the root and no son of the foot node where these links can end. Using the same terminology for the auxiliary tree as in Figure 4 (r is separated in t\" and b', and f in t\" and b\"), one can write instead of \"UNIFY(t,r)\" as well \"UNIFY(t,b')\" and for \"UNIFY(b,f)\" as well \"UNIFY(b,t\")\". What becomes obvious is that in the :cesulting m~e each node has a DAG, which is connected with the DAGs of its neighbors in the tree. This was lhe aim of the new definition, always to produce linked DAGs all over the derivation tree to test for failure of anification at once. ~i I FY(t' r) NI F\u00a5(b, f) Figure 5 : Tile adjoining definition for IUTAGs ~ut this is not the complete definition; there are two things to be added. One is the concrete handling of the elimination of links and the second is the reintroduction of the value definition of the eliminated node. t~eginning with the elimination of links, the separation into q\" and $ at a node X, an adjoining will take place, means that all information propagated along the node X is eliminated (e.g., one can imagine a reason maintenance system to keep track of that task, so that unification is no more commutative and independent from the time of introducing information). E.g., information t'rom a leaf is propagated to the root of the whole tree. This propagation can be interrupted, modit'ied or kept tmtouched if an adjoining takes place. Intuitively, the adjoined tree can be imagined as a filter for the propa-?~ation. Some extra computation must be done for tile reintroduction of 'din value inl\\-)rmation (0X) in the following way. Since tim node, in which a value is defined, will be eliminated in the case of an adjoining, the question arises, what should happen to the value definition? tlere, it was decided to find a point for the reintroduction of that information. The first idea can be to say, i.~y definition add it to the root node. But now a fail can t,,e produced in the case ltmt lhe adjoined tree adds parts ~f the path to reach that value (e.g., if the value definition in node X with the node number 01 is ((01 ilset) val) and in tile root node (10) of the adjoined tree, dm specification rule exists ((10 fset next) (11 fset)), a tail is produced because fset has at the same time a feature and a value as successo0. To allow this property to be interpreted without failure, which is desirable for ihe idea of defining a filter via adjoining, a computation t)f such paris of paths in the adjoined tree is done to find the maximal extension of the path, behind which the value can be added without producing a fail. in this process, called computation of the inheritance history, all maximal prefixes of paths in the adjoined auxiliary tree are computed. Out of this set, those candidates are chosen, which have the value definition as prefix p. Behind these maximal paths the value is reintroduced. Because this selection does not always have a unique path at exactly one node as result (e.g., if ~-oot and foot node add two different feature names behind p, but between both no propagation occurs), at the end of both paths the value is reintroduced by definition. It is clear that the computation of the inheritance history can be done once for all paths in all auxiliary trees, so that this part of the definition doesn't extend the execution time very much. The most elaborate work has to be done in reconstructing the correct links all over the derivation tree after an adjoining. In the worst case, changes of propagation all over the derivation tree are required. To give an idea of how this definition works, in Figure 6 the changes during the adjoining of [31 and 132 in a are represented. Here only the nominatve reading is in use, because the lexical reading with case dative and accusative produces a fail in unification with the valency description of the verbs. Concentrating on the feature path \"fset sere_role\" (note, we don't claim that this is a serious semantics of the sentence!), first the meaning of \"Marie zwemmen\" is produced (action is \"zwemmen\" and actor is \"Marie\"), which is modified during the adjoining by \"Piet laten\" and \"Jan zag\". Tile Comparison of tile Properties of SUTAG and IUTAG Finally, let's weigh the two approaches. A first impression in reading both definitions can be that the differences are marginal. It is simply a decision in ordering processes. But a second look offers that there ,are more differences. The ideas of what should be represented by an adjoining are different. A SUTAG supports the monotone idea behind unification and the parallel and absolute presence of propagated knowledge (what is written in tile ' 1\" and ,[, sets should be propagated exactly fiom that node all over the tree withot,t any more changes). In a UTAG, the idea of filtering propagated information has the highest priority. Specification information should be revisable by new adjoinings. Each of the two approaches works more efficient for different problem classes, which cannot be characterized in more detail here. For SUTAGs, the main disadvantage is the late interpretation of the specifcation rules. Especially here lies the motivation for the definition of IUTAGs. In the above mentioned example, the focus in describing the advantage of online unification is demonstated by the representation of the intermediate states of the DAGs, but it is clear as well, how the lexical readings with case equal dative or accusative for \"Marie\",\"Pict\" and \"Jan\" are eliminated. Another distinguishing feature of IUTAGs is that unification is not further a monotone process as it is in SUTAGs (same as for UGs). Links, which have been installed, can be eliminated. This is the more formally circumscribed effect of a filter, which is the intuitive idea behind that definition. It is obvious that the realization of that fact is more expensive than to wait until all adjoinings are realized. But it comes up with a reduction of execution time for invalid readings. Actually, this is a trade off, which has more or less effect on the time complexity in the relation in which specification rules are used to subcategorize and restrict the structural descriptions. Therefore, both definitions probably have more lxzrfect application domains. A point which was mentioned as a disadvantage of the Unification formalism, was the Turing capacity. For both definitions of UTAGs, the power is restricted in a way t!hat no path can be introduced via specifications without adding a piece of structure, because the definition of an elementary tree requires a non-empty leaf. Therefore, the defined unification process underlies the constant growth property.  Also the UTAG definition can be seen purely as a theoretical result, syntax description as the most prominent application domain has influenced the design. Therefore, our experience with an implementation of the IUTAG definition running a natural language grammar is mentioned here (for all technical details see [Buschauer et al. 89] ). The system is written in Common LISP on a Hewlett Packard machine of the 9000 series with emphazise on efficiency. E.g., the response time for a small test grammar and sentences of a lertgth of about 10 words is less than 10 milliseconds. Presently, this pure parser is extended by tools (e.g., consistency check) to build a workbench for linguists designing IUTAGs. On this basis, more empirical results should be produced for that domain. Currently, we work on further extensions of the definition (e.g., ID/LP for free word order in German). Our main emphazise lies on the aspect of incrementality. In this paper the interpretation direction of the definitions was analysis. But the other direction, the problems in generation are faced now, with the ambitious aim to verify that IUTAGs are appropriate for a bidirectional and integrated description of syntactic, semantic and pragmatic facts. Ullman: Compilers: Principles, Techniques, and Tools, Addison-Wesley, Reading, Massachusetts, 1986.",
    "abstract": "In a proposal, Vijay-Shanker and Joshi presented a definition for combining ttw two formalisms Tree Adjoining Grammars and PATR unification. The essential idea for that combination is the separation of the two recursion operations -adjoining and unification -to preserve all properties of both formalisms which is not desirable for natural language applications. In this paper, a definition for the integrated use of both processes is given and the remaining properties of the resulting formalism are discussed -especially weighing the appropriateness of this d~finition for natural language processing.",
    "countries": [
        "Germany"
    ],
    "languages": [
        "Dutch",
        "German"
    ],
    "numcitedby": "14",
    "year": "1990",
    "month": "",
    "title": "Constraining {T}ree {A}djoining {G}rammars by Unification"
}