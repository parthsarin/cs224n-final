{
    "article": "Disambiguation methods for context-free grammars enable concise specification of programming languages by ambiguous grammars. A disambiguation filter is \u2022 a function that selects a subset from a set of parse trees the possible parse trees for an ambiguous sentence. The framework of filters provides a declarative description of disambiguation methods independent of parsing. Although filters can be implemented straightforwardly as functions that prune the parse forest produced by some generalized parser, this can be too inefficient for practical applications. In this paper the optimization of parsing schemata, a framework for high-level description of parsing algorithms, by disambiguation filters is consider\ufffdd in order to find efficient parsing algorithms for declaratively specified dis ambiguation methods. As a case study the optimization of the parsing schema of Barley's parsing algorithm by two filters is investigated. The main result is a technique for generation of efficient LR-like parsers for ambiguous grammars disambiguated by means of priorities. Introduction The syntax of programming languages is conventionally described by context-free grammars. Although pro gramming languages should be unambiguous, they are often described by ambiguous grammars because these allow a more natural formulation and yield better abstract syntax. For instance, consider the following gram mars. The first, ambiguous grammar gives a clearer and more concise description of arithmetic expressions than the second unambiguous one. -> E ll a 1 1 -> V T -> E E 11 + 11 E -> E E 11 + 11 T -> E V -> T E ll *II E -> E T ll *II V -> T II ( II E II ) II -> E II ( II E II ) II -> V To obtain an unambiguous specification of a language described by an ambiguous grammar it has to be disambiguated. For example, the first grammar above can be disambiguated by associativity and priority rules that express that E 11 * 1 1 E -> E has higher priority than E 1 1 + 11 E -> E and that both pro ductions are left associative. In the second grammar these disambiguation rules have been encoded in the grammar itself by means of extra non-terminals. In Klint and Visser (1994) we have set up a framework for specification and comparison of disambiguation methods. In this framework a disambiguation metho d is described as a filter on sets of parse trees. A disam biguation filter is interpreted by parsing sentences according to the ambiguous context-free grammar with some generalized parsing method, for instance Generalized LR parsing (To mita, 1985 , Rekers, 1992) , and then prune the resulting parse forest with the filter. Because this method of specification of disambiguation is independent of parsing, a language definition can be understood without understanding a parsing algorithm and it can be implemented by any generaliz ed parser. Although filters provide a uniform model for the description of disambiguation, they are too inefficient for several applications because all possible parse trees for a sentence have to he built before the intended ones are selected. (The number of possible parse trees for the first grammar above grows exponentially with the length of strings.) The optimization problem for filters is to find an efficient parser for the combination of a context-free grammar and a disambiguation filter. The filter can be used to prevent parse steps that lead to parse trees that would be removed by the filter after parsing. Parsing schemata, introduced by Sikkel (1993 Sikkel ( , 1994) ) , are high-level descriptions of parsing algorithms that abstract from control-and data-structures and provide a suitable framework for the study of the interaction between filters and parsers. Since it is not clear how to solve the optimization problem in general, if that is possible at all, an instance of the problem is studied in this paper, i.e., the optimization of the underlying parsing schema of Earley's (1970) parsing algorithm by a filter for disambiguation by priorities. This method, which is the disambiguation method of the formalism SDF (Heering et al. , 1989) , interprets a priority relation on context-free productions as two consecutive filters. The first selects trees without a priority conflict. The second selects trees that are minimal with respect to a multi-set ordering on trees induced by the priority relation. The main result of this paper is a parsing schema for parsing with priorities. The schema specifies a complete implementation of parsing modulo priority conflicts and a partial implementation for the multi-set order. The schema can be implemented as an adaptation of any parser generator in the family of LR parser generators. The resulting parsers yield parse trees without priority conflicts. The method of specifying a disambiguation method by a filter and applying it to optimize the parsing schema of some parsing algorithm appears to be fertile soil for growing new parsing algorithms from old ones. The rest of the paper is structured as follows. In \u00a72 some preliminary notions are defined. In \u00a73 disambiguation filters are defined. In \u00a74 parsing schemata are informally introduced. In \u00a75 priority rules and the notion of priority conflict are defined and a parsing schema optimized for the priority conflict filter is derived. In \u00a76 the relation between Earley parsing and LR parsing is discussed and it is shown how optimization results can be translated from the former to the latter. Furthermore, the results are extended to SLR(l) parsing. In \u00a77 the multi-set filter induced by a priority declaration is defined and a partial optimization of the Earley schema for this filter is derived. The two optimizations can be combined in a single schema, obtaining an efficient implementation of disambiguation with priorities. Preliminaries Definition 2.1 ( Context-free Grammar) A context-free grammar 9 is a triple (V N , Vr , P), where V N is a finite set of nonterminal symbols, Vr a finite set of terminal symbols, V the set of symbols of 9 is V N U Vr , and P(Q) = P \ufffd V* x V N a finite set of productions. We write a ----+ A for a production p = (a, A) E P. \u25a1 The a ----+ A notation for productions (instead of the traditional A ----+ a) is a convention of the syntax definition formalism SDF to emphasize the use of productions as mixfix function declarations. The string rewrite relation ----+g induced by a context-free grammar is therefore also reversed, from a generation relation to a recognition relation. Repeated application of productions rewrites a string to its syntactic category. The statement w ----+ * A means that the string w can be reduced to the symbol A. Observe that we do not distinguish a start symbol from which sentences are derived. Each nonterminal in V N generates a set of phrases as is defined in the following definition. Definition 2.2 (Parse Trees) A context-free grammar 9 generates a family of sets of parse trees T( Q) (T(9)(X) IX E V), which contains the minimal sets T(Q)(X) such that XEV X E T(Q)(X) Ai ... An ----+ A E P(Q), t1 E T(9) (A1 ), ... , t n E T(Q) (An ) [t1 ... t n ----+ A] E T(Q)(A) We will write t o: for a list t 1 ... II(Q)(w) = {t E T(Q)(A) II (Q)(a +a* a) = { [[[a -+ E] +[ a-+ E]-+ E] *[ a-+ E]-+ E] [[a -+ E] +[[a -+ E] *[ a-+ E]-+ E]-+ E] } L(Q IF ) = { w E v,; I :3<I> \ufffd T(Q) : yield( <I>) = { w} A F( <I>) = <I>} The interpretation of a string w by 9 / F is the set of trees F(II (Q) ( w)). A filter F 2 is also applicable to a disambiguated grammar 9 / F1 , which is denoted by ( 9 /Fi)/ F 2 and is equivalent to 9 / ( F 2 o F1). Klint and Visser (1994) . In \u00a75 and \u00a77 two examples of disambiguation filters will be presented. The optimization problem for disambiguation filters can be formulated as follows. \u25a1 Several properties and examples of filters are discussed in Definition 3.2 (Optimization by Filter) F(II(Q)(w)) \ufffd 1r(w) \ufffd II(Q)(w) We say that 7r approximates F o II(Q). 7r is an optimal approximation if 1r(w) = F(II (Q)(w)) for any w . \u25a1 Parsing Schemata Parsing schemata (Sikkel, 1993 (Sikkel, , 1997) ) Sikkel (1993 Sikkel ( , 1997) ) . A related approach is the deductive parsing method of Shieber et aL (1995) be derived. Rule (I), the initialization rule, specifies that the item [ \u2022a \u2794 A, 0, 0] can always be derived. The predic t rule (P), states that a production 1 \u2794 B can be predicted at position j, if the item [a \u2022 B/3 \u2794 A, i, j] abstract from the details of control-and data-structures of full parsing algorithms by only considering the intermediate results of parsing. A parsing system is a deduction system that specifies how from a set of hypotheses ( the tokens of a sentence) assertions ( the intermediate parser states) can be derived according to a set of deduction rules for some context-free grammar. A parsing schema is a parsing system parameterized with a context-free grammar and a sentence. Below parsing schemata are introduced informally by means of an example. A formal treatment can be found in has already been derived. Finally, the rules (S) and (C) finalize the recognition of a predicted and recognized token or nonterminal-witnessed by the second premise-by shifting the \u2022 over the predicted symbol. Definition 4.1 (Earley) Parsing schema for Earley's parsing algorithm (Earley, 1970) . a/3 \u2794 A E P(Q), 0 ::; i :: ; j [a \u2022 /3 \u2794 A., i, j] EI [\u2022a \u2794 A, 0, 0] [a \u2022 B/3 \u2794 A, i, j] [\u2022, \u2794 B, j,j] [a \u2022 a/3 \u2794 A, i, j], [a, j,j + l] [aa \u2022 /3 \u2794 A, i, j + 1) [a \u2022 B/3 \u2794 A, h, i] , b\u2022 \u2794 B, i,j] [aB \u2022 /3 \u2794 A., h, j] (I) (P) (S) (C) \u25a1 A derivation according to a parsing schema is a sequence 1 0 , \u2022.. , I m of items such that for each i (0 ::; i ::; m) Ji E H or there is a J \ufffd {1 0 , ... , Iid such that J f--Ii is (the instantiation of) a deduction rule. (Observe that if J is empty this corresponds to the case of using a rule without premises, such as the initialization rule.) A string w = a1 ... a n is in the language of context-free grammar 9 if an item [a\u2022 \u2794 A, 0, n] is deri\ufffdable from the hypotheses corresponding to w in the instantiation of the parsing schema in Definition 4.1 with Q. An item of the form [a\u2022 \u2794 A, 0, n] is called a final item and signifies that the entire string is recognized as an A phrase. The predicate w f--\ufffd I expresses that there is a derivation 1 0 , ... , I m = I of the item I from the hypotheses generated from string w in the instantiation of parsing schema P with grammar 9. The schema in Example 4.1 only defines how strings can be recognized. Since disambiguation filters are defined on sets of trees and not on items, a way to relate items to trees is needed. Definition Definition 4.3 gives an extension of the schema in Definition 4.1 that describes how trees can be built as a result of the deduction steps. First we need a definition of partial parse tree Definition 4.2 (Partial Parse Tree) A partial parse tree is a tree expression of the form [t a \u2794 A] where ta E T(Q) (a) and such that the tree can be_ completed to a normal tree by adding a list of trees t 13 , i.e., [t a t, a \u2794 A] E T(Q)(A) . (which requires a/3 \u2794 A E P(Q).) \u25a1 The items in the schema have the form [a \u2022 /3 \u2794 A., i, j] \u21d2 [t a \u2794 A] and express that from position i to position j a phrase of type a has been recognized and the partial parse tree [t 0 \u2794 A] has been built as a result. The set of hypotheses H is changed such that token items are annotated with trees, i.e., for each token ai in the string [ai , i -1, i) \u21d2 ai E H . Note how the shift and complete rules extend partial parse trees. Definition 4.3 (Earley with Trees) Parsing schema for Earley's algorithm with construction of parse trees. a/3 \u2794 A E P(Q), 0 ::: ; i :!; j, ta E T(Q)(a) [a \u2022 /3 \u2794 A., i, j] \u21d2 [t a \u2794 A] E I [\u2022a \u2794 A, 0, 0] \u21d2 [\u2794 A] [a \u2022 B/3 \u2794 A, h, i] \u21d2 [t a \u2794 A] [\u2022 1 \u2794 B, i, i] \u21d2 [\u2794 B] [a \u2022 a/3 \u2794 A, h,i] \u21d2 [t a \u2794 A] , [a, i,i + 1) \u21d2 a [aa \u2022 /3 \u2794 A. , h, i + 1) \u21d2 [t a a \u2794 A] [a \u2022B/3 -+ A, h, i] \u21d2 [t a \u2794 A] , [,\u2022 \u2794 B, i , j] \u21d2 tB [aB \u2022 /3 \u2794 A, h, j] \u21d2 [t a tB \u2794 A] 213 (I) (P) (S) (C) [a , 0, 1] [+, 1, 2] [a, 2, 3 ] [ \u2022 E + E\u2794E, 0, 0] [\u2022a \u2794 E, 0, 0] [a \u2022 \u2794 E, 0, 1] [E \u2022 +E\u2794E, 0, l] [E + \u2022E \u2794 E, 0, 2] [ \u2022a \u2794 E, 2,2] [a\u2022 \u2794 E, 2,3] [E + E \u2022 \u2794E, 0, 3] \u21d2 a \u21d2 + \u21d2 a \u21d2[ \u2794E ] \u21d2 [\u2794E ] \u21d2 [a \u2794E ] \u21d2 [[a \u2794 E] \u2794 E] \u21d2 [[a \u2794 E] + \u2794 E] \u21d2 [\u2794 E] \u21d2 [a \u2794E ] \u21d2 [[a \u2794 E] + [a \u2794 E] \u2794 E] I A E VN ,w \ufffdi-3 [a\u2022 \u2794 A, 0, n] \u21d2 t} = Il(Q )(w) The following proposition states that the decoration of items with partial parse trees makes no difference to what can be derived. Items in a parsing schema can be annotated with trees as long as they do not affect the deduction. Proposition 4.5 Parsing schema Earley with trees preserves the derivations of parsing schema Earley , i. e., w \ufffdi-1 [a \u2022 (3 \u2794 A, i, j] \ufffd :3t0 E T(Q)(a) : w \ufffdi-3 [a \u2022 (3 \u2794 A, i, j] \u21d2 [t a \u2794 A] The optimization problem can now be rephrased as: Definition 4.6 ( Optimizing Parsing Schemata) The optimization of a parsing schema P by a disambigua tion filter :F constitutes in finding a deri ved parsing schema P' such that F(IT(Q) (w)) \ufffd {t I w \ufffdr I \u21d2 t} \ufffd {t I w \ufffdt I \u21d2 t} where I is some final item. \u25a1 5 Priority Conflicts We consider the optimization of parsing schema Earley by two disambiguation filters that are used to interpret the priority disambiguation rules of the formalism SDF of Heering et al. (1 989) . This disambiguation method is also used in the generalization of SDF to SDF2 presented in Visser (1997a) . The subject of this section is a filter that removes trees with a priority conflict. This filter is similar to the conventional precedence and associativity filter. The declaration of priority rules will also be used in the definition of the multi-set filter in \u00a77. Definition 5.1 (Priority Declaration) A priority declaration Pr(Q) for a context-fr ee grammar Q is a tuple (L, R, N, >), where E9 \ufffd P x P for E9 E {L, R, N, >}, such that L, R and N are symmetric and > is irreflexive and transitive. \u25a1 The relations L, R and N declare left-, right-and non-associativity, respectively, between productions. The relation > declares priority between productions. A tree with signature PI can not be a child of a tree with signature p 2 if p 2 > PI \u2022 The syntax of priority declarations used here is similar to that in Earley (1975) . In SDF (Heering et al. , 1989) a formalism with the same underlying structure but with a less Spartan and more concise syntax is used. In SDF one writes left for L, right for R and non-assoc for N. We will use both notations. Definition 5.2 (Priority Conflict) The set conflicts(Q) generated by the priority declaration of a grammar g is the smallest set of partial trees of the form [a [,6 \u2794 Bh \u2794 A] defined by the following rules. aB'Y \u2794 A > ,6 \u2794 B E Pr(Q) [a [,6 \u2794 Bh \u2794 A] E conflicts(Q) 'Y -::J E, ,6 \u2794 B (right U non-assoc) B\"'( \u2794 A E Pr(Q) [[,6 \u2794 Bh \u2794 A] E conflicts(Q) a -::J E, ,6 \u2794 B (left U non-as soc) aB \u2794 A E Pr(Q) [a[,6 \u2794 B] \u2794 A] E conflicts(Q) This set defines the patterns of trees with a priority conflict. Using the definition of priority conflict we can define a filter on sets of parse trees. D Definition 5.3 (Priority Conflict Filter) A tree t has a root priority conflict if its root matches one of the tree patterns in conflicts(Q). A tree t has a priority conflict, if t has a subtree s that has a root priority conflict. The filter ;: Pr is now defined by ;: Pr (<I>) = { t E <I> I t has no priority conflict}. The pair (9, Pr) defines the disambiguated grammar g / ;:Pr . \u25a1 Example 5.4 Consider the following grammar with priority declaration syntax \"a\" -> E E \"*\" E -> E {left} E \"+\" E -> E {left} priorities E \"*\" E -> E > E \"+\" E -> E Here the attribute left of a production p abbreviates the declaration p L p. The tree [[[a \u2794 E] + [a \u2794 E] \u2794 E] *[ a \u2794 E] \u2794 E] has a priority conflict over this grammar-it violates the first priority condition since multiplication has higher priority than addition. The tree [[a \u2794 E] + [[a \u2794 E] *[ a \u2794 E] \u2794 E] \u2794 E] does not have a conflict. These trees correspond to the (disambiguated) strings (a + a) * a and a+ (a * a) , respectively. The implication operator in logic is an example of a right associative operator: a \u2794 a \u2794 a should be read as a \u2794 ( a \u2794 a). Non-associativity can be used to exclude unbracketed nested use of the equality operator in expressions using the production E \" = \" E -> E. \u25a1 The priority conflict filter induced by a priority declaration can be used to optimize the Earley parsing schema. By the following observation a more general optimization problem can be solved. Definition 5.5 {Subtree Exclusion) A subtree exclusion filter based on a set Q of excluded subtrees is de fined by where t <1 Q (t is excluded by Q) if t has a subtree that matches one of the patterns in Q . \u25a1 The optimized parsing schema should not derive trees that contain a subtree contained in Q. As is shown in definition 4. 3 such patterns are constructed in the complete rule and predicted in the predict rule. The construction of trees with priority conflicts can be prevented by adding an extra condition to thes e rules. This leads to the following adaptation of the Earley parsing schema. [a \u2022 B,B \u2794 A, h , i] \u21d2[ t a \u2794 A] , [a['Y \u2794 B],B \u2794 A] \ufffd Q [\u2022-y \u2794 B, i , i] \u21d2 [\u2794 B] [a \u2022 B,B \u2794 A, h, i] \u21d2 [t a \u2794 A] , ['Y\u2022 \u2794 B, i,j] \u21d2 tB , [a['Y \u2794 B],B \u2794 A] \ufffd Q [aB \u2022 ,6 \u2794 A, h, j] \u21d2 [t a tB \u2794 A] (P) (C) \u25a1 The following theorem states that parsing schema in Definition 5.6 is an optimal approximation of the com I A EV N , w 1 -l'b [A \u2794 a\u2022,O,n] \u21d2 t} = FQ (II(Q) (w)) This is proved using two lemmas. The soundness lemma asserts that no intermediate parse tree derived with the deduction rules has an excluded subtree (i. e., a priority conflict). The completeness lemma states that every parse tree without a priority conflict can be derived. The completeness lemma is obtained by reverting the implication of the soundness lemma. In thes e lemmata we use the notion of a context tB[\u2022] that represents a tree context of ty pe B with one subtree that is a hole \u2022 \u2022 The instantiation tB[tA ] of a context tB [\u2022] is the tree obtained by replacing the \u2022 subtree by the tree tA . Lemma 5.8 (Soundness) Fo r all context-free grammars 9, strings w = a1 ... a n E v,; , symbols A EV N and a, ,6 E V*, natural numbers i \ufffd j EN, and trees t a E T(Q)(a) such that a,B \u2794 A E P( 9 ), and Q a set of parse tree patterns of the fo rm [a['Y \u2794 B],B \u2794 A] we have that w \ufffdt-6 [a \u2022 ,6 \u2794 A, i,j] \u21d2 [t a \u2794 A] yield(tA = [t a ,6 \u2794 A]) = ai+l ... aj,6, :3tB[\u2022] E T(Q)(B) : ,tB[tA ] <l Q I\\ yield(tB [A] ) = a1 ... aiA8 From Earley to LR There is a close correspondence between Earley's algorithm and LR parsing (Knuth, 1965) . In fact, parsing schema Earley in Definition 4.1 can also be considered the underlying parsing schema of an LR(O) parser. The main difference between the algorithms is that in LR parsing the instantiation of the parsing schema with a grammar is compiled into a transition table. Definition 6.1 defines a parsing schema for 'compiled' LR(O) parsing. The intermediate results of an LR parser, the LR states, are sets of LR items closed under prediction, defined by the function closure. The function goto computes the set of items that results from a state by shifting the dot in the items over a symbol X. The schema defines three deduction rules. Rule (I) generates the initial state consisting of the set of all items [\u2022a \u2794 A] predicting all productions of the grammar. Rule (Sh) obtains a new state from a state by shifting a terminal. Rule (Re) reduces a number of states to a new state upon the complete recognition of a production B1 ... Em \u2794 B. It is clear that the function closure corresponds tq the predict rule (P) in Earley, that (Sh) corresponds to (S) and that (Re) corresponds to (C). A goto-graph is a precomputation of the goto function. LLR = { [a \u2022 ,6 \u2794 A] I a,6 \u2794 A E P(Q) } I = { [ <P, i, j] I <P \ufffd LLR } The closure of a set of items <P is the smallest set of items containing <P and closed under prediction, i.e., <P \ufffd closure( <P) [a \u2022 B,6 \u2794 A] , 1 \u2794 B E P(Q) [ \u2022 1 \u2794 B] E closure( <P) Given a symbol X the goto function maps a set of items to the closure of the set obtained by shifting all items with X. goto(X, <P) = closure( {[a.X \u2022 ,6 \u2794 A] I [a \u2022 X ,6 \u2794 A] E <P}) Given these functions an LR parser is defined 1 by the following deduction rules. [ {[\u2022a \u2794 A] I a\u2794 A E 9},0,0] [<P, h, i] , [a, i, i + 1] [goto(a, <P), h, i + 1] a \u2022 B,6 \u2794 A] , 1 \u2794 B E P(Q), [a[, \u2794 B],6 \u2794 A] \ufffd Q [ \u2022 1 \u2794 B] E closure( <P) Given a production 1 \u2794 B the goto function maps a set of items to the closure of the set obtained by shifting all items with 1 \u2794 B for which that does not lead to a conflict. goto(, \u2794 B, <P) = closure( {[aB \u2022 ,6 \u2794 A] I [a \u2022 B,6 \u2794 A] E <P /\\ [a[, \u2794 B]/J \u2794A ] \ufffd Q}) \u25a1 Note that the goto function has to be parameterized with the production that is recognized instead of with just the symbol. (For the (Sh) rule the old goto function is used.) Figure 3 shows the goto-graph for the disambiguated grammar from Example 5.4. SLR(l) Parsing The LR(0) goto graph in Figure 3 contains conflicts that are easy to prevent with the SLR( l) (Simple LR(l)) extension of LR(0) parsing due to DeRemer (1971) . The SLR algorithm is based on the observation that a reduction is only useful if the next symbol in the string can follow the symbol that is recognized by the reduction, i.e., the right hand-side of the production that is reduced. This is expressed in the following adaptation of the LR(0) parsing schema of Definition 6.1. The function first(a, \\JI) yields the set of symbols that can start a phrase derived from a string of symbols a followed by a symbol from the set \\JI. The expression follow(B, \\JI) denotes the set of symbols that can follow symbol B in a ph rase that is followed by a symbol from the set \\JI. The reduce rule now only applies if a production has been recognized and the next symbol in the string can follmv the right-hand side of the production. \u2022E +E\u2794E \u2022 E * E \u2794 E __ E_ \u2022a \u2794E E*\u2022E \u2794 E \u2794 E ---E*E\u2022 \u2794 E * E*E\u2794E \ufffd---\ufffd \ufffd---\ufffd \u2022E +E\u2794E a\u2794 E \u2022 E * E\u2794 E 1---- \u2022 a \u2794E E * \u2022E\u2794 E a\u2794 E E * E\u2022\u2794 E \u2794 E \u2022E* E\u2794 E E (2) E* E \u2794 E (3) E+E \u2794 E (4) E $ \u2794 S (2) > (3) (2) L (2) (3) L ( 3 ) Figure 4 : SLR(l) table for the grammar of example 5.4. s n denotes shift to state n, r n denotes reduce with production n, ace denotes accept. The right part of the table contains the goto entries for the productions. This parse table corresponds to the goto graph of figure 3 . The reduce rule of the schema in Definition 6.1 is restricted by requiring that the next symbol in the string is an element of the follow set of B. [a, i1,;, i1,; [,:r,.[a\u2022B.6\u2794A] h \"] [,:r,.[ B1 e ...Bk \u2794B] \u2022 \u2022 ] [,:r,.[B1 . --Bk\u2022\u2794B] .. ] '\u00b1' , ,z , '\u00b1' 1 ,z,z1 , ... , '\u00b1' 1,; ,z,z1. , , + 1] , a E follow(E, { $}) [goto(E, <I>), h, i,.,] \u25a1 The SLR(l) schema can be adapted in the same way as the LR(O) schema to account for priority conflicts (or subtree exclusion) . However, the definition of follow above is too weak for this extended schema. For instance, in the grammar of Example 5.4, the token * is an element of the follow set of E. However, * can not follow an E if it is a E + E \u2794 E, i.e. , if a reduction is done with E + E \u2794 E, no action for * is possible. The following parsing schema optimizes the SLR(l) parsing schema by defining the follow set for a production instead of for a symbol and adapting the reduce rule accordingly. Figure 4 shows the SLR(l) table for the grammar of Example 5.4. Definition 6.4 (SLR(l) Parsing Modulo Q) This schema defines SLR(l) parsing modulo a set Q of parse trees of the form [o:[,B \u2794 Eh \u2794 A] using the definition of the closure and goto functions from the parsing schema in Definition 6.2 and the definition of first from Definition 6.3. o:E-y \u2794 A E P(9), [o:[,B \u2794 Eh \u2794 A] \ufffd Q follow(,B \u2794 E, \\JI ) ;;;? first(,B, follow(o:E -y \u2794 A, \\JI )) The reduce rule is adapted to the new definition of follow. [a, i1. ,, i1. , Discussion [,:r,.[a\u2022B,6\u2794A] h \u2022] [,:r,. [B 1\u2022---Bk -+B] \u2022 \u2022 ] [,:r,.[B1 . .. Bk \u2022-+B] .. ] '\u00b1' , ,z , '\u00b1' 1 ,z,z1 , .. . , '\u00b1' 1,; ,z,z1,; , + 1] , a E follow(E1 ... E1. , \u2794 E, {$}) [goto(E1 ... E,., \u2794 E, <I>), h, i1.,] (Re) \u25a1 Conventional methods for disambiguating grammars that apply to LR parsing disambiguate the grammar by solving conflicts in an existing LR table. The classical method of Aho et al. (1975) uses associativity and precedence information of a limited form-a linear chain of binary operators that have non-overlapping operator syntax-to solve shift/reduce conflicts in LR tables. The method is based on observations on how such conflicts should be solved given precedence information, without a real understanding of the cause of the conflicts. Aasa (1991 Aasa ( , 1992) ) describes filtering of sets of parse trees by means of precedences. Thorup (1994a) describes a method that tries to find a consistent solution for all conflicts in an LR table starting from, and producing a set of excluded subtrees. All these methods fail on grammars that are inherently non-LR(k), i.e., for whi' ch there is no complete solution of all conflicts in any LR table for the grammar. An example is the grammar syntax -> L L [\\ \\t\\n] -> L \"a\" -> E EL\"*\" LE -> E {left} EL\"+\" LE -> E {left} priorities EL\"*\" LE -> E > EL\"+\" LE -> E that models arithmetic expressions with layout. The tokens of expressions can be separated by any number of spaces, tabs or newlines, which requires unbounded lookahead. Such grammars are the result of integrating the lexical syntax and context-free syntax of a language into a single grammar as is proposed in Visser (1997b) . Parsers for such grammars are called scannerless parsers because the tokens they read are the characters from the input file. This grammar is disambiguated completely (it has no ambiguous sentences) with priorities, resulting in an LR table that contains some LR-conflicts, but that does not produce trees with priority conflicts. In combination with a nondeterministic interpreter, e.g., Tomita's generalized LR algorithm (Tomita, 1985) , of the parse tables this gives an efficient disambiguation method for languages on the border of determinism. Thorup (1994b) describes a transformation on grammars based on a set of excluded subtrees to disambiguate a grammar. This method could be used to generate conflict free parse tables as far as possible. Because such a transformation introduces new grammar symbols, more states and transitions are needed in the parse table than for the original grammar. Since the method defined above also introduces some extra states, it would be interesting to compare the LR tables produced by both methods. Multi-set Filter The multi-set ordering on parse trees induced by a priority declaration solves ambiguities not solvable by priority conflicts. A certain class of ambiguities solved by the multi-set order does not need the full power of multi-sets, only a small part of both trees are actually compared. Based on this observation an optimization of the Earley schema that partially implements the multi-set filters can be defined. Definition \u20227.1 (Multi-sets) A multi-set is a function M : P(Q) \u2794 N that maps productions to the number of their occurrences in the set. The union Ml\u00b1JN of two multi-sets M and N is defined as (Ml\u00b1JN)(p) = M(p) +N(p) . The empty multi-set is denoted by f/J, i.e., f/J(p) = 0 for any p. We write p E M for M(p) > 0. A multi-set with a finite number of elements with a finite number of occurrences can be written as 1\\1 = {P1 , P1 , ... , P2 , ... } , where M (p) is the number of occurrences of p in the list. A parse tree t is interpreted as a multi-set of productions by counting the number of times a production acts as the signature of a subtree of t, where a \u2794 A is the signature o\ufffd [ta \u2794 A] . \u25a1 The following definition due to Jouannaud and Lescanne (1982) defines an ordering on multi-sets. Definition 7.2 (Multi-set Order) Given some priority declaration Pr(9), the order -< Pr ( Q ) on multi-sets is defined as (x)  \u25a1 Definition 7.3 (Multi-set Filter) Given a priority relation Pr( 9 ), the multi-set filter p -< P ,( Q l is defined by The motivation for this filter is that it prefers parse trees that are constructed with the smallest possible number of productions of the highest possible priority. l\\ll -<Pr(9) N \ufffd M =/:-N A Vy E M : M(y) > N(y) \u21d2 3x E N : y > Pr ( Q ) x A M(x) < N P r( Q ) p (r! ) :F -< (<I>) = { t E <I> I ,3s E <I> : s -< r \ufffd t} \u25a1 R + \u2022R --+ R \u2022R+R--+R R\u2022+R--+ R + \u2022r --+R R R+R\u2022--+ R \u2022N --+R R\u2022+R--+ R \u2022N+N--+N \u2022n --+N \u2022N + N--+ N r\u2022--+ R \u2022 R + R--+ R N \u2022n --+N N\u2022 --+R \u2022r --+R N\u2022+N--+ N \u2022N --+ R n\u2022--+ N n N\u2022+N--+ N \u2022N+N--+N N+N\u2022--+ N N\u2022 --+R + N N\u2022+N--+ N \u2022n --+N Example 7.4 Consider the grammar syntax \"n\" -> N N \"+\" N -> N N -> R \"r\" -> R R \"+\" R -> R that describes the language of 'naturals' and 'reals' with an overloaded addition operator. The sentence n + n can be parsed as [[n --+ N] + [n \u2794 N] \u2794 N] and as [[[n \u2794 N] \u2794 R] + [[n \u2794 N] --+ R] \u2794 R] . This ambiguity can be solved, choosing either the first or the second tree, by declaring one of the priority rules N \"+\" N -> N > R \"+\" R -> R or R \"+\" R -> R > N \"+\" N -> N Note that with the se c\"and priority rule, the production N + N \u2794 N is only used as a parse tree in a context where no R is allowed. Therefore, the first priority rule is assumed in further examples. \u25a1 The multi-set order is too strong for this kind of disambiguation. To solve the ambiguity there is no need to compare the complete trees, as the multi-set order does. Comparing the patterns [ ', h, j] can be derived such that A' \u2794 a' has higher priority than A \u2794 aB. [ N + N \u2794 N] \u2794 R] and [[N \u2794 R] + [N \u2794 R] \u2794 R] is sufficient \u2022r \u2022N+N--+ \u2022n \u2794 + \u2022n \u2022r R + R\u2022--+ R R\u2022+R--+ R [N \u2794 R] + R\u2022--+ R R\u2022+R \u2794R N+N\u2022 \u2794 N IE--------l [ N \u2794 R] + 1--------=\ufffd [N \u2794 R] \u2022 \u2794 R N\u2022+N --+N [N \u2794 R] \u2022 +R--+ R --+AE9, lnJ31 #1Va/3=aEVr, O\ufffdi\ufffdj [a \u2022 J3 \u2794 A, i, j] E I [a \u2022B/3 \u2794 A, h, i], [C \u2794 B] E Ve [\u2022, \u2794 C, i , i] [a \u2022 B/3 \u2794 A, h, i], b\u2022 \u2794 C, i ,j], l/31 > 0 [a[C \u2794 B] \u2022 J3 \u2794 A, h, j] [a \u2022 B \u2794 A, h, i] , b\u2022 \u2794 C, i ,j], ,[a'\u2022 \u2794 A', h, j], a' \u2794 A' > aB \u2794 A [a[C \u2794 B]\u2022 \u2794 A, h, j] (P) (Cl) (C2) \u25a1 The negative premise ,[a\u2022 ---t A, i, j] in combination with the condition A' \u2794 a: 1 > A \u2794 a:B is used in rule (C2) to express that an item [a[C \u2794 B]\u2022 \u2794 A, h,j] can be derived from [a \u2022 B \u2794 A, h, i] and b\u2022 \u2794 C, i ,j] only if no item [a' \u2022 \u2794 A With the introduction of negative premises we leave the domain of parsing schemata as defined in Sikkel (1993) and this deserves a more thorough investigation than is possible in the scope of this paper. However, two points about this feature can be observed: (1) As used here the notion has a straightforward implementation in an LR-like compilation scheme: first construct the complete set of items and then choose the maximal items from it. (2) The priority relation > on productions is irreflexive by definition, which entails that rule (C2) has no instantiation of the form 1 1 , h, ,[ 3 f-I3 that would make the schema inconsistent. \u25a1 The method does not help for grammars where the ambiguity is not caused by chain rules, for instance consider the following example due to Kamperman (1992) syntax EE -> E \"-\" E -> E E \"-\" E -> E priorities E E -> E > \"-\" E -> E > E \"-\" E -> E It defines expressions formed by concatenation, prefix minus and infix minus. The methods developed in this paper can be combined into a parsing schema that handles both priority conflicts and th e partial implementation of multi-set filters by adding th e subset exclusion conditions to th e (P), (Cl) and (C2) rules of th e parsing schema in Definition 7.5. As a bonus this combined parsing schema handles priority conflicts modulo chain rules. Conclusions In this paper two di sambiguation methods specified as a filter on sets of parse trees were considered. These filters were used to optimize parsers for context-free grammars by adapting th eir underlying parsing schema. The first optimization uses priority conflicts to prevent ambiguities. The resulting Earley parsers modulo priority conflicts are guaranteed not to produce trees with priority conflicts, even for grammars with overlapping operators, layout in productions or other problems that need unbounded lookahead. In combination with a GLR interpreter of the parse tables this gives an efficient disambiguation method for languages with unbounded lookahead. The second optimization covers a subset of the ambiguities solved by multi-set filters. Together these optimizations can be used in the generation of efficient parsers for a large class of ambiguous context-free grammars di sambiguated by means of priorities. Parsing schemata provide a high-level description of parsing algorithms that is suitable for the derivation of new algorithms. The introduction of negative items was needed to express th e optimization for the multiset filter and needs more research. This first exp eriment in implemenation of di sambiguation methods from formal specifications encourages research into a fuller optimization of multiset filters and application of this approach to other di sambiguation methods. The deductive parsing approach of Shieber et al. (1995) and its implementation in Prolog could be used to prototype such optimized schemata. Deductive parsing consists in computing th e closure of a set of axiom items under the inference rules of a schema, resulting in all items derivable for a sentence. Compiling th e inference rule of a schema into a parse table for a specific grammar increases th e effi ciency of an algorithm,. since work is shifted from th e parser into the parser generator. It seems feasible to generalize th e compilation of Earley rules into LR tables to other sch emata, thus obtaining a very declarative method for creating new parser generators. Acknowledgements I thank Mark van den Brand and several referees for their comments on this paper. This research was supported by th e Netherlands Computer Science Research Foundation (SION) with financial support from the Nether lands Organisation for Scientific Research (NWO). Project 612-317-420 : Incremental parser generation and context-dep endent disambiguation, a multi-disciplinary persp ective.",
    "abstract": "Disambiguation methods for context-free grammars enable concise specification of programming languages by ambiguous grammars. A disambiguation filter is \u2022 a function that selects a subset from a set of parse trees the possible parse trees for an ambiguous sentence. The framework of filters provides a declarative description of disambiguation methods independent of parsing. Although filters can be implemented straightforwardly as functions that prune the parse forest produced by some generalized parser, this can be too inefficient for practical applications. In this paper the optimization of parsing schemata, a framework for high-level description of parsing algorithms, by disambiguation filters is consider\ufffdd in order to find efficient parsing algorithms for declaratively specified dis ambiguation methods. As a case study the optimization of the parsing schema of Barley's parsing algorithm by two filters is investigated. The main result is a technique for generation of efficient LR-like parsers for ambiguous grammars disambiguated by means of priorities.",
    "countries": [
        "Netherlands"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "35",
    "year": "1997",
    "month": "September 17-20",
    "title": "A Case Study in Optimizing Parsing Schemata by Disambiguation Filters"
}