{
    "article": "A range of Natural Language Processing tasks involve making judgments about the semantic relatedness of a pair of sentences, such as Recognizing Textual Entailment (RTE) and answer selection for Question Answering (QA). A key challenge that these tasks face in common is the lack of explicit alignment annotation between a sentence pair. We capture the alignment by using a novel probabilistic model that models tree-edit operations on dependency parse trees. Unlike previous tree-edit models which require a separate alignment-finding phase and resort to ad-hoc distance metrics, our method treats alignments as structured latent variables, and offers a principled framework for incorporating complex linguistic features. We demonstrate the robustness of our model by conducting experiments for RTE and QA, and show that our model performs competitively on both tasks with the same set of general features. Introduction Many complex Natural Language Processing (NLP) applications can be broken down to a subtask of evaluating the semantic relationship of pairs of sentences (e.g., in Question Answering, answer selection involve comparing each answer candidate against the question). This means that research aiming at analyzing pairs of semantically related natural language sentences is promising because of its reusability: it is not tied to a particular internal representation of meanings, but it nevertheless serves as a first step towards full meaning understanding, which is applicable to a number of applications. At the same time, this paradigm clearly defines the input and output space, facilitating system comparison and standard evaluation. Tasks of this paradigm have drawn much of the focus in recent NLP research, including Recognizing Textual Entailment (RTE), answer selection for Question Answering (QA), Paraphrase Identification (PI), Machine Translation Evaluation (MTE), and many more. In each of these tasks, inputs to the systems are pairs of sentences that may or may not convey the desired semantic property (e.g., in RTE, whether the hypothesis sentence can be entailed from the premise sentence; in QA, whether the answer candidate sentence correctly answers the question), and the output of the system is a binary classification decision (or a regression score,as in MTE). Earlier studies in these domains have concluded that simple word overlap measures (e.g., bag of words, n-grams) have a surprising degree of utility (Papineni et al., 2002; Jijkoun and de Rijke, 2005b ), but are nevertheless not sufficient for these tasks (Jijkoun and de Rijke, 2005a) . A common problem identified in these earlier systems is the lack of understanding of the semantic relation between words and phrases. Later systems that include more linguistic features extracted from resources such as WordNet have enjoyed more success (MacCartney et al., 2006) . Studies have also shown that certain prominent syntactic features are often found beneficial (Snow et al., 2006) . More recent studies gained further leverage from systematic exploration of the syntactic feature space through analysis of parse trees (Wang et al., 2007; Das and Smith, 2009) . There are two key challenges imposed by these tasks. The first challenge has to do with the hidden alignment structures embedded in the sentence pairs. It is straightforward to see that in order to extract word-matching and/or syntax-matching features, inevitably one has to consider the alignment between words and/or syntactic parts. These alignments are not given as inputs, and it is a non-trivial task to decide what the correct alignment is. Alignment-based approach have been proven effective by many RTE, QA and MTE systems (Haghighi et al., 2005; Wang et al., 2007; MacCartney et al., 2008; Das and Smith, 2009, inter alia) . Although alignment is a commonly used approach, it is not the only one. Other studies have successfully applied theorem proving and logical induction techniques, translating both sentences to knowledge representations and then doing inference on these representations (Moldovan et al., 2003; Raina et al., 2005; de Salvo Braz et al., 2005; MacCartney and Manning, 2007, inter alia) . A second challenge arises when a system needs to combine various sources of evidence (i.e., surface text features, semantic features, and syntactic features) to make a global classification decision. Quite often these features are heavily overlapping and sometimes contradicting, and thus a robust learning scheme that knows when to activate what feature is desired. Traditional approaches employ a two-stage or multi-stage model where tasks are broken down into alignment finding, feature extraction, and feature learning subtasks (Haghighi et al., 2005; MacCartney et al., 2008) . The alignment finding task is typically done by committing to a one best alignment, and subsequent features are extracted only according to this alignment. A large body of literature in joint learning has demonstrated that such an approach can suffer from cascaded errors at testing, and does not benefit from the potential for joint learning (Finkel et al., 2006) . In this paper, we present a novel undirected graphical model to address these challenges. A promising approach to these challenges is modeling the alignment as an edit operation sequence over parse tree representation, an approach pio-neered by (Punyakanok et al., 2004; Kouylekov and Magnini, 2006; Harmeling, 2007; Mehdad, 2009) . We improve upon this earlier work by showing how alignment structures can be inherently learned as structured latent variables in our model. Tree edits are represented internally as state transitions in a Finite-State Machine (FSM), and our model is parameterized as a Conditional Random Field (CRF) (Lafferty et al., 2001) , which allows us to incorporate a diverse set of arbitrarily overlapping features. In comparison to previous work that exploits various ad-hoc or heuristic ways of incorporating tree-edit operations, our model provides an elegant and much more principled way of describing tree-edit operations in a probabilistic setting. Tree-edit CRF for Classification A training instance consists of a pair of sentences and an associated binary judgment. In RTE, for example, the input sentence pairs is made up of a text sentence (e.g., Gabriel Garcia Marquez is a novelist and winner of the Nobel prize for literature.) and a hypothesis sentence (e.g., Gabriel Garcia Marquez won the Nobel for Literature.). The pair is judged to be true if the hypothesis can be entailed from the text (e.g., the answer is true for the example sentence pair). Formally, we denote the text sentence as txt and the hypothesis sentence as hyp, and denote their labeled dependency parse trees as \u03c4 t and \u03c4 h , respectively. We use the binary variable z \u2208 {0, 1} to denote the judgment. The generative story behind our model is a parse tree transformation process. \u03c4 t is transformed into \u03c4 h through a sequence of tree edits. Examples of tree edits are delete child, insert parent, and substitute current. An edit sequence e = e 1 . . . e m is valid if \u03c4 t can be successfully turned into \u03c4 h according to e. An example of a trivial valid edit sequence is one that first deletes all nodes in \u03c4 t then inserts all nodes in \u03c4 h . Delete, insert and substitute form the three basic edit operations. Each step in an edit sequence is also linked with current edit positions in both trees, denoted as e.p = e 1 .p . . . e m .p. We index the tree nodes using a level-order tree traversal scheme (i.e., root is visited first and assigned in-dex 0, then each one of the first level children of the root is visited in turn, and assigned an index number incremented by 1). It is worth noting that every valid edit sequence has a corresponding alignment mapping. Nodes that are inserted or deleted are aligned to null, and nodes that are substituted are aligned. One can find many edit sequence for the same alignment, by altering the order of edit operations. We extend these basic edit operations into more elaborate edit operations based on the linguistic and syntactic properties of the current tree nodes that they fire on. For example, the following are all possible edit operations: delete a noun that is SUB of the root, delete a named-entity of type PERSON, substitute roots of the tree. In our experiments, we designed a set of 45 edit operations (12 delete, 12 insert and 21 substitute). More details of the edit operations are described in \u00a74. Depending on the specific application domain, more sophisticated and verbose tree edit operations can be designed and easily incorporated into our model. In particular, tree edit operations involving deleting, inserting or substituting entire treelets seem interesting and promising, requiring merely a simple extension to the forwardbackward dynamic programming. Next, we design a Finite-State Machine (FSM) in which each edit operation is mapped to a unique state, and an edit sequence is mapped into a transition sequence among states (denoted as e.a = e 1 .a . . . e m .a). In brief, an edit sequence is associated with a sequence of edit positions in the trees (e.p = e 1 .p . . . e m .p), as well as a transition sequence among states (e.a = e 1 .a . . . e m .a). The probability of an edit sequence e given the parse trees is defined as: P(e | \u03c4 t , \u03c4 h ) = 1 Z |e| \u220f i=1 exp \u03b8 \u2022 f(e i\u22121 , e i , \u03c4 t , \u03c4 h ) (1) where f are feature functions, \u03b8 are associated feature weights, and Z is the partition function to be defined next. Recall that our training data is composed of not only positive examples but also negative examples. In order to take advantage of this label information, we adopt an interesting discriminative learning framework first introduced by McCallum et al. (2005) . We call the FSM state set described above the positive state set (S 1 ), and duplicate the exact same set of states, and call the new set negative state set (S 0 ). We then add a starting state(S s ), and add non-deterministic transitions from S s to every state in S 1 . We then add the same transitions for S 0 . We now arrive at a new FSM structure where upon arriving at the starting state, one makes a non-deterministic decision to enter either the positive set or the negative set and stay in that set until reaching the end of the edit sequence, since no transitions are allowed across the positive and negative set. Each edit operation sequence can now be associated with a sequence of positive states as well as a sequence of negative states. The intuitive idea is that during training, we want to maximize the weights of the positive examples in the positive state set and minimize their weights in the negative state set, and vice versa. In other words, we want the positive state set to attract positive examples but push away negative examples. Figure 1 illustrates two example valid edit sequences in the FSM, one in the positive state set and one in the negative state set. Formally, the partition function Z in ( 1 ) is defined as the sum of weights of all valid edit sequences in both the positive set and negative set. Features extracted from positive states are disjoint from features extracted from negative states. Z = \u2211 e: e.a\u2286S s +{S 0 S 1 } * |e| \u220f i=1 exp \u03b8 \u2022 f(e i\u22121 , e i , \u03c4 t , \u03c4 h ) Recall z \u2208 {0, 1} is the binary judgment indicator variable. The conditional probability of z is obtained by marginalizing over all edit sequences that have state transitions in the state set corresponding to z: P(z | \u03c4 t , \u03c4 h ) = \u2211 e: e.a\u2286S s +S * z P(e | \u03c4 t , \u03c4 h ) (2) The L 2 -norm penalized log-likelihood over n training examples (L) is our training objective function: L = n \u2211 j=1 log(P(z ( j) | \u03c4 ( j) t , \u03c4 ( j) h )) \u2212 \u03b8 2 2\u03c3 2 (3) At test time, the z with higher probability is taken as our prediction outcome. Parameter Estimation We used Expectation Maximization method since the objective function given in ( 3 ) is non-convex. In the M-step, finding the optimal parameters under the current model expectation involves computing forward-backward style dynamic programming (DP) in a three-dimensional table (two for inputs and one for states) and optimization using L-BFGS method. In practice the resulting DP table can be quite large (for a sentence pair of length 100, and 2 sets of 45 states, we obtain 900,000 entries). We improved efficiency by pruning out partial sequences that do not lead to a complete valid sequence and pre-compute the state-transition table and features. Edit Operations Table 1 lists the groups of edit operations we designed and their descriptions. Not shown in the table are three default edits ( insert, delete and substitute), which fire when none of the more specific edit operations match. Edit operations listed in the the top-left section capture basic matching, deletion and insertion of surface text, part-ofspeech tags and named-entity tags. The top-right section capture alignments of semantically related words, based on relational information extracted from various linguistic resources, such as Word-Net and NomBank. And the bottom section capture syntactic edits. Note that multiple edit operations can fire at the same edit position if conditions are matched (e.g., we can choose to delete if there are more words to edit in txt, or to insert if there are more words to edit in hyp). Features One of the most distinctive advantages of our model compared to previous tree-edit based models is the ability to include a wide range of nonindependent, rich linguistic features. syntactic-matching conditions listed below). To give an example, in Figure 1 , the second edit operation in the example sequence is S-NE. A matching condition feature that fires with this state could be substitute NE type PERSON, which tells us exactly what type of named-entity is being substituted. It is notable that in designing edit operations and features, there is a continuum of choice in terms of how much information to be encoded as features versus edit operations. To better illustrate the trade-off, consider the two extreme cases of this continuum. At one extreme, we can design a system where there are only three basic edit operations, and all extra information in our current set of edit operations can be encoded as features. For example, in this case edit operation S-NE would become S with feature substitute NE. The other extreme is to encode every zero-order feature as a separate edit operation. The amount of information encoded in the zero-order features and edit operations is the same in both cases, but the difference lies in first-order features and efficiency. When encoding more information as edit operations (and thus more states in FSM), first-order features become much more expressive; whereas when encoding more information as features, computation becomes cheaper as the number of possible state transition sequences is reduced. In our experiments, we aim to keep a minimal set of edit operations that are meaningful but not overly verbose, and encode additional information as features. Each feature is a binary feature initialized with weight 0. Due to space limitation, we list the most im-portant zero-order features. Many of these features are inspired by MacCartney et al. (2006) and Snow et al. (2006) , but not as sophisticated. Word matching features. These features detect if a text word and a hypothesis word match the following conditions: Preprocessing In all of our experiments, each input pair of text and hypothesis sentence is preprocessed as following: Sentences were first tokenized by the standard Penn TreeBank tokenization script, and then we used MXPOST tagger (Ratnaparkhi, 1996) for part-of-speech (POS) tagging. POS tagged sentences were then parsed by MST-Parser (McDonald et al., 2005) to produce labeled dependency parse trees. The parser was trained on the entire Penn TreeBank. The last step in the pipeline is named-entity tagging using Stanford NER Tagger (Finkel et al., 2005) . RTE Experiments Given an input text sentence and a hypothesis sentence, the task of RTE is to make predictions about whether or not the hypothesis can be entailed from the text sentence. We use standard evaluation datasets RTE1-3 from the Pascal RTE Challenges (Dagan et al., 2006) . For each RTE dataset, we train a tree-edit CRF model on the training portion and evaluate on the testing portion. We report accuracy of classification results, and precision and recall for the true entailment class. There is a balanced positive-negative sample distribution in each dataset, so a random baseline gives 50% classification accuracy. We used RTE1 for feature selection and tuning \u03c3 in the L 2 regularizer (\u03c3 = 5 was used). RTE2 and RTE3 were reserved for testing. Our system is compared with four systems on RTE2 and three other systems on the RTE3 dataset. 1 We chose these systems for comparison because they make use of syntactic dependencies and lexical semantic information. Notably other systems that give state-of-the-art performance on RTE use non-comparable techniques such as theorem-proving and logical induction, and often involve significant manual engineering specifically for RTE, thus do not make meaningful comparison to our model. For RTE2, Kouylekov and Magnini (2006) experimented with various TED cost functions and found a combination scheme to work the best for RTE. Vanderwende et al. (2006) used syntactic heuristic matching rules with a lexical-similarity back-off model. Nielsen et al. (2006) extracted features from dependency path, and combined them with word-alignment features in a mixture of experts classifier. Zanzotto et al. (2006) proposed a syntactic cross-pair similarity measure for RTE. For RTE3, Harmeling (2007) took a similar classification-based approach with transformation sequence features. Marsi et al. (2007) described a system using dependency-based paraphrasing 1 Different systems are used for comparison because none of these systems reported performance on both datasets. RTE2 Acc.% Prec.% Rec.% Vanderwende et al., 2006 techniques for RTE. de Marneffe et al. ( 2006 ) described a system where best alignments between the sentence pairs were first found, then classification decisions were made based on these alignments. Table 2 presents RTE results. Our model performs competitively on both datasets. On RTE2, our model gives second best performance among the methods we compare against, and the difference in accuracy from the best system is quite small (7 out of 800 examples). We observe a larger gap in recall, suggesting our method tends to give higher precision, which is also commonly found in other syntax-based systems (Snow et al., 2006) . It is worth noting that Zanzotto et al. (2006) achieved second place in the official RTE2 evaluation. On RTE3, our model outperforms the other syntax-based systems compared. In particular, out system gives the same precision level as the second best system (de Marneffe et al., 2006) without sacrificing as much recall, which is the most common drawback found in syntax-based systems. QA Experiments A second Tree-edit CRF model was trained for the task of answer selection for Question Answering. In this task, the input pair consists of a short factoid question (e.g., Who beat Floyd Patterson to take the title away?) and an answer candidate sentence (e.g., He saw Ingemar Johansson knock down Floyd Patterson seven times there in winning the heavyweight title.). The pair is judged positive if the answer candidate sentence correctly answers the question and provides sufficient con- textual support (i.e., does not merely contain the answer key, for example, \"Ingemar Johansson was a world heavyweight champion\" would not be a correct answer). We followed the same experimental setup as Wang et al. (2007) Results in Table 3 show that our model gives the same level of performance as Wang et al. (2007) , with no statistically significant difference (p > 5 in sign test). Both systems out-perform the other two earlier systems significantly. Discussion Our experiments on RTE and QA applications demonstrated that Tree-edit CRF models provide results competitive with previous syntax-based methods. Even though the improvements were quite moderate in some cases, the important point is that our model provides a novel principled framework. It works across different problem domains with minimal domain knowledge and feature engineering, whereas previous methods are only engineered for a particular task and are hard to generalize to new problems. While the current Tree-edit CRF model can model a large set of linguistic phenomenon and tree-transformations, it has some clear limitations. One of the biggest drawbacks is the lack of support for modeling phrasal re-ordering, which is a very common and important linguistic phenomena. It is not straightforward to implement reordering in the current model because it breaks the word-order constraint which admits tractable forward-backward style dynamic programming. However, this shortcoming can be addressed partially by extending the model to deal with constrained re-ordering per Zhang (1996) . Related Work Tree Edit Distance (TED) have been studied extensively in theoretical and algorithmic research (Klein, 1989; Zhang and Shasha, 1989; Bille, 2005) . In recent years we have seen many work on applying TED based methods for NLPrelated tasks (Punyakanok et al., 2004; Kouylekov and Magnini, 2006; Harmeling, 2007; Mehdad, 2009) . Mehdad (2009) proposed a method based on particle swarm optimization technique to automatically learn the TED cost function. Another work that also developed an interesting approach to stochastic tree edit distance is Bernard et al. (2008) , but unfortunately experiments in the paper were limited to digit recognition and tasks on small artificial datasets. Many different approaches to modeling sentence alignment have been proposed before (Haghighi et al., 2005; MacCartney et al., 2008) . Haghighi et al. (2005) treated alignment finding in RTE as a graph matching problem between sentence parse trees. MacCartney et al. ( 2008 ) described a phrase-based alignment model for MT, trained by the Perceptron learning algorithm. A line of work that offers similar treatment of alignment to our model is the Quasi-synchronous Grammar (QG) (Smith and Eisner, 2006; Wang et al., 2007; Das and Smith, 2009) . QG models alignments between two parse trees as structured latent variables. The generative story of QG describes one that builds the parse tree of one sentence, loosely conditioned on the parse tree of the other sentence. This formalism prefers but is not confined to tree isomorphism, therefore possesses more model flexibility than synchronous grammars. The work of McCallum et al. (2005) inspired the discriminative training framework that we used in our experiments. They presented a String Edit Distance model that also learns alignments as hidden structures for simple tasks such as restaurant name matching. Our work is also closely related to other recent work on learning probabilistic models involving structural latent variables (Clark and Curran, 2004; Petrov et al., 2007; Blunsom et al., 2008; Chang et al., 2010) . The Tree-edit CRF model we present here is a new addition to this family of interesting models for discriminative learning with structural latent variables. Conclusion We described a Tree-edit CRF model for predicting semantic relatedness of pairs of sentences. Our approach generalizes TED in a principled probabilistic model that embeds alignments as structured latent variables. We demonstrate a wide-range of lexical-semantic and syntactic features can be easily incorporated into the model. Discriminatively trained, the Tree-edit CRF led to competitive performance on the task of Recognizing Textual Entailment and answer selection for Question Answering.",
    "abstract": "A range of Natural Language Processing tasks involve making judgments about the semantic relatedness of a pair of sentences, such as Recognizing Textual Entailment (RTE) and answer selection for Question Answering (QA). A key challenge that these tasks face in common is the lack of explicit alignment annotation between a sentence pair. We capture the alignment by using a novel probabilistic model that models tree-edit operations on dependency parse trees. Unlike previous tree-edit models which require a separate alignment-finding phase and resort to ad-hoc distance metrics, our method treats alignments as structured latent variables, and offers a principled framework for incorporating complex linguistic features. We demonstrate the robustness of our model by conducting experiments for RTE and QA, and show that our model performs competitively on both tasks with the same set of general features.",
    "countries": [
        "United States"
    ],
    "languages": [
        "Chang"
    ],
    "numcitedby": "161",
    "year": "2010",
    "month": "August",
    "title": "Probabilistic Tree-Edit Models with Structured Latent Variables for Textual Entailment and Question Answering"
}