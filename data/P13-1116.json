{
    "article": "This paper presents a novel deterministic algorithm for implicit Semantic Role Labeling. The system exploits a very simple but relevant discursive property, the argument coherence over different instances of a predicate. The algorithm solves the implicit arguments sequentially, exploiting not only explicit but also the implicit arguments previously solved. In addition, we empirically demonstrate that the algorithm obtains very competitive and robust performances with respect to supervised approaches that require large amounts of costly training data. Introduction Traditionally, Semantic Role Labeling (SRL) systems have focused in searching the fillers of those explicit roles appearing within sentence boundaries (Gildea and Jurafsky, 2000, 2002; Carreras and M\u00e0rquez, 2005; Surdeanu et al., 2008; Haji\u010d et al., 2009) . These systems limited their searchspace to the elements that share a syntactical relation with the predicate. However, when the participants of a predicate are implicit this approach obtains incomplete predicative structures with null arguments. The following example includes the gold-standard annotations for a traditional SRL process: (1) [arg0 The network] had been expected to have The previous analysis includes annotations for the nominal predicate loss based on the NomBank structure (Meyers et al., 2004) . In this case the annotator identifies, in the first sentence, the arguments arg0, the entity losing something, arg1, the thing lost, and arg3, the source of that loss. However, in the second sentence there is another instance of the same predicate, loss, but in this case no argument has been associated with it. Traditional SRL systems facing this type of examples are not able to fill the arguments of a predicate because their fillers are not in the same sentence of the predicate. Moreover, these systems also let unfilled arguments occurring in the same sentence, like in the following example: (2) Quest Medical Inc said it adopted [arg1 a shareholders' rights] [np plan] in which rights to purchase shares of common stock will be distributed as a dividend to shareholders of record as of Oct 23. For the predicate plan in the previous sentence, a traditional SRL process only returns the filler for the argument arg1, the theme of the plan. However, in both examples, a reader could easily infer the missing arguments from the surrounding context of the predicate, and determine that in (1) both instances of the predicate share the same arguments and in (2) the missing argument corresponds to the subject of the verb that dominates the predicate, Quest Medical Inc. Obviously, this additional annotations could contribute positively to its semantic analysis. In fact, Gerber and Chai (2010) pointed out that implicit arguments can increase the coverage of argument structures in NomBank by 71%. However, current automatic systems require large amounts of manually annotated training data for each predicate. The effort required for this manual annotation explains the absence of generally applicable tools. This problem has become a main concern for many NLP tasks. This fact explains a new trend to develop accurate unsupervised systems that exploit simple but robust linguistic principles (Raghunathan et al., 2010) . In this work, we study the coherence of the predicate and argument realization in discourse. In particular, we have followed a similar approach to the one proposed by Dahl et al. (1987) who filled the arguments of anaphoric mentions of nominal predicates using previous mentions of the same predicate. We present an extension of this idea assuming that in a coherent document the different ocurrences of a predicate, including both verbal and nominal forms, tend to be mentions of the same event, and thus, they share the same argument fillers. Following this approach, we have developed a deterministic algorithm that obtains competitive results with respect to supervised methods. That is, our system can be applied to any predicate without training data. The main contributions of this work are the following: \u2022 We empirically prove that there exists a strong discourse relationship between the implicit and explicit argument fillers of the same predicates. \u2022 We propose a deterministic approach that exploits this discoursive property in order to obtain the fillers of implicit arguments. \u2022 We adapt to the implicit SRL problem a classic algorithm for pronoun resolution. \u2022 We develop a robust algorithm, ImpAr, that obtains very competitive results with respect to existing supervised systems. We release an open source prototype implementing this algorithm 1 . The paper is structured as follows. Section 2 discusses the related work. Section 3 presents in detail the data used in our experiments. Section 4 describes our algorithm for implicit argument resolution. Section 5 presents some experiments we have carried out to test the algorithm. Section 6 discusses the results obtained. Finally, section 7 offers some concluding remarks and presents some future research lines. Related Work The first attempt for the automatic annotation of implicit semantic roles was proposed by Palmer et al. (1986) . This work applied selectional restrictions together with coreference chains, in a very specific domain. In a similar approach, Whittemore et al. (1991) also attempted to solve implicit arguments using some manually described semantic constraints for each thematic role they tried to cover. Another early approach was presented by Tetreault (2002) . Studying another specific domain, they obtained some probabilistic relations between some roles. These early works agree that the problem is, in fact, a special case of anaphora or coreference resolution. Recently, the task has been taken up again around two different proposals. On the one hand, Ruppenhofer et al. (2010) presented a task in SemEval-2010 that included an implicit argument identification challenge based on FrameNet (Baker et al., 1998) . The corpus for this task consisted in some novel chapters. They covered a wide variety of nominal and verbal predicates, each one having only a small number of instances. Only two systems were presented for this subtask obtaining quite poor results (F1 below 0,02). VENSES++ (Tonelli and Delmonte, 2010) applied a rule based anaphora resolution procedure and semantic similarity between candidates and thematic roles using WordNet (Fellbaum, 1998) . The system was tuned in (Tonelli and Delmonte, 2011) improving slightly its performance. SEMAFOR (Chen et al., 2010 ) is a supervised system that extended an existing semantic role labeler to enlarge the search window to other sentences, replacing the features defined for regular arguments with two new semantic features. Although this system obtained the best performance in the task, data sparseness strongly affected the results. Besides the two systems presented to the task, some other systems have used the same dataset and evaluation metrics. Ruppenhofer et al. (2011) , Laparra and Rigau (2012) , Gorinski et al. (2013) and Laparra and Rigau (2013) explore alternative linguistic and semantic strategies. These works obtained significant gains over previous approaches. Silberer and Frank (2012) adapted an entity-based coreference resolution model to extend automatically the training corpus. Exploiting this additional data, their system was able to improve previous results. Following this approach Moor et al. (2013) present a corpus of predicate-specific annotations for verbs in the FrameNet paradigm that are aligned with PropBank and VerbNet. On the other hand, Gerber and Chai (2010, 2012) studied the implicit argument resolution on NomBank. They uses a set of syntactic, semantic and coreferential features to train a logistic regres-sion classifier. Unlike the dataset from SemEval-2010 (Ruppenhofer et al., 2010) , in this work the authors focused on a small set of ten predicates. But for those predicates, they annotated a large amount of instances in the documents from the Wall Street Journal that were already annotated for PropBank (Palmer et al., 2005) and NomBank. This allowed them to avoid the sparseness problems and generalize properly from the training set. The results of this system were far better than those obtained by the systems that faced the SemEval-2010 dataset. This works represent the deepest study so far of the features that characterizes the implicit arguments 2 . However, many of the most important features are lexically dependent on the predicate and cannot been generalized. Thus, specific annotations are required for each new predicate to be analyzed. All the works presented in this section agree that implicit arguments must be modeled as a particular case of coreference together with features that include lexical-semantic information, to build selectional preferences. Another common point is the fact that these works try to solve each instance of the implicit arguments independently, without taking into account the previous realizations of the same implicit argument in the document. We propose that these realizations, together with the explicit ones, must maintain a certain coherence along the document and, in consequence, the filler of an argument remains the same along the following instances of that argument until a stronger evidence indicates a change. We also propose that this feature can be exploited independently from the predicate. Datasets In our experiments, we have focused on the dataset developed in Gerber and Chai (2010, 2012) . This dataset (hereinafter BNB which stands for \"Beyond NomBank\") extends existing predicate annotations for NomBank and ProbBank. BNB presented the first annotation work of implicit arguments based on PropBank and Nom-Bank frames. This annotation was an extension of the standard training, development and testing sections of Penn TreeBank that have been typically used for SRL evaluation and were already annotated with PropBank and NomBank predicate structures. The authors selected a limited set of predicates. These predicates are all nominalizations of other verbal predicates, without sense ambiguity, that appear frequently in the corpus and tend to have implicit arguments associated with their instances. These constraints allowed them to model enough occurrences of each implicit argument in order to cover adequately all the possible cases appearing in a test document. For each missing argument position they went over all the preceding sentences and annotated all mentions of the filler of that argument. In tables 3 and 4 we show the list of predicates and the resulting figures of this annotation. In this work we also use the corpus provided for the CoNLL-2008 task. These corpora cover the same BNB documents and include annotated predictions for syntactic dependencies and Super-Sense labels as semantic tags. Unlike Gerber and Chai (2010, 2012) we do not use the constituent analysis from the Penn TreeBank. ImpAr algorithm 4.1 Discoursive coherence of predicates Exploring the training dataset of BNB, we observed a very strong discourse effect on the implicit and explicit argument fillers of the predicates. That is, if several instances of the same predicate appear in a well-written discourse, it is very likely that they maintain the same argument fillers. This property holds when joining the different parts-of-speech of the predicates (nominal or verbal) and the explicit or implicit realizations of the argument fillers. For instance, we observed that 46% of all implicit arguments share the same filler with the previous instance of the same predicate while only 14% of them have a different filler. The remaining 40% of all implicit arguments correspond to first occurrences of their predicates. That is, these fillers can not be recovered from previous instances of their predicates. The rationale behind this phenomena seems to be simple. When referring to different aspects of the same event, the writer of a coherent document does not repeat redundant information. They refer to previous predicate instances assuming that the reader already recalls the involved participants. That is, the filler of the different instances of a predicate argument maintain a certain discourse coherence. For instance, in example (1), all the argument positions of the second occurrence of the predicate loss are missing, but they can be easily inferred from the previous instance of the same predicate. ( Therefore, we propose to exploit this property in order to capture correctly how the fillers of all predicate arguments evolve through a document. Our algorithm, ImpAr, processes the documents sentence by sentence, assuming that sequences of the same predicate (in its nominal or verbal form) share the same argument fillers (explicit or implicit) 3 . Thus, for every core argument arg n of a predicate, ImpAr stores its previous known filler as a default value. If the arguments of a predicate are explicit, they always replace default fillers previously captured. When there is no antecedent for a particular implicit argument arg n , the algorithm tries to find in the surrounding context which participant is the most likely to be the filler according to some salience factors (see Section 4.2). For the following instances, without an explicit filler for a particular argument position, the algorithm repeats the same selection process and compares the new implicit candidate with the default one. That is, the default implicit argument of a predicate with no antecedent can change every time the algorithm finds a filler with a greater salience. A damping factor is applied to reduce the salience of distant predicates. Filling arguments without explicit antecedents Filling the implicit arguments of a predicate has been identified as a particular case of coreference, very close to pronoun resolution (Silberer and Frank, 2012) . Consequently, for those implicit arguments that have not explicit antecedents, we propose an adaptation of a classic algorithm for deterministic pronoun resolution. This component of our algorithm follows the RAP approach (Lappin and Leass, 1994). When our algorithm needs to fill an implicit predicate argument without an explicit antecedent it considers a set of candidates within a window formed by the sentence of the predicate and the two previous sentences. Then, the algorithm performs the following steps: 1. Apply two constraints to the candidate list: (a) All candidates that are already explicit arguments of the predicate are ruled out. (b) All candidates commanded by the predicate in the dependency tree are ruled out. 2. Select those candidates that are semantically consistent with the semantic category of the implicit argument. 3. Assign a salience score to each candidate. 4. Sort the candidates by their proximity to the predicate of the implicit argument. 5. Select the candidate with the highest salience value. As a result, the candidate with the highest salience value is selected as the filler of the implicit argument. Thus, this filler with its corresponding salience weight will be also considered in subsequent instances of the same predicate. Now, we explain each step in more detail using example (2). In this example, arg 0 is missing for the predicate plan: (2) Quest Medical Inc said it adopted [arg1 a shareholders' rights] [np plan] in which rights to purchase shares of common stock will be distributed as a dividend to shareholders of record as of Oct 23. Filtering. In the first step, the algorithm filters out the candidates that are actual explicit arguments of the predicate or have a syntactic dependency with the predicate, and therefore, they are in the search space of a traditional SRL system. In our example, the filtering process would remove [a shareholders' rights] because it is already the explicit argument arg 1 , and [in which rights to purchase shares of common stock will be distributed as a dividend to shareholders of record as of Oct 23] because it is syntactically commanded by the predicate plan. Semantic consistency. To determine the semantic coherence between the potential candidates and a predicate argument arg n , we have exploited the selectional preferences in the same way as in previous SRL and implicit argument resolution works. First, we have designed a list of very general semantic categories. Second, we have semi-automatically assigned one of them to every predicate argument arg n in PropBank and Nom-Bank. For this, we have used the semantic annotation provided by the training documents of the CoNLL-2008 dataset. This annotation was performed automatically using the SuperSense-Tagger (Ciaramita and Altun, 2006) and includes named-entities and WordNet Super-Senses 4 . We have also defined a mapping between the semantic classes provided by the SuperSenseTagger and our seven semantic categories (see Table 1 for more details). Then, we have acquired the most common categories of each predicate argument arg n . ImpAr algorithm also uses the SuperSenseTagger over the documents to be processed from BNB to check if the candidate belongs to the expected semantic category of the implicit argument to be filled. Following the example above, [Quest Medical Inc] is tagged as an ORGANIZATION by the SuperSenseTagger. Therefore, it belongs to our semantic category COGNITIVE. As the semantic category for the implicit argument arg 0 for the predicate plan has been recognized to be also COGNITIVE, [Quest Medical Inc] remains in the list of candidates as a possible filler. Salience weighting. In this process, the algorithm assigns to each candidate a set of salience factors that scores its prominence. The sentence recency factor prioritizes the candidates that occur close to the same sentence of the predicate. The subject, direct object, indirect object and nonadverbial factors weight the salience of the candidate depending on the syntactic role they belong to. Additionally, the head of these syntactic roles are prioritized by the head factor. We have used the same weights, listed in table 2, proposed by Lappin and Leass (1994) belongs to a subject, and, indeed, it is the head of that subject. Hence, the salience score for this candidate is: 100 + 80 + 80 = 260. Damping the salience of the default candidate As the algorithm maintains the default candidate until an explicit filler appears, potential errors produced in the automatic selection process explained above can spread to distant implicit instances, specially when the salience score of the default candidate is high. In order to reduce the impact of these errors we have included a damping factor that is applied sentence by sentence to the salience value of the default candidate. ImpAr applies that damping factor, r, as follows. It assumes that, independently of the initial salience assigned, 100 points of the salience score came from the sentence recency factor. Then, the algorithm changes this value multiplying it by r. So, given a salience score s, the value of the score in a following sentence, s , is: s = s \u2212 100 + 100 \u2022 r Obviously, the value of r must be defined without harming excessively those cases where the default candidate has been correctly identified. For this, we studied in the training dataset the cases of implicit arguments filled with the default candidate. Figure 1 shows that the influence of the default filler is much higher in near sentences that in more distance ones. We tried to mimic a damping factor following this distribution. That is, to maintain high score salience for the near sentences while strongly decreasing them in the subsequent ones. In this way, if the filler of the implicit argument is wrongly identified, the error only spreads to the nearest instances. If the identification is correct, a lower score for more distance sentences is not too harmful. The distribution shown in figure 1 follows an exponential decay, therefore we have described the damping factor as a curve like the following, where \u03b1 must be a value within 0 and 1: In order to illustrate the whole process we will use the previous example. In that case, [Quest Medical Inc] is selected as the arg 0 of plan with a salience score of 260. Therefore [Quest Medical Inc] becomes the default arg 0 of plan. In the following sentence the damping factor is: 0.5 = 0.5 1 Therefore, its salience score changes to 260 \u2212 100+100\u20220.5 = 210. Then, the algorithm changes the default filler for arg 0 only if it finds a candidate that scores higher in their current context. At two sentence distance, the resulting score for the default filler is 260 \u2212 100 + 100 \u2022 0.25 = 185. In this way, at more distance sentences, the influence of the default filler of arg 0 becomes smaller. Evaluation In order to evaluate the performance of the Im-pAr algorithm, we have followed the evaluation method presented by Gerber and Chai (2010, 2012) . For every argument position in the goldstandard the scorer expects a single predicted constituent to fill in. In order to evaluate the correct span of a constituent, a prediction is scored using the Dice coefficient: 2|P redicted \u2229 T rue| |P redicted| + |T rue| The function above relates the set of tokens that form a predicted constituent, P redicted, and the set of tokens that are part of an annotated constituent in the gold-standard, T rue. For each missing argument, the gold-standard includes the whole coreference chain of the filler. Therefore, the scorer selects from all coreferent mentions the highest Dice value. If the predicted span does not cover the head of the annotated filler, the scorer returns zero. Then, P recision is calculated by the sum of all prediction scores divided by the number of attempts carried out by the system. Recall is equal to the sum of the prediction scores divided by the number of actual annotations in the goldstandard. F-measure is calculated as the harmonic mean of recall and precision. Traditionally, there have been two approaches to develop SRL systems, one based on constituent trees and the other one based on syntactic dependencies. Additionally, the evaluation of both types of systems has been performed differently. For constituent based SRL systems the scorers evaluate the correct span of the filler, while for dependency based systems the scorer just check if the systems are able to capture the head token of the filler. As shown above, previous works in implicit argument resolution proposed a metric that involves the correct identification of the whole span of the filler. ImpAr algorithm works with syntactic dependencies and therefore it only returns the head token of the filler. In order to compare our results with previous works, we had to apply some simple heuristics to guess the correct span of the filler. Obviously, this process inserts some noise in the final evaluation. We have performed a first evaluation over the test set used in (Gerber and Chai, 2010) . This dataset contains 437 predicate instances but just 246 argument positions are implicitly filled. Table 3 includes the results obtained by ImpAr, the results of the system presented by Gerber and Chai (2010) and the baseline proposed for the task. Best results are marked in bold 5 . For all predicates, ImpAr improves over the baseline (19.3 points higher in the overall F 1 ). Our system also outperforms the one presented by Gerber and Chai (2010) instance, our system obtains much higher results for the predicates bid and fund, while much lower for loss and loan. In general, ImpAr seems to be more robust since it obtains similar performances for all predicates. In fact, the standard deviation, \u03c3 , of F 1 measure is 10.98 for ImpAr while this value for the (Gerber and Chai, 2010) system is 20.00. In a more recent work, Gerber and Chai (2012) presented some improvements of their previous results. In this work, they extended the evaluation of their model using the whole dataset and not just the testing documents. Applying a crossvalidated approach they tried to solve some problems that they found in the previous evaluation, like the small size of the testing set. For this work, they also studied a wider set of features, specially, they experimented with some statistics learnt from parts of GigaWord automatically annotated. Table 4 shows that the improvement over their previous system was remarkable. The system also seems to be more stable across predicates. For comparison purposes, we also included the performance of ImpAr applied over the whole dataset. The results in table 4 show that, although ImpAr still achieves the best results in some cases, this time, it cannot beat the overall results obtained by the supervised model. In fact, both systems obtain a very similar recall, but the system from (Gerber and Chai, 2012) obtains much higher precision. In both cases, the \u03c3 value of F 1 is reduced, 8.81 for ImpAr and 8.21 for (Gerber and Chai, 2012) . However, ImpAr obtains very similar performance independently of the testing dataset what proves the robustness of the algorithm. This suggests that our algorithm can obtain strong results also for other corpus and predicates. Instead, the supervised approach would need a large amount of manual annotations for every predicate to be processed. Discussion Component Analysis In order to assess the contribution of each system component, we also tested the performance of ImpAr algorithm when disabling only one of its components. With this evaluations we pretend to sight the particular contribution of each component. In table 5 we present the results obtained in the following experiments for the two testing sets explained in section 5: \u2022 Exp1: The damping factor is disabled. All selected fillers maintain the same salience over all sentences. \u2022 Exp2: Only explicit fillers are considered as candidates 6 . \u2022 Exp3: No default fillers are considered as candidates. As expected, we observe a very similar performances in both datasets. Additionally, the highest loss appears when the default fillers are ruled out (Exp3). In particular, it also seems that the explicit information from previous predicates provides the most correct evidence (Exp2). Also note that for Exp2, the system obtains the highest precision. This means that the most accurate cases are obtained by previous explicit antecedents. As Exp1 also includes instances with explicit antecedents, and for these cases the damping factor component has no effect, we have designed two additional experiments: \u2022 Exp4: Full system for the cases not solved by explicit antecedents. \u2022 Exp5: As in Exp4 but with the damping factor disabled. As expected, now the contribution of the dumping factor seems to be more relevant, in particular, for the test dataset. Correct span of the fillers As explained in Section 5, our algorithm works with syntactic dependencies and its predictions only return the head token of the filler. Obtaining the correct constituents from syntactic dependencies is not trivial. In this work we have applied a simple heuristic that returns all the descendant tokens of the predicted head token. This naive process inserts some noise to the evaluation of the system. For example, from the following sentence our system gives the following prediction for an implicit arg 1 of an instance of the predicate sale: Ports of Call Inc. reached agreements to sell its remaining seven aircraft [arg1 to buyers] that weren't disclosed. But the actual gold-standard annotation is: [arg 1 buyers that weren't disclosed]. Although the head of the constituent, buyers, is correctly captured by ImpAr, the final prediction is heavily penalized by the scoring method. Table 5 presents the results of ImpAr when evaluating the head tokens of the constituents only (Exp6). These results show that the current performance of our system can be easily improved applying a more accurate process for capturing the correct span. Conclusions and Future Work In this work we have presented a robust deterministic approach for implicit Semantic Role Labeling. The method exploits a very simple but relevant discoursive coherence property that holds over explicit and implicit arguments of closely related nominal and verbal predicates. This property states that if several instances of the same predicate appear in a well-written discourse, it is very likely that they maintain the same argument fillers. We have shown the importance of this phenomenon for recovering the implicit information about semantic roles. To our knowledge, this is the first empirical study that proves this phenomenon. Based on these observations, we have developed a new deterministic algorithm, ImpAr, that obtains very competitive and robust performances with respect to supervised approaches. That is, it can be applied where there is no available manual annotations to train. The code of this algorithm is publicly available and can be applied to any document. As input it only needs the document with explicit semantic role labeling and Super-Sense annotations. These annotations can be easily obtained from plain text using available tools 7 , what makes this algorithm the first effective tool available for implicit SRL. As it can be easily seen, ImpAr has a large margin for improvement. For instance, providing more accurate spans for the fillers. We also plan to test alternative approaches to solve the arguments without explicit antecedents. For instance, our system can also profit from additional annotations like coreference, that has proved its utility in previous works. Finally, we also plan to study our approach on different languages and datasets (for instance, the SemEval-2010 dataset). Acknowledgment We are grateful to the anonymous reviewers for their insightful comments. This work has been partially funded by SKaTer (TIN2012-38584-C06-02), OpeNER (FP7-ICT-2011-SME-DCL-296451) and NewsReader (FP7-ICT-2011-8-316404), as well as the READERS project with the financial support of MINECO, ANR (convention ANR-12-CHRI-0004-03) and EPSRC (EP/K017845/1) in the framework of ERA-NET CHIST-ERA (UE FP7/2007-2013).",
    "abstract": "This paper presents a novel deterministic algorithm for implicit Semantic Role Labeling. The system exploits a very simple but relevant discursive property, the argument coherence over different instances of a predicate. The algorithm solves the implicit arguments sequentially, exploiting not only explicit but also the implicit arguments previously solved. In addition, we empirically demonstrate that the algorithm obtains very competitive and robust performances with respect to supervised approaches that require large amounts of costly training data.",
    "countries": [
        "Spain"
    ],
    "languages": [
        "Chai"
    ],
    "numcitedby": "32",
    "year": "2013",
    "month": "August",
    "title": "{I}mp{A}r: A Deterministic Algorithm for Implicit Semantic Role Labelling"
}