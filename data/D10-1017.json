{
    "article": "We describe a new scalable algorithm for semi-supervised training of conditional random fields (CRF) and its application to partof-speech (POS) tagging. The algorithm uses a similarity graph to encourage similar ngrams to have similar POS tags. We demonstrate the efficacy of our approach on a domain adaptation task, where we assume that we have access to large amounts of unlabeled data from the target domain, but no additional labeled data. The similarity graph is used during training to smooth the state posteriors on the target domain. Standard inference can be used at test time. Our approach is able to scale to very large problems and yields significantly improved target domain accuracy. Introduction Semi-supervised learning (SSL) is the use of small amounts of labeled data with relatively large amounts of unlabeled data to train predictors. In some cases, the labeled data can be sufficient to provide reasonable accuracy on in-domain data, but performance on even closely related out-of-domain data may lag far behind. Annotating training data for all sub-domains of a varied domain such as all of Web text is impractical, giving impetus to the development of SSL techniques that can learn from unlabeled data to perform well across domains. The earliest SSL algorithm is self-training (Scudder, 1965) , where one makes use of a previously trained model to annotate unlabeled data which is then used to re-train the model. While self-training is widely used and can yield good results in some applications (Yarowsky, 1995) , it has no theoretical guarantees except under certain stringent conditions, which rarely hold in practice (Haffari and Sarkar, 2007) . Other SSL methods include co-training (Blum and Mitchell, 1998) , transductive support vector machines (SVMs) (Joachims, 1999) , and graph-based SSL (Zhu et al., 2003) . Several surveys cover a broad range of methods (Seeger, 2000; Zhu, 2005; Chapelle et al., 2007; Blitzer and Zhu, 2008) . A majority of SSL algorithms are computationally expensive; for example, solving a transductive SVM exactly is intractable. Thus we have a conflict between wanting to use SSL with large unlabeled data sets for best accuracy, but being unable to do so because of computational complexity. Some researchers attempted to resolve this conflict by resorting to approximations (Collobert et al., 2006) , but those lead to suboptimal results (Chapelle et al., 2007) . Graph-based SSL algorithms (Zhu et al., 2003; Joachims, 2003; Corduneanu and Jaakkola, 2003; Belkin et al., 2005; Subramanya and Bilmes, 2009) are an important subclass of SSL techniques that have received much attention in the recent past, as they outperform other approaches and also scale easily to large problems. Here one assumes that the data (both labeled and unlabeled) is represented by vertices in a graph. Graph edges link vertices that are likely to have the same label. Edge weights govern how strongly the labels of the nodes linked by the edge should agree. Most previous work in SSL has focused on unstructured classification problems, that is, problems with a relatively small set of atomic labels. There has been much less work on SSL for structured prediction where labels are composites of many atomic labels with constraints between them. While the number of atomic labels might be small, there will generally be exponentially many ways to combine them into the final structured label. Structured prediction problems over sequences appear for example in speech recognition, named-entity recognition, and part-of-speech tagging; in machine translation and syntactic parsing, the output may be treestructured. Altun et al. (2005) proposed a max-margin objective for semi-supervised learning over structured spaces. Their objective is similar to that of manifold regularization (Belkin et al., 2005) and they make use of a graph as a smoothness regularizer. However their solution involves inverting a matrix whose size depends on problem size, making it impractical for very large problems. Brefeld and Scheffer (2006) present a modified version of the co-training algorithm for structured output spaces. In both of the above cases, the underlying model is based on structured SVM, which does not scale well to very large datasets. More recently Wang et al. (2009) proposed to train a conditional random field (CRF) (Lafferty et al., 2001 ) using an entropy-based regularizer. Their approach is similar to the entropy minimization algorithm (Grandvalet and Bengio, 2005) . The problem here is that their objective is not convex and thus can pose issues for large problems. Further, graphbased SSL algorithms outperform algorithms based on entropy minimization (Chapelle et al., 2007) . In this work, we propose a graph-based SSL method for CRFs that is computationally practical for very large problems, unlike the methods in the studies cited above. Our method is scalable because it trains with efficient standard building blocks for CRF inference and learning and also standard graph label propagation machinery. Graph regularizer computations are only used for training, so at test time, standard CRF inference can be used, unlike in graph-based transductive methods. Briefly, our approach starts by training a CRF on the source domain labeled data, and then uses it to decode unlabeled data from the target domain. The state posteriors on the target domain are then smoothed using the graph regularizer. Best state sequences for the unlabeled target data are then created by Viterbi decod-ing with the smoothed state posteriors, and this automatic target domain annotation is combined with the labeled source domain data to retrain the CRF. We demonstrate our new method in domain adaptation for a CRF part-of-speech (POS) tagger. While POS tagging accuracies have reached the level of inter-annotator agreement (>97%) on the standard PennTreebank test set (Toutanova et al., 2003; Shen et al., 2007) , performance on out-of-domain data is often well below 90%, impairing language processing tasks that need syntactic information. For example, on the question domain used in this paper, the tagging accuracy of a supervised CRF is only 84%. Our domain adaptation algorithm improves performance to 87%, which is still far below in-domain performance, but a significant reduction in error. Supervised CRF We assume that we have a set of labeled source domain examples D l = {(x i , y i )} l i=1 , but only un- labeled target domain examples D u = {x i } l+u i=l+1 . Here x i = x (1) i x (2) i \u2022 \u2022 \u2022 x (|x i |) i is the sequence of words in sentence i and y i = y (1) i y (2) i \u2022 \u2022 \u2022 y (|x i |) i is the corresponding POS tag sequence, with y (j) i \u2208 Y where Y is the set of POS tags. Our goal is to learn a CRF of the form: p(y i |x i ; \u039b) \u221d exp N i j=1 K k=1 \u03bb k f k (y (j\u22121) i ,y (j) i , x i , j) for the target domain. In the above equation, \u039b = {\u03bb 1 , . . . , \u03bb K } \u2208 R K , f k (y (j\u22121) i , y (j) i , x i , j) is the kth feature function applied to two consecutive CRF states and some window of the input sequence, and \u03bb k is the weight of that feature. We discuss our features in detail in Section 6. Given only labeled data D l , the optimal feature weights are given by: \u039b * = argmin \u039b\u2208R K \u2212 l i=1 log p(y i |x i ; \u039b)+\u03b3 \u039b 2 (1) Here \u039b 2 is the squared 2 -norm and acts as the regularizer, and \u03b3 is a trade-off parameter whose setting we discuss in Section 6. In our case, we also have access to the unlabeled data D u from the target domain which we would like to use for training the CRF. We first describe how we construct a similarity graph over the unlabeled which will be used in our algorithm as a graph regularizer. Graph Construction Graph construction is the most important step in graph-based SSL. The standard approach for unstructured problems is to construct a graph whose vertices are labeled and unlabeled examples, and whose weighted edges encode the degree to which the examples they link should have the same label (Zhu et al., 2003) . Then the main graph construction choice is what similarity function to use for the weighted edges between examples. However, in structured problems the situation is more complicated. Consider the case of sequence tagging we are studying. While we might be able to choose some appropriate sequence similarity to construct the graph, such as edit distance or a string kernel, it is not clear how to use whole sequence similarity to constrain whole tag sequences assigned to linked examples in the learning algorithm. Altun et al. (2005) had the nice insight of doing the graph construction not for complete structured examples but instead for the parts of structured examples (also known as factors in graphical model terminology), which encode the local dependencies between input data and output labels in the structured problem. However, their approach is too demanding computationally (see Section 5), so instead we use local sequence contexts as graph vertices, exploting the empirical observation that the part of speech of a word occurrence is mostly determined by its local context. Specifically, the set V of graph vertices consists of all the word n-grams 1 (types) that have occurrences (tokens) in training sentences (labeled and unlabeled). We partition V = V l \u222a V u where V l corresponds to n-grams that occur at least once in the labeled data, and V u corresponds to n-grams that occur only in the unlabeled data. Given a symmetric similarity function between types to be defined below, we link types u and v with Description Feature Trigram + Context x 1 x 2 x 3 x 4 x 5 Trigram x 2 x 3 x 4 Left Context x 1 x 2 Right Context x 4 x 5 Center Word x 2 Trigram -Center Word x 2 x 4 Left Word + Right Context x 2 x 4 x 5 Left Context + Right Word x 1 x 2 x 4 Suffix HasSuffix(x 3 ) Table 1 : Features we extract given a sequence of words \"x 1 x 2 x 3 x 4 x 5 \" where the trigram is \"x 2 x 3 x 4 \". an edge of weight w uv , defined as: w uv = sim(u, v) if v \u2208 K(u) or u \u2208 K(v) 0 otherwise where K(u) is the set of k-nearest neighbors of u according to the given similarity. For all experiments in this paper, n = 3 and k = 5. To define the similarity function, for each token of a given type in the labeled and unlabeled data, we extract a set of context features. For example, for the token x 2 x 3 x 4 occurring in the sequence x 1 x 2 x 3 x 4 x 5 , we use feature templates that capture the left (x 1 x 2 ) and right contexts (x 4 x 5 ). Additionally, we extract suffix features from the word in the middle. Table 1 gives an overview of the features that we used. For each n-gram type, we compute the vector of pointwise mutual information (PMI) values between the type and each of the features that occur with tokens of that type. Finally, we use the cosine distance between those PMI vectors as our similarity function. We have thus circumvented the problem of defining similarities over sequences by defining the graph over types that represent local sequence contexts. Since our CRF tagger only uses local features of the input to score tag pairs, we believe that the graph we construct captures all significant context information. Figure 1 shows an excerpt from our graph. The figure shows the neighborhoods of a subset of the vertices with the center word 'book.' To reduce clutter, we included only closest neighbors and the edges that involve the nodes of interest. It is remarkable that the neighborhoods are coherent, showing very similar syntactic configurations. Furthermore, different vertices that (should) have the same label are close to each other, forming connected components for each part-of-speech category (for nouns and verbs in the figure). We expect the similarity graph to provide information that cannot be expressed directly in a sequence model. In particular, it is not possible in a CRF to directly enforce the constraint that similar trigrams appearing in different sentences should have similar POS tags. This constraint however is important during (semi-supervised) learning, and is what makes our approach different and more effective than selftraining. In practice, we expect two main benefits from our graph-based approach. First, the graph allows new features to be discovered. Many words occur only in the unlabeled data and a purely supervised CRF would not be able to learn feature weights for those observations. We could use self-training to learn weights for those features, but self-training just tends to reinforce the knowledge that the supervised model already has. The similarity graph on the other hand can link events that occur only in the unlabeled data to similar events in the labeled data. Furthermore, because the graph is built over types rather than tokens, it will encourage the same interpretation to be chosen for similar trigrams occurring in different sentences. For example, the word 'unrar' will most likely not occur in the labeled training data. Seeing it in the neighborhood of words for which we know the POS tag will help us learn the correct POS tag for this otherwise unknown word (see Figure 1 ). Second, the graph propagates adjustments to the weights of known features. Many words occur only a handful of times in our labeled data, resulting in poor estimates of their contributions. Even for frequently occurring events, their distribution in the target domain might be different from their distribution in the source domain. While self-training might be able to help adapt to such domain changes, its effectiveness will be limited because the model will always be inherently biased towards the source domain. In contrast, labeled vertices in the similarity graph can help disambiguate ambiguous contexts and correct (some of) the errors of the supervised model. Semi-Supervised CRF Given unlabeled data D u , we only have access to the prior p(x). As the CRF is a discriminative model, the lack of label information renders the CRF weights independent of p(x) and thus we cannot directly utilize the unlabeled data when training the CRF. Therefore, semi-supervised approaches to training discriminative models typically use the unlabeled data to construct a regularizer that is used to guide the learning process (Joachims, 1999; Lawrence and Jordan, 2005) . Here we use the graph as a smoothness regularizer to train CRFs in a semisupervised manner. Our algorithm iterates between the following five Algorithm 1 Semi-Supervised CRF Training \u039b s = crf-train(D l , \u039b 0 ) Set \u039b (t) 0 = \u039b (s) while not converged do {p} = posterior decode(D u , \u039b old ) {q} = token to type({p}) {q} = graph propagate({q}) D (1) u = viterbi decode({q}, \u039b old ) \u039b (t) n+1 = crf-train(D l \u222a D (1) u , \u039b (t) n ) end while Return last \u039b (t) simple (and convex) steps: Given a set of CRF parameters, we first compute marginals over the unlabeled data (posterior decode). The marginals over tokens are then aggregated to marginals over types (token to type), which are used to initialize the graph label distributions. After running label propagation (graph propagate), the posteriors from the graph are used to smooth the state posteriors. Decoding the unlabeled data (viterbi decode) produces a new set of automatic annotations that can be combined with the labeled data to retrain the CRF using the supervised CRF training objective (crftrain). These steps, summarized in Algorithm 1, are iterated until convergence. Posterior Decoding Let \u039b (t) n (t refers to target domain) represent the estimate of the CRF parameters for the target domain after the n-th iteration. 2 In this step, we use the current parameter estimates to compute the marginal probabilities p(y (j) i |x i ; \u039b (t) n ) 1 \u2264 j \u2264 |x i |, i \u2208 D l over POS tags for every word position j for i indexing over sentences in D l \u222a D u . Token-to-Type Mapping Recall that our graph is defined over types while the posteriors computed above involve particular tokens. We accumulate token-based marginals to create type marginals as follows. For a sentence i and word position j in that sentence, let T (i, j) be the trigram (graph node) centered at position j. Conversely, for a trigram type u, let T \u22121 (u) be the set of actual occurrences (tokens) of that trigram u; that is, all pairs (i, j) where i is the index of a sentence where u occurs and j is the position of the center word of an occurrence of u in that sentence. We calculate type-level posteriors as follows: q u (y) 1 |T \u22121 (u)| (i,j)\u2208T \u22121 (u) p(y (j) i |x i ; \u039b (t) n ) . This combination rule connects the token-centered CRF with the type-centered graph. Other ways of combining the token marginals, such as using weights derived from the entropies of marginals, might be worth investigating. Graph Propagation We now use our similarity graph (Section 3) to smooth the type-level marginals by minimizing the following convex objective: C(q) = u\u2208V l r u \u2212 q u 2 + \u00b5 u\u2208V,v\u2208N (i) w uv q u \u2212 q v 2 + \u03bd u\u2208V q u \u2212 U 2 s.t. y q u (y) = 1 \u2200u & q u (y) \u2265 0 \u2200u, y (2) where q = {q 1 , q 2 , . . . q |V | }. The setting of the hyperparameters \u00b5 and \u03bd will be discussed in Section 6, N (u) is the set of neighbors of node u, and r u is the empirical marginal label distribution for trigram u in the labeled data. We use a squared loss to penalize neighboring nodes that have different label distributions: q u \u2212 q v 2 = y (q u (y) \u2212 q v (y)) 2 , additionally regularizing the label distributions towards the uniform distribution U over all possible labels Y. It can be shown that the above objective is convex in q. Our graph propagation objective can be seen as a multi-class generalization of the quadratic cost criterion (Bengio et al., 2007) . The first term in the above objective requires that we respect the information in our labeled data. The second term is the graph smoothness regularizer which requires that the q i 's be smooth with respect to the graph. In other words, if w uv is large, then q u and q v should be close in the squared-error sense. This implies that vertices u and v are likely to have similar marginals over POS tags. The last term is a regularizer and encourages all type marginals to be uniform to the extent that is allowed by the first two terms. If a unlabeled vertex does not have a path to any labeled vertex, this term ensures that the converged marginal for this vertex will be uniform over all tags, ensuring that our algorithm performs at least as well as a standard self-training based algorithm, as we will see later. While the objective in Equation 2 admits a closed form solution, it involves inverting a matrix of order |V | and thus we use instead the simple iterative update given by q (m) u (y) = \u03b3 u (y) \u03ba u where \u03b3 u (y) = r u (y)\u03b4(u \u2208 V l ) + v\u2208N (u) w uv q (m\u22121) v (y) + \u03bdU (y), \u03ba u = \u03b4(u \u2208 V l ) + \u03bd + \u00b5 v\u2208N (u) w uv ( 3 ) where m is the iteration index and \u03b4 is the indicator function that returns 1 if and only if the condition is true. The iterative procedure starts with q (0) u (y) = q u (y) as given in the previous section. In all our experiments we run 10 iterations of the above algorithm, and we denote the type marginals at completion by q * u (y). Viterbi Decoding Given the type marginals computed in the previous step, we interpolate them with the original CRF token marginals. This interpolation between type and token marginals encourages similar n-grams to have similar posteriors, while still allowing n-grams in different sentences to differ in their posteriors. For each unlabeled sentence i and word position j in it, we calculate the following interpolated tag marginal: p(y (j) i = y|x i ) = \u03b1p(y (j) i = y|x i ; \u039b (t) n ) + (1 \u2212 \u03b1)q * T (m,n) (y) (4) where \u03b1 is a mixing coefficient which reflects the relative confidence between the original posteriors from the CRF and the smoothed posteriors from the graph. We discuss how we set \u03b1 in Section 6. The interpolated marginals summarize all the information obtained so far about the tag distribution at each position. However, if we were to use them on their own to select the most likely POS tag sequence, the first-order tag dependencies modeled by the CRF would be mostly ignored. This happens because the type marginals obtained from the graph after label propagation will have lost most of the sequence information. To enforce the first-order tag dependencies we therefore use Viterbi decoding over the combined interpolated marginals and the CRF transition potentials to compute the best POS tag sequence for each unlabeled sentence. We refer to these 1-best transcripts as y * i , i \u2208 D u . Re-training the CRF Now that we have successfully labeled the unlabeled target domain data, we can use it in conjunction with the source domain labeled data to re-train the CRF: \u039b (t) n+1 =argmin \u039b\u2208R K \u2212 l i=1 log p(y i |x i ; \u039b (t) n ) \u2212 \u03b7 l+u i=l+1 log p(y * i |x i ; \u039b (t) n )+\u03b3 \u039b 2 (5) where \u03b7 and \u03b3 are hyper-parameters whose setting we discuss in Section 6. Given the new CRF parameters \u039b we loop back to step 1 (Section 4.1) and iterate until convergence. It is important to note that every step of our algorithm is convex, although their combination clearly is not. Related Work Our work differs from previous studies of SSL (Blitzer et al., 2006; III, 2007; Huang and Yates, 2009) for improving POS tagging in several ways. First, our algorithm can be generalized to other structured semi-supervised learning problems, although POS tagging is our motivating task and test application. Unlike III (2007), we do not require target domain labeled data. While the SCL algorithm (Blitzer et al., 2006) has been evaluated without target domain labeled data, that evaluation was to some extent transductive in that the target test data (unlabeled) was included in the unsupervised stage of SCL training that creates the structural correspondence between the two domains. We mentioned already the algorithm of Altun et al. (2005) , which is unlikely to scale up because its dual formulation requires the inversion of a matrix whose size depends on the graph size. Gupta et al. (2009) also constrain similar trigrams to have similar POS tags by forming cliques of similar trigrams and maximizing the agreement score over these cliques. Computing clique agreement potentials however is NP-hard and so they propose approximation algorithms that are still quite complex computationally. We achieve similar effects by using our simple, scalable convex graph regularization framework. Further, unlike other graph-propagation algorithms (Alexandrescu and Kirchhoff, 2009) , our approach is inductive. While one might be able to make inductive extensions of transductive approaches (Sindhwani et al., 2005) , these usually require extensive computational resources at test time. Experiments and Results We use the Wall Street Journal (WSJ) section of the Penn Treebank as our labeled source domain training set. We follow standard setup procedures for this task and train on sections 00-18, comprising of 38,219 POS-tagged sentences with a total of 912,344 words. To evaluate our domain-adaptation approach, we consider two different target domains: questions and biomedical data. Both target domains are relatively far from the source domain (newswire), making this a very challenging task. The QuestionBank (Judge et al., 2006) , provides an excellent corpus consisting of 4,000 questions that were manually annotated with POS tags and parse trees. We used the first half as our development set and the second half as our test set. Questions are difficult to tag with WSJ-trained taggers primarily because the word order is very different than that of the mostly declarative sentences in the training data. Additionally, the unknown word rate is more than twice as high as on the in-domain development set (7.29% vs. 3.39%). As our unlabeled data, we use a set of 10 million questions collected from anonymized Internet search queries. These queries were selected to be similar in style and length to the questions in the QuestionBank. 3  As running the CRF over 10 million sentences can be rather cumbersome and probably unnecessary, we randomly select 100,000 of these queries and treat this as D u . Because the graph nodes and the features used in the similarity function are based on n-grams, data sparsity can be a serious problem, and we therefore use the entire unlabeled data set for graph construction. We estimate the mutual information-based features for each trigram type over all the 10 million questions, and then construct the graph over only the set of trigram types that actually occurs in the 100,000 random subset and the WSJ training set. For our second target domain, we use the Penn BioTreebank (PennBioIE, 2005) . This corpus consists of 1,061 sentences that have been manually annotated with POS tags. We used the first 500 sentences as a development set and the remaining 561 sentences as our final test set. The high unknown word rate (23.27%) makes this corpus very difficult to tag. Furthermore, the POS tag set for this data is a super-set of the Penn Treebank's, including the two new tags HYPH (for hyphens) and AFX (for common post-modifiers of biomedical entities such as genes). These tags were introduced due to the importance of hyphenated entities in biomedical text, and are used for 1.8% of the words in the test set. Any tagger trained only on WSJ text will automatically predict wrong tags for those words. For unlabeled data we used 100,000 sentences that were chosen by searching MEDLINE for abstracts pertaining to cancer, in particular genomic variations and mutations (Blitzer et al., 2006) . Since we did not have access to additional unlabeled data, we used the same set of sentences as target domain unlabeled data, D u . The graph here was constructed over the 100,000 unlabeled sentences and the WSJ training set. Finally, we remind the reader that we did not use label information for graph construction in either corpus. Baselines Our baseline supervised CRF is competitive with state-of-the-art discriminative POS taggers (Toutanova et al., 2003; Shen et al., 2007) , achieving 97.17% on the WSJ development set (sections 19-21). We use a fairly standard set of features, including word identity, suffixes and prefixes and detectors when, etc.), and have between 30 and 160 characters. for special characters such as dashes and digits. We do not use of observation-dependent transition features. Both supervised and semi-supervised models are regularized with a squared 2 -norm regularizer with weight set to 0.01. In addition to the supervised baseline trained exclusively on the WSJ, we also consider a semisupervised self-trained baseline (\"Self-trained CRF\" in Table 2 ). In this approach, we first train a supervised CRF on the labeled data and then do semisupervised training without label propagation. This is different from plain self-training because it aggregates the posteriors over tokens into posteriors over types. This aggregation step allows instances of the same trigram in different sentences to share information and works better in practice than direct selftraining on the output of the supervised CRF. Domain Adaptation Results The data set obtained concatenating the WSJ training set with the 10 million questions had about 20 million trigram types. Of those, only about 1.1 million trigram types occurred in the WSJ training set or in the 100,000 sentence sub-sample. For the biomedical domain, the graph had about 2.2 million trigrams. For all our experiments we set hyperparameters as follows: for graph propagation, \u00b5 = 0.5, \u03bd = 0.01, for Viterbi decoding mixing, \u03b1 = 0.6, for CRF re-training, \u03b7 = 0.001, \u03b3 = 0.01. These parameters were chosen based on development set performance. All CRF objectives were optimized using L-BFGS (Bertsekas, 2004) . Table 2 shows the results for both domains. For the question corpus, the supervised CRF performs at only 85% on the development set. While it is almost impossible to improve in-domain tagging accuracy and tagging is therefore considered a solved problem by many, these results clearly show that the problem is far from solved. Self-training improves over the baseline by about 0.6% on the de-velopment set. However the gains from self-training are more modest (0.2%) on the evaluation (test) set. Our approach is able to provide a more solid improvement of about 3% absolute over the supervised baseline and about 2% absolute over the selftrained system on the question development set. Unlike self-training, on the question evaluation set, our approach provides about 3% absolute improvement over the supervised baseline. For the biomedical data, while the performances of our approach and self-training are statistically indistinguishable on the development set, we see modest gains of about 0.5% absolute on the evaluation set. On the same data, we see that our approach provides about 1.4% absolute improvement over the supervised baseline. Analysis & Conclusion The results suggest that our proposed approach provides higher gains relative to self-training on the question data than on the biomedical corpus. We hypothesize that this caused by sparsity in the graph generated from the biomedical dataset. For the questions graph, the PMI statistics were estimated over 10 million sentences while in the case of the biomedical dataset, the same statistics were computed over just 100,000 sentences. We hypothesize that the lack of well-estimated features in the case of the biomedical dataset leads to a sparse graph. To verify the above hypothesis, we measured the percentage of trigrams that occur in the target domain (unlabeled) data that do not have any path to a trigram in the source domain data, and the average minimum path length between a trigram in the target data and a trigram in the source data (when such a path exists). The results are shown in Table 3. For the biomedical data, close to 50% of the trigrams from the target data do not have a path to a trigram from the source data. Even when such a path exists, the average path length is about 22. the other hand, for the question corpus, only about 12% of the target domain trigrams are disconnected, and the average path length is about 9. These results clearly show the sparse nature of the biomedical graph. We believe that it is this sparsity that causes the graph propagation to not have a more noticeable effect on the final performance. It is noteworthy that making use of even such a sparse graph does not lead to any degradation in results, which we attribute to the choice of graph-propagation regularizer (Section 4.3). We presented a simple, scalable algorithm for training structured prediction models in a semisupervised manner. The approach is based on using as a regularizer a nearest-neighbor graph constructed over trigram types. Our results show that the approach not only scales to large datasets but also produces significantly improved tagging accuracies.",
    "abstract": "We describe a new scalable algorithm for semi-supervised training of conditional random fields (CRF) and its application to partof-speech (POS) tagging. The algorithm uses a similarity graph to encourage similar ngrams to have similar POS tags. We demonstrate the efficacy of our approach on a domain adaptation task, where we assume that we have access to large amounts of unlabeled data from the target domain, but no additional labeled data. The similarity graph is used during training to smooth the state posteriors on the target domain. Standard inference can be used at test time. Our approach is able to scale to very large problems and yields significantly improved target domain accuracy.",
    "countries": [
        "United States"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "120",
    "year": "2010",
    "month": "October",
    "title": "Efficient Graph-Based Semi-Supervised Learning of Structured Tagging Models"
}