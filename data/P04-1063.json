{
    "article": "The paper describes a particular approach to multiengine machine translation (MEMT), where we make use of voted language models to selectively combine translation outputs from multiple off-theshelf MT systems. Experiments are done using large corpora from three distinct domains. The study found that the use of voted language models leads to an improved performance of MEMT systems. Introduction As the Internet grows, an increasing number of commercial MT systems are getting on line ready to serve anyone anywhere on the earth. An interesting question we might ponder is whether it is not possible to aggregate the vast number of MT systems available on the Internet into one super MT which surpasses in performance any of those MTs that comprise the system. And this is what we will be concerned with in the paper, with somewhat watered-down settings. People in the speech community pursued the idea of combining off-the-shelf ASRs (automatic speech recognizers) into a super ASR for some time, and found that the idea works (Fiscus, 1997; Schwenk  and Gauvain, 2000; Utsuro et al., 2003). In IR (information retrieval), we find some efforts going (under the name of distributed IR or meta-search) to selectively fuse outputs from multiple search engines on the Internet (Callan et al., 2003). So it would be curious to see whether we could do the same with MTs. Now back in machine translation, we do find some work addressing such concern: Frederking  and Nirenburg (1994) develop a multi-engine MT or MEMT architecture which operates by combining outputs from three different engines based on the knowledge it has about inner workings of each of the component engines. Brown and Frederking (1995) is a continuation of Frederking and  Nirenburg (1994) with an addition of a ngrambased mechanism for a candidate selection. Nomoto  (2003), however, explores a different line of research whose goal is to combine black box MTs using statistical confidence models. Similar efforts are also found in Akiba et al. (2002). The present paper builds on the prior work by Nomoto (2003). We start by reviewing his approach, and go on to demonstrate that it could be improved by capitalizing on dependence of the MEMT model there on language model. Throughout the paper, we refer to commercial black box MT systems as OTS (off-the-shelf) systems, or more simply, OTSs. Confidence Models We take it here that the business of MEMT is about choosing among translation outputs from multiple MT systems, whether black box or not, for each input text. Therefore the question we want to address is, how do we go about choosing among MT outputs so that we end up with a best one? What we propose to do is to use some confidence models for translations generated by OTSs, and let them decide which one we should pick. We essentially work along the lines of Nomoto (2003). We review below some of the models proposed there, together with some motivation behind them. Confidence models he proposes come in two varieties: Fluency based model (FLM) and Alignment based model (ALM), which is actually an extension of FLM. Now suppose we have an English sentence e and its Japanese translation j generated by some OTS. (One note here: throughout the paper we work on English to Japanese translation.) FLM dictates that the quality of j as a translation of e be deter-mined by: F LM (e, j) = log P l (j) (1) P l (j) is the probability of j under a particular language model (LM) l. 1 What FLM says is that the quality of a translation essentially depends on its log likelihood (or fluency) and has nothing to do with what it is a translation of. ALM extends FLM to include some information on fidelity. That is, it pays some attention to how faithful a translation is to its source text. ALM does this by using alignment models from the statistical machine translation literature (Brown et al., 1993). Here is what ALM looks like. ALM (e, j) = log P l (j)Q(e | j) Q(e | j) is the probability estimated using IBM Model 1. ALM takes into account the fluency of a translation output (given by P l (j)) and the degree of association between e and j (given by Q(e | j)), which are in fact two features generally agreed in the MT literature to be most relevant for assessing the quality of translations (White, 2001). One problem with FLM and ALM is that they fail to take into account the reliability of an OTS system. As Nomoto (2003) argues, it is reasonable to believe that some MT systems could inherently be more prone to error and outputs they produce tend to be of less quality than those from other systems, no matter what the outputs' fluency or translation probability may be. ALM and FLM work solely on statistical information that can be gathered from source and target sentences, dismissing any operational bias that an OTS might have on a particular task. Nomoto (2003) responds to the problem by introducing a particular regression model known as Support Vector regression (SVR), which enables him to exploit bias in performance of OTSs. What SVR is intended to do is to modify confidence scores FLM and ALM produce for MT outputs in such a way that they may more accurately reflect their independent evaluation involving human translations or judgments. SVR is a multi-dimensional regressor, and works pretty much like its enormously popular counterpart, Support Vector classification, except that we are going to work with real numbers for target values and construct the margin, using Vapnik's -insensitive loss function (Sch\u00f6lkopf et al.,  1998). 1 Note that P l (j) = P (l) Q m i P (wi | wi\u22122, wi\u22121, l) where j = w1 \u2022 \u2022 \u2022 wm. Assume a uniform prior for l. SVR looks something like this. h( x) = w \u2022 x + b, with input data x = (x 1 , . . . , x m ) and the corresponding weights w = (w 1 , . . . , w m ). 'x \u2022 y' denotes the inner product of x and y. x could be a set of features associated with e and j. Parameters w and b are something determined by SVR. It is straightforward to extend the ALM and FLM with SVR, which merely consists of plugging in either model as an input variable in the regressor. This would give us the following two SVR models with m = 1. Regressive FLM (rFLM) h(F LM (e, j)) = w 1 \u2022 F LM (e, j) + b Regressive ALM (rALM) h(ALM (e, j)) = w 1 \u2022 ALM (e, j) + b Notice that h(\u2022) here is supposed to relate FLM or ALM to some independent evaluation metric such as BLEU (Papineni et al., 2002), not the log likelihood of a translation. With confidence models in place, define a MEMT model \u03a8 by: \u03a8(e, J, l) = arg max j\u2208J (\u03b8(e, j | l)) Here e represents a source sentence, J a set of translations for e generated by OTSs, and \u03b8 denotes some confidence model under an LM l. Throughout the rest of the paper, we let FLM \u03c8 and ALM \u03c8 denote MEMT systems based on FLM and ALM, respectively, and similarly for others. Notes on Evaluation We assume here that the MEMT works on a sentence-by-sentence basis. That is, it takes as input a source sentence, gets it translated by several OTSs, and picks up the best among translations it gets. Now a problem with using BLEU in this setup is that translations often end up with zero because model translations they refer to do not contain ngrams of a particular length. 2 This would make impossible a comparison and selection among possible translations. One way out of this, Nomoto (2003) suggests, is to back off to a somewhat imprecise yet robust metric for evaluating translations, which he calls mprecision. 3 The idea of m-precision helps define what an optimal MEMT should look like. Imagine a system which operates by choosing, among candidates, a translation that gives a best m-precision. We would reasonably expect the system to outperform any of its component OTSs. Indeed Nomoto  (2003) demonstrates empirically that it is the case. Moreover, since rFLM \u03c8 and rALM \u03c8 work on a sentence, not on a block of them, what h(\u2022) relates to is not BLEU, but m-precision. Hogan and Frederking (1998) introduces a new kind of yardstick for measuring the effectiveness of MEMT systems. The rationale for this is that it is often the case that the efficacy of MEMT systems does not translate into performance of outputs that they generate. We recall that with BLEU, one measures performance of translations, not how often a given MEMT system picks the best translation among candidates. The problem is, even if a MEMT is right about its choices more often than a best component engine, BLEU may not show it. This happens because a best translation may not always get a high score in BLEU. Indeed, differences in BLEU among candidate translations could be very small. Now what Hogan and Frederking (1998) suggest is the following. d(\u03c8 m ) = N i \u03b4(\u03c8 m (e) , max{\u03c3 e 1 \u2022 \u2022 \u2022 \u03c3 e M }) N where \u03b4(i, j) is the Kronecker delta function, which gives 1 if i = j and 0 otherwise. Here \u03c8 m represents some MEMT system, \u03c8 m (e) denotes a particular translation \u03c8 m chooses for sentence e, i.e., \u03c8 m (e) = \u03a8(e, J, l). \u03c3 e 1 . . . \u03c3 e M \u2208 J denotes a set of candidate translations. max here gives a translation with the highest score in m-precision. N is the number of source sentences. \u03b4(\u2022) says that you get 1 if a particular translation the MEMT chooses for a given sentences happens to rank highest among can-3 For a reference translation r and a machine-generated translation t, m-precision is defined as: m-precision = N X i P v\u2208S i t C(v, r) P v\u2208S i t C(v, t) , which is nothing more than Papineni et al. (2002)'s modified n-gram precision applied to a pair of a single reference and the associated translation. S i t here denotes a set of i-grams in t, v an i-gram. C(v, t) indicates the count of v in t. Nomoto  (2003) finds that m-precision strongly correlates with BLEU, which justifies the use of m-precision as a replacement of BLEU at the sentence level. didates. d(\u03c8 m ) gives the average ratio of the times \u03c8 m hits a right translation. Let us call d(\u03c8 m ) HF accuracy (HFA) for the rest of the paper. LM perplexity and MEMT performance Now the question we are interested in asking is whether the choice of LM really matters. That is, does a particular choice of LM gives a better performing FLM \u03c8 or ALM \u03c8 than something else, and if it does, do we have a systematic way of choosing one LM over another? Let us start with the first question. As a way of shedding some light on the issue, we ran FLM \u03c8 and ALM \u03c8 using a variety of LMs, derived from various domains with varying amount of training data. We worked with 24 LMs from various genres, with vocabulary of size ranging from somewhere near 10K to 20K in words (see below and also Appendix A for details on train sets). LMs here are trigram based and created using an open source speech recognition tool called JULIUS. 4 Now train data for LMs are collected from five corpora, which we refer to as CPC, EJP, PAT, LIT, NIKMAI for the sake of convenience. CPC is a huge set of semi-automatically aligned pairs of English and Japanese texts from a Japanese news paper which contains as many as 150,000 sentences (Utiyama and Isahara, 2002), EJP represents a relatively small parallel corpus of English/Japanese phrases (totaling 15,187) for letter writing in business (Takubo and Hashimoto, 1999), PAT is a bilingual corpus of 336,971 abstracts from Japanese patents filed in 1995, with associated translations in English (a.k.a NTCIR-3 PATENT). 5 LIT contains 100 Japanese literary works from the early 20th century, and NIKMAI 1,536,191 sentences compiled from several Japanese news paper sources. Both LIT and NIKMAI are monolingual. Fig. 1 gives a plot of HF accuracy by perplexity for FLM \u03c8 's on test sets pulled out of PAT, EJP and CPC. 6 Each dot there represents an FLM \u03c8 with a particular LM plugged into it. The HFA of each FLM \u03c8 in Fig. 1 represents a 10-fold cross validated HFA score, namely an HFA averaged over evenly-  split 10 blocks of a test set. The perplexity is that of P l (j) averaged over blocks, with a particular LM plugged in for l (see Equation 1 ). We can see there an apparent tendency for an LM with lower perplexity to give rise to an FLM \u03c8 with higher HFA, indicating that the choice of LM does indeed influence the performance of FLM \u03c8 . Which is somewhat surprising given that the perplexity of a machine generated translation should be independent of how similar it is to a model translation, which dictates the HFA. 7 Now let us turn to the question of whether there is any systematic way of choosing an LM so that it gives rise to a FLM \u03c8 with high HFA. Since we are working with multiple OTS systems here, we get multiple outputs for a source text. Our idea is to let them vote for an LM to plug into FLM \u03c8 or for that matter, any other forms of MEMT discussed earlier. Note that we could take an alternate approach of letting a model (or human) translation (associated with a source text) pick an LM by alone. An obvious problem with this approach, however, is that a mandatory reference to model translations would compromise the robustness of the approach. We would want the LM to work for MEMT regardless of whether model translations are available. So our concern here is more with choosing an LM in the absence of model translations, to which we will return below. \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022\u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 LM \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 LM Perplexity HF Accuracy 500 1000 1500 0.38 0.40 0.42 0.44 CPC \u2022 \u2022 \u2022\u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 LM Voting Language Model We consider here a simple voting scheme \u00e0 la ROVER (Fiscus, 1997; Schwenk and Gauvain,  2000; Utsuro et al., 2003), which works by picking 7 Recall that the HFA does not represent the confidence score such as one given by FLM (Equation 1 ), but the average ratio of the times that an MEMT based on FLM picks a translation with the best m-precision. Table 1 : A MEMT algorithm implementing V-by-M. S represents a set of OTS systems, L a set of language models. \u03b8 is some confidence model such (r)FLM or (r)ALM. V-by-M chooses a most-votedfor LM among those in L, given the set J of translations for e. MEMT(e,S,L) begin J = {j | j is a translation of e generated by s \u2208 S.} l = V-by-M(J, L) j k = arg max j\u2208J (\u03b8(e, j | l)) return j k end up an LM voted for by the majority. More specifically, for each output translation for a given input, we first pick up an LM which gives it the smallest perplexity, and out of those LMs, one picked by the majority of translations will be plugged into MEMT. We call the selection scheme voting-by-majority or simply V-by-M. The V-by-M scheme is motivated by the results in Fig. 1 , where perplexity is found to be a reasonably good predictor of HFA. Formally, we could put the V-by-M scheme as follows. For each of the translation outputs j e 1 . . . j e n associated with a given input sentence e, we want to find some LM M from a set L of LMs such that: M i = arg min m\u2208L P P (j e i | m), where P P (j | m) is the perplexity of j under m. Now assume M 1 . . . M n are such LMs for j e 1 . . . j e n . Then we pick up an M with the largest frequency and plug it into \u03b8 such as FLM. 8 Suppose, for instance, that M a , M b , M a and M c are lowest perplexity LMs found for translations j e 1 ,j e 2 ,j e 3 and j e 4 , respectively. Then we choose M a as an LM most voted for, because it gets two votes from j e 1 and j e 3 , meaning that M a is nominated as an LM with lowest perplexity by j e 1 and j e 3 , while M b and M c each collect only one vote. In case of ties, we randomly choose one of the LMs with the largest count of votes. Experiment Setup and Procedure Let us describe the setup of experiments we have conducted. The goal here is to learn how the Vby-M affects the overall MEMT performance. For test sets, we carry over those from the perplexity experiments (see Footnote 6, Section 4), which are derived from CPC, EJP, and PAT. (Call them tCPC, tEJP, and tPAT hereafter.) In experiments, we begin by splitting a test set into equal-sized blocks, each containing 500 sentences for tEJP and tCPC, and 100 abstracts (approximately 200 sentences) for tPAT. 9 We had the total of 15 blocks for tCPC and tEJP, and 46 blocks for tPAT. We leave one for evaluation and use the rest for training alignment models, i.e., Q(e | j), SV regressors and some inside-data LMs. (Again we took care not to inadvertently train LMs on test sets.) We send a test block to OTSs Ai, Lo, At, and Ib, for translation and combine their outputs using the V-by-M scheme, which may or may not be coupled with regression SVMs. Recall that the MEMT operates on a sentence by sentence basis. So what happens here is that for each of the sentences in a block, the MEMT works the four MT systems to get translations and picks one that produces the best score under \u03b8. We evaluate the MEMT performance by running HFA and BLEU on MEMT selected translations block by block, 10 and giving average performance over the blocks. Table 1 provides algorithmic details on how the MEMT actually operates. 8 It is worth noting that the voted language model readily lends itself to a mixture model: P (j) = P m\u2208M \u03bbmP (j | m) where \u03bbm = 1 if m is most voted for and 0 otherwise. 9 tCPC had the average of 15,478 words per block, whereas tEJP had about 11,964 words on the average in each block. With tPAT, however, the average per block word length grew to 16,150. 10 We evaluate performance by block, because of some reports in the MT literature that warn that BLEU behaves erratically on a small set of sentences (Reeder and White, 2003). See also Section 3 and Footnote 2 for the relevant discussion. Results and Discussion Now let us see what we found from the experiments. We ran the MEMT on a test set with (r)FLM or (r)ALM embedded in it. Recall that our goal here is to find how the V-by-M affects performance of MEMT on tCPC, tEJP, and tPAT. First, we look at whether the V-by-M affects in any way, the HFA of the MEMT, and if it does, then how much. Table 2 and Table 3 give summaries of results on HFA versus V-by-M. Table 2 shows how things are with V-by-M on, and Table 3 shows what happens to HFA when we turn off V-by-M, that is, when we randomly choose an LM from the same set that the V-by-M chooses from. The results indicate a clear drop in performance of FLM \u03c8 and ALM \u03c8 when one chooses an LM randomly. 11 Curiously, however, rFLM \u03c8 and rALM \u03c8 are affected less. They remain roughly at the same level of HFA over Table 2 and Table 3 . What this means 11 Another interesting question to ask at this point is, how does one huge LM trained across domains compare to the Vby-M here? By definition of perplexity, the increase in size of the training data leads to an increase in perplexity of the LM. So if general observations in Fig. 1 hold, then we would expect the \"one-huge-LM\" approach to perform poorly compared to the V-by-M, which is indeed demonstrated by the following results. HFLM \u03c8 below denotes a FLM \u03c8 based on a composite LM trained over CPC, LIT, PAT, NIKMAI, and EJP. The testing procedure is same as that described in Sec.6 Model tCPC tEJP tPAT avg. HFLM \u03c8 (HFA) 0.4182 0.4081 0.6927 0.5063 HFLM \u03c8 (BLEU) 0.1710 0.2619 0.1874 0.2067 is that there is some discrepancy in the effectiveness of V-by-M between the fluency based and regression based models. We have no explanation for the cause of the discrepancy at this time, though we may suspect that in learning, as long as there is some pattern to exploit in m-precision and the probability estimates of test sentences, how accurate those estimates are may not matter much. Table 4 and Table 5 give results in BLEU. 12 The results tend to replicate what we found with HFA. rFLM \u03c8 and rALM \u03c8 keep the edge over FLM \u03c8 and ALM \u03c8 whether or not V-by-M is brought into action. The differences in performance between rFLM \u03c8 and rALM \u03c8 with or without the V-by-M scheme are rather negligible. However, if we turn to FLM \u03c8 and ALM \u03c8 , the effects of the V-by-M are clearly visible. FLM \u03c8 scores 0.2107 when coupled with the V-by-M. However, when disengaged, the score slips to 0.1946. The same holds for ALM \u03c8 . First, let us look at Table 6 and compare it to Table 2. A good news is that most of the OTS systems do not even come close to the MEMT models. At, a best performing OTS system, gets 0.4643 on the average, which is about 20% less than that scored by rFLM \u03c8 . Turning to BLEU, we find again in Table 7 that a best performing system among the OTSs, i.e., Ai, is outperformed by FLM \u03c8 , ALM \u03c8 and all their varieties (Table 4 ). Also something of note here is that on tPAT, (r)FLM \u03c8 and (r)ALM \u03c8 in Table 4 , which operate by the V-by-M scheme, score somewhere from 0.1907 to 0.1954 in BLEU, coming close to OPM, which scores 0.1995 on tPAT (Table 7 ). It is interesting to note, incidentally, that there is some discrepancy between BLEU and HFA in performance of the OTSs: A top performing OTS in To return to the discussion of (r)FLM \u03c8 and (r)ALM \u03c8 , an obvious fact about their behavior is that regressor based systems rFLM \u03c8 and rALM \u03c8 , whether V-by-M enabled or not, surpass in performance their less sophisticated counterparts (see 3,5 ). Regression allows the MEMT models to correct themselves for some domain-specific bias of the OTS systems. But the downside of using regression to capitalize on their bias is that you may need to be careful about data you train a regressor on. Here is what we mean. We ran experiments using SVM regressors trained on a set of data randomly sampled from tCPC, tEJP, and tPAT. (In contrast, rFLM \u03c8 and rALM \u03c8 in earlier experiments had a regressor trained separately on each data set.) They all operated in the V-by-M mode. The results are shown in Table 8 and Table 9 . What we find there is that with regressors trained on perturbed data, both rFLM \u03c8 and rALM \u03c8 are not performing as well as before; in fact they even fall behind FLM \u03c8 and ALM \u03c8 in HFA and their performance in BLEU turns out to be just about as good as FLM \u03c8 and ALM \u03c8 . So regression may backfire when trained on wrong data. Conclusion Let us summarize what we have done and learned from the work. We started with a finding that the choice of language model could affect performance of MEMT models of which it is part. The V-by-M was introduced as a way of responding to the problem of how to choose among LMs so that we get the best MEMT. We have shown that the V-by-M scheme is indeed up to the task, predicting a right LM most of the time. Also worth mentioning is that the MEMT models here, when coupled with V-by-M, are all found to surpass component OTS systems by a respectable margin (cf., Tables 4, 7 for BLEU, 2, 6 for HFA). Regressive MEMTs such as rFLM \u03c8 and rALM \u03c8 , are found to be not affected as much by the choice of LM as their non-regressive counterparts. We suspect this happens because they have access to extra information on the quality of translation derived from human judgments or translations, which may cloud effects of LMs on them. But we also pointed out that regressive models work well only when they are trained on right data; if you train them across different sources of varying genres, they could fail. An interesting question that remains to be addressed is how we might deal with translations from a novel domain. One possible approach would be to use a dynamic language model which adapts itself for a new domain by re-training itself on data sampled from the Web (Berger and Miller, 1998). Appendix A Language Models Table 10 lists language models used in the voting based MEMTs discussed in the paper. They are more or less arbitrarily built from parts of the copora CPC, EJP, NIKMAI, EJP, and LIT. 'Train size' indicates the number of sentences, given in kilo, in a corpus on which a particular model is trained. Under 'Voc(abulary)' is listed the number of type words for each LM (also given in kilo). Notice the difference in the way the train set and vocabulary are measured. 'Genre' indicates the genre of a trainig data used for a given LM: PAT stands for patents (from PAT), LIT literary texts (from LIT), NWS news articles (from CPC and NIKMAI), and BIZ business related texts (from EJP).",
    "abstract": "The paper describes a particular approach to multiengine machine translation (MEMT), where we make use of voted language models to selectively combine translation outputs from multiple off-theshelf MT systems. Experiments are done using large corpora from three distinct domains. The study found that the use of voted language models leads to an improved performance of MEMT systems.",
    "countries": [
        "Japan"
    ],
    "languages": [
        "Japanese",
        "English"
    ],
    "numcitedby": "52",
    "year": "2004",
    "month": "July",
    "title": "Multi-Engine Machine Translation with Voted Language Model"
}