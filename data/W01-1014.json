{
    "article": "In interpreting multilingual queries to databases whose domain information is described in a particular language, we must address the problem of word sense disambiguation. Since full-fledged semantic classification information is difficult to construct either automatically or manually for this purpose, we propose to disambiguate the senses of the source lexical items by automatically augmenting a simple translation dictionary with database terminologies and describe an implemented multilingual query interpretation system in a combinatory categorial grammar framework. 1 Introduction In interpreting multilingual queries to databases with domain information such as objects, table names, and attribute names that are described in a particular language, we must address the problem of word sense disambiguation. For example, if we wish to interpret a query in English to a database with domain information described in Korean, lexical items in English must be disambiguated to the matching senses in Korean. This problem is similar to that of lexical selection in machine translation domain (Lee et al.,   1 This work was supported by the Korea Science and Engineering Foundation (KOSEF) through AITrc. Palmer et al., 1999) , except that the target is different in the sense that one is a formal query language and the other is another natural language. This difference prompts us to make use of database information, such as domain database objects, table names, and attribute names, instead of the general semantic classifications (Palmer et al., 1999) for disambiguating the senses of lexical items in the query. Example queries are shown below: (1) (a) Which shoes does Mary buy? (b) Who wears a brown coat? (c) Who wears old shoes and buys an old car? Query 1a shows a query made up of unambiguous words having a unique target interpretation. But in 1b, wears may have several interpretations in Korean such as 'ip-ta', 'ssu-ta', 'sin-ta', and 'tti-ta' (cf. Table 3 ). And old in query 1c also contains several senses 2 . If we assume a simple database made up of tables such as 'ip-ta' (to put on the body), 'sin-ta' (to put on the foot), and 'sa-ta' (buy) in Table 1 , wears in 1b can be disambiguated by a lexical item 'coat' and its target 'oy-twu', since 'oy-twu' only appears in the table as related to 'ip-ta'. And wears in 1c is also restricted by 'shoes', but 'shoes' appears in the table as related to 'sin-ta' and 'sa-ta'. As shown, these senses can be disambiguated with the translation dictionary. Since 'sa-ta', or 'buy', is not registered in the translation dictionary, it is simply discarded. old in a query 1c can be interpreted into 'nalk-ta' (not new) and 'nulk-ta' (not young) because it appears in the same table entries for 'sa-ta'. Since it is difficult to disambiguate the senses only with database information, we may utilize co-occurrence information between the collocated words such as (old,shoes) and (old,car) (Park and Cho, 2000; Lee et al., 1999) . In this paper, we propose a disambiguation method with the database information and cooccurrence information (Park and Cho, 2000; Palmer et al., 1999) for the interpretation of natural language queries (Lee and Park, 2001) in multilingual query interpretation. Although we propose to construct the system without an intermediate representation language, we show that our Combinatory Categorial Grammar (CCG) framework is compatible with the approaches with an intermediate representation (Nelken and Francez, 2000; Androutsopoulos et al., 1998; Klein et al., 1998) . We also discuss the advantages and disadvantages of these two approaches. The rest of the paper is organized as follows. A brief introduction to CCGs and natural language database interfaces (NLDBs) will be shown in Section 2. We show the translation process with and without an intermediate representation using CCG in Section 3. The proposed system with multilingual translation is described in Sections 4 and 5. Related Work In this paper, we propose to interpret natural language queries in English and Korean with CCGs and argue that word selection problem must be resolved for multilingual query interpretation. Rule Rule Name (Symbol) F/W Application ( ) \u00d2 B/W Application ( ) \u00d3\u00d2 Coordination ( \u00d2 ) F/W Composition ( ) \u00d2 \u00d2 \u00d2 B/W Composition ( ) \u00d2 \u00d2 F/W Crossed Comp. ( \u00dc) \u00cc \u00b4\u00cc \u00d2 \u00b5 F/W Type Raising ( \u00cc ) \u00cc \u00d2\u00b4\u00cc \u00b5 B/W Type Raising ( \u00cc ) Table 2 : CCG Rules for Korean Combinatory Categorial Grammar Combinatory Categorial Grammars (CCGs) are combinatory extensions to the categorial grammars (Steedman, 2000) . CCGs are among the lexicalized grammars, such as linear indexed grammars and tree adjoining grammars, and are generally known to provide a wide linguistic coverage and a way of processing sentences incrementally. Table 2 shows the CCG reduction rules proposed for Korean (Park and Cho, 2000) . (Steedman, 2000) suggested the reduction rules for English which include backward crossed composition and backward substitution. We adopt this rule set for the processing of the queries in English. (2 ) \u00cf \u00d3 \u00db \u00d6\u00d7 \u00d3\u00d0 \u00d7 \u00d3 \u00d7 \u00d2\u00d4 \u00b4\u00d7\u00d2\u00d2\u00d4\u00b5 \u00d2\u00d4 \u00d2\u00d4 \u00d2\u00d4 \u00d2\u00d4 \u00d2\u00d4 \u00d7\u00d2\u00d2\u00d4 \u00d7 Example 2 shows a syntactic derivation for an example query using CCG. Transitive verbs like 'wears' are assigned the category (s\u00d2np)/np, which receives a phrase of category np on its right (the second np and the directionality is indicated by the slash /, that is, to the right) and then receives another np on its left (the first np and the directionality is indicated by the backslash \u00d2, that is, to the left), to give rise to the phrase of category s. Such a computation is done by simple function application. Example 3 shows the CCG derivation for a query with coordination. ( ) \u00cf \u00d3 \u00db \u00d6\u00d7 \u00d3\u00d0 \u00d7 \u00d3 \u00d7 \u00d2 \u00d6\u00d3\u00db\u00d2 \u00d3 \u00d8 \u00d2\u00d4 \u00b4\u00d7\u00d2\u00d2\u00d4\u00b5 \u00d2\u00d4 \u00d2\u00d4 \u00d3\u00d2 \u00d2\u00d4 \u00a8\u00d2 \u00d2\u00d4 \u00d7\u00d2\u00d2\u00d4 \u00d7 3 In addition to function application utilized in examples 2 and 3, CCGs use rules for a limited set of combinators such as B (function composition), T (type raising), and S (function substitution) to model natural language. The reader is referred to (Steedman, 2000) for further details. Multilingual Database Interfaces There have been many proposals for NLDBs since the 1960's 3 . In this section, we review some of the more recent ones. (Androutsopoulos et al., 1998; Nelken and Francez, 2000) focus on queries in English with temporal expressions, with a specialized semantic representation language that can handle temporality. Examples are shown below. (4) (a) Did any flight circle while runway 2 was open? (b) Which companies serviced BA737 in 1990? (c) During which years did Mary work in marketing? The system in (Klein et al., 1998) interprets noun phrase queries such as 5 in German: (5) Ersatzzeiten wegen Kindererziehung (Exemption times because of child raising) While the system can analyze noun phrases with various adverbial phrases, it is not reported to handle more complex noun phrase queries such as those with subordinate or coordinate constructions. None of these work deals with multilingual issues. Nor is there much related work in the field of NLDBs. (Thompson and Mooney, 1999) presents a system that automatically constructs the lexicon for NLDBs, in various languages such as English, Spanish, Japanese, and Turkish, which represents the lexical entries with a pair of the phrases and the corresponding semantic representation in first-order logic. Since the semantic representation for lexical items is determined using the frequency of the general terms of the semantic representation in the corpus made up of the query sentences annotated by their logical representation, the system makes it difficult to incorporate various linguistic considerations on natural language. Translation with CCG In this section, we discuss the translation with and without an intermediate language. The translation based on CCG can derive the target database language expressions/queries such as SQL, TSQL, and QUBE, as well as expressions in intermediate representation languages. We show the translation into both languages with examples (Nelken and Francez, 2000) . Indirect vs. Direct Translation Most NLDBs use an intermediate representation which does not make use of expressions that correspond directly to real database objects. The intermediate representations are usually notated as logic expressions such as a quasi-logical form (Klein et al., 1998) and a customized language (Androutsopoulos et al., 1998; Nelken and Francez, 2000) . These representations provide a way to translate indirectly to the target database languages. For example, query 6a is translated into 6b with the intermediate representation \u00c4 \u00d0\u00d0 \u00d2 (Nelken and Francez, 1999; Toman, 1996) , and into 6c with the SQL/Temporal expressions (Nelken and Francez, 2000) . (6) (a) During which years did Mary work in marketing? The translation using an intermediate representation has several advantages, including (a) the availability of an independent linguistic frontend, (b) the separation of domain dependent knowledge from the system engine, and (c) the relative easiness of augmenting the system with an extra inference module for disambiguation (cf. Androutsopoulos et al., 1995) . (b) \u00dd \u00d6\u00b4\u00c1 \u00b5 \u00c2 \u00b4\u00db\u00d3 \u00d6 \u00b4\u00d1 \u00d6\u00dd \u00d1 \u00d6 \u00d8 \u00d2 \u00c2 \u00b5 \u00c2 \u00d4 \u00d7\u00d8 \u00c2 \u00c1 (c) The points (a) and (b) indicate the separation of domain-dependent resources such as lexicon, database mapping information, and other knowledge bases. (c) arises from the modularity of the translation process. When we use an intermediate language, we do not need to concern ourselves with the syntactic details of the target query language during the mapping process, so that we can pay more attention to the differences in syntax between the two source languages (i.e. English and Korean), making the resulting interpretation more reliable. In addition, the use of an intermediate language gives rise to a more flexible query interpretation system as the queries can be translated into multiple target query languages without further processing at the stage of the source query interpretation. However, the use of the same intermediate language for source query languages such as English and Korean that are known to have very different linguistic characteristics makes it difficult to capture subtle differences between the queries of the different source languages unless the intermediate language is quite expressive. And much of the expressiveness of the intermediate language for the translation of the queries in one language may not be what is needed in the translation of the queries in the other. \u00d9\u00d6 \u00d2 \u00db \u00dd \u00d6 \u00d1 \u00d6\u00dd \u00db\u00d3\u00d6 \u00d2 \u00d1 \u00d6 \u00d8 \u00d2 \u00b4\u00d7 \u00d7\u00b5 \u00d2\u00d4 \u00d2\u00d4 \u00dd \u00d6\u00b4\u00c1\u00b5 \u00d7 \u00d7 \u00d2\u00d4 \u00d1 \u00d6\u00dd \u00bc \u00d7\u00d2\u00d2\u00d4 \u00b4\u00d7\u00d2\u00d2\u00d4\u00b5\u00d2\u00b4\u00d7\u00d2\u00d2\u00d4\u00b5 \u00b4\u00dc \u00c1\u00b5 \u00b4\u00dd \u00c2\u00b5 \u00dc \u00dd \u00c2 \u00c1 \u00b4\u00dc \u00c2\u00b5 \u00dc \u00c2 \u00d4 \u00d7\u00d8 \u00dc \u00dd \u00c2\u00db\u00d3\u00d6 \u00b4\u00dc \u00dd \u00c2\u00b5 \u00d1 \u00d6 \u00d8 \u00d2 \u00bc \u00d7 \u00d7 \u00b4\u00dd \u00c2\u00b5 \u00dd \u00d6\u00b4\u00c1\u00b5 \u00dd \u00c2 \u00c1 \u00d7\u00d2\u00d2\u00d4 \u00dd \u00c2 \u00db \u00d3 \u00d6 \u00b4\u00dd \u00d1 \u00d6 \u00d8 \u00d2 \u00bc \u00c2 \u00b5 \u00d7 \u00c2\u00db\u00d3\u00d6 \u00b4\u00d1 \u00d6\u00dd \u00bc \u00d1 \u00d6 \u00d8 \u00d2 \u00bc \u00c2 \u00b5 \u00d7 \u00c2\u00db\u00d3\u00d6 \u00b4\u00d1 \u00d6\u00dd \u00bc \u00d1 \u00d6 \u00d8 \u00d2 \u00c2\u00b5 \u00c2 \u00d4 \u00d7\u00d8 \u00d7 \u00dd \u00d6\u00b4\u00c1\u00b5 \u00c2\u00db\u00d3\u00d6 \u00b4\u00d1 \u00d6\u00dd \u00bc \u00d1 \u00d6 \u00d8 \u00d2 \u00c2\u00b5 \u00c2 \u00d4 \u00d7\u00d8 \u00c2 \u00c1 The translation without an intermediate representation has a simpler and more straightforward process. And there is no extra effort on development of a formal intermediate representation which is difficult to ensure the full coverage on linguistic expressiveness and the soundness of the proposed formalism. Nevertheless, the three points mentioned above are thought to be difficult to overcome in this approach. However, the points (a) and (b) can be equally achieved by separating domain-dependent elements from the query processing module using lexicalized grammars such as CCG. In this case, the construction of a domain-dependent lexicon can be a problem, but it can be resolved to some extent with an automatic construction method. The point (c) is difficult to address, since the translation without an intermediate representation usually is done in a single module. The inference module, however, can be complemented by disambiguation using co-occurrence information (Park and Cho, 2000) and disambiguation of domaindependent word senses with consideration for the context-dependent information such as information structure (Steedman, 2000) . (Nelken and Francez, 2000) use an intermediate representation because the compositional construction of formulae during parsing becomes easier. However, we show that database queries can be interpreted compositionally during parsing without such an intermediate representation through direct translation. Translation to an Intermediate Representation While our approach does not make use of an intermediate representation, the CCG framework itself allows queries to be interpreted into an intermediate representation. Figure 1 shows the translation process from the query 6a to the form 6b which is in \u00c4 \u00d0\u00d0 \u00d2 . Since we are only showing the possibility of translation, we use an example from (Nelken and Francez, 2000) . In Figure 1 , we slightly modified the semantics in (Nelken and Francez, 2000; Nelken and Francez, 1999) for the convenience of translation. And for the same reason, we devised the operator \u00b4\u00dc \u00c1\u00b5 where \u00dc is an argument and \u00c1 represents a time interval variable. Translation to a Target Language Figure 2 shows the translation process from the query 6a to SQL/Temporal expression 6c, also indicating the need for post-processing. For in- Multilingual Translation Source word disambiguation is an important problem in both of the approaches mentioned in the previous section because the problem of lexical selection arises equally. We propose a method to translate and disambiguate the source queries to the appropriate target database information in a direct translation approach. Word Sense Disambiguation and Target Mapping Our method to disambiguate the source queries is based on the semantic features of the lexical items. In lexical selection methods using the semantic features and their syntactic relations (Palmer et al., 1999; Copestake and Sanfilippo, 1993) , the lexicon is designed with semantic type-features constructed from the semantic classifications of a language for the collocated verb-object and modifier-modifiee relations. We also consider these two syntactic relations, but we do not adopt the general semantic classifications that are hard to construct automatically. For this, we would need the additional mapping information to the domain databases. So we designed a method with the database information which can play the role of semantic classifications in the restricted database domain. In query 1b, the meaning of 'wears' is 'to put on the body', but in 1c, its meaning is 'to put on the foot'. The meaning of 'old' in 1c is 'not new', but that in the phrase 'the oldest man' is 'not young'. Table 3 shows word senses and their candidate target words of 'wears' and 'old' (Lee et al., 1999) . We can disambiguate the senses of 'wears' with information in the database, like the sample database shown in Table 1 , annotated in the lexical entries. But 'old' in 1c cannot be disambiguated with the database information alone because the values of the 'old' can occur in the same table attributes as shown in the sample database (Table 1 ). For this problem, we can think of two disambiguation methods. \u00afUse of additional semantic type-features based on the semantic classifications \u00afUse of co-occurrence information between the collocated words In the first method, the source queries are disambiguated during parsing, but this method requires the semantic classification information. And the semantic features from the classifications generate many lexical entries, since all the senses for a given lexical item have to be accounted for. As a result, we can expect that the increase in the number of lexical entries may also cause the increase in the loss of both the space and processing time of the system. The second method needs co-occurrence information, but no additional lexical entries. And this method also requires an additional disambiguation process after the parsing to extract information on the collocated words. However, since co-occurrence information between the words can be automatically extracted from a general-purpose corpus, the construction of this information is thought to be relatively straightforward, compared to the construction of the semantic classifications. (Park and Cho, 2000; Lee et al., 1999) proposed to use the co-occurrence information during parsing and lexical selection. For example, in 1c, 'wears' is disambiguated into 'sin-ta' for the semantics of 'shoes' and the collocated words 'old' and 'shoes' is extracted during the parsing. Then the disambiguation module selects the preferred sense of 'old' through the computation of the similarity for the co-occurrence information. As a result, 'old' is correctly disambiguated into the target 'nalk-ta'. Representation of Lexical Entry In a CCG framework, all the levels of information, such as syntax, semantics, and discourse, are integrated into the categorial lexicon as lexical entries. The following shows example lexical entries of a CCG for English. (7) (a) lex(coat,np:[ ,' \u00b0 ',body='ae \u00b0 ']; ).   The lexical entry consists of a lexical item and its CCG category. The CCG category is a pair of the syntactic and semantic information that are interwoven in the following way. Elementary CCG (syntactic) categories include \u00d2\u00d4 and \u00d7, and CCG categories are recursively defined as either or \u00d2 , where and are also CCG categories, including elementary categories. Each elementary CCG (syntactic) category is augmented with an appropriate semantic information and word disambiguation information so that the resulting form is a CCG category (Steedman, 1996) . In our proposal, the semantic information is replaced with a suitable fragment of SQL, with slots corresponding to shows other 'coat' instances in the database table ' ' (sa-ta, meaning 'buy'). In entries 7c and 7d, the verb 'wears' and the adjective 'old' are taken to add information in form of and for the disambiguation of their senses. provides a template for co-occurrence information. Translation Process Figure 3 shows a derivation of the query 1c and a relevant portion of the translation dictionary. This derivation does not show the binding with SQL syntax. In the final step of the derivation, the syntactic information is combined by a backward application with the category sql:[SELECT A,FROM B,WHERE C]\u00d2s:[A,B,C]; . And the exhibited portion of the translation dictionary shows the list of pairs of a word and its target word. Using this information, after the derivation in Figure 3 , semantic checking is performed with the tagged information, that is, 'wear@ipta'. This tagging is compared with the translation dictionary for the correct sense disambiguation. Through this process, the results that have a matching pair in the translation dictionary are confirmed as the desired result, and the others are discarded. Because the result in Figure 3 In response to the SQL statement 8, the answer 'Mary' is produced from Table 1 . Construction of the Lexicon from Available Resources We construct an English lexicon for the multilingual query from several linguistic resources such as an English lexicon with only POS information, a Korean lexicon for the mapping information and an English-Korean translation dictionary. In our system, the English-Korean translation dictionary is needed in two processes. The first is the process of adding word sense information to the lexical items in English and the second is the process of checking for the senses of the given source word. The Korean lexicon is used for the mapping into the database and the English lexicon with POS tag is used for extracting syntactic categories and syntactic relations between the words. Figure 4 shows the needed information resources for the English and Korean lexicons. The Korean lexicon is constructed by a tool in a semi-automatic manner (Lee and Park, 2001) . The lexicon construction tool constructs the Korean lexicon using information from a general-purpose corpus and domain specific database information. CCG Parser Results Generation Query Results Query Sentence (English/Korean) Database Query Results Engine-DB Interaction Module Word Translation Checking Co-occurrence Information English-Korean Dic. Lexicon Implementation Figure 5 shows the structure of the engine that processes multilingual queries. The database is on the home appliance domain in e-commerce. It contains objects for appliance information such as category, name, maker, price, size, other features and so forth. We have populated the database with information from Korean shopping mall websites. Two queries are shown below: (9) (a) Who makes a flat-screen TV set? The query processing engine is implemented on the UNIX using SICStus Prolog. The word translation checking module performs disambiguation using the English-Korean dictionary (cf. Figure 3 ) and co-occurrence information. The Korean lexicon contains about a million number of lexical entries, but the English lexicon is comparatively much smaller, and still under construction. The system can process diverse linguistic expressions in English such as coordination, unbounded dependencies, and gapping etc. The system can also process diverse expressions in Korean including subject ellipsis, noun phrases, numerical expressions, coordination, and subordination where the performance of the system for the queries in Korean is reported in (Lee and Park, 2001) . Conclusion In the paper, we proposed a method to disambiguate the source lexical items of queries with database information such as the objects, table names and attribute names. Since information about the interpreted candidates and the collocated words is extracted during parsing, the implemented query interpretation system can extract the results in a straightforward manner. Since full-fledged semantic classification information is difficult to construct either automatically or manually in a reliable manner, we proposed to dispense with it and instead to utilize information that can be extracted automatically from the available resources such as the database information, a simple translation dictionary and other linguistic resources.",
    "abstract": "In interpreting multilingual queries to databases whose domain information is described in a particular language, we must address the problem of word sense disambiguation. Since full-fledged semantic classification information is difficult to construct either automatically or manually for this purpose, we propose to disambiguate the senses of the source lexical items by automatically augmenting a simple translation dictionary with database terminologies and describe an implemented multilingual query interpretation system in a combinatory categorial grammar framework. 1",
    "countries": [
        "South Korea"
    ],
    "languages": [
        "English",
        "Korean"
    ],
    "numcitedby": "3",
    "year": "2001",
    "month": "",
    "title": "Automatic Augmentation of Translation Dictionary with Database Terminologies In Multilingual Query Interpretation"
}