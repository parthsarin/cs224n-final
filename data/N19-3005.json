{
    "article": "In this paper, we address the problem of effectively self-training neural networks in a lowresource setting. Self-training is frequently used to automatically increase the amount of training data. However, in a low-resource scenario, it is less effective due to unreliable annotations created using self-labeling of unlabeled data. We propose to combine self-training with noise handling on the self-labeled data. Directly estimating noise on the combined clean training set and self-labeled data can lead to corruption of the clean data and hence, performs worse. Thus, we propose the Clean and Noisy Label Neural Network which trains on clean and noisy self-labeled data simultaneously by explicitly modelling clean and noisy labels separately. In our experiments on Chunking and NER, this approach performs more robustly than the baselines. Complementary to this explicit approach, noise can also be handled implicitly with the help of an auxiliary learning task. To such a complementary approach, our method is more beneficial than other baseline methods and together provides the best performance overall. Introduction For many low-resource languages or domains, only small amounts of labeled data exist. Raw or unlabeled data, on the other hand, is usually available even in these scenarios. Automatic annotation or distant supervision techniques are an option to obtain labels for this raw data, but they often require additional external resources like humangenerated lexica which might not be available in a low-resource context. Self-training is a popular technique to automatically label additional text. There, a classifier is trained on a small amount of labeled data and then used to obtain labels for unlabeled instances. However, this can lead to unreliable or noisy labels on the additional data which impede the learning process (Pechenizkiy et al., 2006; Nettleton et al., 2010) . In this paper, we focus on overcoming this slowdown of self-training. Hence, we propose to apply noisereduction techniques during self-training to clean the self-labeled data and learn effectively in a lowresource scenario. Inspired by the improvements shown by the Noisy Label Neural Network (NLNN, Bekker and Goldberger (2016) ), we can directly apply NLNN to the combined set of the existing clean data and the noisy self-labeled data. However, such an application can be detrimental to the learning process (Section 6). Thus, we introduce the Clean and Noisy Label Neural Network (CNLNN) that treats the clean and noisy data separately while training on them simultaneously (Section 3). This approach leads to two advantages over NLNN (Section 6 and 7) when evaluating on two sequence-labeling tasks, Chunking and Named Entity Recognition. Firstly, when adding noisy data, CNLNN is robust showing consistent improvements over the regular neural network, whereas NLNN can lead to degradation in performance. Secondly, when combining with an indirect-noise handling technique, i.e. with an auxiliary target in a multi-task fashion, CNLNN complements better than NLNN in the multi-task setup and overall leads to the best performance. Related Work Self-training has been applied to various NLP tasks, e.g. Steedman et al. (2003) and Sagae and Tsujii (2007) . While McClosky et al. (2006) are able to leverage self-training for parsing, Charniak (1997) and Clark et al. (2003) obtain only minimal improvements at best on parsing and POS-tagging respectively. In some cases, the results even deteriorate. Other successful approaches of automatically labeling data include using a different classifier trained on out-of-domain data (Petrov et al., 2010) or leveraging external knowledge (Dembowski et al., 2017) . A detailed review of learning in the presence of noisy labels is given in (Fr\u00e9nay and Verleysen, 2014) . Recently, several approaches have been proposed for modeling the noise using a confusion matrix in a neural network context. Many works assume that all the data is noisy-labeled (Bekker and Goldberger, 2016; Goldberger and Ben-Reuven, 2017; Sukhbaatar et al., 2015) . Hedderich and Klakow (2018) and Hendrycks et al. (2018) propose a setting where a mix of clean and unlabeled data is used. However, they require external knowledge sources for labeling the data or evaluate on synthetic noise. Alternatively, instances with incorrect labels might be filtered out, e.g. in the work by Guan et al. (2011) or Han et al. (2018) , but this involves the risk of also filtering out difficult but correct instances. Another orthogonal approach is the use of noise-robust loss functions (Zhang and Sabuncu, 2018) . Clean and Noisy Label Neural Network The Noisy Label Neural Network (NLNN, Bekker and Goldberger (2016) ) assumes that all observed labels in the training set pass through a noise channel flipping some of them from a correct to an incorrect label (see left part of Figure 1 ). In our scenario, this means that both the humanannotated and the additional automatically-labeled (self-training) corpora are assumed to be noisy. In our experiments (Section 6 and 7), treating both corpora in this fashion degrades the overall performance. To remedy this effect, we propose to treat the human-annotated data as clean data and the self-training data as noisy. We assume a similar setup as Bekker and Goldberger ( 2016 ), training a multi-class neural network soft-max classifier p(y = i|x; w) = exp(u T i h) k j=1 exp(u T j h) where x is the feature vector, y is the label, w denotes the network weights, k is the number of possible labels, u are soft-max weights and h = h(x) denotes the multi-layer neural network applied to x. In contrast to Bekker and Goldberger (2016) , we assume that not all of the training data passes We define the probability of observing a label z, which can either be noisy or clean and is, thus, dependent on the label's membership to C or N : p(z j|x, w, \u03b8) \uf8f1 \uf8f2 \uf8f3 k i 1 p(z j|y i; \u03b8)p(y i|x; w) if z \u2208 N p(y j|x; w) if z \u2208 C i.e. z y Using this probability function and t to index training instances, the log-likelihood of the model parameters is defined as L(w, \u03b8) = z t \u2208C log p(zt|xt, w) + z t \u2208N log( k i 1 (p(zt|yt i; \u03b8) \u2022 p(yt i|xt; w)) As in Bekker and Goldberger (2016) the model parameters are computed using Expectation Maximization. In the E-step, \u03b8 and w are fixed and an estimate c of the true labels y is obtained for the noisy labels z: cti p(yt i|xt, zt; w, \u03b8) p(zt|yt i, \u03b8)p(yt i|xt; w) j p(zt|yt j; \u03b8)p(yt j|xt, w) for zt \u2208 N Note that the estimate c is calculated only for the noisy labels whereas the clean labels remain unchanged. Similarly, the noise distribution \u03b8 is calculated only for the noisy labels. The initialization of \u03b8 and the \u03b8's update step in M-step remain the same as in Bekker and Goldberger (2016) shown below. \u03b8(i, j) = t cti1 {z t =j} t cti i, j \u2208 {1, ..., k}, zt \u2208 N During the M-step, the neural network weights w are estimated as well. The loss function, however, changes compared to the original approach (Bekker and Goldberger, 2016) to (1) and thus, changing the calculation of the gradient to (2): S(w) = z t \u2208C log p(zt|xt, w)+ z t \u2208N k i 1 cti log p(yt i|xt; w) (1) \u2202S \u2202ui z t \u2208C (1 {z t i} \u2212 p(zt|xt, w))h(xt) + z t \u2208N (cti \u2212 p(yt|xt, w))h(xt) (2) Interestingly, the gradient calculation (2) is a summation of two parts: one to learn from the clean labels and another to learn from the noisy labels. We refer to this model as the Clean and Noisy Label Neural Network (CNLNN). Training with Noisy Labels in a Multi-Task Setup NLNN and CNLNN form explicit ways of handling noise as the noise distribution is calculated during training. In contrast, we can apply a Deep Multi-Task Learning (MTL) approach (S\u00f8gaard and Goldberg, 2016) , which, unlike NLNN and CNLNN, does not estimate the noise directly and thus, is an implicit noise-cleaning approach. The MTL method leverages an auxiliary task that augments the data providing other reliable labels and hence, ignoring noisy labels (Ruder, 2017) . In our experiments, we combine the implicit noise handling of Deep MTL with the explicit noise han-dling of NLNN and CNLNN to complement each other and obtain a more powerful noise handling model than the individual models. Schematic depiction of combining MTL and CNLNN is shown in Figure 1 . MTL and NLNN can also be combined in a similar way. Experimental Setup We evaluate CNLNN and other methods on a Chunking and a Named Entity Recognition (NER) task with F 1 -score as the metric in each case. For Chunking, we use the same data splits as (S\u00f8gaard and Goldberg, 2016) based on the English Penn Treebank dataset (Marcus et al., 1993) . For NER, the data splits of the English CoNLL 2003 task are used (Sang and Buchholz, 2000) . Note that in our NER setup, we evaluate using BIO-2 labels, so F 1scores reported below might not be comparable to prior work. To mimic a low resource setting, we limit each training set to the first 10k tokens. The development sets are randomly chosen sentences from the original training set restricted to 1k tokens. The test sets remain unchanged. For the rest of the training data, the original labels are removed and the words are automatically labeled using the baseline model (NN described below). We add variable amounts of this automatically-annotated data for self-training in our experiments. Models We apply the following models to the above two tasks: NN (the simple baseline) is an architecture with bidirectional LSTMs (Hochreiter and Schmidhuber, 1997) . For Chunking, we use three LSTM layers, for NER five. The NN model, only trained on the clean data, is used for automatically labeling the raw data (obtaining the noisy data). NLNN combines the NN with the original noise channel (Bekker and Goldberger, 2016) , training it both on clean and noisy instances. CNLNN is our new approach of modeling noise, treating clean and noisy labels separately (section 3). In contrast to the explicit noise handling of NLNN and CNLNN, we also apply MTL for implicit noise handling. Here, we use NN as the base architecture and POS-tagging as an auxiliary task. We hypothesise that this low-level task helps the model to generalise its representation and that the POS-tags are helpful because e.g. many named entities are proper nouns. The auxiliary task is trained jointly with the first LSTM layer of NN for Chunking and with the second LSTM layer for NER. In our low-resource setting, we use the first 10k tokens of section 0 of Penn Treebank for the auxiliary POS-tagging task for the MTL (S\u00f8gaard and Goldberg, 2016) . This data is disjunct from the other datasets. Additionally, we combine both the explicit and implicit noise handling. In the low-resource setting, in general, such a combination addresses the data scarcity better than the individual models. NLNN and CNLNN combinations with MTL are labeled as MTL+NLNN and MTL+CNLNN respectively. Implementation Details During training, we minimize the cross entropy loss which sums over the entire sentence. The networks are trained with Stochastic Gradient Descent (SGD). To determine the number of iterations for both the NN model and the EM algorithm we use the development data. All models are trained with word embeddings of dimensionality 64 that are initialized with pre-trained Polygot embeddings (Al-Rfou et al., 2013) . We add Dropout (Srivastava et al., 2014) with p=0.1 in between the word embedding layer and the LSTM. Results In Figure 2 , we present the F 1 scores of the models introduced in the previous section. We perform experiments on Chunking and NER with various amounts of added, automatically-labeled data. In general, adding additional, noisy data tends to improve the performance for all mod- els. This includes the plain NN, showing that this model is somewhat robust to noise. Especially for the Chunking task, the possibility for improvement seems limited for NN as the performance converges after adding 40k noisy instances. In the Chunking 10k case, the negative effect of the noisy instances results in a score lower than if no data is added. The original NLNN model performs similarly to the NN model without a noise-handling component. In some cases, the score is even lower. In contrast, CNLNN is able to consistently improve over these scores. This demonstrates the importance of our proposed CNLNN which treats clean and noisy data separately. MTL is able to improve somewhat over NN even without adding automatically-annotated data thanks to the auxiliary task. Additionally, MTL performs even better when noisy data is added showing its implicit noise handling capabilities. On their own, both CNLNN and MTL are able to eliminate some of the negative effects of the noisy data and to leverage the additional data effectively. Combining MTL with NLNN results in small improvements at best and can decrease perfor-mance, especially on Chunking. The best results are achieved with our combined MTL+CNLNN model as it outperforms all other models. Even when adding 19 times the amount of self-labeled data, the model is still able to cope with the noise and improve the performance. 7 Analysis NLNN vs. CNLNN: In NLNN, we observed that clean training tokens were subverted to become noisy in subsequent EM iterations mostly due to the influence of noisy labels from self-labeled data and this effect leads to NLNN's worse performance. Figure 3 presents one such case where the corruption of the confusion matrix from 1. iteration to 3. iteration is displayed. CNLNN treats clean and noise data separately and therefore avoids the corruption of clean labels. MTL+CNLNN vs. MTL+NLNN: We noted that MTL+CNLNN consistently outperforms MTL and MTL+NLNN, whereas the MTL+NLNN combination can degrade MTL's performance. For nearly all predicted labels the improvements in precision over MTL are higher for MTL+CNLNN when compared to MTL+NLNN (Figure 4 ). This shows that CNLNN complements MTL better than NLNN. Concluding Remarks In this paper, we apply self-training to neural networks for Chunking and NER in a low-resource setup. Adding automatically-labeled data, the performance of the classifier can wane or can even decline. We propose to mitigate this effect by applying noisy label handling techniques. However, we found that directly applying an off-the-shelf noise-handling technique as NLNN leads to corruption of the clean training set and worse performance. Thus, we propose the Clean and Noisy Label Neural Network to work separately on the automatically-labeled data. Our model improves the performance faster for a lesser amount of additional data. Moreover, combing the training with auxiliary information can further help handle noise in a complementary fashion. Meanwhile, more complex neural network architectures (Goldberger and Ben-Reuven, 2017; Luo et al., 2017; Veit et al., 2017) are available for handling noise and we look forward to working with these to upgrade our approach in the future. Acknowledgements This work has been supported by the German Research Foundation as part of the Research Training Group Adaptive Preparation of Information from Heterogeneous Sources (AIPHES) under grant No. GRK 1994/1. We also thank the anonymous reviewers whose comments helped improve this paper.",
    "abstract": "In this paper, we address the problem of effectively self-training neural networks in a lowresource setting. Self-training is frequently used to automatically increase the amount of training data. However, in a low-resource scenario, it is less effective due to unreliable annotations created using self-labeling of unlabeled data. We propose to combine self-training with noise handling on the self-labeled data. Directly estimating noise on the combined clean training set and self-labeled data can lead to corruption of the clean data and hence, performs worse. Thus, we propose the Clean and Noisy Label Neural Network which trains on clean and noisy self-labeled data simultaneously by explicitly modelling clean and noisy labels separately. In our experiments on Chunking and NER, this approach performs more robustly than the baselines. Complementary to this explicit approach, noise can also be handled implicitly with the help of an auxiliary learning task. To such a complementary approach, our method is more beneficial than other baseline methods and together provides the best performance overall.",
    "countries": [
        "Germany",
        "Finland"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "14",
    "year": "2019",
    "month": "June",
    "title": "Handling Noisy Labels for Robustly Learning from Self-Training Data for Low-Resource Sequence Labeling"
}