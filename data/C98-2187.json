{
    "article": "Several methods are known for parsing languages generated by Tree Adjoining Grammars (TAGs) in O(n 6) worst case running time. In this paper we investigate which restrictions on TAGs and TAG derivations are needed in order to lower this O(n 6) time complexity, without introducing large runtime constants, and without losing any of the generative power needed to capture the syntactic constructions in natural language that can be handled by unrestricted TAGs. In particular, we describe an algorithm for parsing a strict subclass of TAG in O(ns), and attempt to show that this subclass retains enough generative power to make it useful in the general case. Introduction Several methods are known that can parse languages generated by Tree Adjoining Grammars (TAGs) in worst case time O(n~) , where n is the length of the input string (see (Schabes and Joshi, 1991) and references therein). Although asymptotically faster methods can be constructed, as discussed in (Rajasekaran and Yooseph, 1995) , these methods are not of practical interest, due to large hidden constants. More generally, in (Satta, 1994 ) it has been argued that methods for TAG parsing running in time asymptotically faster than (9(n 6) are unlikely to have small hidden constants. A careful inspection of the proof provided in (Satta, 1994) reveals that the source of the claimed computational complexity of TAG parsing resides in the fact that auxiliary trees can get adjunctions at (at least) two distinct nodes in their spine (the path connecting the root and the foot nodes). The question then arises of whether the bound of two is tight. More generally, in this paper we investigate which re-strictions on TAGs are needed in order to lower tile O(n 6) time complexity, still retaining the generative power that is needed to capture the syntactic constructions of natural language that unrestricted TAGs can handle. The contribution of this paper is twofold: \u2022 We define a strict subclass of TAG where adjunction of so-called wrapping trees at the spine is restricted to take place at no more than one distinct node. We show that in this case the parsing problem for TAG can be solved in worst case timc O(nS). \u2022 We provide evidence that the proposed subclass still captures the vast majority of TAG analyses that have been currently proposed for the syntax of English and of several other languages. Several restrictions on the adjunction operation for TAG have been proposed in the literature (Schabes and Waters, 1993; Schabes and Waters, 1995) (Rogers, 1994) . Differently from here, in all those works the main goal was one of characterizing, through the adjunction operation, the set of trees that can be generated by a context-free grammar (CFG). For the sake of critical comparison, we discuss some common syntactic constructions found in current natural language TAG analyses, that can be captured by our proposal but fall outside of the restrictions mentioned above. Overview We introduce here the subclass of TAG that we investigate in this paper, and briefly compare it with other proposals in the literature. A TAG is a tuple G --= (N, Z, I, A, S), where N, Z are the finite sets of nonterminal and terminal symbols, respectively, I, A are the finite sets of initial and auxiliary trees, respectively, and S E N is the initial symbol. Trees in I O A are also called elementary trees. The reader is referred to (Joshi, 1985) for the definitions of tree adjunction, tree substitution, and language derived by a TAG. The spine of an auxiliary tree is the (unique) path that connects the root and the foot node. An auxiliary tree [:1 is called a right (left) tree if (i) the leftmost (rightmost, resp.) leaf in fl is the foot node; and (ii) the spine of ~ contains only the root and the foot nodes. An auxiliary tree which is neither left nor right is called a wrapping tree. 1 The TAG restriction we propose is stated as followed: 1. At the spine of each wrapping tree, there is at most one node that can host adjunction of a wrapping tree. This node is called a wrapping node. 2. At the spine of each left (right) tree, no wrapping tree can be adjoined and no adjunction constraints on right (left, resp.) auxiliary trees are found. The above restriction does not in any way constrain adjunction at nodes that are not in the st)ine of ass auxiliary tree. Similarly, there is no restriction on the adjunction of left or right trees at the spines of wrapping trees. Our restriction is fundamentally different from those in (Schabes and Waters, 1993; Schabes and Waters, 1995) and (Rogers, 1994) , in that we allow wrapping auxiliary trees to nest inside each other an unbounded number of times, so long as they only adjoin at one place its each others' spines. Rogers, in contrast, restricts the nesting of wrapping auxiliaries to a number of times bounded by the size of the grammar, and Sehabes and Waters forbid wrapping auxiliaries altogether, at any node in the grammar. We now focus on the recognition problem, and informally discuss the computational advantages that arise in this task when a TAG obeys the above restriction. These ideas are fl)rmally developed in the next section. Most of 1The above names are also used in (Schabes and Waters, 1995) for slightly different kinds of trees. the tabular methods for TAG recognition represent; subtrees of derived trees, rooted at some node N and having the same span within the input string, by means of items of the form <N,i,p, q,j) . In this notation i, j are positions in the input st)anned by N, and p, q are positions spanned by the foot node, in case N belongs to the spine, as we assume its the discussion below. The most time expensive step in TAG recognition is the one that deals with adjunction. When we adjoin at N a derived auxiliary tree rooted at some node R, we have to combine together two items <R, i', i, j, j') and (N, i, p, q, j>. This is shown in Figure 1 . Tiffs step involves six different indices that could range over any position in the input, and thus has a time cost of O(n6). Let us now consider adjunction of wrapping trees, and leave aside left and right trees for the moment. Assume that no adjunction has been t)erformed in tim portion of the spine below N. Then none of the trees adjoined below N will simultaneously atfect the portions of the tree yield to the left and to the right of the tbot node. In this case we can safely split the tree yieht and ret)resent item (N,i,p,q,j} by means of two items of a new kind, <NteIt,i,P) and (N,.ioht,q,j). The adjunction step can now be performed t)y means of two successive steps. The first step combines (R,i',i,j,j') and <Nl~#,i,p), producing a new intermediate item I. The second step combines I and <Nright , q, j>, producing the desired result. In this way the time cost is reduced to O(nS). It is not ditficult to see that the above reasoning also applies in cases where no adjunction has been performed at the portion of the spine above N. This suggests that, when t)ro-(b): cessing a TAG that obeys the restriction introduced above, we can always 'split' each wrapping tree into four parts at the wrapping node N, since N is the only site in the spine that can host adjunction (see Figure 2 (a)). Adjunction of a wrapping tree /3 at N can then be simulated by four steps, executed one after the other. Each step composes the item resulting from the application of the previous step with an item representing one of the four parts of the wrapping tree (see Figure 2(b) ). We now consider adjunction involving left and right trees, and show that a similar splitting along the spine can be performed. Assume that 3' is a derived auxiliary tree, obtained by adjoining several left and right trees one at the spine of the other. Let x and y be the part of the yield of 3' to the left and right, respectively, of the foot node. From the definition of left and right trees, we have that the nodes in the spine of 3' have all the same nonterminal label. Also, from condition 2 in the above restriction we have that the left trees adjoined in 3' do not constrain in any way the right trees adjoined in 3'. Then the following derivation can always be performed. We adjoin all the left trees, each one at the spine of the other, in such a way that the resulting tree Vldt has yield x. Similarly, we adjoining all the right trees, one at the spine of the other, in such a way that the yield of the resulting tree 7right is y. Finally, we adjoin \")'right at the root of \"/t4t, obtaining a derived tree having the same yield as 3'. From the above observations it directly fol-lows that we can always recognize the yield of 7 by independently recognizing 71elt and \")'right. Most important, 71~lt and ')'right can be represented by means of items {Rlelt,i,P} and (Rright,q,j). As before, the adjunction of tree 3' at some subtree represented by an item I can be recognized by means of two successive steps, one combining I with (Rlelt, i,p) at its left, resulting in an intermediate item I ~, and the second combining I' with (Rright , q,j} at its right, obtaining the desired result. 3 Recognition This section presents the main result of the paper. We provide an algorithm for the recognition of languages generated by the subclass of TAGs introduced in the previous section, and show that the worst case running time is O(nS), where n is the length of the input string. To simplify the presentation, we assume the following conditions throughout this section: first, that elementary trees are binary (no more than two children at each node) and no leaf node is labeled by e; and second, that there is always a wrapping node in each wrapping tree, and it differs from the foot and the root node. This is without any loss of generality. Grammar transformation Let G = (N, E, I, A) be a TAG obeying the restrictions of Section 2. We first transform A into a new set of auxiliary trees A ~ that will be processed by our method. The root and foot nodes of a tree/3 are denoted R E and FE, respectively. The wrapping node (as defined in Section 2) of fl is denoted W E. Each left (right) tree /3 in A is inserted in A I and is called flL (fin). Let /3 be a wrapping tree in A. We split p into four auxiliary trees, as informally described in Section 2. Let/3D be the subtree of/3 rooted at W~. We call flu the tree obtained from/3 by removing every descendant of W E (and the corresponding arcs). We remove every node to the right (left,) of the spine of/3D and call flLD (/3RD) the resulting tree. Similarly, we remove every node to the right (left) of the spine of/3u and call /3LU (~RU) the resulting tree. We set FZL D and FER D equal to FE, and set FZL u and FZR u equal to W E. Trees /3LU, /3RU, /3LD, and/3RD are inserted in A r for every wrapping tree/3 in A. Each tree in A' inherits at its nodes the adjunction constraints specified in G. In addition, we impose the following constraints: \u2022 only trees /3L can be adjoined at the spine of trees /3LD,/3LU; \u2022 only trees fl,2 can be adjoined at the spine of trees /3RD, flRU ; \u2022 no adjunction can be performed at nodes a.2 The algorithm The algorithm below is a tabular nmthod that works bottom Ul) on derivation trees. Following (Shiet)er et al., 1995), we specify the algorithm using inference rules. (The specification has been optinfized for presentation simplicity, not for computational efficiency.) Symbols N, P, Q denote nodes of trees in A' (including foot and root), a denotes initial trees and fl denotes auxiliary trees. Symbol label(N) is the label of N and children(N) is a string denoting all children of N from left to right (children(N) is undefined if N is a leaf). We write a E Sbst(N) if ee can be substituted at N. We writ('./3 E Adj(N) if/3 can be adjoined at N, and nil E Adj(N) if adjunction at N is optional. We use two kind of items: \u2022 Item (N X, i, j), X E {t3, M, T}, denotes a subtree rooted at N and spanning the portion of the input from i to j. Note that two input positions are sufficient, since trees in A' always have their foot node at the position of tile leftmost or rightmost leaf. We have X = B if N has not yet been processed for adjunction, X = M if N has been processed only for adjunction of trees ilL, and X = T if N has already been processed for adjunction. \u2022 Item (/3, i,p, q, j) denotes a wrapping tree /3 (in A) with R~ spanning the portion of the input from i to j and with F~ spanning the portion of the input from p to q. In place of/3 we nfight use symbols [/3, LD], [/3, R.D] and [/3, RU] to denote the temporaw results of recognizing the adjunction of some wrapping tree at W~. Algorithm. Let G be a TAG with the restrictions of Section 2, and let A' be the asso-ciated set of auxiliary trees defined as in section 3.1. Let ala2\". \"an, n > 1, be an input string. The algorithm accepts the input iff some R T item ( ~, 0, n) can be inferred for some ce E I. Step 1 This step recognizes subtrees with root N from subtrees with roots in children(N). (N', i -1,i) ' = ,.; (V~' fleA'' 0<i<n; r, i, j) (N.r,i,j) , ~ E Ebst(N); (fr, i, k) (Or, k, j) (NU,i,j) , children(N) = PQ; (Pr,i,j) -~~, children(N) = P. Step 2 This step recognizes the adjunction of wrapping trees at wrat)ping nodes. We recognize the tree hosting adjunction by composing its fore\" %hunks', represented by auxiliary trees [3LD, /3RD, /3RU and/3LU in A', around the wrapped tree. (R\u00a39,k,p)~ (fl',i,k,q,j) fl, E Adj(W/,),p < q; <[[3, LD], i, p, q, j) ' R u c k> ([fl, LD] i,p,k,j) ~17 <[13, RD],i,p,q,j) t' < q; (t(~. 'w,k,j) ([[3, RDl, i, p, q, k) ([fl, RU], i, p, q, j) ~([f3, RU], k, p, q, j) (R~'L,,,i,p) (R~,q,j) ,nil E Adj(W/~),p < q. ([f3, RD], i,p, q,j) Step 3 This step recognizes all remaining cases of ad.iunction. .\u00a2~ , k,j) XE{B,M}; (NB,i,j) nil c Adj(N); (NU,p,q) (fl, i,p,q,j) (~,i,j) ' fl E Adj(N). (NX,i,j) -,f3EAdj(N),XE{M,T}; (N X, i, k) (R.~, k, j) (NT, i,j) [3EAdj(N), Due to restrictions on space, we nmrely claim the correctness of the abow; algorithm. We now establish its worst case time complexity with respect to the input string length n. We need to consider tile maximum numl)er d of int)ut positions appearing in the antecedent of an inference rule. In fact, in the worst case we will have to execute a number of different evaluations of each inference rule which is proportional to n d, and each evaluation can be carried out in an amount of time independent of n. It is easy to establish that Step 1 can be executed in time O(n a) and that Step 3 can be executed in time O(n4). Adjunction at wrapping nodes performed at Step 2 is the most expensive operation, requiring an amount of time O(nS). This is also the time complexity of our algorithm. 4 Linguistic Relevance In this section we will attempt to show that the restricted formalism presented in Section 2 retains enough generative power to make it useful in the general case. Athematie and Complement Trees We begin by introducing the distinction between athematic auxiliary trees and complement auxiliary trees (Kroch, 1989) , which are meant to exhaustively characterize the auxiliary trees used in any natural language TAG grammar. 2 An athematic auxiliary tree does not subcategorize for or assign a thematic role to its foot node, so the head of the foot node becomes the head of the phrase at the root. The structure of an athematic auxiliary tree may thus be described as: X n__+xn...(Ymaz)..., where X n is any projection of category X, ymaz is the maximal projection of Y, and the order of the constituents is variable. 3 A complement auxiliary tree, on the other hand, introduces a lexical head that subcategorizes for the tree's foot node and assigns it a thematic role. The structure of a complement auxiliary tree may be described as: xmax ._+ . . . yO ... xmax ... where X max is the maximal projection Of some category X, and y0 is the lexical projection 2The same linguistic distinction is used in the conception of 'modifier' and 'predicative' trees (Schabes and Shieber, 1994) , but Schabes and Shieber give the trees special properties in the calculation of derivation structures, which we do not. aThe CFG-like notation is taken directly from (Kroch, 1989) , where it is used to specify labels at the root and frontier nodes of a tree without placing constraints on the internal structure. of some category Y, whose maximal projection dominates X max . From this we make the following observations: 1. Because it does not assign a theta role to its foot node, an athematic auxiliary tree may adjoin at any projection of a category, which we take to designate any adjunction site in a host elementary tree. 2. Because it does assign a theta role to its foot node, a complement auxiliary tree may only adjoin at a certain 'complement' adjunction site in a host elementary tree, which must at least be a maximal projection of a lexical category. 3. The foot node of an athematic auxiliary tree is dominated only by the root, with no intervening nodes, so it falls outside of the maximal projection of the head. 4. The foot node of a complement auxiliary tree is dominated by the maximal projection of the head, which may also dominate other arguments on either side of the foot. To this we now add the assumption that each auxiliary tree can have only one complement adjunction site projecting from y0, where y0 is the lexical category that projects ymax. This (1) is justified in order to prevent projections of y0 from receiving more than one theta role from complement adjuncts, which would violate the underlying theta criterion in Government and Binding Theory (Chomsky, 1981) .We also assume that an auxiliary tree can not have complement adjunetion sites on its spine projecting from lexical heads other than y0 in order to preserve the minimality of elementary trees (Kroch, 1989; Frank, 1992) . Thus there (2) can be no more than one complement adjunction site on the spine of any complement auxiliary tree, and no complement adjunction site on the spine of any athematie auxiliary tree, since the foot node of an athematie tree lies outside of the maximal projection of the head. 4 Based on observations 3 and 4, we can further specify that only complement trees may wrap, because the foot node of an athematic tree lies outside of the maximal projection of the head, below which all of its subcategories must attach. 5 In this manner, we can insure that only one wrapping tree (the complement auxiliary) can adjoin into the spine of a wrapping (complement) auxiliary, and only athematic auxiliaries (which must be left/right trees) can adjoin elsewhere, fulfilling our TAG restriction in Section 2. Possible Extensions We may want to weaken our definition to include wrapping athematic auxiliaries, in order to account for modifiers with raised heads or complements as in Figure 3 : \"They so revered him that they built a statue in his honor.\" This can be done within the above algorithm as long as the athematic trees do not wrap productively (that is as long as they cannot be adjoined one at the spine of the other) by splitting the athematic auxiliary tree down the spine and treating the two fragments as tree-local multicomponents, which can be simulated with nonrecursive features (Hockey and Srinivas, 1993 Concluding remarks Our proposal is intended to contribute to the assessment of the computational complexity of syntactic processing. We have introduced a strict subclass of TAGs having the generative power that is needed to account for the syntactic constructions of natural language that unrestricted TAGs can handle. We have specified a method that recognizes the generated languages in worst case time O(n5), where n is the length of the input string. In order to account for the dependency on the input grammar G, let us de- It is not difficult to see that the running time of our method is proportional to I G I. Our method works as a recognizer. As for many other tabular methods for TAG recognition, we can devise simple procedures in order to obtain a derived tree associated with an accepted string. To this end, we must be able to 'interleave' adjunctions of left and right trees, that are always kept separate by our recognizer. The average case time complexity of our method should surpass its worst case time performance, as is the case for many other tabular algorithms for TAG recognition. In a more applicative perspective, then, the question arises of whether there is any gain in using an algorithm that is unable to recognize more than one wrapping adjunction at each spine, as opposed to using an unrestricted TAG algorithm. As we have tried to argue in Section 4, it seems that standard syntactic constructions do not exploit multiple wrapping adjunctions at a single spine. Nevertheless, the local ambiguity of natural language, as well as cases of ill-formed input, could always produce cases in which such expensive analyses are attempted by an unrestricted algorithm. In this perspective, then, we conjecture that having the single-wrappingadjunction restriction embedded into the recognizer would improve processing efficiency in the average case. Of course, more experimental work would be needed in order to evaluate such a conjecture, which we leave for future work. Acknowledgments References",
    "abstract": "Several methods are known for parsing languages generated by Tree Adjoining Grammars (TAGs) in O(n 6) worst case running time. In this paper we investigate which restrictions on TAGs and TAG derivations are needed in order to lower this O(n 6) time complexity, without introducing large runtime constants, and without losing any of the generative power needed to capture the syntactic constructions in natural language that can be handled by unrestricted TAGs. In particular, we describe an algorithm for parsing a strict subclass of TAG in O(ns), and attempt to show that this subclass retains enough generative power to make it useful in the general case.",
    "countries": [
        "Italy",
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "0",
    "year": "1998",
    "month": "",
    "title": "Restrictions on Tree Adjoining Languages"
}