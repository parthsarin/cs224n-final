{
    "article": "In a spoken dialog system, dialog state tracking deduces information about the user's goal as the dialog progresses, synthesizing evidence such as dialog acts over multiple turns with external data sources. Recent approaches have been shown to overcome ASR and SLU errors in some applications. However, there are currently no common testbeds or evaluation measures for this task, hampering progress. The dialog state tracking challenge seeks to address this by providing a heterogeneous corpus of 15K human-computer dialogs in a standard format, along with a suite of 11 evaluation metrics. The challenge received a total of 27 entries from 9 research groups. The results show that the suite of performance metrics cluster into 4 natural groups. Moreover, the dialog systems that benefit most from dialog state tracking are those with less discriminative speech recognition confidence scores. Finally, generalization is a key problem: in 2 of the 4 test sets, fewer than half of the entries out-performed simple baselines. Overview and motivation Spoken dialog systems interact with users via natural language to help them achieve a goal. As the interaction progresses, the dialog manager maintains a representation of the state of the dialog in a process called dialog state tracking (DST). For example, in a bus schedule information system, the dialog state might indicate the user's desired bus route, origin, and destination. Dialog state tracking is difficult because automatic speech * Most of the work for the challenge was performed when the second and third authors were with Honda Research Institute, Mountain View, CA, USA recognition (ASR) and spoken language understanding (SLU) errors are common, and can cause the system to misunderstand the user's needs. At the same time, state tracking is crucial because the system relies on the estimated dialog state to choose actions -for example, which bus schedule information to present to the user. Most commercial systems use hand-crafted heuristics for state tracking, selecting the SLU result with the highest confidence score, and discarding alternatives. In contrast, statistical approaches compute scores for many hypotheses for the dialog state (Figure 1 ). By exploiting correlations between turns and information from external data sources -such as maps, bus timetables, or models of past dialogs -statistical approaches can overcome some SLU errors. Numerous techniques for dialog state tracking have been proposed, including heuristic scores (Higashinaka et al., 2003) , Bayesian networks (Paek and Horvitz, 2000; Williams and Young, 2007) , kernel density estimators (Ma et al., 2012) , and discriminative models (Bohus and Rudnicky, 2006) . Techniques have been fielded which scale to realistically sized dialog problems and operate in real time (Young et al., 2010; Thomson and Young, 2010; Williams, 2010; Mehta et al., 2010) . In end-to-end dialog systems, dialog state tracking has been shown to improve overall system performance (Young et al., 2010; Thomson and Young, 2010) . Despite this progress, direct comparisons between methods have not been possible because past studies use different domains and system components, for speech recognition, spoken language understanding, dialog control, etc. Moreover, there is little agreement on how to evaluate dialog state tracking. Together these issues limit progress in this research area. The Dialog State Tracking Challenge (DSTC) provides a first common testbed and evaluation Figure 1 : Overview of dialog state tracking. In this example, the dialog state contains the user's desired bus route. At each turn t, the system produces a spoken output. The user's spoken response is processed to extract a set of spoken language understanding (SLU) results, each with a local confidence score. A set of N t dialog state hypotheses is formed by considering all SLU results observed so far, including the current turn and all previous turns. Here, N 1 = 3 and N 2 = 5. The dialog state tracker uses features of the dialog context to produce a distribution over all N t hypotheses and the meta-hypothesis that none of them are correct. suite for dialog state tracking. The DSTC organizers made available a public, heterogeneous corpus of over 15K transcribed and labeled humancomputer dialogs. Nine teams entered the challenge, anonymously submitting a total of 27 dialog state trackers. This paper serves two roles. First, sections 2 and 3 provide an overview of the challenge, data, and evaluation metrics, all of which will remain publicly available to the community (DST, 2013). Second, this paper summarizes the results of the challenge, with an emphasis on gaining new insights into the dialog state tracking problem, in Section 4. Section 5 briefly concludes. Challenge overview Problem statement First, we define the dialog state tracking problem. A dialog state tracker takes as input all of the observable elements up to time t in a dialog, including all of the results from the automatic speech recognition (ASR) and spoken language understanding (SLU) components, and external knowledge sources such as bus timetable databases and models of past dialogs. It also takes as input a set of N t possible dialog state hypotheses, where a hypothesis is an assignment of values to slots in the system. The tracker outputs a probability distribution over the set of N t hypotheses, and the meta-hypothesis REST which indicates that none of them are correct. The goal is to assign probability 1.0 to the correct state, and 0.0 to other states. Note that the set of dialog states is given. Also note that N t varies with t -typically as the dialog progresses and more concepts are discussed, the number of candidate hypotheses increases. An example is given in Figure 1 . In this challenge, dialog states are generated in the usual way, by enumerating all slots values that have appeared in the SLU N-best lists or system output up until the current turn. While this approach precludes a tracker assigning a score to an SLU value that has not been observed, the cardinality of the slots is generally large, so the likelihood of a tracker correctly guessing a slot value which hasn't been observed anywhere in the input or output is vanishingly small. Challenge design The dialog state tracking challenge studies this problem as a corpus-based task -i.e., dialog state trackers are trained and tested on a static corpus of dialogs, recorded from systems using a variety of state tracking models and dialog managers. The challenge task is to re-run state tracking on these dialogs -i.e., to take as input the runtime system logs including the SLU results and system output, and to output scores for dialog states formed from the runtime SLU results. This corpus-based design was chosen because it allows different trackers to be evaluated on the same data, and because a corpus-based task has a much lower barrier to entry for research groups than building an end-to-end dialog system. In practice of course, a state tracker will be used in an end-to-end dialog system, and will drive action selection, thereby affecting the distribution of the dialog data the tracker experiences. In other words, it is known in advance that the distribution in the training data and live data will be mismatched, although the nature and extent of the mis-match are not known. Hence, unlike much of supervised learning research, drawing train and test data from the same distribution in offline experiments may overstate performance. So in the DSTC, train/test mis-match was explicitly created by choosing test data to be from different dialog systems. Source data and challenge corpora The DSTC uses data from the public deployment of several systems in the Spoken Dialog Challenge (SDC) (Black et al., 2010) , provided by the Dialog Research Center at Carnegie Mellon University. In the SDC, telephone calls from real passengers of the Port Authority of Allegheny County, who runs city buses in Pittsburgh, were forwarded to dialog systems built by different research groups. The goal was to provide bus riders with bus timetable information. For example, a caller might want to find out the time of the next bus leaving from Downtown to the airport. The SDC received dialog systems from three different research groups, here called Groups A, B, and C. Each group used its own ASR, SLU, and dialog manager. The dialog strategies across groups varied considerably: for example, Groups A and C used a mixed-initiative design, where the system could recognize any concept at any turn, but Group B used a directed design, where the system asked for concepts sequentially and could only recognize the concept being queried. Groups trialled different system variants over a period of almost 3 years. These variants differed in acoustic and language models, confidence scoring model, state tracking method and parameters, number of supported bus routes, user population, and presence of minor bugs. Example dialogs from each group are shown in the Appendix. The dialog data was partitioned into 5 training corpora and 4 testing corpora (Table 1 ). The partioning was intended to explore different types of mis-match between the training and test data. Specifically, the dialog system in TRAIN1A, TRAIN1B, TRAIN1C, TRAIN2, and TEST1 are all very similar, so TEST1 tests the case where there is a large amount of similar data. TEST2 uses the same ASR and SLU but a different dialog controller, so tests the case where there is a large amount of somewhat similar data. TEST3 is very similar to TRAIN3 and tests the case where there is a small amount of similar data. TEST4 uses a completely different dialog system to any of the training data. Data preparation The dialog system log data from all three groups was converted to a common format, which described SLU results and system output using a uniform set of dialog acts. For example, the system speech East Pittsburgh Bus Schedules. Say a bus route, like 28X, or say I'm not sure. was represented as hello(), request(route), example(route=28x), example(route=dontknow). The user ASR hypothesis the next 61c from oakland to mckeesport transportation center was represented as inform(time.rel=next), inform(route=61c), inform(from.neighborhood=oakland), inform(to.desc=\"mckeesport transportation center\"). In this domain there were a total of 9 slots: the bus route, date, time, and three components each for the origin and destination, corresponding to streets, neighborhoods, and points-of-interest like universities. For complete details see (Williams et al., 2012) . Group B and C systems produced N-best lists of ASR and SLU output, which were included in the log files. Group A systems produced only 1best lists, so for Group A systems, recognition was re-run with the Pocketsphinx speech recognizer (Huggins-Daines et al., 2006) with N-best output enabled, and the results were included in the log files. Some information in the raw system logs was specific to a group. For example, Group B's logs included information about word confusion networks, but other groups did not. All of this information was included in a \"system specific\" section of the log files. Group A logs contained about 40 system-specific name/value pairs per turn, and Group B about 600 system-specific name/value pairs per turn. Group C logs contained no system specific data. Labeling and evaluation design The output of a dialog state tracker is a probability distribution over a set of given dialog state hypotheses, plus the REST meta-hypothesis. To evaluate this output, a label is needed for each dialog state hypothesis indicating its correctness. In this task-oriented domain, we note that the user enters the call with a specific goal in mind. Further, when goal changes do occur, they are usually explicitly marked: since all of the sys-tems first collect slot values, and then provide bus timetables, if the user wishes to change their goal, they need to start over from the beginning. These \"start over\" transitions are obvious in the logs. This structure allows the correctness of each dialog state to be equated to the correctness of the SLU items it contains. As a result, in the DSTC we labeled the correctness of SLU hypotheses in each turn, and then assumed these labels remain valid until either the call ends, or until a \"start over\" event. Thus to produce the labels, the labeling task followed was to assign a correctness value to every SLU hypothesis on the N-best list, given a transcript of the words actually spoken in the dialog up to the current turn. To accomplish this, first all user speech was transcribed. The TRAIN1 datasets had been transcribed using crowd-sourcing in a prior project (Parent and Eskenazi, 2010) ; the remainder were transcribed by professionals. Then each SLU hypothesis was labled as correct or incorrect. When a transcription exactly and unambiguously matched a recognized slot value, such as the bus route \"sixty one c\", labels were assigned automatically. The remainder were assigned using crowdsourcing, where three workers were shown the true words spoken and the recognized concept, and asked to indicate if the recognized concept was correct -even if it did not match the recognized words exactly. Workers were also shown dialog history, which helps decipher the user's meaning when their speech was ambiguous. If the 3 workers were not unanimous in their labels (about 4% of all turns), the item was labeled manually by the organizers. The REST meta-hypothesis was not explicitly labeled; rather, it was deemed to be correct if none of the prior SLU results were labeled as correct. In this challenge, state tracking performance was measured on each of the 9 slots separately, and also on a joint dialog state consisting of all the slots. So at each turn in the dialog, a tracker output 10 scored lists: one for each slot, plus a 10th list where each dialog state contains values from all slots. Scores were constrained to be in the range [0, 1] and to sum to 1. To evaluate tracker output, at each turn, each hypothesis (including REST) on each of the 10 lists was labeled as correct or incorrect by looking up its corresponding SLU label(s). The scores and labels over all of the dialogs were then compiled to compute 11 metrics. Accuracy measures the percent of turns where the top-ranked hypothesis is correct. This indicates the correctness of the item with the maximum score. L2 measures the L 2 distance between the vector of scores, and a vector of zeros with 1 in the position of the correct hypothesis. This indicates the quality of all scores, when the scores as viewed as probabilities. AvgP measures the mean score of the first correct hypothesis. This indicates the quality of the score assigned to the correct hypothesis, ignoring the distribution of scores to incorrect hypotheses. MRR measures the mean reciprocal rank of the first correct hypothesis. This indicates the quality of the ordering the scores produces (without necessarily treating the scores as probabilities). The remaining measures relate to receiveroperating characteristic (ROC) curves, which measure the discrimination of the score for the highest-ranked state hypothesis. Two versions of ROC are computed -V1 and V2. V1 computes correct-accepts (CA), false-accepts (FA), and false-rejects (FR) as fractions of all utterances, so for example CA.V 1(s) = #CA(s) N (1) where #CA(s) indicates the number of correctly accepted states when only those states with score \u2265 s are accepted, and N is the total number of states in the sample. The V1 metrics are a useful indication of overall performance because they combine discrimination and overall accuracy -i.e., the maximum CA.V 1(s) value is equal to accuracy computed above. V2 considers fractions of correctly classified utterances, so for example CA.V 2(s) = #CA(s) #CA(0) . (2) The V2 metrics are useful because they measure the discrimination of the scoring independently of accuracy -i.e., the maximum value of CA.V 2(s) is always 1, regardless of accuracy. From these ROC statistics, several metrics are computed. ROC.V1.EER computes F A.V 1(s) where F A.V 1(s) = F R.V 1(s). The metrics ROC.V1.CA05, ROC.V1.CA10, and ROC.V1.CA20 compute CA.V 1(s) when F A.V 1(s) = 0.05, 0.10, and 0.20 respectively. ROC.V2.CA05, ROC.V2.CA10, and ROC.V2.CA20 do the same using the V2 versions. Apart from what to measure, there is currently no standard that specifies when to measure -i.e., which turns to include when computing each metric. So for this challenge, a set of 3 schedules were used. schedule1 includes every turn. schedule2 include turns where the target slot is either present on the SLU N-best list, or where the target slot is included in a system confirmation action -i.e., where there is some observable new information about the target slot. schedule3 includes only the last turn of a dialog. In sum, for each tracker, one measurement is reported for each test set (4), schedule (3), and metric (11) for each of the 9 slots, the \"joint\" slot, and a weighted average of the individual slots ( 11 ), for a total of 4 \u2022 3 \u2022 11 \u2022 11 = 1452 measurements per tracker. In addition, each tracker reported average latency per turn -this ranged from 10ms to 1s. Baseline trackers For comparisons, two simple baselines were implemented. The first (Baseline0) is a majority class baseline that always guesses REST with score 1. The second (Baseline1) follows simple rules which are commonly used in spoken dialog systems. It maintains a single hypothesis for each slot. Its value is the SLU 1-best with the highest confidence score observed so far, with score equal to that SLU item's confidence score. Results and discussion Logistically, the training data and labels, bus timetable database, scoring scripts, and baseline system were publicly released in late December 2012. The test data (without labels) was released on 22 March 2013, and teams were given a week to run their trackers and send results back to the organizers for evaluation. After the evaluation, the test labels were published. Each team could enter up to 5 trackers. For the evaluation, teams were asked to process the test dialogs online -i.e., to make a single pass over the data, as if the tracker were being run in deployment. Participation was open to researchers at any institution, including the organizers and advisory board. To encourage participation, the organizers agreed not to identify participants in publications, and there was no requirement to disclose how trackers were implemented. 9 teams entered the DSTC, submitting a total of 27 trackers. The raw output and all 1452 measurements for each tracker (and the 2 baselines) are available from the DSTC homepage (DST, 2013). Analysis of trackers and datasets We begin by looking at one illustrative metric, schedule2 accuracy averaged over slots, which measures the accuracy of the top dialog hypothesis for every slot when it either appears on the SLU N-best list or is confirmed by the system. 1 Results in Figure 2 show two key trends. First, relative to the baselines, performance on the test data is markedly lower than the training data. Comparing TRAIN2 to TEST1/TEST2 and TRAIN3 to TEST3, the relative gain over the baselines is much lower on test data. Moreover, only 38% of trackers performed better than a simple majority-class baseline on TEST4, for which there was no matched training data. These findings suggests that generalization is an important open issues for dialog state trackers. Second, Figure 2 indicates that the gains made Figure 5 : Percent of highest-scored dialog state hypotheses which did not appear in the top-ranked SLU position vs. schedule2 accuracy over all slots. Trackers -including those with the highest accuracyfor TEST1 and TEST2 rarely assigned the highest score to an SLU hypothesis other than the top. All trackers for TEST3 and TEST4 assigned the highest score to an SLU hypothesis other than the top in a non-trivial percent of turns. by the trackers over the baselines are larger for Group A systems (TEST1 and TEST2) than for Group B (TEST3) and C (TEST4) systems. Whereas the baselines consider only the top SLU hypothesis, statistical trackers can make use of the entire N-best list, increasing recall -compare the 1-best and N-best SLU recall rates in Table 1 . However, Group A trackers almost never assigned the highest score to an item below the top position in the SLU N-best list. Rather, the larger gains for Group A systems seem due to the relatively poor discrimination of Group A's SLU confidence score (Figure 3 ): whereas the trackers use a multitude of features to assign scores, the baselines rely entirely on the SLU confidence for their scores, so undiscriminative SLU confidence measures hamper baseline performance. Analysis of metrics This challenge makes it possible to study the empirical differences among the evaluation metrics. Intuitively, if the purpose of a metric is to order a set of trackers from best to worst, then 2 metrics are similar if they yield a similar ordering over trackers. Specifically, for every metric m, we have a value x(m, d, s, t) where d is the dataset, and s is the evaluation schedule, and t is the tracker. We define r(m, d, s, t) as the rank of tracker t when ordered using metric m, dataset d and evaluation schedule s. Using these ranks, we compute Kendall's Tau for every d, s, and pair of metrics m 1 and m 2 (Kendall, 1938) . We then compute the average Kendall's Tau for m 1 and m 2 by averaging over all d and s. 2 Results are in Figure 6 . Here we see 4 natural clusters emerge: a cluster for correctness with Accuracy, MRR, and the ROC.V1.CA measures; a cluster for probability quality with L2 and Average score; and two clusters for score discrimination -one with ROC.V1.EER and the other with the three ROC.V2 metrics. This finding suggest  that measuring one metric from each cluster will contain nearly the same information as all 9 metrics. For example, one might report only Accuracy, L2, ROC.V1.EER, and ROC.V2.CA5. Using these 4 metrics, we rank-ordered each tracker, using schedule2 and a weighted average of all slots. We then computed the average rank across the 4 test sets. Finally we selected the set of trackers with the top three average ranks for each metric. Results in Figure 4 emphasize that different trackers are tuned for different performance measures, and the optimal tracking algorithm depends crucially on the target performance measure. Conclusion The dialog state tracking challenge has provided testbed for this task. The data, evaluation tools, and baselines will continue to be freely available to the research community (DST, 2013) . The details of the trackers themselves will be published at SIGDIAL 2013. The results of the challenge show that the suite of performance metrics cluster into 4 groups. We also find that larger gains over conventional rule-based baselines are present in dialog systems where the speech recognition confidence score has poor discrimination. Finally, we observe substantial limitations on generalization: in mismatched conditions, around half of the trackers entered did not exceed the performance of two simple baselines. In future work, it should be verified that improvements in dialog state tracking lead to improvements in end-to-end dialog performance (e.g., task completion, user satisfaction, etc.). In addition, it would be interesting to study dialogs where goal changes are more common. Following is a log from a call in TRAIN3. Some elements have been omitted for space. Logs are formatted in JavaScript Object Notation (JSON). { \"session-id\": \"dt-201007221854-4808D\", \"turns\": [ { \"input\": { \"asr-hyps\": [ { \"asr-hyp\": \"sixty one b\", \"score\": 0.834314, }, ... ], \"slu-hyps\": [ { \"slu-hyp\": [ {\"act\": \"inform\", \"slots\": [[\"route\", \"61b\"]]}, ], \"score\": 0.834314, }, ... ], \"audio-file\": \"002.raw\", \"start-time\": 7.504 }, \"output\": { \"start-time\": 0.078, \"transcript\": \"East Pittsburgh Bus Schedules. Say a bus route, like 28X, or say I'm not sure.\", \"dialog-acts\": [ { \"act\": \"hello\", \"slots\": [] }, { \"act\": \"request\", \"slots\": [[\"route\",null]] }, { \"act\": \"example\", \"slots\": [[\"route\",\"28x\"]] }, { \"act\": \"example\", \"slots\": [[\"route\",\"dontknow\"]] } ], } \"system-specific\": { \"wcn\": { \"best_path_score\": 0.9965, \"best_path\": { \"word\": [\"sixty\",\"one\",\"b\"], \"prob\": [ 1.0,1.0,0.9965 ], } \"network\": [ ... ] }, \"nbest\": [ { \"normSpeechLhood\": -152.654, \"lastSpeechFrame\": 266, \"numFrames\": 354, \"udelta\": -3.0280, \"speechLikelihood\": -15876.0, }, ... ], ... }, }, ... ] } Acknowledgements The organizers thank the advisory board for their valuable input on the design of the challenge: Daniel Boies, Paul Crook, Maxine Eskenazi, Milica Gasic, Dilek Hakkani-Tur, Helen Hastie, Kee-Eung Kim, Ian Lane, Sungjin Lee, Teruhisa Misu, Olivier Pietquin, Joelle Pineau, Blaise Thomson, David Traum, and Luke Zettlemoyer. The organizers also thank Ian Lane for his support for transcription, and Microsoft and Honda Research Institute USA for funding the challenge. Finally, we thank the participants for making the challenge successful. Appendix 1: Sample dialog excerpts Below are transcripts of calls in the DSTC corpus. The user's side shows utterances as transcribed by human annotators.",
    "abstract": "In a spoken dialog system, dialog state tracking deduces information about the user's goal as the dialog progresses, synthesizing evidence such as dialog acts over multiple turns with external data sources. Recent approaches have been shown to overcome ASR and SLU errors in some applications. However, there are currently no common testbeds or evaluation measures for this task, hampering progress. The dialog state tracking challenge seeks to address this by providing a heterogeneous corpus of 15K human-computer dialogs in a standard format, along with a suite of 11 evaluation metrics. The challenge received a total of 27 entries from 9 research groups. The results show that the suite of performance metrics cluster into 4 natural groups. Moreover, the dialog systems that benefit most from dialog state tracking are those with less discriminative speech recognition confidence scores. Finally, generalization is a key problem: in 2 of the 4 test sets, fewer than half of the entries out-performed simple baselines.",
    "countries": [
        "United States"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "330",
    "year": "2013",
    "month": "August",
    "title": "The Dialog State Tracking Challenge"
}