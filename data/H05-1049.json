{
    "article": "We present a system for deciding whether a given sentence can be inferred from text. Each sentence is represented as a directed graph (extracted from a dependency parser) in which the nodes represent words or phrases, and the links represent syntactic and semantic relationships. We develop a learned graph matching approach to approximate entailment using the amount of the sentence's semantic content which is contained in the text. We present results on the Recognizing Textual Entailment dataset (Dagan et al., 2005) , and show that our approach outperforms Bag-Of-Words and TF-IDF models. In addition, we explore common sources of errors in our approach and how to remedy them. Introduction A fundamental stumbling block for several NLP applications is the lack of robust and accurate semantic inference. For instance, question answering systems must be able to recognize, or infer, an answer which may be expressed differently from the query. Information extraction systems must also be able recognize the variability of equivalent linguistic expressions. Document summarization systems must generate succinct sentences which express the same content as the original document. In Machine Translation evaluation, we must be able to recognize legit-imate translations which structurally differ from our reference translation. One sub-task underlying these applications is the ability to recognize semantic entailment; whether one piece of text follows from another. In contrast to recent work which has successfully utilized logicbased abductive approaches to inference (Moldovan et al., 2003; Raina et al., 2005b) , we adopt a graphbased representation of sentences, and use graph matching approach to measure the semantic overlap of text. Graph matching techniques have proven to be a useful approach for tractable approximate matching in other domains including computer vision. In the domain of language, graphs provide a natural way to express the dependencies between words and phrases in a sentence. Furthermore, graph matching also has the advantage of providing a framework for structural matching of phrases that would be difficult to resolve at the level of individual words. Task Definition and Data We describe our approach in the context of the 2005 Recognizing Textual Entailment (RTE) Challenge (Dagan et al., 2005) , but note that our approach easily extends to other related inference tasks. The system presented here was one component of our research group's 2005 RTE submission (Raina et al., 2005a) which was the top-ranking system according to one of the two evaluation metrics. In the 2005 RTE domain, we are given a set of pairs, each consisting of two parts: 1) the text, a Figure 1 : An example parse tree and the corresponding dependency graph. Each phrase of the parse tree is annotated with its head word, and the parenthetical edge labels in the dependency graph correspond to semantic roles. small passage, 1 and the hypothesis, a single sentence. Our task is to decide if the hypothesis is \"entailed\" by the text. Here, \"entails\" does not mean strict logical implication, but roughly means that a competent speaker with basic world-knowledge would be happy to conclude the hypothesis given the text. This criterion has an aspect of relevance logic as opposed to material implication: while various additional background information may be needed for the hypothesis to follow, the text must substantially support the hypothesis. Despite the informality of the criterion and the fact that the available world knowledge is left unspecified, human judges show extremely good agreement on this task -3 human judges independent of the organizers calculated agreement rates with the released data set ranging from 91-96% (Dagan et al., 2005) . We believe that this in part reflects that the task is fairly natural to human beings. For a flavor of the nature (and difficulty) of the task, see Table 1 . We give results on the data provided for the RTE task which consists of 567 development pairs and 800 test pairs. In both sets the pairs are divided into 7 tasks -each containing roughly the same number of entailed and not-entailed instances -which were used as both motivation and means for obtaining and constructing the data items. We will use the following toy example to illustrate our representation and matching technique: Text: In 1994, Amazon.com was founded by Jeff Bezos. Hypothesis: Bezos established a company. 1 Usually a single sentence, but occasionally longer. Semantic Representation The Need for Dependencies Perhaps the most common representation of text for assessing content is \"Bag-Of-Words\" or \"Bag-of-N-Grams\" (Papineni et al., 2002) . However, such representations lose syntactic information which can be essential to determining entailment. Consider a Question Answer system searching for an answer to When was Israel established? A representation which did not utilize syntax would probably enthusiastically return an answer from (the 2005 RTE text): The National Institute for Psychobiology in Israel was established in 1979. In this example, it's important to try to match relationships as well as words. In particular, any answer to the question should preserve the dependency between Israel and established. However, in the proposed answer, the expected dependency is missing although all the words are present. Our approach is to view sentences as graphs between words and phrases, where dependency relationships, as in (Lin and Pantel, 2001) , are characterized by the path between vertices. Given this representation, we judge entailment by measuring not only how many of the hypothesis vertices are matched to the text but also how well the relationships between vertices in the hypothesis are preserved in their textual counterparts. For the remainder of the section we outline how we produce graphs from text, and in the next section we introduce our graph matching model. From Text To Graphs Starting with raw English text, we use a version of the parser described in (Klein and Manning, 2003) , to obtain a parse tree. Then, we derive a dependency tree representation of the sentence using a slightly modified version of Collins' head propagation rules (Collins, 1999) , which make main verbs not auxiliaries the head of sentences. Edges in the dependency graph are labeled by a set of hand-created tgrep expressions. These labels represent \"surface\" syntax relationships such as subj for subject and amod for adjective modifier, similar to the relations in Minipar (Lin and Pantel, 2001) . The dependency graph is the basis for our graphical representation, but it is enhanced in the following ways: 2. Dependency Folding: As in (Lin and Pantel, 2001) , we found it useful to fold certain dependencies (such as modifying prepositions) so that modifiers became labels connecting the modifier's governor and dependent directly. For instance, in the text graph in Figure 2 , we have changed in from a word into a relation between its head verb and the head of its NP complement. 3. Semantic Role Labeling: We also augment the graph representation with Probank-style semantic roles via the system described in (Toutanova et al., 2005) . Each predicate adds an arc labeled with the appropriate semantic role to the head of the argument phrase. This helps to create links between words which share a deep semantic relation not evident in the surface syntax. Additionally, modifying phrases are labeled with their semantic types (e.g., in 1991 is linked by a Temporal edge in the text graph of Figure 2 ), which should be useful in Question Answering tasks. 4. Coreference Links: Using a co-rereference resolution tagger, coref links are added through-out the graph. These links allowed connecting the referent entity to the vertices of the referring vertex. In the case of multiple sentence texts, it is our only \"link\" in the graph between entities in the two sentences. For the remainder of the paper, we will refer to the text as T and hypothesis as H, and will speak of them in graph terminology. In addition we will use H V and H E to denote the vertices and edges, respectively, of H. Entailment by Graph Matching We take the view that a hypothesis is entailed from the text when the cost of matching the hypothesis graph to the text graph is low. For the remainder of this section, we outline a general model for assigning a match cost to graphs. For hypothesis graph H, and text graph T , a matching M is a mapping from the vertices of H to those of T . For vertex v in H, we will use M (v) to denote its \"match\" in T . As is common in statistical machine translation, we allow nodes in H to map to fictitious NULL vertices in T if necessary. Suppose the cost of matching M is Cost(M ). If M is the set of such matchings, we define the cost of matching H to T to be MatchCost(H, T ) = min M \u2208M Cost(M ) (1) Suppose we have a model, VertexSub(v, M (v)), which gives us a cost in [0, 1], for substituting vertex v in H for M (v) in T . One natural cost model is to use the normalized cost for each of the vertex substitutions in M : VertexCost(M ) = 1 Z v\u2208H V w(v)VertexSub(v, M (v)) (2) Here, w(v) represents the weight or relative importance for vertex v, and Z = v\u2208H V w(v) is a normalization constant. In our implementation, the weight of each vertex was based on the part-ofspeech tag of the word or the type of named entity, if applicable. However, there are several other possibilities including using TF-IDF weights for words and phrases. Notice that when Cost(M ) takes the form of (2), computing MatchCost(H, T ) is equivalent to finding the minimal cost bipartite graph-matching, which can be efficiently computed using linear programming. We would like our cost-model to incorporate some measure of how relationships in H are preserved in T under M . Ideally, a matching should preserve all local relationships ; i.e, if v \u2192 v \u2032 \u2208 H E , then M (v) \u2192 M (v \u2032 ) \u2208 T E . When this condition holds for all edges in H, H is isomorphic to a sub- graph of T . What we would like is an approximate notion of isomorphism, where we penalize the distortion of each edge relation in H. Consider an edge e = (v, v \u2032 ) \u2208 H E , and let \u03c6 M (e) be the path from M (v) to M (v \u2032 ) in T . Again, suppose we have a model, PathSub(e, \u03c6 M (e)) for assessing the \"cost\" of substituting a direct relation e \u2208 H E for its counterpart, \u03c6 M (e), under the matching. This leads to a formulation similar to (2), where we consider the normalized cost of substituting each edge relation in H with a path in T : RelationCost(M ) = 1 Z e\u2208H E w(e)PathSub(e, \u03c6 M (e)) (3) where Z = e\u2208H E w(e) is a normalization constant. As in the vertex case, we have weights for each hypothesis edge, w(e), based upon the edge's label; typically subject and object relations are more important to match than others. Our final matching cost is given by a convex mixture of Notice that minimizing Cost(M ) is computationally hard since if our PathSub model assigns zero cost only for preserving edges, then RelationCost(M ) = 0 if and only if H is isomorphic to a subgraph of T . Since subgraph isomophism is an NP-complete problem, we cannot hope to have an efficient exact procedure for minimizing the graph matching cost. As an approximation, we can efficiently find the matching M * which minimizes VertexCost(\u2022); we then perform local greedy hillclimbing search, beginning from M * , to approximate the minimal matching. The allowed operations are changing the assignment of any hypothesis vertex to a text one, and, to avoid ridges, swapping two hypothesis assignments Node and Edge Substitution Models In the previous section we described our graph matching model in terms of our VertexSub model, which gives a cost for substituting one graph vertex for another, and PathSub, which gives a cost for substituting the path relationship between two paths in one graph for that in another. We now outline these models. Vertex substitution cost model Our VertexSub(v, M (v)) model is based upon a sliding scale, where progressively higher costs are given based upon the following conditions: \u2022 Exact Match: v and M (v) are identical words/ phrases. \u2022 Stem Match: v and M (v)'s stems match or one is a derivational form of the other; e.g., matching coaches to coach. \u2022 Synonym Match: v and M (v) are synonyms according to WordNet (Fellbaum, 1998) . In particular we use the top 3 senses of both words to determine synsets. \u2022 Hypernym Match: v is a \"kind of\" M (v), as determined by WordNet. Note that this feature is asymmetric. \u2022 WordNet Similarity: v and M (v) are similar according to WordNet::Similarity (Pedersen et al., 2004). In particular, we use the measure described in (Resnik, 1995) . We found it useful to only use similarities above a fixed threshold to ensure precision. \u2022 LSA Match: v and M (v) are distributionally similar according to a freely available Latent Semantic Indexing package, 2 or for verbs similar according to VerbOcean (Chklovski and Pantel, 2004 ). \u2022 POS Match: v and M (v) have the same part of speech. \u2022 No Match: M (v) is NULL. Although the above conditions often produce reasonable matchings between text and hypothesis, we found the recall of these lexical resources to be far from adequate. More robust lexical resources would almost certainly boost performance. Path substitution cost model Our PathSub(v \u2192 v \u2032 , M (v) \u2192 M (v \u2032 )) model is also based upon a sliding scale cost based upon the following conditions: \u2022 Exact Match: M (v) \u2192 M (v \u2032 ) is an en edge in T with the same label. \u2022 Partial Match: M (v) \u2192 M (v \u2032 ) is an en edge in T , not necessarily with the same label. \u2022 Ancestor Match: M (v) is an ancestor of M (v \u2032 ). We use an exponentially increasing cost for longer distance relationships. \u2022 Kinked Match: M (v) and M (v \u2032 ) share a common parent or ancestor in T . We use an exponentially increasing cost based on the maximum of the node's distances to their least common ancestor in T . These conditions capture many of the common ways in which relationships between entities are distorted in semantically related sentences. For instance, in our system, a partial match will occur whenever an edge type differs in detail, for instance use of the preposition towards in one case and to in the other. An ancestor match will occur whenever an indirect relation leads to the insertion of an intervening node in the dependency graph, such as matching John is studying French farming vs. John is studying French farming practices. Learning Weights Is it possible to learn weights for the relative importance of the conditions in the VertexSub and PathSub models? Consider the case where match costs are given only by equation ( 2 ) and vertices are weighted uniformly (w(v) = 1). Suppose that \u03a6(v, M (v)) is a vector of features 3 indicating the cost according to each of the conditions listed for matching v to M (v). Also let w be weights for each element of \u03a6(v, M (v)). First we can model the substitution cost for a given matching as: VertexSub(v, M (v)) = exp (w T \u03a6(v, M (v))) 1 + exp (w T \u03a6(v, M (v))) Letting s(\u2022) be the 1-sigmoid function used in the right hand side of the equation above, our final matching cost as a function of w is given by c(H, T ; w) = min M \u2208M 1 |H V | v\u2208H s(w T \u03a6(v, M (v))) (4) Suppose we have a set of text/hypothesis pairs, {(T (1) , H (1) ), . . . , (T (n) , H (n) )}, with labels y (i)  which are 1 if H (i) is entailed by T (i) and 0 otherwise. Then we would like to choose w to minimize costs for entailed examples and maximize it for non-entailed pairs: \u2113(w) = i:y (i) =1 log c(H (i) , T (i) ; w) + i:y (i) =0 log(1 \u2212 c(H (i) , T (i) ; w)) Unfortunately, \u2113(w) is not a convex function. Notice that the cost of each matching, M , implicitly depends on the current setting of the weights w. It can be shown that since each c(H, T ; w) involves minimizing M \u2208 M, which depends on w, it is not convex. Therefore, we can't hope to globally optimize our cost functions over w and must settle for an approximation. One approach is to use coordinate ascent over M and w. Suppose that we begin with arbitrary weights and given these weights choose M (i) to minimize each c(H (i) , T (i) ; w). Then we use a relaxed form of the cost function where we use the matchings found in the last step: \u0109(H (i) , T (i) ; w) = 1 |H V | v\u2208H s(w T \u03a6(v, M (i) (v))) Then we maximize w with respect to \u2113(w) with each c(\u2022) replaced with the cost-function \u0109(\u2022). This step involves only logistic regression. We repeat this procedure until our weights converge. To test the effectiveness of the above procedure we compared performance against baseline settings using a random split on the development set. Picking each weight uniformly at random resulted in 53% accuracy. Setting all weights identically to an arbitrary value gave 54%. The procedure above, where the weights are initialized to the same value, resulted in an accuracy of 57%. However, we believe there is still room for improvement since carefully-hand chosen weights results in comparable performance to the learned weights on the final test set. We believe this setting of learning under matchings is a rather general one and could be beneficial to other domains such as Machine Translation. In the future, we hope to find better approximation techniques for this problem. Checks One systematic source of error coming from our basic approach is the implicit assumption of upwards monotonicity of entailment; i.e., if T entails H then adding more words to T should also give us a sentence which entails H. This assumption, also made by other recent abductive approaches (Moldovan et al., 2003) , does not hold for several classes of examples. Our formalism does not at present provide a general solution to this issue, but we include special case handling of the most common types of cases, which we outline below. 4 These checks are done after graph matching and assume we have stored the minimal cost matching. Negation Check Text: Clinton's book is not a bestseller Hypothesis: Clinton's book is a bestseller To catch such examples, we check that each hypothesis verb is not matched to a text word which is negated (unless the verb pairs are antonyms) and vice versa. In this instance, the is in H, denoted by is H , is matched to is T which has a negation modifier, not T , absent for is H . So the negation check fails. Factive Check Text: Clonaid claims to have cloned 13 babies worldwide. Hypothesis: Clonaid has cloned 13 babies. Non-factive verbs (claim, think, charged, etc.) in contrast to factive verbs (know, regret, etc.) have sentential complements which do not represent true propositions. We detect such cases, by checking that each verb in H that is matched in T does not have a non-factive verb for a parent. Superlative Check Text: The Osaka World Trade Center is the tallest building in Western Japan. Hypothesis: The Osaka World Trade Center is the tallest building in Japan. In general, superlative modifiers (most, biggest, etc.) invert the typical monotonicity of entailment and must be handled as special cases. For any noun n with a superlative modifier (part-of-speech JJS) in H, we must ensure that all modifier relations of M (n) are preserved in H. Additionally, during error analysis on the development set, we spotted the following cases where our VertexSub function erroneously labeled vertices as similar, and required special case consideration: \u2022 Antonym Check: We consistently found that the WordNet::Similarity modules gave highsimilarity to antonyms. 5 We explicitly check whether a matching involved antonyms and reject unless one of the vertices had a negation modifier. \u2022 Numeric Mismatch: Since numeric expressions typically have the same part-of-speech tag (CD), they were typically matched when exact matches could not be found. However, mismatching numerical tokens usually indicated that H was not entailed, and so pairs with a numerical mismatch were rejected. Experiments and Results For our experiments we used the devolpement and test sets from the Recognizing Textual Entailment challenge (Dagan et al., 2005) . We give results for our system as well as for the following systems: \u2022 Bag-Of-Words: We tokenize the text and hypothesis and strip the function words, and stem the resulting words. The cost is given by the fraction of the hypothesis not matched in the text. \u2022 TF-IDF: Similar to Bag-Of-Words except that there is a tf.idf weight associated with each hypothesis word so that more \"important\" words are higher weight for matching. We also present results for two graph matching (GM) systems. The GM-General system fits a single global threshold from the development set. The GM-ByTask system fits a different threshold for each of the tasks. Our results are summarized in Table 2 . As the result indicates, the task is particularly hard; all RTE participants scored between 50% and 60% in terms of overall accuracy (Dagan et al., 2005) . Nevevertheless, both GM systems perform better than either Bag-Of-Words or TF-IDF. CWS refers to Confidence Weighted Score (also known as average precision). This measure is perhaps a more insightful measure, since it allows the inclusion of a ranking of answers by confidence and assesses whether you are correct on the pairs that you are most confident that you know the answer to. To assess CWS, our n answers are sorted in decreasing order by the confidence we return, and then for each i, we calculate a i , our accuracy on our i most confident predictions. Then CWS = 1 n n i=1 a i . We also present results on a per-task basis in Table 3. Interestingly, there is a large variation in performance depending on the task. Conclusion We have presented a learned graph matching approach to approximating textual entailment which outperforms models which only match at the word level, and is competitive with recent weighed abduction models (Moldovan et al., 2003) . In addition, we explore problematic cases of nonmonotonicity in entailment, which are not naturally handled by either subgraph matching or the so-called \"logic form\" Table 4 : Analysis of results on some RTE examples along with out guesses and confidence probabilities inference of (Moldovan et al., 2003) and have proposed a way to capture common cases of this phenomenon. We believe that the methods employed in this work show much potential for improving the state-of-the-art in computational semantic inference. Acknowledgments Many thanks to Rajat Raina, Christopher Cox, Kristina Toutanova, Jenny Finkel, Marie-Catherine de Marneffe, and Bill MacCartney for providing us with linguistic modules and useful discussions. This work was supported by the Advanced Research and Development Activity (ARDA)'s Advanced Question Answering for Intelligence (AQUAINT) program.",
    "abstract": "We present a system for deciding whether a given sentence can be inferred from text. Each sentence is represented as a directed graph (extracted from a dependency parser) in which the nodes represent words or phrases, and the links represent syntactic and semantic relationships. We develop a learned graph matching approach to approximate entailment using the amount of the sentence's semantic content which is contained in the text. We present results on the Recognizing Textual Entailment dataset (Dagan et al., 2005) , and show that our approach outperforms Bag-Of-Words and TF-IDF models. In addition, we explore common sources of errors in our approach and how to remedy them.",
    "countries": [
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "167",
    "year": "2005",
    "month": "October",
    "title": "Robust Textual Inference via Graph Matching"
}