{
    "article": "This paper explores an optimality-theoretic approach to syntax based on Tree-Adjoining Grammars (TAG), where two separate optimizations are responsible for the construction of local pieces of tree structure (elementary trees) and the combination of these pieces of structure. The local optimization takes a non-recursive predicate-argument structure (PA-chunk) as an underlying representation and chooses the best tree structure realizing it. The linking optimization takes as an underlying representation a tree whose nodes are labeled by PA-chunks and chooses among a set of structurally isomorphic TAG derivation trees. We provide formal definitions of the OTAG system and prove equivalence in strong generative capacity between OTAG and TAG. Finally, we apply the mechanics of the formal system to the analysis of cross-serial dependencies in Swiss-German. Definitions Let us begin with a formal definition of an OT system, adapted from (Frank and Satta, 1998) . Def. 1 An optimality system is a 4-tuple OS = Introduction Optimality Theory (OT) claims that linguistic expressions are restricted by a set of universal, mutually inconsistent and violable constraints (Prince and Smolensky, 1993) . Conflicts result in the satisfaction of higher ranked constraints at the expense of their lower ranked adversaries. The variations among languages are attributed to differences in the constraint rankings. In OT, a grammatical linguistic expression is a winner of an optimization. Given an underlying representation (UR), a generator function (Gen) produces a (potentially infinite) set of surface realizations (SRs), and a process of optimization picks the SRs that minimally violate the constraints according to a language-particular ranking. OT is a general framework that can give rise to a variety of specific formal instantiations depending on the types of representations and constraints invoked, but it is a largely unresolved question just what sort of formalism is appropriate for OT syntax. Since natural language syntax permits recursively embedded structures, this suggests that the OT optimizations ought to apply to unbounded domains. However, optimization over such structures can give rise to a system with excessive generative capacity, if the number of violations of a constraint can grow without bound as well (Frank and Satta, 1998; Wartena, 2000) . Moreover, if we look at the properties of natural language syntax, it appears that the structural tradeoffs that arise from the resolution of constraint conflict take place over local domains. We therefore propose an OT formalism based on Tree Adjoining Grammar, which we call Optimality Tree Adjoining Grammar (OTAG), where separate optimizations are responsible for the construction of local pieces of tree structure (elementary trees) and the combination of these pieces of structure.The first optimization (which we call local optimization) takes as UR a non-recursive predicate argument structure (PA-chunk) and chooses among a set of local trees generated by Gen as candidate SRs of this PA-chunk. The local optimization yields a finite tree language which serves as a set of elementary trees. The second type of optimization (which we refer to as linking optimization) takes as UR a tree whose nodes are labeled by PA-chunks (a derivation tree of sorts) and chooses among a set of structurally isomorphic TAG derivation trees, where each node in these trees is labeled by an elementary tree that is among the locally optimal outputs for the corresponding PA-chunk. {\u03a3, \u0393, Gen, C} where \u03a3 and \u0393 are the finite input and output alphabets, Gen is a relation over \u03a3 * \u00d7 \u0393 * , and C is a finite set of total functions from \u03a3 * \u00d7 \u0393 * to N . As seen in this definition, Gen maps a UR to a set of SRs, while a constraint is a function from a candidate UR-SR pair to a natural number, which we take to represent the degree of violation incurred by that candidate on that constraint. An OS gives rise to a set of optimality grammars (OG), defined in (2): Def. 2 An optimality grammar OG is an OS together with a total ordering R on C, called a ranking. Frank and Satta's definition is not directly applicable to OT syntax because it defines the URs and the SRs as strings. We assume that in syntax, the SRs are trees, while the URs are predicate-argument (PA) structures in tree form. A PA structure may contain simple and nested predicates. A simple predicate is a predicate applied over atomic arguments, i.e., arguments that do not contain predicates, as in example (1). (1) loves(John, Mary) A nested predicate is a predicate applied to other predicates, like says in example (2). (2) says(Bill, (loves(John, Mary))) We postulate a grammatical component, the PA \u2212 chunker, which breaks down a complex PA structure into simple PA structures by substituting non-atomic arguments with predicate labels, which are treated as atomic arguments in the local optimization. \u2022 C is a finite set of total functions from Chunk \u00d7 Loc to N ; \u2022 K is a finite set of total functions from \u03a8 \u00d7 \u039e to N (with \u03a8 and \u039e defined as above). The alphabets \u03a3 and \u0393 are the sets of symbols in the representations making up the UR and SR, respectively. In our current conception, \u03a3 consists of the set of predicate and argument symbols, while \u0393 contains the set of terminal and non-terminal symbols. 1 Chunk will contain the set of URs that feed the local optimization, the set of PAchunks, while Loc contains the SRs that can be the output of this process, the possible syntactic realizations of the PA-chunks. Gen C maps a PA-chunk \u03c3 \u2208 Chunk to corresponding SR \u03b3 \u2208 Loc. Gen K maps any tree structure whose nodes are labeled by (local-UR, pred-label, locally-optimal-SRs) triples to a recursive surface tree realization. C is the set of constraints on local trees, while K is the constraints over recursive trees. 2 According to definition (2), an OT grammar is obtained by imposing a unique ranking on the set of constraints. In OTAG, a ranking must be specified for each type of optimization. Def. 5 An OTAG Grammar (OTG) is an OTAS with a pair of rankings R C , R K on C and K. Grammar A. Y N A \u00a8r r a Y c Y \u00a8r r b Y L = ab * c Grammar B. Y \u00a8r r a Y N A c Y \u00a8r r b Y L = b * ac Figure 1: Related TAG grammars. With these definitions in place, we can now define the notion of optimization in an OTG. Let us begin with local optimization: Def. 6 The local optimum, LOpt(p), associated with a simple predicate argument structure p is defined recursively, as in (Frank and Satta, 1998) : LOpt i (p) = Gen C (p) if i = 0; argmin ci (LOpt i\u22121 (p)) if i \u2265 1 LOpt(p) = LOpt m (p) where m = |C| Given such a set of local optima, we can now define the linking optimization process. Assume that we have a recursive predicate argument structure \u03a0. The input to the linking optimization is a tree whose labels are taken from the following set of locally optimal pairings: \u039b = {(p, \u03c0, LOpt(p))|(p, \u03c0) \u2208 PA-Chunk(p)} Given such a \u039b, there will be a unique tree \u03c4 such that (p, \u03c0, \u03b3) is a daughter of node (p , \u03c0 , \u03b3 ) iff p contains predicate label \u03c0. Linking optimization is now defined over this \u03c4 as in definition 6, using Gen K and constraint set K. Substitution, adjoining and the Linking Optimization In traditional TAG, grammars sharing the same set of local trees can generate different languages. An example of this situation is depicted in Figure 1 , where we see two grammars that differ only in the locus of adjoining constraints and generate distinct languages. Since the linking optimization in OTAG constrains how the elementary trees that result from the local optimization are put together, the languages of these grammars could also generated by two OTAGs derived from the same OTAG system with different constraint rankings (Figure 2 ). The constraints on adjoining are implemented in the set of violable constraints K, which prohibit or require adjoining at a set of nodes. In the grammar illustrated here, C 1 requires some adjoining to take place, C 2 forbids adjoining at the root Y node of the ac elementary tree, and C 3 forbids adjoining at the lower Y node of the same tree. When C 1 is ranked above either or both of C 2 or C 3 , the higher ranked of this latter pair of constraints determines where adjoining applies, whereas when C 1 is lowest ranked, no adjoining takes place at all. Constraint reranking, then, achieves the effect of altering the loci of adjoining constraints. In principle, the linking optimization may apply globally, evaluating the whole UR against a derivation, but that would lead to the possibility of conditioning an adjunction at high levels on lower level adjunctions. In order to limit the generative power of OTAG, we require that the linking optimization apply cyclically. Each cycle adjoins a set of auxiliary trees into a single local tree, and these cycles proceed in a bottomup fashion through the PA-chunk structure that is the input to the linking optimization. The result of a linking optimization may be used for a subsequent cycle, when a derived auxiliary is adjoined. This constraint enforces a strong parallelism between the OTAG derivation and the TAG derivation. They differ only by the presence of an optimization step in OTAG, which determines where the auxiliary tree is adjoined into another elementary tree. In other words, an OTAG derivation tree represents a series of optimal adjoining operations. With this restriction in place, it turns out that the resulting formalism is exactly as powerful as the TAG formalism. Specifically, we can prove the following theorems (see appendix for proofs): Theorem 1 For any TAG G, there is a OTAG G' such that T(G) = T(G'). Theorem 2 For any OTAG G', there is a TAG G such that T(G') = T(G). OTAG in action: An illustrative example To illustrate the practical application of the formalism, we will go through the steps of a derivation of the Swiss-German cross-serial construction, and the corresponding C 1 >> C 2 >> C 3 Y \u00a8r r a Y \u00a8r r Y b c C 1 >> C 3 >> C 2 Y \u00a8r r b Y \u00a8r r Y a c {C 2 , C 3 } >> C 1 Y \u00a8r r a Y c Figure 2 : Output of OTAG grammars that differ only in constraint ranking. German and English constructions. Swiss-German exhibits cross-serial dependencies that can be modeled by the language LCross = a n b m c n d m |m, n \u2208 N (Shieber, 1985) . The German sentence exhibits center embedding -the innermost verb case-marking the innermost noun, the outermost verb case-marking the outermost noun. In the English case, there is no embedding at all: verbs always immediately precede their associated arguments. Let us consider the necessary steps in an OTAG analysis of these data. First, we must isolate the local winners. As we know, they are SRs corresponding to PA-chunks. Table 4 shows the simple predicates and the corresponding yield of the local winners in English, German, and The symbol marks the insertion site for the other SR. The question we need to tackle is what kind of trees yield these strings. We notice that the German and Swiss-German cases differ from the English case by the position of the verb with respect to its arguments. One way to account for this difference would be to invoke a Headedness constraint on the local trees, Head-Left, and a counter-constraint, e.g., Head-Right. We also invoke a local Markedness constraint such as \"Move V\" which conflicts with a Faithfulness constraint \"*trace\" (a.k.a. \"Stay!\", cf. Grimshaw1977). These constraints are defined as follows: \u2022 Move V: Raise V to T. \u2022 *trace: No traces. In German, unlike English, \"*trace\" is ranked lower than \"Move V\". Note that the overt difference between English and German can be explained by assuming the verb help raises to node Y, without assuming anything about the verb paint. However, our OTAG analysis forces us to make a theoretical commitment that paint also raises, since the tree it is part of is a winner of a local optimization under the same constraint hierarchy. We can now characterize the Swiss-German case in a way consistent with our theory of the English and German cases. At this point, we are going to make use of the linking optimization to distinguish German from Swiss-German in particular. Descriptively, Swiss-German differs from German by the fact that help intervenes between paint and its argument. This is exactly what we expect if we assume that adjoining in Swiss-German takes place at a lower node than adjoining in German. In the analysis of English and German, the node X 3 was the adjoining site. By supposing that instead, the adjoining site for Swiss-German is X 4 , we obtain the desired cross-serial dependency. To enforce this difference in adjoining sites, we need to postulate two constraints that play a role in the linking optimization by favoring nodes X 3 and X 4 , respectively. A linguistically motivated constraint favoring X 3 may be related to the relationship between Hans and PRO resulting from the adjoining. In English and German, but not in Swiss-German, Hans c-commands PRO in the output of the linking optimization. Another plausible constraint is a subcategorization constraint on the adjoining tree. Suppose the adjoining tree is of type A and node X 3 is of a particular type N. Thus, the linking optimization may involve a constraint \"C-PRO: PRO must be c-commanded\" and a constraint \"A-to-N: Adjoin trees of type A to nodes of type N\" ranked differently with respect to each other. In our case, let us suppose \"trees of type A\" means \"Auxiliary trees of type VP\" and \"Nodes of type N\" means \"Highest VP node of initial tree.\" To recount, here is how our model analysis would play out. Table 4 presents the local optimizations with candidate structures, including the winners for English (E), German (G) and Swiss-German (SG). Note that at this point the local optimization contains two constraints more than necessary to account for the data. We can prune the analysis by removing any pair of constraints that favor opposite candidates. For example, PA-chunks English German Swiss-German ([paint(Hans, house)], X) paint the house das Haus anstreichen es huus aastriiche helped(we, Hans, X) We helped Hans wir Hans hilften mer em Hans h\u00e4lfed we have the option of scrapping either the pair Head-Left, Move V or the pair Head-Right, *trace from the constraint set. If we get rid of the former pair, we will essentially be claiming that movement of the verb happens in order to position the head to the right of the verb phrase. Alternatively, if we remove the latter constraint pair, we will be suggesting that movement of the verb can only happen to the right and hence necessarily violates Head-Left. There is no reason to dismiss either scenario right away. On the other hand, some new data might discredit either alternative and persuade us to keep all constraints in the set. Finally, a third scenario may involve obligatory verb movement in both English and German/Swiss-German. In this case, the only relevant players in the constraint set are Head-Left and Head-Right, which force the movement to take the preferred direction. The optimization would include only candidate representations in which movement has occurred (i.e. Loc would be restricted to such structures, Table 3 ). Another issue in the local optimization is the realization of the argument \"Hans\" as PRO in one sentence, but as Hans in the other. This issue can only be solved by exploiting the possibility of multiple winners in the local optimizations. In other words PRO and the full argument must be indistinguishable from the point of view of the local optimization, but one or the other must be preferred in the linking optimization. The argument is simple. By virtue of our definition of the PA chunker, the predicate argument structure paint(Hans, house) is independent of the larger complex predicate it was embedded in. Consequently, the same predicate argument structure would qualify as an UR of Hans paints the house since the latter is a grammatical structure, Hans may equally surface as PRO or simply Hans. We need to update our Table once again by adding two more competitors, as shown in Table 4 . This competition is resolved in the subsequent linking optimizations as seen in Table 5 . The constraint \"*Repeat\" penalizes the repetition of a nominal element. Admittedly, this is a very crude way of enforcing the presence of PRO in the final structure. A more sophisticated way of defining *Repeat could refer to the relationship between trees with argument Arg in SpecVP on one hand, and trees with the same argument Arg in a complement position on the other. For example: *Repeat: Do not adjoin trees with complement Arg to trees with Arg in SpecVP This formulation is a better match for the type of constraints we have used in our formal treatment of OTAG so far. The role of *Repeat here is to show how multiple winners in the local optimization allow us to sneak in solutions to differences in the form of main versus embedded clauses. Recall that, if the PA-chunker is only given the simple predicate argument structure to start with, the linking optimization will involve adjoining of the null tree. Consequently, \"*Repeat\" will not play a role, as shown in Table 6 Conclusion Our proposal is a step towards a restrictive and adequate framework for handling syntactic phenomena in the spirit of OT. We have demonstrated that the generative power of any grammar specified within the framework is limited to the class of MCSLs, which many believe is the complexity class of natural languages. Appendix: Proofs of theorems We define a TAG G as a tuple (A, I, R), where A is the set of auxiliary trees, I is the set of initial trees, and R is the set of adjoining constraints associated with nodes of A \u222a I. We require that A contain a distinguished null auxiliary tree , capable of adjoining at any node. With such an tree, we can assume without loss of generality that every legal TAG/OTAG derivation involves adjoining to every node of every tree involved in the derivation. An adjoining constraint r \u2208 R specifies a set of trees S and a node d such that S cannot adjoin at d (r = * S@d). Such a constraint corresponds to the usual notion of selective adjoining constraint. Obligatory adjoining constraints can be modeled as a constraint which forbids adjoining of . Null adjoining constraints permit adjoining of only the tree . On the OTAG side, we will assume a constraint *NIL that penalizes SRs in the linking optimization in which trees present in the UR do not participate in the TAG derivation yielding the surface tree. Acknowledgments Special thanks to Paul Smolensky for helpful comments on an earlier draft. The research in this paper was supported in part by NSF grant SBR-9972807. (D) \u2264 k. Let t be the root of D and {1...n} the set of nodes in t. Let {D 1 ...D n } be a set of derivations with roots {a 1 ...a n } \u2208 A such that a i is adjoined to node i in t. Observe that (D i ) \u2264 k for 1 \u2264 i \u2264 n. D / \u2208 T (G ) iff one of the following is true: 1. t / \u2208 Loc. But D \u2208 T (G) by hypothesis, which is true only if t \u2208 A \u222a I. Since Loc = A \u222a I, t \u2208 Loc; 2. {D 1 ...D n } / \u2208 T (G ).But {D 1 ...D n } \u2208 T (G ) by the induction hypothesis; 3. \u2203k i \u2208 K|k i = * a i @i. This is true only if \u2203r i \u2208 R|r i = * a i @i. But if this were true, D \u2208 T (G) would be false. Hence k i do not exist and Proof by induction on the depth of W: Base case (W) = 0. W consists of one optimization adjoining the empty tree into some w \u2208 Loc. W / \u2208 T (G) iff one of the following is true: would be false. Hence {r 1 ...r n } do not exist and W \u2208 T (G) Induction hypothesis Suppose Claim 2 is true for any derivation W, (W ) \u2264 k. Let w be the root of W and {1...n} the set of nodes in w. Let {W 1 ...W n } be a set of derivations with roots {z 1 ...z n } \u2208 Loc such that z i is adjoined at node i. Observe that (W i ) \u2264 k for all 1 \u2264 i \u2264 n. W / \u2208 T (G) iff one of the following is true: would be false. Hence r i do not exist and W \u2208 T (G). Theorem 2. For any OTAG G', there is a TAG G such that T(G') = T(G). Here, we will also give a general procedure for converting a OTAG into an equivalent TAG. Before we proceed, it would be useful to informally consider the two cases that cause complications in this conversion. Both cases are easily illustrated with a minimal OTAG. Suppose Loc contains only two trees: the initial tree t and the auxiliary tree a. In addition, let t contain only two nonterminal nodes (n1, n2). Case 1: Now suppose that the constraint set K of our OTAG G contains two OA constraints, k 1 and k 2 , such that k 1 and k 2 require the adjoining of the same tree a at different nodes (n 1 , n 2 ) of the tree t (k 1 = * (A \u2212 a)@n 1 ; k 2 = * (A \u2212 a)@n 2 ; ). Furthermore, suppose * N ull >> k 1 >> k 2 . This constraint ranking would enforce the adjoining of a into n 2 (t) only if another instance of a is adjoined at n 1 (t). Case 2 is similar: Suppose that the constraint set K of our OTAG G contains two NA constraints, k 1 and k 2 against adjoining any auxiliary tree a at either one of two different nodes (n 1 , n 2 ) of the same tree t. Furthermore, suppose * N ull >> k 1 >> k 2 . This constraint ranking would allow adjoining into n 1 (t) only if adjoining has taken place already at n 2 (t). It is clear from these cases that a simple translation of constraints into adjoining constraints is not sufficient. The violated OA constraint k 2 cannot be emulated by an OA constraint forcing a to adjoin at n 2 (because the adjoining fails when a is not adjoined at n 1 ); nor does it correspond to a SA constraint that merely allows adjoining of a at n 2 (because it the adjoining is obligatory whenever an instance of a is already adjoined at n 1 ). Thus, instead of picking a single type of constraint to place on each elementary tree, we need to multiply out the trees in Loc affected by problematic constraint sets of this type. The tree t corresponds to a subset of two trees in the elementary tree set of the corresponding TAG: One tree has an OA constraint on node n 1 . The other has an NA constraint on node n 2 . Similarly, the violated NA constraint k 2 cannot be emulated by a NA constraint against a on n 1 (because the adjoining could occur if an instance of a is already adjoined at n 2 ). Neither can it be completely disregarded, because it prevents a from adjoining into n 1 if a has not adjoined to n 2 beforehand. The tree t maps to a subset of two trees in the elementary tree set of the corresponding TAG: One tree has an NA constraint on n 1 , the other has an OA constraint on n 2 . Let G' be a OT AG = {\u03a3, \u0393, \u03a0, Chunk, Loc, Gen C , Gen K , C, K} with rankings R C and R K . Then TAG G = {A, I, R}, obtained based on the outcome of all linking optimizations involving the adjoining of a set S of trees from Loc into some tree t in Loc (note that |S| \u2264 the number of non-terminals in t). Conversion algorithm: Step 1: Create a table T t of size n\u00d7p associated with each tree t in Loc, where n is the number of nodes in t, and p is the number of possible multisets of trees Z drawn from Loc of cardinality n. In each cell (j, k), enter all trees z \u2208 Z adjoined to node j in some linking optimization over \u03a5, where \u03a5 is a UR tree whose nodes are labeled with triples (\u03c3 i , \u03c0, \u03b3 i ) and \u222a(\u03b3 i ) = k. Step 2: For every tree t \u2208 Loc, create a set of elementary trees E t containing distinct copies of t for each cell of T t . For each such t (i,j) \u2208 E t , create adjoining constraints r = * A \u2212 T t (i, j)@h, where h is the name of the copy of node i in t (i,j) . Claim 1: Proof by induction on depth of W . Base case Let (W ) = 0. W involves one optimization adjoining of only instances of the empty tree into some w \u2208 Loc. W / \u2208 T (G) iff one of the following is true: 1. w / \u2208 A \u222a I. But A \u222a I \u2287 Loc and w \u2208 Loc. Hence w \u2208 A \u222a I. 2. \u2203r 1 ...r n \u2208 R|r i = * { }@i, i a node \u2208 t. This is true only if never adjoins into w in the linking optimization of G'. But if this were the case, W \u2208 T (G ) would be false. Hence {r 1 ...r n } do not exist and W \u2208 T (G) Induction hypothesis Suppose Claim 1 is true for any derivation (W ) \u2264 k. Let w be the root of W and {1...n} the set of nodes in w. Let {W 1 ...W n } be a set of derivations,(W i ) \u2264 k with roots {z 1 ...z n } \u2208 Loc such that z i is adjoined at node i. W / \u2208 T (G) iff one of the following is true: 1. w / \u2208 A \u222a I. But w \u2208 T (G ) by hypothesis, which is true only if w \u2208 Loc. Since A \u222a I contains copies of all the trees in Loc, w \u2208 A \u222a I; 2. {W 1 ...W n } / \u2208 T (G). But {W 1 ...W n } \u2208 T (G) by hypothesis; 3. \u2203r i \u2208 R|r i = * z i @i. This is true only if G' disallows adjoining of z i to i, in which case W \u2208 T (G ) would be false. Hence r i do not exist and W \u2208 T (G).  3. \u2203k i \u2208 K|k i = * a i @i. This is true only if \u2203r i \u2208 R|r i = * a i @i. But if r i \u2208 R was true D \u2208 T (G) would be false. Hence k i do not exist and D \u2208 T (G ).",
    "abstract": "This paper explores an optimality-theoretic approach to syntax based on Tree-Adjoining Grammars (TAG), where two separate optimizations are responsible for the construction of local pieces of tree structure (elementary trees) and the combination of these pieces of structure. The local optimization takes a non-recursive predicate-argument structure (PA-chunk) as an underlying representation and chooses the best tree structure realizing it. The linking optimization takes as an underlying representation a tree whose nodes are labeled by PA-chunks and chooses among a set of structurally isomorphic TAG derivation trees. We provide formal definitions of the OTAG system and prove equivalence in strong generative capacity between OTAG and TAG. Finally, we apply the mechanics of the formal system to the analysis of cross-serial dependencies in Swiss-German. Definitions Let us begin with a formal definition of an OT system, adapted from (Frank and Satta, 1998) . Def. 1 An optimality system is a 4-tuple OS =",
    "countries": [
        "United States"
    ],
    "languages": [
        "English",
        "German"
    ],
    "numcitedby": "0",
    "year": "2004",
    "month": "May",
    "title": "Tree-adjoining Grammars for {O}ptimality {T}heory Syntax"
}