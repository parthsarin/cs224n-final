{
    "article": "This paper presents a new word alignment method which incorporates knowledge about Bilingual Multi-Word Expressions (BMWEs). Our method of word alignment first extracts such BMWEs in a bidirectional way for a given corpus and then starts conventional word alignment, considering the properties of BMWEs in their grouping as well as their alignment links. We give partial annotation of alignment links as prior knowledge to the word alignment process; by replacing the maximum likelihood estimate in the M-step of the IBM Models with the Maximum A Posteriori (MAP) estimate, prior knowledge about BMWEs is embedded in the prior in this MAP estimate. In our experiments, we saw an improvement of 0.77 Bleu points absolute in JP-EN. Except for one case, our method gave better results than the method using only BMWEs grouping. Even though this paper does not directly address the issues in Cross-Lingual Information Retrieval (CLIR), it discusses an approach of direct relevance to the field. This approach could be viewed as the opposite of current trends in CLIR on semantic space that incorporate a notion of order in the bag-of-words model (e.g. co-occurences). Introduction Word alignment (Brown et al., 1993; Vogel et al., 1996; Och and Ney, 2003a; Graca et al., 2007) remains key to providing high-quality translations as all subsequent training stages rely on its performance. It alone does not effectively capture many-to-many word correspondences, but instead relies on the ability of subsequent heuristic phrase extraction algorithms, such as grow-diagfinal (Koehn et al., 2003) , to resolve them. Some aligned corpora include implicit partial alignment annotation, while for other corpora a partial alignment can be extracted by state-ofthe-art techniques. For example, implicit tags such as reference number within the patent corpus of Fujii et al. (2010) provide (often many-tomany) correspondences between source and target words, while statistical methods for extracting a partial annotation, like Kupiec et al. (1993) , extract terminology pairs using linguistically predefined POS patterns. Gale and Church (1991) extract pairs of anchor words, such as numbers, proper nouns (organization, person, title), dates, and monetary information. Resnik and Melamed (1997) automatically extract domainspecific lexica. Moore (2003) extracts namedentities. In Machine Translation, Lambert and Banchs (2006) extract BMWEs from a phrase table, which is an outcome of word alignment followed by phrase extraction; this method does not alter the word alignment process. This paper introduces a new method of incorporating previously known many-to-many word correspondences into word alignment. A well-known method of incorporating such prior knowledge in Machine Learning is to replace the likelihood maximization in the M-step of the EM algorithm with either the MAP estimate or the Maximum Penalized Likelihood (MPL) estimate (McLach-lan and Krishnan, 1997; Bishop, 2006) . Then, the MAP estimate allows us to incorporate the prior, a probability used to reflect the degree of prior belief about the occurrences of the events. A small number of studies have been carried out that use partial alignment annotation for word alignment. Firstly, Graca et al. (2007) introduce a posterior regularization to employ the prior that cannot be easily expressed over model parameters such as stochastic constraints and agreement constraints. These constraints are set in the E-step to discard intractable alignments contradicting these constraints. This mechanism in the E-step is in a similar spirit to that in GIZA++ for IBM Model 3 and 4 which only searches around neighbouring alignments around the Viterbi alignment. For this reason, this algorithm is not intended to be used combined with IBM Models 3 and 4. Although theoretically it is possible to incorporate partial annotation with a small change in its code, Graca et al. do not mention it. Secondly, Talbot (2005) introduces a constrained EM method which constrains the E-step to incorporate partial alignment into word alignment, 1 which is in a similar manner to Graca et al. (2007) . He conducted experiments using partial alignment annotation based on cognate relations, a bilingual dictionary, domain-specific bilingual semantic annotation, and numerical pattern matching. He did not incorporate BMWEs. Thirdly, Callison-Burch et al. (2004) replace the likelihood maximization in the M-step with mixed likelihood maximization, which is a convex combination of negative log likelihood of known links and unknown links. The remainder of this paper is organized as follows: in Section 2 we define the anchor word alignment problem. In Section 3 we include a review of the EM algorithm with IBM Models 1-5, and the HMM Model. Section 4 describes our own algorithm based on the combination of BMWE extraction and the modified word alignment which incorporates the groupings of BMWEs and enforces their alignment links; we explain the EM algorithm with MAP estimation 1 Although the code may be similar in practice to our Prior Model I, his explanation to modify the E-step will not be applied to IBM Models 3 and 4. Our view is to modify the M-step due to the same reason above, i.e. GIZA++ searches only over the alignment space around the Viterbi alignment. with three kinds of priors. In Section 5 our experimental results are presented, and we conclude in Section 6. Anchor Word Alignment Problem The input to standard methods of word alignment is simply the sentence-aligned corpus, whereas our alignment method takes in additionally a partial alignment. We assume, therefore, the availability of a partial alignment, for example via a MWE extraction tool. Let \u0207 denote an English sentence, and e denote an English word, throughout this paper. The anchor word alignment problem is defined as follows: Definition 1 (Anchor Word Alignment Problem) Let (\u0207, f ) = {(\u0207 1 , f1 ), . . . , (\u0207 n , fn )} be a parallel corpus. By prior knowledge we additionally have knowledge of anchor words (\u00ea, f ) = {(sent i , t e 1 , t f 1 , pos e 1 , pos f 1 , length e , length f ), . . ., (sent k , t en , t fn , pos en , pos fn , length e , length f )} where sent i denotes sentence ID, pos e i denotes the position of t e i in a sentence \u0207i , and length e (and length f ) denotes the sentence length of the original sentence which includes e i . Under a given (\u0207, f ) and (\u00ea, f ), our objective is to obtain word alignments. It is noted that an anchor word may include a phrase pair which forms n-to-m mapping objects. Table 1 shows two example phrase pairs for French to English c'est la vie and that is life, and la vie en rose and rosy life with the initial value for the EM algorithm, the prior value and the fi-  There are 5 columns for each term: sentence number, source term, target term, source position, and target position. The number appended to each term from the patent corpus (lower half) is a reference number. In this corpus, all the important technical terms have been identified and annotated with reference numbers. nal lexical translation probability for Giza++ IBM Model 4 and that of our modified Giza++. Our modified Giza++ achieves the correct result when anchor words 'life' and 'vie' are used to assign a value to the prior in our model. Word Alignment We review two models which address the problem of word alignment. The aim of word alignment is to obtain the model parameter t among English and French words, e i and f j respectively. We search for this model parameter under some model M where M is chosen by IBM Models 1-5 and the HMM model. We introduce the latent variable a, which is an alignment function with the hypothesis that each e and f correspond to this latent variable. (e, f, a) is a complete data set, and (e, f ) is an incomplete data set. EM Algorithm We follow the description of the EM algorithm for IBM Models of Brown et al. (1993) but introduce the parameter t explicitly. In this model, the parameter t represents the lexical translation proba-bilities t(e i |f j ). It is noted that we use e|f rather than f |e following the notation of Koehn (2010) . One important remark is that the Viterbi alignment of the sentence pair (\u0207, f ) = (e J 1 , f I 1 ), which is obtained as in ( 1 ): E viterbi : \u00e2J 1 = arg max a J 1 p \u03b8(f, a|e) (1) provides the best alignment for a given loglikelihood distribution p \u03b8(f, a|e). Instead of summing, this step simplifies the E-step. However, under our modification of maximum likelihood estimate with MAP estimate, this simplification is not a correct approximation of the summation since our surface in the E-step is greatly perturbed by the prior. There is no guarantee that the Viterbi alignment is within the proximity of the target alignment (cf. Table 1 ). Let z be the latent variable, t be the parameters, and x be the observations. The EM algorithm is an iterative procedure repeating the E-step and the M-step as in ( 2 ): E EXH : q(z; x) =p(z|x; \u03b8) (2) M MLE : t \u2032 = arg max t Q(t, t old ) = arg max t x,z q(z|x) log p(x, z; t) In the E-step, our knowledge of the values of the latent variables in a is given only by the posterior distribution p(a|e, f, t). Hence, the (negative log)-likelihood of complete data (e, f, a), which we denote by \u2212 log p(t|e, f, a), is obtained over all possible alignments a. We use the current parameter values t old to find the posterior distribution of the latent variables given by p(a|e, f, t old ). We then use this posterior distribution to find the expectation of the complete data log-likelihood evaluated for parameter value t. This expectation is given by a p(a|e, f, t old ) log p(e, f, a|t). In the M-step, we use a maximal likelihood estimation to minimize negative log-likelihood in order to determine the parameter t; note that t is a lexical translation probability. Instead of using the log-likelihood log p(a, e, f |t), we use the expected complete data log-likelihood over all the possible alignments a that we obtained in the E-step, as in (3): M MLE : t \u2032 = arg max t Q(t, t old ) (3) = c(f |e; f, e) e c(f |e; f, e) where an auxiliary function c(e|f ; e, f ) for IBM Model 1 introduced by Brown et al. is defined as c(f |e; f, e) = a p(a|e, f ) m j=1 \u03b4(f, f j )\u03b4(e, e a j ) and where the Kronecker-Delta function \u03b4(x, y) is 1 if x = y and 0 otherwise. This auxiliary function is convenient since the normalization factor of this count is also required. We note that if we use the MAP estimate, the E-step remains the same as in the maximum likelihood case, whereas in the M-step the quantity to be minimized is given by Q(t, t old ) + log p(t). Hence, we search for the value of t which maximizes the following equation: M MAP : t \u2032 = arg max t Q(t, t old ) + log p(t) HMM A first-order Hidden Markov Model (Vogel et al., 1996) uses the sentence length probability p(J|I), the mixture alignment probability p(i|j, I), and the translation probability, as in (4): p(f |e) = p(J|I) J j=1 p(f j |e i ) (4) Suppose we have a training set of R observation sequences X r , where r = 1, \u2022 \u2022 \u2022 , R, each of which is labelled according to its class m, where m = 1, \u2022 \u2022 \u2022 , M , as in (5): p(i|j, I) = r(i \u2212 j I J ) I i \u2032 =1 r(i \u2032 \u2212 j I J ) (5) The HMM alignment probabilities p(i|i \u2032 , I) depend only on the jump width (i \u2212 i \u2032 ). Using a set of non-negative parameters s(i \u2212 i \u2032 ), we have (6): Algorithm 1 consists of seven steps. We use the Model I prior for the case where our prior knowledge is sparse and evenly distributed throughout the corpus, whereas we use the Model II prior when our prior knowledge is dense in a partial corpus. A typical example of the former case is when we use partial alignment annotation extracted throughout a corpus for bilingual terminology. A typical example of the latter case is when a sample of only a few hundred lines from the corpus have been hand-annotated. p(i|i \u2032 , I) = s(i \u2212 i \u2032 ) I l=1 s(l \u2212 i \u2032 ) (6 MWE Extraction Our algorithm of extracting MWEs is a statistical method which is a bidirectional version of Kupiec (1993) . Firstly, Kupiec presents a method to extract bilingual MWE pairs in a unidirectional manner based on the knowledge about typical POS patterns of noun phrases, which is languagedependent but can be written down with some ease by a linguistic expert. For example in French they are N N, N prep N, and N Adj. Secondly, we take the intersection (or union) of extracted bilingual MWE pairs. 2 Algorithm 2 MWE Extraction Algorithm Given: a parallel corpus and a set of anchor word alignment links: 1. We use a POS tagger (Part-Of-Speech Tagger) to tag a sentence on the SL side. Let SL be the source language side and TL be the target language side. The procedure is shown in Algorithm 2. We informally evaluated the MWE extraction tool following Kupiec (1993) by manually inspecting the mapping of the 100 most frequent terms. For example, we found that 93 of the 100 most frequent English terms in the patent corpus were correctly mapped to their Japanese translation. Depending on the corpus, we can use more prior knowledge about implicit alignment links. For example in some categories of patent and technical documents corpora, 3 we can use heuristics to extract the \"noun phrase\" + \"reference number\" from both sides. This is due to the fact that terminology is often labelled with a unique reference number, which is labelled on both the SL and TL sides. Prior Model I Prior for Exhaustive Alignment Space IBM Models 1 and 2 implement a prior for all possible 3 Unlike other language pairs, the availability of Japanese-English parallel corpora is quite limited: the NT-CIR patent corpus (Fujii et al., 2010) of 3 million sentence pairs (the latest NTCIR-8 version) for the patent domain and JENAAD corpus (Utiyama and Isahara, 2003) of 150k sentence pairs for the news domain. In this regard, the patent domain is particularly important for this particular language pair. Algorithm 3 Prior Model I for IBM Model 1 Given: parallel corpus \u0207, f , anchor words biT erm initialize t(e|f ) uniformly do until convergence set count(e|f ) to 0 for all e,f set total(f) to 0 for all f for all sentence pairs (\u0207 s , fs ) prior(e|f )s = getPriorModelI(\u0207, f , biT erm) for all words e in \u0207s total s (e) = 0 for all words f in fs total s (e) += t(e|f ) for all words e in \u0207s for all words f in fs count(e|f )+=t(e|f )/totals(e)\u00d7 prior(e|f )s total(f) += t(e|f )/totals(e) \u00d7 prior(e|f )s for all f for all e t(e|f ) = count(e|f )/total(f ) alignments exhaustively. Such a prior requires the following two conditions. Firstly, partial knowledge about the prior that we use in our context is defined as follows. Let us denote a bilingual term list T = {(s 1 , t 1 ), . . . , (s m , t m )}. For example with IBM Model 1: Let us define the following prior p(e|f, e, f ; T ) from Equation (4): p(e|f, e, f ; T ) = \uf8f1 \uf8f2 \uf8f3 1 (ei = si, fj = tj) 0 (ei = si, fj = tj) 0 (ei = si, fj = tj) uniform (ei = si, fj = tj) Secondly, this prior should be proper for the exhaustive case and non-proper for the sampled alignment space where by proper we mean that the probability is normalized to 1. Algorithm 3 shows the pseudo-code for Prior Model I. Note that if the prior is uniform in the MAP estimation, this is equivalent to maximum likelihood estimation. Prior for Sampled Alignment (Function) Space Due to the exponential costs introduced by fertility, null token insertion, and distortion probability, IBM Models 3 and 4 do not consider all (I + 1) J alignments exhaustively, but rather a small subset in the E-step. Each iteration only uses the subset of all the alignment functions: this sampling is not uniform, as it only includes the best possible alignment with all its neighbouring alignments which differ from the best alignment by one word (this can be corrected by a move operation) or two words (this can be corrected by a swap operation). If we consider the neighbouring alignment via a move or a swap operation, two issues arise. Firstly, the fact that these two neighbouring alignments are drawn from different underlying distributions needs to be taken into account, and secondly, that the application of a move and a swap operation alters a row or column of a prior matrix (or indices of the prior) since either operation involves the manipulation of links. Algorithm 4 Pseudo-code for Prior Model II Exhaustive Alignment Space def getPriorModelII(\u0207, f ,biTerm): for i in sentence: for e in \u0207i : allWords i = length of sentence \u0207 for f in fi : if (e, f ) in biTerm: n= num of anchor words in i uni(e|f ) i = allWords i \u2212n allWords i expSum(e|f ) += uni(e|f )i \u00d7 n else: countSum(e|f )i += n countSum(e|f ) += count(e|f ) i for e in all e : for f in all f : prior(e|f ) = expSum(e|f ) + countSum(e|f ) return prior(e|f ) Prior for Jump Width i \u2032 One implementation of HMM is to use the forward-backward algorithm. A prior should be embedded within the forward-backward algorithm. From Equation ( 6 ), there are three cases which depend on whether a i and its neighbouring alignment a i\u22121 are determined by our prior knowledge about anchor words or not. When both a i and a j are determined, this probability is expressed as in (7): Prior for Sampled Alignment (Function) Space This is identical to that of the Prior Model II exhaustive alignment space with only a difference in the normalization process. Prior for Jump Width i \u2032 This categorization of Prior Model II is the same as that of Prior Model I for for Jump Width i \u2032 (see Section 4.2). Note that Prior Model II requires more memory compared to the Prior Model I. 6 Experimental Settings The baseline in our experiments is a standard log-linear phrase-based MT system based on Moses. The GIZA++ implementation (Och and Ney, 2003a) of IBM Model 4 is used as the baseline for word alignment, which we compare to our modified GIZA++. Model 4 is incrementally trained by performing 5 iterations of Model 1, 5 iterations of HMM, 5 iterations of Model 3, and 5 iterations of Model 4. For phrase extraction the grow-diag-final heuristics are used to derive the refined alignment from bidirectional alignments. We then perform MERT while a 5-gram language model is trained with SRILM. Our implementation is based on a modified version of GIZA++ (Och and Ney, 2003a) . This modification is on the function that reads a bilingual terminology file, the function that calculates priors, the M-step in IBM Models 1-5, and the forward-backward algorithm in the HMM Model. Other related software tools are written in Python and Perl: terminology concatenation, terminology numbering, and so forth. Experimental Results We conduct an experimental evaluation on the NTCIR-8 corpus (Fujii et al., 2010) and on Europarl (Koehn, 2005) . Firstly, MWEs are extracted from both corpora, as shown in Table 3 . In the second step, we apply our modified version of GIZA++ in which we incorporate the results of 6 This is because it needs to maintain potentially an \u2113 \u00d7 m matrix, where \u2113 denotes the number of English tokens in the corpus and m denotes the number of foreign tokens, even if the matrix is sparse. Prior Model I only requires an l \u00d7 m matrix where l is the number of English tokens in a sentence and m is the number of foreign tokens in a sentence, which is only needed until this information is incorporated in a posterior probability during the iterative process. Finally, in the fifth step, we run MERT, and proceed with decoding before automatically evaluating the translations. Table 4 shows the results where 'baseline' indicates no BMWE grouping nor prior, and 'base-line2' represents a BMWE grouping but without the prior. Although 'baseline2' (BMWE grouping) shows a drop in performance in the JP-EN / EN-JP 50k sentence pair setting, Prior Model I results in an increase in performance in the same setting. Except for EN-ES 200k, our Prior Model I was better than 'baseline2'. For EN-JP NT-CIR using 200k sentence pairs, we obtained an absolute improvement of 0.77 Bleu points compared to the 'baseline'; for EN-JP using 50k sentence pairs, 0.75 Bleu points; and for ES-EN Europarl corpus using 200k sentence pairs, 0.63 Bleu points. In contrast, Prior Model II did not work well. The possible reason for this is the misspecification, i.e. the modelling by IBM Model 4 was wrong in terms of the given data. One piece of evidence for this is that most of the enforced alignments were found correct in a manual inspection. For EN-JP NTCIR using the same corpus of 200k, although the number of unique MWEs ex- tracted by the statistical method and the heuristic method varies significantly, the total number of MWEs by each method becomes comparable. The resulting Bleu score for the heuristic method (24.24 / 22.48 Blue points for 200k EN-JP / JP-EN) is slightly better than that of the statistical method. The possible reason for this is related to the way the heuristic method groups terms including reference numbers, while the statistical method does not. As a result, the complexity of the alignment model simplifies slightly in the case of the heuristic method. Conclusion This paper presents a new method of incorporating BMWEs into word alignment. We first detect BMWEs in a bidirectional way and then use this information to do groupings and to enforce already known alignment links. For the latter process, we replace the maximum likelihood estimate in the M-step of the EM algorithm with the MAP estimate; this replacement allows the incorporation of the prior in the M-step of the EM algorithm. We include an experimental investigation into incorporating extracted BMWEs into a word aligner. Although there is some work which incorporates BMWEs in groupings, they do not enforce alignment links. There are several ways in which this work can be extended. Firstly, although we assume that our a priori partial annotation is reliable, if we extract such MWEs automatically, we cannot avoid erroneous pairs. Secondly, we assume that the reason why our Prior Model II did not work was due to the misspecification (or wrong modelling). We would like to check this by discriminative modelling. Thirdly, although here we extract BMWEs, we can extend this to extract paraphrases and nonliteral expressions. Acknowledgments This research is supported by the Science Foundation Ireland (Grant 07/CE/I1142) as part of the Centre for Next Generation Localisation (http://www.cngl.ie) at Dublin City University and Trinity College Dublin. We would also like to thank the Irish Centre for High-End Computing. (7) 1 (e i = s i , f j = t j for a i ) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for a j ) When either a i or a j is determined, this probability is expressed as in (8): 4 When neither a i nor a j is determined, this probability is expressed as in (9): 5 Prior Model II Prior Model II assumes that we have prior knowledge only in some part of the training corpus. A typical example is when a small part of the corpus has a hand-crafted 'gold standard' annotation. Prior for Exhaustive Alignment Space Prior Model II is used to obtain the prior probability p(e|f ) over all possible combinations of e and f . In contrast to Prior Model I, which computes the prior probability p(e|f ) for each sentence, Prior Model II computes the prior probability globally for all sentences in the corpus. Algorithm 4 shows the pseudo-code for Prior Model II Exhaustive Alignment Space. 4 condition 1 is as follows: ((ei = si, fj = tj for ai) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for aj)) or ((ei = si, fj = tj for ai) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for aj)) or ((ei = si, fj = tj for ai) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for aj)) or ((ei = si, fj = tj for ai) and (e 'condition 2' is as follows: ((ei = si, fj = tj for ai) and (e 5 'condition 3' is as follows: ((ei = si, fj = tj for ai) and (e 'condition 4' is as follows: ((ei = si, fj = tj for ai) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for aj)) or ((ei = si, fj = tj for ai) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for aj)) or ((ei = si, fj = tj for ai) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for aj)) or ((ei = si, fj = tj for ai) and (e \u2032 i = s \u2032 i , f \u2032 j = t \u2032 j for aj))",
    "abstract": "This paper presents a new word alignment method which incorporates knowledge about Bilingual Multi-Word Expressions (BMWEs). Our method of word alignment first extracts such BMWEs in a bidirectional way for a given corpus and then starts conventional word alignment, considering the properties of BMWEs in their grouping as well as their alignment links. We give partial annotation of alignment links as prior knowledge to the word alignment process; by replacing the maximum likelihood estimate in the M-step of the IBM Models with the Maximum A Posteriori (MAP) estimate, prior knowledge about BMWEs is embedded in the prior in this MAP estimate. In our experiments, we saw an improvement of 0.77 Bleu points absolute in JP-EN. Except for one case, our method gave better results than the method using only BMWEs grouping. Even though this paper does not directly address the issues in Cross-Lingual Information Retrieval (CLIR), it discusses an approach of direct relevance to the field. This approach could be viewed as the opposite of current trends in CLIR on semantic space that incorporate a notion of order in the bag-of-words model (e.g. co-occurences).",
    "countries": [
        "Ireland"
    ],
    "languages": [
        "French",
        "English"
    ],
    "numcitedby": "41",
    "year": "2010",
    "month": "August",
    "title": "Multi-Word Expression-Sensitive Word Alignment"
}