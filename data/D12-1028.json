{
    "article": "The possibility of deleting a word from a sentence without violating its syntactic correctness belongs to traditionally known manifestations of syntactic dependency. We introduce a novel unsupervised parsing approach that is based on a new n-gram reducibility measure. We perform experiments across 18 languages available in CoNLL data and we show that our approach achieves better accuracy for the majority of the languages then previously reported results. Introduction The true nature of the notion of dependency (after removing sedimentary deposits of rules imposed only by more or less arbitrary conventions) remains still somewhat vague and elusive. This holds in spite of a seemingly strong background intuition and even after a decade of formalized large-scale dependencybased resources being available to the research community. It is undeniable that a huge progress has been reached in the field of supervised dependency parsing, especially due to the CoNLL shared task series. However, when it comes to unsupervised parsing, there are surprisingly few clues we could rely on. As mentioned e.g. by K\u00fcbler et al. (2009) , one of the traditional linguistic criteria for recognizing dependency relations (including their head-dependent orientation) is that a head H of a construction C determines the syntactic category of C and can often replace C. Or, in words of Dependency Analysis by Reduction (Lopatkov\u00e1 et al., 2005) , stepwise deletion of dependent elements within a sentence preserves its syntactic correctness. A similar idea of dependency analysis by splitting a sentence into all possible acceptable fragments is used by Gerdes and Kahane (2011) . Of course, all the above works had to respond to the notorious fact that there are many language phenomena precluding the ideal (word by word) sentence reducibility (e.g. in the case of prepositional groups, or in the case of subjects in English finite clauses). However, we disregard their solutions tentatively and borrow only the very core of the reducibility idea: if a word can be removed from a sentence without damaging it, then it is likely to be dependent on some other (still present) word. As it is usual with dichotomies in natural languages, it seems more adequate to use a continuous scale instead of the reducible-irreducible opposition. That is why we introduce a simple reducibility measure based on n-gram corpus statistics. We employ this reducibility measure as the main feature in our unsupervised parsing procedure. The procedure is based on a commonly used Bayesian inference technique called Gibbs sampling (Gilks et al., 1996) . In our sampler, the more reducible a given token is, the more likely it is to be sampled as a dependant and not as a head. After certain number of sampling iterations, for each sentence a final dependency tree is created (one token per node, including punctuation) that maximizes the product of edge probabilities gathered along the sampling history. Our approach allows to utilize information from very large corpora. While the computationally demanding sampling procedure can be applied only on limited data, the unrepeated precomputation of statistics for reducibility estimates can easily exploit much larger data. We are not aware of any other published work on unsupervised parsing employing reducibility or a similar idea. Dominating approaches in unsupervised parsing are typically based on repeated patterns, and not on the possibility of a deletion inside a pattern. It seems that the two views of dependency (frequent co-occurrence of head-dependant pair, versus reducibility of the dependant) are rather complementary, so fruitful combinations can be hopefully expected in future. The remainder of this paper is structured as follows. Section 2 briefly outlines the state of the art in unsupervised dependency parsing. Our measure of reducibility based on a large monolingual corpus is presented in Section 3. Section 4 shows our models which serve for generating probability estimates for edge sampling described in Section 5. Experimental parsing results for languages included in CoNLL shared task treebanks are summarized in Section 6. Section 7 concludes this article. Related Work The most popular approach in unsupervised dependency parsing of the recent years is to employ Dependency Model with Valence (DMV), which was introduced by Klein and Manning (2004) . The inference algorithm was further improved by Smith (2007 ) and Cohen et al. (2008 ). Headden, Johnson and McClosky (2009) introduced the Extended Valence Grammar (EVG) and added lexicalization and smoothing. Blunsom and Cohn (2010) use tree substitution grammars, which allow learning larger dependency fragments. Unfortunately, many of these works show results only for English. 1 However, the main feature of unsupervised methods should be their applicability across a wide range of languages. Such experiments were done by Spitkovsky (2011b; 2011c) , where the parsing algorithm was evaluated on all 19 languages included in CoNLL 2006 (Buchholz and Marsi, 2006) and 2007 (Nivre et al., 2007) shared tasks. The fully unsupervised linguistic analysis (Spitkovsky et al., 2011a) shows that the unsupervised part-of-speech tags may be more useful for this task than the supervised ones. Another possibility for obtaining dependency structures for languages without any linguistically annotated resources can be the projection using a parallel treebank with a resource-rich language (typically English). McDonald et al. (2011) showed that such projection produce better structures than the current unsupervised parsers do. However, our task is different. We would like to produce structures that are not burdened by any linguistic conventions. In this paper, we describe a novel approach to unsupervised dependency parsing. Our model differs from DMV, since we employ the reducibility feature and use fertility of nodes instead of generating STOP signs. We use Gibbs sampling procedure for inference instead of Variational Bayes, which has been more common for induction of linguistic strucures. Gibbs sampling algorithm for grammar induction was used also by Mare\u010dek and \u017dabokrtsk\u00fd (2011) . However, their sampling algorithm produces generally nonprojective trees. Our sampler, which is described in Section 5, introduces a completely different smallchange operator that guarantees projective edges. Computing Reducibility scores We call a word (or a sequence of words) in a sentence reducible, if the sentence after removing the word remains grammatically correct. Although we cannot automatically recognize grammaticality of such newly created sentence, we can search for it in a large corpus. If we find it, we assume the word was reducible in the original sentence. Since the number of such reducible word sequences found in any corpus will be low, we determine the reducibility scores from their individual types (part-of-speech tags). This then implicitly allows some sharing of the scores between different word sequences. The necessity to search for the whole sentences in the corpus and not only for some smaller context (considering, for example, just left and right neigh-bor), which would lead to lower sparsity, is rationalized by the following example: Their children went to school. I took their children to school. The verb 'went' would be reducible in the context 'their children went to school', because the sequence 'their children to school' occurs in the second sentence. One could find such examples frequently even for large contexts. For instance, verbs in free wordorder languages can be placed almost at any position in a sentence; therefore, without the full sentence context, they would have to be considered as reducible. To prevent this, we decided to work exclusively with the full sentence context instead of shorter contexts. Other way that would lead to lower sparsity would be searching for sequences of part-of-speech tags instead of sequences of word forms. However, this also does not bring desired results. For instance, the two following sentence patterns DT NNS VBD IN DT NN . DT NNS VBD DT NN . are quite frequent in English and we can deduce from them that the preposition IN is reducible. But this is of course a wrong deduction, since the preposition cannot be removed from the prepositional phrase. Using part-of-speech tags instead of word forms is thus not suitable for computing reducibility scores. Although we search for reducible sequences of word forms in the corpus, we compute reducibility scores for sequences of part-of-speech tags. This requires to have the corpus morphologically disambiguated. A sequences of part-of-speech tags will be denoted as \"PoS n-gram\" in the following text. Assume a PoS n-gram g = [t 1 , . . . , t n ]. We go through the corpus and search for all its occurrences. For each such occurrence, we remove the respective words from the current sentence and check in the corpus whether the rest of the sentence occurs at least once elsewhere in the corpus. 2 If so, then such occurrence of PoS n-gram is reducible, otherwise it is not. We denote the number of such reducible oc- currences of PoS n-gram g by r(g). The number of all its occurrences is c(g). The relative reducibility R(g) of a PoS n-gram g is then computed as R(g) = 1 N r(g) + \u03c3 1 c(g) + \u03c3 2 , (1) where the normalization constant N , which expresses relative reducibility over all the PoS n-grams (denoted by G), causes the scores are concentrated around the value 1. N = g\u2208G (r(g) + \u03c3 1 ) g\u2208G (c(g) + \u03c3 2 ) (2) Smoothing constants \u03c3 1 and \u03c3 2 , which prevent reducibility scores from being equal to zero, are set to \u03c3 1 = g\u2208G r(g) g\u2208G c(g) , \u03c3 2 = 1 (3) This setting causes that even if a given PoS n-gram is not reducible anywhere in the corpus, its reducibility score is 1/(c(g) + 1). Tables 1, 2 , and 3 show reducibility scores of the most frequent PoS n-grams of three selected languages: English, German, and Czech. If we consider only unigrams, we can see that the scores for verbs are often among the lowest. Verbs are followed by prepositions and nouns, and the scores for adjectives Models We introduce a new generative model that is different from the widely used Dependency Model with Valence (DMV). In DMV (Klein and Manning, 2004) and in the extended model EVG (Headden III et al., 2009) , there is a STOP sign indicating that no more dependents in a given direction will be generated. Given a certain head, all its dependents in left direction are generated first, then the STOP sign in that direction, then all its right dependents and then STOP in the other direction. This process continues recursively for all generated dependents. Our model introduces fertility of a node, which substitutes the STOP sign. For a given head, we first generate the number of its left and right children  If a zero fertility is generated in both the directions, the head becomes a leaf. Besides the fertility model and the edge model, we use two more models (subtree model and distance model), which force the generated trees to have more desired shape. 4 Fertility Model We express a fertility of a node by a pair of numbers: the number of its left dependents and the number of its right dependents. For example, fertility \"1-3\" means that the node has one left and three right dependents, fertility \"0-0\" indicates that it is a leaf. Fertility is conditioned by part-of-speech tag of the node and it is computed following the Chinese restaurant process. This means that if a specific fertility has been frequent for a given PoS tag in the past, it is more likely to be generated again. The formula for computing probability of fertility f i of a word on the position i in the corpus is as follows: P f (f i |t i ) = c \u2212i (\"t i , f i \") + \u03b1P 0 (f i ) c \u2212i (\"t i \") + \u03b1 , (4) where t i is part-of-speech tag of the word on the position i, c \u2212i (\"t i , f i \") stands for the count of words with PoS tag t i and fertility f i in the history, and P 0 is a prior probability for the given fertility which depends on the total number of node dependents denoted by |f i | (the sum of numbers of left and right dependents): P 0 (f i ) = 1 2 |f i |+1 (5) This prior probability has a nice property: for a given number of nodes, the product of fertility probabilities over all the nodes is equal for all possible dependency trees. This ensures the stability of this model during the inference. Besides the basic fertility model, we introduce also an extended fertility model, which uses frequency of a given word form for generating number of children. We assume that the most frequent words are mostly function words (e.g. determiners, prepositions, auxiliary verbs, conjunctions). Such words tend to have a stable number of children, for example (i) some function words are exclusively leaves, (ii) prepositions have just one child, and (iii) attachment of auxiliary verbs depends on the annotation style, but number of their children is also not very variable. The higher the frequency of a word form, the higher probability mass is concentrated on one specific number of children and the lower Dirichlet hyperparameter \u03b1 in Equation 4 is needed. The extended fertility is described by equation P f (f i |t i , w i ) = c \u2212i (\"t i , f i \") + \u03b1e F (w i ) P 0 (f i ) c \u2212i (\"t i \") + \u03b1e F (w i ) , (6) where F (w i ) is a frequency of the word w i , which is computed as a number of words w i in our corpus divided by number of all words. Edge Model After the fertility (number of left and right dependents) is generated, the individual slots are filled using the edge model. A part-of-speech tag of each dependent is conditioned by part-of-speech tag of the head and the edge direction (position of the dependent related to the head). 5  Similarly as for the fertility model, we employ Chinese restaurant process to assign probabilities of individual dependent. P e (t j |t i , d j ) = c \u2212i (\"t i , t j , d j \") + \u03b2 c \u2212i (\"t i , d j \") + \u03b2|T | , (7) where t i and t j are the part-of-speech tags of the head and the generated dependent respectively; d j is a direction of edge between the words i and j, which can have two values: left and right. c \u2212i (\"t i , t j , d j \") stands for the count of edges t i \u2190 t j with the direction d j in the history, |T | is a number of unique tags in the corpus and \u03b2 is a Dirichlet hyperparameter. Distance Model Distance model is an auxiliary model that prevents the resulting trees from being too flat. Ideally, it would not be needed, but experiments showed that it helps to infer better trees. This simple model says that shorter edges are more probable than longer ones. We define probability of a distance between a word and its parent as its inverse value, 6 which is then normalized by the normalization constant d . P d (i, j) = 1 d 1 |i \u2212 j| \u03b3 (8) The hyperparameter \u03b3 determines the weight of this model. Subtree Model The subtree model uses the reducibility measure. It plays an important role since it forces the reducible words to be leaves and reducible n-grams to be subtrees. Words with low reducibility are forced towards the root of the tree. We define desc(i) as a sequence of tags [t l , . . . , t r ] that corresponds to all the descendants of the word w i including w i , i.e. the whole subtree of w i . The probability of such subtree is proportional to its reducibility R(desc(i)). The hyperparameter \u03b4 determines the weight of the model; s is a normalization constant. P s (i) = 1 s R(desc(i)) \u03b4 (9) sentence, so the head word of the sentence is always its right dependent. 6 Distance between any word and the technical root of the dependency tree was set to 10. Since each technical root has only one dependent, this value does not affect the model. Probability of the Whole Treebank We want to maximize the probability of the whole generated treebank, which is computed as follows: P treebank = n i=1 (P f (f i |t i , w i ) (10) P e (t i |t \u03c0(i) , d i ) (11) P d (i, \u03c0(i)) (12) P s (i)), (13) where \u03c0(i) denotes the parent of the word on the position i. We multiply the probabilities of fertility, edge, distance from parent, and subtree over all words (nodes) in the corpus. The extended fertility model P f can be substituted by its basic variant P f . Sampling Algorithm For stochastic searching for the most probable dependency trees, we employ Gibbs sampling, a standard Markov Chain Monte Carlo technique (Gilks et al., 1996) . In each iteration, we loop over all words in the corpus in a random order and change the dependencies in their neighborhood (a small change described in Section 5.2). In the end, \"average\" trees based on the whole sampling are built. Initialization Before the sampling starts, we initialize the projective trees randomly. For doing so, we tried the following two initializers: \u2022 For each sentence, we choose randomly one word as the head and attach all other words to it. \u2022 We are picking one word after another in a random order and we attach it to the nearest left (or right) neighbor that has not been attached yet. The left-right choice is made by a coin flip. If it is not possible to attach a word to one side, we attach it to the other side. The last unattached word becomes the head of the sentence. While the first method generates only flat trees, the second one can generate all possible projective trees. However, the sampler converges to similar results for both the initializations. Therefore we conclude that the choice of the initialization mechanism The dog was in the park . (((The) dog) was (in ((the) park)) (.)) ( ( ( ) ) ) (((The) dog) was in ((the) park) (.)) (((The) dog) was in ((the) park) (.)) ( ( ) ) Figure 2 : An example of small change in a projective tree. The bracket (in the park) is removed and there are five possibilities how to replace it. is not so important here and we choose the first one due to its simplicity. Small Change Operator We use the bracketing notation for illustrating the small change operator. Each projective dependency tree consisting of n words can be expressed by n pairs of brackets. Each bracket pair belongs to one node and delimits its descendants from the rest of the sentence. Furthermore, each bracketed segment contains just one word that is not embedded deeper; this node is the segment head. An example of this notation is in Figure 1 . The small change is then very simple. We remove one pair of brackets and add another, so that the conditions defined above are not violated. An example of such change is in Figure 2 . From the perspective of dependency structures, the small change can be described as follows: 1. Pick a random non-root word w (the word in in our example) and find its parent p (the word was). 2. Find all other children of w and p (the words dog, park, and .) and denote this set by C. 3. Choose the new head out of w and p. Mark the new head as g and the second candidate as d. Attach d to g. 4. Select a neighborhood D adjacent to the word d as a continuous subset of C and attach all words from D to d. D may be also empty. 5. Attach the remaining words from C that were not in D to the new head g. Building \"Average\" Trees The \"burn-in\" period is set to 10 iterations. After this period, we begin to count how many times an edge occurs at a particular location in the corpus. These counts are collected over the whole corpus with the collection-rate 0.01. 7  When the samling is finished, we build final dependency trees based on the edge counts obtained during the sampling. We employ the maximum spanning tree (MST) algorithm (Chu and Liu, 1965) to find them; the weights of edges for computing MST correspond to the number of times they were present during the sampling. This averaging method was used also by Mare\u010dek and \u017dabokrtsk\u00fd (2011) . Other possibilities for obtaining final dependency trees would be using Eisner's projective algorithm (Eisner, 1996) or using annealing method (favoring more likely changes) at the end of the sampling. However, the general non-projective MST algorithm enable non-projective edges, which are by no means negligible in treebanks (Havelka, 2007) . Experiments and Evaluation We evaluate our parser on 20 treebanks (18 languages) included in CoNLL shared tasks 2006 (Buchholz and Marsi, 2006) and 2007 (Nivre et al., 2007) . Similarly to some previous papers on unsupervised parsing (Gillenwater et al., 2011; Spitkovsky et al., 2011b) , the tuning experiments were performed on English only. We used English for checking functionality of the individual models and for optimizing hyperparameter values. The best configuration of the parser achieved on English development data was then used for parsing all other languages. This simulates the situation in which we have only one treebank (English) on which we can tune our parser and we want to parse other languages for which we have no manually annotated treebanks. language tokens (mil.) language tokens (mil. We need two kinds of data for our experiments: a smaller treebank, which is used for sampling and for evaluation, and a large corpus, from which we compute n-gram reducibility scores. The treebanks are taken from the CoNLL shared task 2006 and 2007. The experiments are performed for all languages except for Chinese. 8 We use only the testing parts of the treebanks (the files test.conll) for the dependency tree induction. As a source of the part-of-speech tags, we use the fine-grained gold PoS tags, which are in the fifth column in the CoNLL format. For obtaining reducibility scores, we used the W2C corpus 9 of Wikipedia articles, which was downloaded by Majli\u0161 and \u017dabokrtsk\u00fd (2012) . Their statistics across languages are shown in Table 4 . To make them useful, the necessary preprocessing steps must have been done. The texts were first automatically segmented and tokenized 10 and then they were part-of-speech tagged by TnT tagger (Brants, 2000) , which was trained on the respective CoNLL training data (the files train.conll). The quality of such tagging is not very high, since we do not use any lexicons 11 or pretrained models. However, it is sufficient for obtaining good reducibility scores. Setting the Hyperparameters The applicability of individual models and their parameters were tested on development data set of English (the file en/dtest.conll in CoNLL shared task 2007). After several experiments, we have observed that the extended fertility model provides better results than the basic fertility model; the parser using the basic fertility model achieved 44.1% attachment score for English, whereas the extended fertility model increased the score to 46.8%. The four hyperparameters \u03b1 e (extended fertility model), \u03b2 (edge model), \u03b3 (distance model), and \u03b4 (subtree model), were set by a grid search algorithm, 12 which found the following optimal values: \u03b1 e = 0.01, \u03b2 = 1, \u03b3 = 1.5, \u03b4 = 1 In informal experiments, parameters were tuned also for other treebanks and we found out that they vary across languages. Therefore, adjusting the hyperparameters on another language would probably change the scores significantly. Evaluation The best setting from the experiments on English is now used for evaluating our parser on all CoNLL languages. To be able to compare our parser attachment score to previously published results, the following steps must be done: \u2022 We take the testing part of each treebank (the file test.conll) and remove all the punctuation marks. If the punctuation node is not a leaf, its children are attached to the parent of the removed node. \u2022 Some previous papers report results on up-to-10-words sentences only. Therefore we extract such sentences from the test data and evaluate on this subsets as well. 12 Here we make use of manually annotated trees. However, we use only English treebank an we are setting only four numbers out of several previously given values (e.g \u03b1e out of 0.01, 0.1, 1, 10). These numbers could be tuned also by inspecting the outputs. So we believe this method can be treated as unsupervised. CoNLL \u2264 10 tokens all sentences language year gil11 our spi11 Gillenwater et al (2011) (see the best configuration in Table 7 in their paper). They provided only results on sentences of up to 10 tokens from CoNLL 2006 treebanks. Results in the column \"spi11\" are taken from Spitkovsky et al (2011b), best configuration in Table 6 in their paper. The average score in the last line is computed across all comparable results, i.e. for comparison with \"gil11\" only the CoNLL'06 results are averaged ( * ). Our parser was not evaluated on Turkish CoNLL'06 data and Chinese data, because we have not them available. The resulting scores are given in Table 5 . We compare our results with results previously reported by Gillenwater (2011) and Spitkovsky (2011b) , who used the CoNLL data for evaluation too. Since they provide results for several configurations of their parsers, we choose only the best one from each the paper. We define the best configuration as the one with the highest average attachment score across all the tested languages. We can see that our parser outperforms the previously published ones. In one case, it is better for 8 out of 10 data sets, in the other case, it is better for 14 out of 20 data sets. The average attachment scores, which are computed only from the results present for both compared parsers, also confirm the improvement. However, it is important to note that we used an additional source of information, namely large unannotated corpora for computing reducibility scores, while the others used only the CoNLL data. Error Analysis Our main motivation for developing an unsupervised dependency parser was that we wanted to be able to parse any language. However, the experiments show that our parser fails for some languages. In this section, we try to analyze and explain some of the most substantial types of errors. Auxiliary verbs in Slovenian -In the Slovenian treebank, many verbs are composed of two words: main verb (marked as Verb-main) and auxiliary verb (Verb-copula). Our parser choose the auxiliary verb as the head and the main verb and all its dependants become its children. That is why the attachment score is so poor (only 18.1%). In fact, the induced structure is not so bad. The main verb is switched with the auxiliary one which causes also the wrong attachment of all its dependants. Articles in German -Attachment of about one half of German articles is wrong. Instead of the article being attached below the appropriate noun, the noun is attached below the article. It is a similar problem as the aforementioned Slovenian auxiliary verbs. The dependency between content and function word is switched and the dependants of the content word are attached to the function word. Klein and Manning (2004) observed a similar behavior in their experiments with DMV. Noun phrases in English -The structure of phrases that consist of more nouns are often induced badly. This is caused probably by ignoring word forms. For example, the structure of the sequence 'NN NN NN' can be hardly recognized by our parser. Ablation Analysis To investigate the impact of individual components of the model, we run the parser for all possible component combinations. We choose three languages along the scale of word order freedom: English (very rigid word order), Czech (relatively free word order), and German (somewhere in the middle). The attachment scores are shown in Table 6 . If no model is used for the inference and the sampling algorithm samples completely random trees, we get the random baseline score, which is 19.8% for English 13 . From the perspective of the subtree model, which implements the reducibility feature, we can see that it is the most useful model here. Alone, it improves the score for English to 28.2%. If we do not use it, the score decreases from 46.8% (when all models are used) to 30.7%. Very important is also the distance model which eliminates the possibility of attaching all words to one head word. If we omit it, the score for English falls drastically to 14.1%. Some combinations of models have their scores far below the baseline. This is caused by the fact that some regularities have been found but the structures are induced differently and thus all attachments are wrong. Induction without Wikipedia Corpus We have performed also experiments using exclusively the CoNLL data. However, the numbers of reducible words in CoNLL training set were very low (50 words at maximum in CoNLL 2006 training data and 10 words at maximum in CoNLL 2007 training data). This led to completely unreliable reducibility scores and the consequent poor results. Conclusions and Future Work We have shown that employing the reducibility feature is useful in unsupervised dependency parsing task. We extracted the n-gram reducibility scores from a large corpus, and then made the computationally demanding inference on smaller data using only these scores. We evaluated our parser on 18 languages included in CoNLL and for 14 of them, we achieved higher attachment scores than previously published results. The most errors were caused by function words, which sometimes take over the dependents of adjacent content words. This can be caused by the fact that the reducibility cannot handle function words correctly, because they must be reduced together with a content word, not one after another. In future work, we would like to estimate the hyperparameters automatically. Furthermore, we would like to get rid of manually designed PoS tags and use some kind of unsupervised clusters in order to have all the annotation process completely unsupervised. We would also like to employ lexicalized models that should help in situations in which the PoS tags are too coarse. Finally, we would like to move towards deeper syntactic structures, where the tree would be formed only by content words and the function words would be treated in a different way. Software The source code of our unsupervised dependency parser including the script for computing reducibility scores from large corpora is available at http://ufal.mff.cuni.cz/ \u02dcmarecek/udp. Acknowledgement This research was supported by the grants GAUK 116310, GA201/09/H057 (Res Informatica), LM2010013, MSM0021620838, and by the European Commission's 7th Framework Program (FP7) under grant agreement n \u2022 247762 (FAUST). We thank anonymous reviewers for their valuable comments and suggestions.",
    "funding": {
        "defense": 0.0,
        "corporate": 0.0,
        "research agency": 1.0,
        "foundation": 0.0,
        "none": 0.0
    },
    "reasoning": "Reasoning: The acknowledgements section of the article mentions support from grants GAUK 116310, GA201/09/H057 (Res Informatica), LM2010013, MSM0021620838, and by the European Commission's 7th Framework Program (FP7) under grant agreement n \u2022 247762 (FAUST). These are indicative of research agency funding (government and European Commission grants). There is no mention of defense, corporate, or foundation funding."
}