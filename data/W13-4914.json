{
    "article": "This paper revisits the work of (Malladi and Mannem, 2013) which focused on building a Statistical Morphological Analyzer (SMA) for Hindi and compares the performance of SMA with other existing statistical analyzer, Morfette. We shall evaluate SMA in various experiment scenarios and look at how it performs for unseen words. The later part of the paper presents the effect of the predicted morph features on dependency parsing and extends the work to other morphologically rich languages: Hindi and Telugu, without any language-specific engineering. Introduction Hindi is one of the widely spoken language in the world with more than 250 million native speakers 1 . Language technologies could play a major role in removing the digital divide that exists between speakers of various languages. Hindi, being a morphologically rich language with a relatively free word order (Mor-FOW), poses a variety of challenges for NLP that may not be encountered when working on English. Morphological analysis is the task of analyzing the structure of morphemes in a word and is generally a prelude to further complex tasks such as parsing, machine translation, semantic analysis etc. These tasks need an analysis of the words in the sentence in terms of lemma, affixes, parts of speech (POS) etc. 1 http://www.ethnologue.com/statistics/size NLP for Hindi has suffered due to the lack of a high coverage automatic morphological analyzer. For example, the 2012 Hindi Parsing Shared Task (Sharma et al., 2012) held with COLING-2012 workshop had a gold-standard input track and an automatic input track, where the former had gold-standard morphological analysis, POS tags and chunks of a sentence as input and the automatic track had only the sentence along with automatic POS tags as input. The morphological information which is crucial for Hindi parsing was missing in the automatic track as the existing analyzer had limited coverage. Parsing accuracies of gold-standard input track were significantly higher than that of the other track. But in the real scenario NLP applications, gold information is not provided. Even Ambati et al. (2010b) and Bharati et al. (2009a) have exploited the role of morpho-syntactic features in Hindi dependency parsing. Hence we need a high coverage and accurate morphological analyzer. Related work Previous efforts on Hindi morphological analysis concentrated on building rule based systems that give all the possible analyses for a word form irrespective of its context in the sentence. The paradigm based analyzer (PBA) by Bharati et al. (1995) is one of the most widely used applications among researchers in the Indian NLP community. In paradigm based analysis, words are grouped into a set of paradigms based on the inflections they take. Each paradigm has a set of add-delete rules to account for its inflections and words belonging to a paradigm take the same inflectional forms. Given a word, the PBA identifies the lemma, coarse POS tag, gender, number, person, case marker, vibhakti 2 and TAM (tense, aspect, modality). Being a rule-based system, the PBA takes a word as input and gives all the possible analyses as output. (Table 1 presents an example). It doesn't pick the correct analysis for a word in its sentential context. Goyal and Lehal's analyser (2008) , which is a reimplementation of the PBA with few extensions, has not done any comparative evaluation. Kanuparthi et al. (2012) built a derivational morphological analyzer for Hindi by introducing a layer over the PBA. It identifies 22 derivational suffixes which helps in providing derivational analysis for the word whose suffix matches with one of these 22 suffixes. The large scale machine translation projects 3 that are currently under way in India use shallow parser built on PBA and an automatic POS tagger. The shallow parser prunes the morphological analyses from PBA to select the correct one using the POS tags from the tagger. Since it is based on PBA, it suffers from similar coverage issues for out of vocabulary (OOV) words. The PBA, developed in 1995, has a limited vocabulary and has received only minor upgrades since then. Out of 17,666 unique words in the Hindi Treebank (HTB) released during the 2012 Hindi Parsing Shared Task (Sharma et al., 2012) , the PBA does not have entries for 5,581 words (31.6%). Apart from the traditional rule-based approaches, Morfette (Chrupa\u0142a et al., 2008) is a modular, data-2 Vibhakti is a Sanskrit grammatical term that encompasses post-positionals and case endings for nouns, as well as inflection and auxiliaries for verbs (Pedersen et al., 2004 Malladi and Mannem (2013) have build a Statistical Morphological Analyzer (SMA) with minimal set of features but they haven't compared their system with Morfette. In our work we shall discuss in detail about SMA with more concentration on evaluating the system in various scenarios and shall extend the approach to other morphologically rich languages. Later we evaluate the effect of the predicted morph features (by SMA) on Hindi dependency parsing. Hindi Dependency Treebank (HTB) A multi layered and multi representational treebank for Hindi is developed by annotating with morpho-syntactic (morphological analyses, POS tags, chunk) and syntacto-semantic (dependency relations labeled in the computational paninian framework) information. A part of the HTB (constituting of 15,102 sentences) was released for Hindi Parsing Shared Task. Table 2 shows the word counts of training, development and test sections of HTB. With the existing morph analyzer (PBA) performing poorly on OOV words and the availability of an annotated treebank, Malladi and Mannem (2013) set out to build a high-coverage automatic Hindi morph analyzer by learning each of the seven morphological attributes separately from the Hindi Treebank. During this process, it was realized that vibhakti and TAM can be better predicted using heuristics on fine-grained POS tags than by training on the HTB. In the rest of the section, we discuss the methods used by SMA to predict each of the seven mor-  phological attributes and their effect on Hindi dependency parsing. Table 3 lists the values that each of the morph attributes take in HTB. Statistical Morphological Analyzer (SMA) The output of a morphological analyzer depends on the language that it is developed for. Analyzers for English (Goldsmith, 2000) predict just the lemmas and affixes mainly because of its restricted agreement based on semantic features such as animacy and natural gender. But in Hindi, agreement depends on lexical features such as grammatical gender, number, person and case. Hence, it is crucial that Hindi analyzers predict these along with TAM and vibhakti which have been found to be useful for syntactic parsing (Ambati et al., 2010b; Bharati et al., 2009a) . Hindi has syntactic agreement (of GNP and case) of two kinds: modifier-head agreement and nounverb agreement. Modifiers, including determiners, agree with their head noun in gender, number and case, and finite verbs agree with some noun in the sentence in gender, number and person (Kachru, 2006) . Therefore, apart from lemma and POS tags, providing gender, number and person is also crucial for syntactic parsing. 4 Lemma prediction The PBA uses a large vocabulary along with paradigm tables consisting of add-delete rules to find the lemma of a given word. All possible add-delete rules are applied on a given word form and the resulting lemma is checked against the vocabulary to find if it is right or not. If no such lemma exists (for OOV words), it returns the word itself as the lemma. While the gender, number and person of a word form varies according to the context (due to syntactic agreement with head words), there are very few cases where a word form can have more than one lemma in a context. For example, vaha can either be masculine or feminine depending on the form that the verb takes. It is feminine in vaha Gara gayI (she went home) and masculine in vaha Gara gayA (he went home). The lemma for vaha can only be vaha irrespective of the context and also the lemma for gayI and gayA is jA. This makes lemma simpler to predict among the morphological features, provided there is access to a dictionary of all the word forms along with their lemmas. Unfortunately, such a large lemma dictionary doesn't exist. There are 15,752 word types in training, 4,292 word types in development and 5,536 word types in test sections of HTB respectively. Among these 18.5% of the types in development and 20.2% in test data are unseen in training data. SMA analyzer perceives lemma prediction from a machine translation perspective, with the characters in the input word form treated as the source sentence and those in the lemma as the target. The strings on source and target side are split into sequences of characters separated by space, as shown in Table 4. The phrase based model (Koehn et al., 2007) in Moses is trained on the parallel data created from the training part of HTB. The translation model accounts for the changes in the affixes (sequence of characters) from word form to lemma whereas the language model accounts for which affixes go with which stems. In this perspective, the standard MT experiment of switching source and target to attain better accuracy would not apply since it is unreasonable to predict the word form from the lemma without taking the context into account. Apart from the above mentioned approach, we apply a heuristic on top of SMA, wherein proper nouns (NNP) take the word form itself as the lemma. Gender, Number, Person and Case Prediction Unlike lemma prediction, SMA uses SVM (support vector machine) machine learning algorithm to predict GNP and case. Though knowing the syntactic head of a word helps in enforcing agreement (and thereby accurately predicting the correct GNP), parsing is usually a higher level task and is not performed before morphological analysis. Hence, certain cases of GNP prediction are similar in nature to the standard chicken and egg problem. Gender Gender prediction is tricky in Hindi as even native speakers tend to make errors while annotating. Gender prediction in English is easy when compared to Hindi since gender in English is inferred based on the biological characteristics the word is referring to. For example, Train has neuter gender in English whereas in Hindi, it exhibits feminine characteristics. A dictionary of word-gender information may usually suffice for gender prediction in English but in Hindi it isn't the case as gender could vary based on its agreement with verb/modifier. The values that gender can take for a word in a given context are masculine(m), feminine(f ), any (either m or f ) or none (neither m nor f ). nouns (of genitive form), adjectives and verbs inflect according to the gender of the noun they refer to. Number Every noun belongs to a unique number class. Noun modifiers and verbs have different forms for each number class and inflect accordingly to match the grammatical number of the nouns to which they refer. Number takes the values singular (sg), plural (pl), any (either sg or pl) and none (neither sg nor pl). Table 6 lists examples for each of the values. In it, ladZake takes the grammatical number sg (in direct case) or pl (in oblique case) depending on the context in which it occurs. It may be noted that since PBA does not consider the word's context, it outputs both the values and leaves the disambiguation to the subsequent stages. Person Apart from first, second and third persons, Hindi also has the honorific forms, resulting in 1h, 2h and 3h. Postpositions do not have person information, hence none is also a possible value. Apart from the above mentioned grammatical person values, any is also a feasible value. Case Marker Case markers in Hindi (direct and oblique) are attributed to nouns and pronouns. Words which inflect for gender, number, person and case primarily undergo affixation at the end. Features for GNP & Case Marker The following features were tried out in building the models for gender, number, person and case prediction: \u2022 Word level features -Word -Last 2 characters -Last 3 characters -Last 4 characters -Character N-grams of the word -Lemma -Word Length \u2022 Sentence level features -Lexical category 5 -Next word -Previous word Combinations of these features have been tried out to build the SVM models for GNP and case. For each of these tasks, feature tuning was done separately. In Malladi and Mannem (2013), a linear SVM classification (Fan et al., 2008) is used to build statistical models for GNP and case but we found that with RBF kernel (non-linear SVM) 6 we achieve better accuracies. Furthermore, the parameters (C, \u03b3) of the RBF kernel are learned using grid search technique. Vibhakti and TAM Vibhakti and TAM are helpful in identifying the karaka 7 dependency labels in HTB. While nouns and pronouns take vibhakti, verbs inflect for TAM. Both TAM and vibhakti occur immediately after the words in their respective word classes. Instead of building statistical models for vibhakti and TAM prediction, SMA uses heuristics on POS tag sequences to predict the correct value. The POS tags of words following nouns, pronouns and verbs give an indication as to what the vibhakti/TAM are. Words with PSP (postposition) and NST (noun with spatial and temporal properties) tags are generally considered as the vibhakti for the preceding nouns and pronouns. A postposition in HTB is annotated as PSP only if it is written separately (usane/PRP vs usa/PRP ne/PSP). For cases where the postposition is not written separately SMA relies on the treebank data to get the suffix. Similarly, words with 5 POS is considered as a sentence level feature since tagging models use the word ngrams to predict the POS category 6 LIBSVM tool is used to build non-linear SVM models for our experiments (Chang and Lin, 2011) . 7 karakas are syntactico-semantic relations which are employed in Paninian framework (Begum et al., 2008; Bharati et al., 2009b) VAUX tag form the TAM for the immediately preceding verb. The PBA takes individual words as input and hence does not output the entire vibhakti or TAM of the word in the sentence. It only identifies these values for those words which have the information within the word form (e.g. usakA he+Oblique, kiyA do+PAST). In the sentence, rAma/NNP kA/PSP kiwAba/NN cori/NN ho/VM sakawA/VAUX hE/VAUX PBA identifies rAma's vibhakti as 0 and ho's TAM as 0. Whereas in HTB, vibhakti and TAM of rAma and ho are annotated as 0 kA and 0 saka+wA hE respectively. SMA determines this information precisely and Morfette which can predict other morph features, is not capable of predicting TAM and Vibhakti as these features are specific to Indian languages. Evaluation Systems SMA is compared with a baseline system, Morfette and two versions of the PBA wherever relevant. The baseline system takes the word form itself as the lemma and selects the most frequent value for the rest of the attributes. Since PBA is a rule based analyzer which gives more than one analysis for words, we use two versions of it for comparison. The first system is the oracle PBA (referred further as O-PBA) which uses an oracle to pick the best analysis from the list of all analyses given by the PBA. The second version of the PBA (F-PBA) picks the first analysis from the output as the correct analysis. Morfette can perdict lemma, gender, number, person and case attributes but it cannot predict TAM and Vibhakti as they do not have a definite set of predefined values unlike other morphological attributes. Experiments and Results SMA approach to Hindi morphological analysis is based on handling each of the seven attributes (lemma, gender, number, person, case, vibhakti and TAM) separately. However, evaluation is performed on individual attributes as well as on the combined output. SMA builds models for lemma, gender, number, person and case prediction trained on the training data of the HTB. All the models are tuned on development data and evaluated on test data of the HTB. Table 8 presents the accuracies of five systems (baseline, F-PBA, O-PBA, Morfette and SMA) in predicting the morphological attributes of all the words in the HTB's test data and also for OOV words of SMA (i.e. words that occur in the test section but not in training section of HTB) 8 . The accuracies are the percentages of words in the data with the correct analysis. It may be noted that SMA performs significantly better than the best analyses of PBA and the baseline system in all the experiments conducted. As far as Morfette is concerned, it performs on par with SMA in terms of overall accuracy but for OOV words, except for lemma prediction, SMA outperforms Morfette by significant margin. Table 13 lists the accuracies of lemma, gender, number, person and case for the most frequently occurring POS tags. Table 12 reports the same for OOV words. The number of OOV words in postpo-8 OOV words for SMA need not be out of vocabulary for PBA's dictionaries. Table 8 lists accuracies for OOV words of SMA. We shall also report accuracies for OOV words of PBA in the later part of the paper ( sition and pronoun categories is quite less and hence have not been included in the table. Hindi derivational morph analyzer (Kanuparthi et al., 2012) and the morph analyzer developed by Punjab University (Goyal and Lehal, 2008) do not add much to PBA accuracy since they are developed with PBA as the base. Out of 334,287 words in HTB, the derivational morph analyzer identified only 9,580 derivational variants. For the remaining words, it gives similar analysis as PBA. Lemma The evaluation metric for lemma's model is accuracy, which is the percentage of predicted lemmas that are correct. The phrase based translation system used to predict lemmas achieved an accuracy of 95.84% compared to O-PBA's 86.69%. For OOV words, the PBA outputs the word itself as the lemma whereas the translation-based lemma model is robust enough to give the analysis. The translation-based lemma model and O-PBA report accuracies of 89.51% and 82.48% respectively for OOV words of SMA. In terms of both overall and OOV accuracies, translation-based model outperforms PBA. Though SMA performs better than Morfette in terms of overall accuracy, but for OOV accuracy Morfette narrowly outperforms SMA. The postposition accuracy is significantly worse than the overall accuracy. This is because the confusion is high among postpositions in HTB. For example, out of 14,818 occurrences of ke, it takes the lemma kA in 7,763 instances and ke in 7,022 cases. This could be the result of an inconsistency in the annotation process of HTB. The accuracies for verbs are low (when compared to Nouns, Adjectives) as well mainly because verbs in Hindi take more inflections than the rest. The accuracy for verbs is even lower for OOV words (69.23% in Table 12 ). Gender, Number, Person and Case The accuracies of gender, number, person and case hover around 95% but the combined (G+N+P) accuracy drops to 91.11%. This figure is important if one wants to enforce agreement in parsing. The OOV accuracy for person is close to overall accuracy as most of the OOV words belong to the 3rd person category. It is not the same case for gender and number. Gender particularly suffers a significant drop of 14% for OOV words confirming the theory that gender prediction is a difficult problem without knowing the semantics of the word. The number and person accuracies for verbs are consistently low for OOV words as well as for seen words. This could be because SMA doesn't handle long distance agreement during GNP prediction. Until now, we reported accuracies for OOV words of SMA. analyses. In a nutshell, we have evaluated SMA for OOV words of the PBA as well as for OOV words of SMA. In both the cases, SMA performed better than other systems. We shall evaluate SMA in a challenging scenario wherein training data consists of the words from the HTB which are analyzed by the PBA and test data consists of the remaining unanalyzed words by the PBA. Thereby, the entire test data contains only out of vocabulary instances for both SMA and PBA. Table 14 presents the results of this new evaluation. The results are almost similar with that of OOV results shown in Table 8 except for Person. The reason behind that could be, in the training data there are only 0.1% instances of 3h class but in test data their presence is quite significant (approximately 10%). The training instances for 3h class were not sufficient for the model to learn and hence very few of these instances were identified correctly. This explains the drop in Person accuracy for this experiment scenario. It may be noted that, we have used gold POS tags for all our experiments related to GNP and case prediction. There are numerous efforts on building POS taggers for Hindi. The ILMT pos tagger 9 is 96.5% accurate on the test data of the HTB. Table 17 shows the evaluation results for Telugu and Urdu. Conclusion and Future work In conclusion, SMA is a robust state-of-the-art statistical morphological analyzer which outperforms previous analyzers for Hindi by a considerable margin. SMA achieved an accuracy of 63.06% for lemma, gender, number, person and case whereas PBA and Morfette are 34.89% and 51.52% accurate respectively. With the predicted morphological attributes by SMA, we achieve a labeled attachment score of 89.41 while without these morphological attributes the parsing accuracy drops to 87.75. The agreement phenomenon in Hindi provides challenges in predicting gender, number and person of words in their sentential context. These can be better predicted if dependency relations are given as input. However, the standard natural language analysis pipeline forbids using parse information during morphological analysis. This provides an opportunity to explore joint modelling of morphological analysis and syntactic parsing for Hindi. We plan to experiment this as part of our future work. Performance of Morfette is comparable to SMA 10 iiit.ac.in and for lemma prediction in the case of OOV words, Morfette outperforms SMA. We plan to build a hybrid system whose feature set includes features from both the systems. Effect on Parsing The effect of morphological features on parsing is well documented (Ambati et al., 2010a) . Previous works used gold morphological analysis to prove their point. In this work, we also evaluated the effect of automatic morph features (predicted by SMA) on dependency parsing. MALT parser was trained 2010a ) also reported similar results with gold-standard morph features. Lemma, case, vibhakti and TAM features contribute to the increase in label accuracy because of the karaka labels in Paninian annotation scheme (Begum et al., 2008) . Table 9 also lists the performance of MALT parser with gold morph features (as annotated in HTB). It may be noted that, predicted morph features had similar effect on hindi dependency parsing as of gold features which is desirable making SMA usable for real scenario applications. Extending the work to Telugu and Urdu We shall look at how SMA performs in prediciting GNP and case for other morphologically rich Indian languages: Telugu and Urdu. At this stage, we have not done any language-dependent engineering effort Language #Sentences #Words Urdu 5230 68588 Telugu 1600 6321",
    "abstract": "This paper revisits the work of (Malladi and Mannem, 2013) which focused on building a Statistical Morphological Analyzer (SMA) for Hindi and compares the performance of SMA with other existing statistical analyzer, Morfette. We shall evaluate SMA in various experiment scenarios and look at how it performs for unseen words. The later part of the paper presents the effect of the predicted morph features on dependency parsing and extends the work to other morphologically rich languages: Hindi and Telugu, without any language-specific engineering.",
    "countries": [
        "India"
    ],
    "languages": [
        "Hindi",
        "Urdu",
        "Telugu"
    ],
    "numcitedby": "5",
    "year": "2013",
    "month": "October",
    "title": "Context Based Statistical Morphological Analyzer and its Effect on {H}indi Dependency Parsing"
}