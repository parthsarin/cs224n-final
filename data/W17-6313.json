{
    "article": "We present a new transition system with word reordering for unrestricted nonprojective dependency parsing. Our system is based on decomposed arc-eager rather than arc-standard, which allows more flexible ambiguity resolution between a local projective and non-local crossing attachment. In our experiment on Universal Dependencies 2.0, we find our parser outperforms the ordinary swapbased parser particularly on languages with a large amount of non-projectivity. Introduction A dependency tree as illustrated in Figure 1 is called a non-projective tree, which contains discontinuous subtrees and is informally remarked with crossing arcs (arcs from idea 4 to talking 8 and from who 5 to to 9 ). Comparing to the class of projective trees, which has a weak equivalence to the context-free grammars (Gaifman, 1965) , parsing non-projective trees is generally involved. This is particularly the case for transition-based dependency parsing; contrary to the graph-based approaches, in which a simple spanning-tree algorithm is capable of handling them (McDonald et al., 2005) , due to the incremental nature, transition-based parsers need some extra mechanisms to find crossing arcs. There are several attempts to handle crossing arcs in transition-based parsers. Among them online reordering with swap (Nivre, 2009) has a number of appealing properties, of which the most notable is that it inherits the standard architecture of the transition systems using a stack and buffer while covering all types of crossing arcs. This simplicity allows us to incorporate the ideas developed for the standard projective parsers, such as neural network architectures (Chen and Manning, 2014; Dyer et al., 2015) , and joint modeling with other phenomena (Hatori et al., 2011; Honnibal and Johnson, 2014) , with a minimal effort. Such extensions with swap include a recent nonprojective neural parser (Straka et al., 2015) and joint system with POS tagging (Bohnet and Nivre, 2012) . Other approaches often employ additional data structures with non-trivial transitions (Covington, 2001; Choi and McCallum, 2013; Pitler and McDonald, 2015) , which interfere with the transparency to the standard systems, or cannot handle all crossing arcs (Attardi, 2006) . Despite the popularity of the swap system, to our knowlege there is little work focusing on the swap mechanism, or the transition system itself, apart from the original proposal (Nivre, 2009; Nivre et al., 2009) . In other words, we are still unsure whether the current swap mechanism is the best strategy for handling crossing arcs with word reordering. In this work, we present a dependency parser with a new transition system that employs swapbased reordering but in a different manner from the existing one (Nivre, 2009) built on the arcstandard system. As we discuss (Section 2.2), in Nivre's transition system, choosing a correct swap transition is sometimes hard due to the parser's preference to local attachments. The proposed system (Section 3) alleviates this difficulty by allowing a swap transition for a token that is already linked on the stack. As we will see, it can be seen as an extension to the arc-eager system (Nivre, 2003) while we divide each attachment transition into two more primitive operations as in the divided formulation of G\u00f3mez-Rodr\u00edguez and Nivre (2013) . The divided system is more flexible, and by operating swap on this we can deal with the issue of reordering at an appropriate step. On this transition system we implement a pars-ing model with the stack LSTMs (Dyer et al., 2015) (Section 4). We extensively examine the utility of new transition system (Section 5) with the recently released Universal Dependencies (UD) 2.0 dataset, which contains more than 60 treebanks with varying degree of non-projectivity, and find that our system is superior to the ordinary swap system particularly for languages with a larger amount of non-projectivity. Background We first introduce some notations and the concept of transition systems (Section 2.1), and then describe the existing swap-based transition system of Nivre (2009) (Section 2.2). Transition System We focus in this paper on a standard transition system operating on a triple called a configuration c = (\u03c3, \u03b2, A), where \u03c3 is a stack, \u03b2 is a buffer, and A is a set of labeled arcs. See Nivre (2008) for the other variants and overview. In a configuration i-th token in a sentence is denoted by its index i while 0 denotes the special root token. Following the standard notations, by \u03c3|i and j|\u03b2, we mean i and j are the top-most tokens of the stack and buffer, respectively. We use i l \u2212 \u2192 j or (i, l, j) to denote an arc from i to j with label l. Given a sentence of length n, the system begins parsing with the initial configuration c 0 = ([0], [1, 2, 3, ...n], \u03c6) where only the root token is on the stack, all inputs are on the buffer, and the set of arcs is empty. Parsing finishes when it reaches a terminal configuration, in which any transitions cannot be performed, and the set of arcs A defines a labeled dependency tree. The system continues to make a transition decision at each step under the current configuration until it reaches a terminal configuration. Arc-Standard Swap Arc-standard swap system (ASS) (Nivre, 2009) is the most popular transition system for nonprojective dependency parsing, which can handle arbitrary crossing arcs. ASS rows in Table 1 show the set of transitions, in which LA, RA, and SH are the transitions of the arc-standard system, which can only produce a projective tree by linking two adjacent tokens on the top of the stack. Swap (SW) is the key transition to support non-projectivity, which reorders the top two tokens on the stack by moving the second top token back to the buffer. Reducing a reordered token by LA or RA means we create subtrees that are non-adjacent with each other, i.e., crossing arcs. One potential issue in ASS is its tendency to prefer local attachments due to the mechanism of LA and RA, which at the same time reduce the dependent token. This is problematic in that because crossing arcs often involve a longer dependency arc, if two tokens on the stack are locally likely to be connected, choosing correct SW rather than LA and RA is quite difficult. To see an example, let us consider the configuration in Figure 2 (c = (\u03c3|who|talking, to|\u03b2, A)), which occurs when parsing the sentence in Figure 1 . The correct action here is SW to create a crossing arc talking 8 obl \u2212\u2192 who 5 . However, at this point LA is a more likely transition since talking 8 obl \u2212\u2192 who 5 is a typical arc in a relative clause. The problem is that since LA reduces talking, we will miss the arc who 5 case \u2212\u2212\u2192 to 9 if we choose LA rather than SW. New System: Stay-Eager Swap Now we describe our proposed transition system, which we call Stay-Eager Swap (SES). We first present the transitions and its advantage (Section 3.1), and then discuss oracles (Section 3.2) and some improvements (Section 3.3). 1 show the set of transitions of the new system. To understand the mechanism, we first note that without SW, this system looks very much similar to the arc-eager transition system (Nivre, 2003) . The main difference from the original one is in the attaching transitions, which we call STAY-LEFT (SL) and STAY-RIGHT (SR) and do not reduce a dependent token, but just establish an arc between two tokens on the stack top and buffer top. Specifically, this system is identical to the divided arc-eager transition system with the primitive operations in G\u00f3mez-Rodr\u00edguez and Nivre (2013) ; in the arc-eager system, LEFT-ARC first builds an arc and then reduces the top of the stack, i.e., it is a combination of SL \u2192 RD (reduce) in our system, while RIGHT-ARC builds an arc and shift the top token of the buffer, i.e., it can be seen as SR \u2192 SH. Transition System SES rows in Table (LA) (\u03c3|i|j, \u03b2, A) \u21d2 (\u03c3|j, \u03b2, A \u222a {(j, l, i)}) i = 0 ASS RIGHT-ARC l (RA) (\u03c3|i|j, \u03b2, A) \u21d2 (\u03c3|i, \u03b2, A \u222a {(i, \u2022, j)}) SHIFT (SH) (\u03c3, i|\u03b2, A) \u21d2 (\u03c3|i, \u03b2, A) SWAP (SW) (\u03c3|i|j, \u03b2, A) \u21d2 (\u03c3|j, i|\u03b2, A) 0 < i < j STAY-LEFT l (SL) (\u03c3|i, j|\u03b2, A) \u21d2 (\u03c3|i, j|\u03b2, A \u222a {(j, l, i)}) i = 0 \u2227 (\u2022, \u2022, i) / \u2208 A \u2227 i * \u2212 \u2192 j / \u2208 A STAY-RIGHT l (SR) (\u03c3|i, j|\u03b2, A) \u21d2 (\u03c3|i, j|\u03b2, A \u222a {(i, l, j)}) (\u2022, \u2022, j) / \u2208 A \u2227 j * \u2212 \u2192 i / \u2208 A SES SHIFT (SH) (\u03c3, i|\u03b2, A) \u21d2 (\u03c3|i, \u03b2, A) REDUCE (RD) (\u03c3|i, \u03b2, A) \u21d2 (\u03c3, \u03b2, A) (\u2022, \u2022, i) \u2208 A SWAP (SW) (\u03c3|i, j|\u03b2, A) \u21d2 (\u03c3, j|i|\u03b2, A) 0 < i < j AUX UNSHIFT (UN) (\u03c3|i, [], A) \u21d2 (\u03c3, [i], A) (\u2022, \u2022, i) / \u2208 A RIGHT-ROOT (RR) ([0, i] [], A) \u21d2 ([0], [], A \u222a {(0, root, i)}) (\u2022, \u2022, i) / \u2208 A \u2227 (0, root, i) / \u2208 A SW SL Figure 2: A configuration difficult for ASS (above), which fails when LA is selected (SW is correct). Our system avoides this difficulty by first attaching who to talking (SL) and then SW (below). Dotted arcs are correct arcs yet unattached. We allow SW at an arbitrary point. This means we can insert SW just after SL and SR, by which we can alleviate the difficulty with an attachment vs. swap transitions discussed in Section 2.2. Fig- ure 2 shows how our system can swap after resolving local projective attachments. Static and Non-static Oracles An oracle for a transition system is a function from a configuration to the action that leads to a given dependency tree. Before discussing in details, we first note that our system suffers from the spurious ambiguity as in the arc-eager system (Goldberg and Nivre, 2012), which means an oracle for some configurations is not unique. Table 2 shows a specific oracle, which checks for each action in descending order whether the current configuration satisfies the condition, and select the first found one. 2 3 2 The priority of attaching transitions over SW is also helpful to avoid unnecessary SW transitions for nested nonprojective structures. For example in Figure 1 , if to9 has a child node x4.5 at the left to who5 and SW is preferred than SL and SR, it causes an additional crossing between talking6 \u2212 \u2192 who5 and to9 \u2212 \u2192 x4.5. This is not the case for our oracle because talking6 \u2212 \u2192 who5 has been already attached and isCross(i, j) ignores such attached arcs. 3 The function isCross(i, j) for SW could be defined like ASS style which reorders by projective order (Nivre, 2009) . However their projective orders are different: for example in Figure 1 , while to9 comes up at sixth word for ASS, who5 goes down at eighth word for SES. In this paper, we could not reach the detailed description and formal definition of projective order for SES, but they are the one of important Transition Configuration Condition STAY-LEFT l (\u03c3|i, j|\u03b2, A) (j, l, i) \u2208 Ag STAY-RIGHT l (\u03c3|i, j|\u03b2, A) (i, l, j) \u2208 Ag SWAP (\u03c3|i, j|\u03b2, A) isCross(i, j) REDUCE (\u03c3|i, \u03b2, A) (\u2022, \u2022, i) \u2208 A \u2227 \u2200h.\u2200j.((i, h, j) \u2208 Ag \u2192 (i, h, j) \u2208 A) SHIFT (\u03c3, j|\u03b2, A) \u2200i.\u2200l.((j, l, i) \u2208 Ag \u2227 j < i) \u2192 (j, l, i) \u2208 A 1 isCross(i, j ) returns true if i and j are two endpoints of two crossing arcs yet unattached. Formally: (\u2203b.b \u2208 \u03b2 \u2227 ((b, \u2022, i) \u2208 Ag \u2227 (b, \u2022, i) / \u2208 A \u2228 (i, \u2022, b) \u2208 Ag \u2227 (i, \u2022, b) / \u2208 A)) \u2227 (\u2203s.s \u2208 \u03c3 \u2227 ((s, \u2022, j) \u2208 Ag \u2227 (s, \u2022, j) / \u2208 A \u2228 (j, \u2022, s) \u2208 Ag \u2227 (j, \u2022, s) / \u2208 A)). [0] [1, 2, 3, 4, 5] 1 SH [0, 1] [2, 3, 4, 5] 2 SW [0] [2, 1, 3, 4, 5] 3 SR [0] [2, 1, 3, 4, 5] (0, root, 2) 4 SH [0, 2] [1, 3, 4, 5] 5 SH [0, 2, 1] [3, 4, 5] 6 SL [0, 2, 1] [3, 4, 5] (3, obj, 1) 7 RD [0, 2] [3, 4, 5] 8 SR [0, 2] [3, 4, 5] (2, xcomp, 3) 9 SH [0, 2, 3] [4, 5] 10 RD [0, 2] [4, 5] 11 SR [0, 2] [4, 5] (2, nmod, 4) 12 SH [0, 2, 4] [5] 13 SR [0, 2, 4] [5] (4, punct, 5) 14 RD [0, 2] [5] 15 SH [0, 2, 5] [] 16 RD [0, 2] [] 17 RD [0] [] Table 3 : Static oracle transitions by our system for the sentence in Figure 3 . This is a static oracle in that it is a deterministic function given a configuration. Table 3 shows the oracle transitions by this for the sentence in Figure 3 . In addition to the static oracle, we also try a partially non-static oracle, which occasionally prefers SH over RD when both are applicable. Specifically, for this oracle when both conditions for SH and RD are satisfied we choose SH with some probability. This allows the parser to learn the transitions that postpone RD when possible, but stochastically, which we found effective in many languages in practice. This is a partially non-static oracle since it does not postpone the other transitions such as SL and SR. Designing future works. such oracle could also be possible; for example, in Figure 2 , we can also build the gold tree by SW followed by SH and SR. We leave such fully nonstatic oracle as well as the dynamic oracle (Goldberg and Nivre, 2012) as a future work. Auxiliary transitions Our system employs the following two additional transitions (AUX in Table 1 ), which can be applied in restricted conditions. UNSHIFT The arc-eager system is not guaranteed to output a single rooted tree, i.e., it may keep unconnected tree fragments in the stack while the buffer is empty (Nivre, 2008) . Then, a parser becomes stack because no actions are permissible before reaching a terminal configuration, and our system suffers from the same issue. To escape from this, we employ the same hack as Nivre and Fern\u00e1ndez-Gonz\u00e1lez (2014) and add a special transition UN, which pushes back the stack top node to the empty buffer. We only apply UN at decoding. It is deterministically chosen in the con- figuration c = ([n], [], A / \u2208 (\u2022, \u2022, n)) , so does not have any associated score. RIGHT-ROOT This is our new transition to improve the root attachment accuracy for arc-eager. The arc-eager system attaches the sentence root to the special ROOT eagerly immediately after it collects all its left dependents, but this decision is sometimes hard for some types of garden-path. The purpose of RR is to postpone the decision of this root token until the terminal configuration, as in the arc-standard system. To be concrete, during training, we allow the parser to select SH with some probability when the gold transition is SR root . This eventually leads to a terminal configuration where the sentence root token not attached to ROOT remains on the stack. RR is used only for this configuration, also during decoding. Note that unlike UN, the parser ex-plores this transition during training and learns the parameters associated with it. We hope by this the parser becomes capable of postponing the decision on the root token during decoding when it seems ambiguous locally. We use this transition only with the non-static oracle. Parser Model A model of a transition-based parser calculates the score of each transition at the current configuration. Our model is basically the stack-LSTM parser (Dyer et al., 2015) 4 , which we slightly customize from the original architecture (Section 4.2). In this work we focus our attention on the incremental setting, in which the model is not able to access the full tokens in the buffer. With regard for transition-based parsers this is practically a more important scenario where the graph-based parser is not applicable. Stack-LSTM parser We first briefly describe the original model in Dyer et al. (2015) designed for the arc-standard system. For a configuration c t at time t, the parser maintains the three vector representations, s t that encodes the stack, b t the buffer, and a t the action history. Each of them is modeled with a stack LSTM, an LSTM that supports push and pop operations by keeping the representations of intermediate time steps. The stack LSTM for s t is left-toright while that for b t is right-to-left. a t encodes the entire action history from the initial action to the last action. Using these representations we encode the configuration into a single vector: p t = ReLU(W[s t ; b t ; a t ] + e p ), where W is the parameters. Here and the followings e x denotes a bias vector. Using this the probability for each valid transition z t is obtained with restricted softmax: p(z t |p t ) = exp(g T zt p t + q zt ) z \u2208A(ct) exp(g T z p t + q z ) , where g z is the parameters and q z is the bias term for action z. The set A(c t ) returns the set of valid transitions on c t . After each transition we update s t+1 , b t+1 , and a t+1 accordingly following the new configuration. For the buffer, each element of the LSTM is a token representation, which Dyer et al. (2015) obtains from the word and POS embeddings. b t is then the last output of the LSTM. For the stack, each element of the LSTM is a compositional representation of a subtree, or a token if it is just a shifted one. The subtree representation of the stack element is updated in a recursive manner. In Dyer et al. (2015) when LA or RA builds an arc h l \u2212 \u2192 d, the representation h for the subtree rooted at h is updated by: h = tanh(U[h; d; l] + e h ), (1) in which d is the representation for the subtree rooted at d, l is the label embeddings. s t is then updated by popping the top two elements of the stack LSTM, h and d, and pushing h . Modifications We modify the above basic architecture in the following three ways. Configuration encoding This is a restriction that we impose on the model. While the original model exploits the entire sentence for the buffer representation b t using the LSTM, this violates our assumption of incrementality, the main advantage of the transition-based parsers. We thus avoid to use b t and instead use the representations of top three nodes on the buffer: b1 t , b2 t , and b3 t . We also use the representations of the top three nodes (subtrees) on the stack, s1 t , s2 t , and s3 t , which we found effective. The new encoding is: Token representation Many languages in UD are annotated with XPOS, fine language specific tags, as well as FEATS, the morphological features. We utilize the embeddings of these features, initialized randomly. We also add character embeddings, which we obtain from character-level bidirectional LSTMs. Our token representation is: o = W[ x = ReLU(V[w; t; tx; f ; w ch ] + e x ), where w, t, tx, and f are word, POS, XPOS, and FEAT embeddings, respectively. w ch is the output of linear mapping from the concatenation of the last hidden states of the forward and backward character-level LSTMs. Composition This is the only modification needed to obtain the stack representation in our stay-eager transition system. The subtree representation in Dyer et al. (2015) is fully compositional in that h in Eq. 1 encodes the entire subtree with the recursive network. This is possible essentially because of the bottom-up nature of the arc-standard system. Unfortunatelly the same encoding is not straightforward in our system due to its arc-eager property, in which the right arcs are constructed top-down (Nivre, 2004) . In this work, we give up the full compositionality of the original model, and simply mimic Eq. 1 with the following equation: c = tanh(U[h; d; l; c] + e h ). (2) We update the node representation of both of the stack top and the buffer top. This means that apart from the original model we also update the dependent node with composition. In the equation, c is the updated representation of the head or the dependent after SR or SL, which is originally c. For example, after SL, since the stack top becomes dependent, its representation (d) is updated to tanh(U[h; d; r; d] + e h ). Note that without c in Eq. 2, the representations of two updated nodes are identical. The role of c is thus to distinguish the two updates for h and d. Experiment Data We use the 63 treebanks in 45 languages in Universal Dependencies 2.0 (Nivre et al., 2017) , which are distributed with the training data in the recent shared task in CoNLL 2017 (Zeman et al., 2017) . 5 Following the shared task, we focus on real world parsing and assume the raw input text. For all preprocessing (sentence segmantion, tokenization, and tagging), we use UDpipe 1.1 (Straka et al., 2015) . We report the official F1 LAS used in the shared task. Baseline To make a comparison between transition systems fair, we implement the arc-standard lazy swap (ASS) parser (Nivre et al., 2009) with almost the same settings as our stay-eager swap (SES) parser including our network architecture (Section 4.2). 6 We also report the scores of UD-pipe 1.1, the baseline system in the shared task, although the results may not be directly comparable as they tune several settings including the oracle and learning rate etc. for each language. Settings Our network sizes are: 100 dimensional word embeddings and LSTMs, 50 dimentional POS, XPOS, and FEATS embeddings, and 20 dimensional action and label embeddings, and 32 dimensional character embeddings and bi-LSTMs. We do not use any pre-trained embeddings. We use Adam (Kingma and Ba, 2014) for the optimizer, and set the learning decay of 0.08 and the dropout ratio in LSTMs of 0.33. In addition to the greedy search, we also try beam search for learning and decoding (beam size is 8). Note that due to swap, each transition sequence may have a different number of actions. We alleviate this inconsistency by ranking with the average scores (Honnibal and Johnson, 2014) . 7  For non-static oracles, we set both probabilities to postpone RD and SR root to 0.33, which works well for the development set. Results The main results are shown in the left columns of Table 4 . Comparing to ASS, our nonstatic SES achieves the higher LAS on average, regardless of search method. In more detail, it is on about half treebanks (27 for greedy and 28 for beam search) that the score improvements from ASS are more than 0.5 points. Also the static SES is not stronger, suggesting that non-static exploration during training is important for our system. Focusing on the results on only non-projective sentences (right columns), the score improvements get larger: the average LAS difference between non-static SES and SAS is 1.54 points with greedy search, and 1.18 points with beam search. To further inspect the parser behaviors on nonprojective and projective sentences, we next compare the average LAS on a subset of treebanks, which we divide into four groups according to implements arc-standard swap (https://github.com/clab/lstmparser). Example UAS on development sets (with gold tags) are: Arabic: 80.83 (Dyer et al.) vs. 82.01 (ours) ; English: 86.71 (Dyer et al.) vs. 85.28 (ours); and German: 82.87 (Dyers et al.) vs. 84.45 (ours) . Both employ greedy search. Note that our system does not use the buffer LSTM. 7 For learning, we find the following heuristics inspired by max-violation (Huang et al., 2012) works well. Our training is basically local with cross-entropy while for each sentence we calculate the max violation point by beam search and use only the prefix until that point. Although this is simpler than global structured learning (Andor et al., 2016) , it provides some improvements with much faster training time. no bokmaal, fa, fi ftb, lv, fi, and id. 4 VERYLOW (0%-5%) : it, pt br, ug, sk, fr rtut, en partut, en, vi, bg, sv, he, zh, and pl. 5 gl and ja are excluded when calculating the scores of \"non-projective only\" (bottom rows), as these treebanks only contain projective sentences in their test data. Table 5 : The average LAS on all, only projective, and only non-projective sentences on the grouped treebanks according to the ratio of non-projective sentences in the test set. The scores in brackets are the results with beam search. the ratio of non-projective sentences (Table 5 ). When evaluating on all sentences (top rows), we can see the larger improvements by the non-static SES in HIGH, MID, and LOW groups (having nonnegligible non-projectivity), which confirms the above results. Interestingly, for projective sentences only (mid rows) the scores of SES do not degrade comparing to ASS, or rather improves in all cases. This suggests our transition system also helps to recover the projective arcs. Discussion While the ordinary reordering-based transition system is built on the arc-standard system, we choose arc-eager as our basic architecture. One reason for this is that decomposing the arcstandard system is more involved than arc-eager; G\u00f3mez-Rodr\u00edguez and Nivre (2013) observe the RIGHT-ARC in arc-standard would be divided into four transitions including a nontrivial UN-SHIFT operation. Otherwise, we need two different reduce operations for each direction, which complicates the system and learning. Though we have seen the empirical advantage, in terms of the reordering strategy our approach may not be optimal. Consider the sentence in Figure 4 , which we borrow from Nivre et al. (2009) . Our system needs more swap transitions than the Nivre et al.'s swap-lazy system for this sentence. In Nivre et al.'s system, swapping Who 1 and did 2 occurs after you 3 is reduced as a dependent of did 2 . In our system, due to the right top-down nature of arc-eager, we need to build ROOT 0 \u2192 did 2 before did 2 \u2192 you 3 . This means we also need an additional swap between Who 1 and you 3 . Past work shows that a smaller number of swap transitions improves accuracies (Bj\u00f6rkelund and Nivre, 2015) , and thus it is an important future work to revise our system to minimize the necessary swap transitions. Another direction might be to incorporate our idea to postpone swap transitions into the arc-standard system, possibly with the divided system as we did for arc-eager. In our system each word is once attached, shifted, and reduced, so the total number of transitions is 3n plus the number of swap transitions. This is greater than Nivre et al.'s system, though we expect this additional cost is not substantial comparing to the other techniques, e.g., beam search with larger beam sizes. Conclusion We have shown for incremental non-projective parsing, explicitly separating the attachment and reduce transitions alleviates the difficulty of local decisions, and leads to higher parsing accuracies for both projective and crossing arcs. Nonprojectivity is prevalent in multilingual parsing beyond the popular languages in the current NLP such as English and Chinese. Also incremental parsing is essential for many online applications, in particular the speech-oriented systems. In this paper, we proposed an alternative to the popular approach for incremental non-projective parsing. There are much rooms for improvements, and this is our first step of reconsidering the optimal mechanism to handle crossing arcs incrementally. Acknowledgements This work was supported by JST CREST Grant Number JPMJCR1513, Japan.",
    "abstract": "We present a new transition system with word reordering for unrestricted nonprojective dependency parsing. Our system is based on decomposed arc-eager rather than arc-standard, which allows more flexible ambiguity resolution between a local projective and non-local crossing attachment. In our experiment on Universal Dependencies 2.0, we find our parser outperforms the ordinary swapbased parser particularly on languages with a large amount of non-projectivity.",
    "countries": [
        "Japan"
    ],
    "languages": [
        "Arabic",
        "German",
        "English"
    ],
    "numcitedby": "0",
    "year": "2017",
    "month": "September",
    "title": "Effective Online Reordering with Arc-Eager Transitions"
}