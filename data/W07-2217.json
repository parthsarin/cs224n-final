{
    "article": "This paper investigates new design options for the feature space of a dependency parser. We focus on one of the simplest and most efficient architectures, based on a deterministic shift-reduce algorithm, trained with the perceptron. By adopting second-order feature maps, the primal form of the perceptron produces models with comparable accuracy to more complex architectures, with no need for approximations. Further gains in accuracy are obtained by designing features for parsing extracted from semantic annotations generated by a tagger. We provide experimental evaluations on the Penn Treebank. Introduction A dependency tree represents a sentence as a labeled directed graph encoding syntactic and semantic information. The labels on the arcs can represent basic grammatical relations such as \"subject\" and \"object\". Dependency trees capture grammatical structures that can be useful in several language processing tasks such as information extraction (Culotta & Sorensen, 2004 ) and machine translation (Ding & Palmer, 2005) . Dependency treebanks are becoming available in many languages, and several approaches to dependency parsing on multiple languages have been evaluated in the CoNLL 2006 and 2007 shared tasks (Buchholz & Marsi, 2006; Nivre et al., 2007) . Dependency parsing is simpler than constituency parsing, since dependency trees do not have extra non-terminal nodes and there is no need for a grammar to generate them. Approaches to dependency parsing either generate such trees by considering all possible spanning trees (McDonald et al., 2005) , or build a single tree by means of shift-reduce parsing actions (Yamada & Matsumoto, 2003) . Deterministic dependency parsers which run in linear time have also been developed (Nivre & Scholz, 2004; Attardi, 2006) . These parsers process the sentence sequentially, hence their efficiency makes them suitable for processing large amounts of text, as required, for example, in information retrieval applications. Recent work on dependency parsing has highlighted the benefits of using rich feature sets and high-order modeling. Yamada and Matsumoto (2003) showed that learning an SVM model in the dual space with higher-degree polynomial kernel functions improves significantly the parser's accuracy. McDonald and Pereira (2006) have shown that incorporating second order features relating to adjacent edge pairs improves the accuracy of maximum spanning tree parsers (MST). In the SVMbased approach, if the training data is large, it is not feasible to train a single model. Rather, Yamada and Matsumoto (see also (Hall et al., 2006) ) partition the training data in different sets, on the basis of Partof-Speech, then train one dual SVM model per set. While this approach simplifies the learning task it makes the parser more sensitive to the error rate of the POS tagger. The second-order MST algorithm has cubic time complexity. For non-projective languages the algorithm is NP-hard and McDonald and Pereira (2006) introduce an approximate algorithm to handle such cases. In this paper we extend shift reduce parsing with second-order feature maps which explicitly repre-sent all feature pairs. Also the augmented feature sets impose additional computational costs. However, excellent efficiency/accuracy trade-off is achieved by using the perceptron algorithm, without the need to resort to approximations, producing high-accuracy classifiers based on a single model. We also evaluate a novel set of features for parsing. Recently various forms of shallow semantic processing have been investigated such as namedentity recognition (NER), semantic role labeling (SRL) and relation extraction. Syntactic parsing can provide useful features for these tasks; e.g., Punyakanok et al. (2005) show that full parsing is effective for semantic role labeling (see also related approaches evaluated within the CoNNL 2005 shared task (Carreras et al., 2005) ). However, no evidence has been provided so far that annotated semantic information can be leveraged for improving parser performance. We report experiments showing that adding features extracted by an entity tagger improves the accuracy of a dependency parser. Dependency parsing A dependency parser takes as input a sentence s and returns a dependency graph d. Figure 1 shows a dependency tree for the sentence \"Last week CBS Inc. canceled 'The People Next Door'.\" 1 . Dependencies are represented as labeled arrows from the head of the relation to the modifier word; thus, in the example, \"Inc.\" is the modifier of a dependency labeled \"SUB\" (subject) to the main verb, the head, \"canceled\". In statistical syntactic parsing a generator (e.g., a PCFG) is used to produce a number of candidate trees (Collins, 2000) with associated probability scores. This approach has been used also for dependency parsing, generating spanning trees as candidates and computing the maximum spanning tree (MST) using discriminative learning algorithms (McDonald et al., 2005) . Second-order MST dependency parsers currently represent the state of the art in terms of accuracy. Yamada and Matsumoto (2003) proposed a deterministic classifierbased parser. Instead of learning directly which tree to assign to a sentence, the parser learns which Shift/Reduce actions to use in building the tree. Parsing is cast as a classification problem: at each step the parser applies a classifier to the features representing its current state to predict which action to perform on the tree. Similar deterministic approaches to parsing have been investigated also in the context of constituent parsing (Wong & Wu, 1999; Kalt, 2004) . Nivre and Scholz (2004) proposed a variant of the model of Yamada and Matsumoto that reduces the complexity, from the worst case quadratic to linear. Attardi (2006) proposed a variant of the rules that handle non-projective relations while parsing deterministically in a single pass. Shift-reduce algorithms are simple and efficient, yet competitive in terms of accuracy: in the CoNLL-X shared task, for several languages, there was no statistically significant difference between second-order MST parsers and shift-reduce parsers. A shift-reduce parser We build upon DeSR, the shift-reduce parser described in (Attardi, 2006) . This and Nivre and Scholz's (2004) provide among the simplest and most efficient methods. This parser constructs dependency trees by scanning input sentences in a single left-to-right pass and performing shift/reduce parsing actions. The parsing algorithm is fully deterministic and has linear complexity. The parser's behavior can be described as repeatedly selecting and applying a parsing rule to transform its state, while advancing through the sentence. Each token is analyzed once and a decision is made locally concerning the action to take, that is, without considering global properties of the tree being built. Nivre (2004) investigated the issue of (strict) incrementality for this type of parsers; i.e., if at any point of the analysis the processed input forms one connected structure. Nivre found that strict incrementality is not guaranteed within this parsing framework, although for correctly parsed trees the property holds in almost 90% of the cases. Parsing algorithm The state of the parser is represented by a triple S, I, A , where S is the stack, I is the list of input tokens that remain to be processed and A is the arc relation for the dependency graph, which consists of a set of labeled arcs (w i , r, w j ), where w i , w j \u2208 W (the set of tokens), d \u2208 D (the set of dependencies). Given an input sentence s, the parser is initialized to \u2205, s, \u2205 , and terminates at configuration s, \u2205, A . There are three parsing schemata: Shift S,n|I,A n|S,I,A (1) Right r s|S,n|I,A S,n|I,A\u222a{(s,r,n)} (2) Left r s|S,n|I,A S,s|I,A\u222a{(n,r,s)} (3) The Shift rule advances on the input; each Left r and Right r rule creates a link r between the next input token n and the top token on the stack s. For producing labeled dependencies the rules Left r and Right r are instantiated several times once for each dependency label. Additional parsing actions (cf. (Attardi, 2006) ) have been introduced for handling non-projective dependency trees: i.e., trees that cannot be drawn in the plane without crossing edges. However, they are not needed in the experiments reported here, because in the Penn Treebank used in our experiments dependencies are extracted without considering empty nodes and the resulting trees are all projective 2 . The pseudo code in Algorithm 1 reproduces schematically the parsing process. The function getContext() extracts a vector of features x relative to the structure built up to that point from the context of the current token, i.e., from a subset of I, S and A. The step estimateAction() predicts a parsing action y, given a trained model \u03b1 Features The set of features used in this paper were chosen with a few simple experiments on the development data as a variant of a generic model. The only features of the tokens used are \"Lemma\", \"Pos\" and \"Dep\": \"Lemma\" refers to the morphologically simplified form of the token, \"Pos\" is the Part-of-Speech and \"Dep\" is the label on a dependency. \"Child\" refers to the child of a node (right or left): up to two furthest children of a node are considered. Table 1 lists which feature is extracted for which token: negative numbers refer to tokens on the stack, positive numbers refer to input tokens. As an example, POS(-1) is the Part-of-Speech of the token on the top of the stack, while Lemma(0) is the lemma of the next token in the input, PosLeftChild(-1) extracts the Part-of-Speech of the leftmost child of the token on the top of the stack, etc. TOKEN FEATURES Stack Input Lemma -2 -1 0 1 2 3 Pos -2 -1 0 1 2 3 LemmaLeftChild -1 0 PosLeftChild -1 0 DepLeftChild -1 0 LemmaRightChild -1 0 PosRightChild -1 0 DepRightChild -1 LemmaPrev 0 PosSucc -1 Table 1 . Configuration of the feature parameters used in the experiments. Learning a parsing model with the perceptron The problem of learning a parsing model can be framed as a classification task where each class y i \u2208 Y represents one of k possible parsing actions. Each of such actions is associated with a weight vector \u03b1 k \u2208 IR d . Given a datapoint x \u2208 X , a ddimensional vector of binary features in the input space X , a parsing action is chosen with a winnertake-all discriminant function: estimateAction(x, \u03b1) = arg max k f (x, \u03b1 k ) (4) when using a linear classifier, such as the perceptron or SVM, f (u, v) = u, v is the inner product between vectors u and v. We learn the parameters \u03b1 from the training data with the perceptron (Rosemblatt, 1958) , in the online multiclass formulation of the algorithm (Crammer & Singer, 2003) with uniform negative updates. The perceptron has been used in previous work on dependency parsing by Carreras et al. (2006) , with a parser based on Eisner's algorithm (Eisner, 2000) , and also on incremental constituent parsing (Collins & Roark, 2006) . Also the MST parser of McDonald uses a variant of the perceptron algorithm (McDonald, 2006) . The choice is motivated by the simplicity and performance of perceptrons, which have proved competitive on a number of tasks; e.g., in shallow parsing, where perceptron's performance is comparable to that of Conditional Random Field models (Sha & Pereira, 2003) . The only adjustable parameter of the model is the number of instances T to use for training. We fixed T using the development portion of the data. In our experiments, the best value is between 20 and 30 times the size of the training data. To regularize the model we take as the final model the average of all weight vectors posited during training (Collins, 2002) . Algorithm 2 illustrates the perceptron learning procedure. The final average model can be computed efficiently during training without storing the individual \u03b1 vectors (e.g., see (Ciaramita & Johnson, 2003) ). Algorithm 2: Average multiclass perceptron 4 ) learned with the perceptron is inherently limited in the types of solutions it can learn. As originally pointed out by Minsky and Papert (1969) , there are problems which require non-linear solutions that cannot be learned by such models. A simple workaround this limitation relies on feature maps \u03a6 : IR d \u2192 IR h that map the input vectors x \u2208 X into some higher hdimensional representation \u03a6(X ) \u2282 IR h , the feature space. The feature space can represent, for example, all combinations of individual features in the input space. We define a feature map which extracts all second order features of the form x i x j ; i.e., \u03a6(x) = (x i , x j |i = 1, ..., d, j = i, ..., d). The linear perceptron working in \u03a6(X ) effectively implements a non-linear classifier in the original input space X . One shortcoming of this approach is that it inflates considerably the feature representation and might not scale. In general, the number of features of degree g over an input space of dimension d is d+g\u22121 g . In practice, a second-order feature map can be handled with reasonable efficiency by the perceptron. We call this the 2nd-order model, which uses a modified scoring function: input : S = (x i , y i ) N ; \u03b1 0 k = 0, \u2200k \u2208 Y for t = 1 to T do choose j E t = {r \u2208 Y : x j , \u03b1 t r \u2265 x j , \u03b1 t y j } if |E t | > 0 then \u03b1 t+1 r = \u03b1 t r \u2212 x j |E t | , \u2200r \u2208 E t \u03b1 t+1 y j = \u03b1 t y j + x j output: \u03b1 k = 1 T t \u03b1 t k , \u2200k \u2208 Y 3.4 g(x, \u03b1 k ) = f (\u03a6(x), \u03b1 k ) (5) where also \u03b1 k is h-dimensional. The proposed feature map is equivalent to a polynomial kernel function of degree two. Yamada and Matsumoto (2003) have shown that the degree two polynomial kernel has superior accuracy than the linear model and polynomial kernels of higher degrees. However, using the dual model is not always practical for dependency parsing. The discriminant function of the dual model is defined as: f (x, \u03b1) = arg max k N i=1 \u03b1 k,i x, x i g (6) where the weights \u03b1 are associated with classinstance pairs rather than class-feature pairs. With respect to the discriminant function of equation ( 4 ) there is an additional summation. In principle, the inner products can be cached in a Kernel matrix to speed up training. There are two shortcomings to using such a model in dependency parsing. First, if the amount of training data is large it might not be feasible to store the Kernel matrix; which for a dataset of size N requires O(N 3 ) computations and O(N 2 ) space. As an example, the number of training instances N in the Penn Treebank is over 1.8 million, caching the Kernel matrix would require several Terabytes of space. The second shortcoming is independent of training. In predicting a tree for unseen sentences the model will have to recompute the inner products between the observation and all the support vectors; i.e., all class-instance pairs with \u03b1 k,i > 0. The second-order feature map with the perceptron is more efficient and allows faster training and prediction. Training a single parsing model avoids a potential loss of accuracy that occurs when using the technique of partitioning the training data according to the POS. Inaccurate predictions of the POS can affect significantly the accuracy of the actions predicted, while the single model is more robust, since the POS is just one of the many features used in prediction. Semantic features Semantic information is used implicitly in parsing. For example, conditioning on lexical heads provides a source of semantic information. There have been a few attempts at using semantic information more explicitly. Charniak's 1997 Charniak's parser (1997)) , defined probability estimates backed off to word clusters. Collins and Koo (Collins & Koo, 2005) introduced an improved reranking model for parsing which includes a hidden layer of semantic features. Yi and Palmer (2005) retrained a constituent parser in which phrases were annotated with argument information to improve SRL, however this didn't improve over the output of the basic parser. In recent years there has been a significant amount of work on semantic annotation tasks such as named-entity recognition, semantic role labeling and relation extraction. There is evidence that dependency and constituent parsing can be helpful in these and other tasks; e.g., by means of tree kernels in question classification and semantic role labeling (Zhang & Lee, 2003; Moschitti, 2006) . It is natural to ask if also the opposite holds: whether semantic annotations can be used to improve parsing. In particular, it would be interesting to know if entity-like tags can be used for this purpose. One reason for this is that entity tagging is efficient and does not seem to need parsing for achieving top performance. Beyond improving traditional parsing, independently learned semantic tags might be helpful in adapting a parser to a new domain. To the best of our knowledge, no evidence has been produced yet that annotated semantic information can improve parsing. In the following we investigate adding entity tags as features of our parser. BBN Entity corpus The BBN corpus (BBN, 2005) supplements the Wall Street Journal Penn Treebank with annotation of a large set of entity types. The corpus includes annotation of 12 named entity types (Person, Facility, Organization, GPE, Location, Nationality, Product, Event, Work of Art, Law, Language, and Contact-Info), nine nominal entity types (Person, Facility, Organization, GPE, Product, Plant, Animal, Substance, Disease and Game), and seven numeric types (Date, Time, Percent, Money, Quantity, Ordinal and Cardinal). Several of these types are further divided into subtypes 3 . This corpus provides adequate support for experimenting semantic features for parsing. Figure 1 illustrates the annotation layer provided by the BBN corpus 4 . It is interesting to notice one apparent property of the combination of semantic tags and dependencies. When we consider segments composed of several words there is exactly one dependency connecting a token outside the segment with a token inside the segment; e.g., \"CBS Inc.\" is connected outside only through the token \"Inc.\", the subject of the main verb. With respect to the rest of the tree, segments tend to form units, with their own internal structure. Intuitively, this information seems relevant for parsing. This locally-structured patterns could help particularly simple algorithms like ours, which have limited knowledge of the global structure being built. Table 2 lists the 40 most frequent categories in sections 2 to 21 of the BBN corpus, and the percentage of all entities they represent -together more than 97%. Sections 2-21 are comprised of 949,853 tokens, 23.5% of the tokens have a non-null BBN entity tag, on average there is one tagged token every four. The total number of entities is 139,029, 70.5% of which are named entities and nominal concepts, 17% are numerical types and the remaining 12.5% describe time entities. We designed three new features which extract simple properties of entities from the semantic annotation information: TOKEN FEATURES Stack Input AS-0 = EOS+BIO+TAG 0 AS-1 = EOS+BIO+TAG -1 0 1 AS-2 = EOS+BIO+TAG -2 -1 0 1 2 EOS -2 -1 0 1 2 BIO -2 -1 0 1 2 TAG -2 -1 0 1 2 Table 3 . Additional configurations for the models with BBN entity features. \u2022 EOS: Distance to the end of the segment; e.g., EOS(\"Last\") = 1, EOS(\"canceled\") = 0; \u2022 BIO: The first character of the BBN label for a token; e.g., BIO(\"CBS\") = \"B\", and BIO(\"canceled\") = 0; \u2022 TAG: Full BBN tag for the token; e.g., TAG(\"CBS\") = \"B-ORG:Corporation\", TAG(\"week\") = \"I-DATE\". The feature EOS provides information about the relative position of the token within a segment with respect to the end of the segment. The feature BIO discriminates tokens with no semantic annotation associated, from tokens within a segment and token which start a segment. Finally the feature TAG identifies the full semantic tag associated with the token. With respect to the former two features this bears the most fine-grained semantics. Table 3 summarizes six additional models we implemented. The first three use all additional features together, applied to different sets of tokens, while the last three apply only one feature, on top of the base model, relative to the next token in the input, the following two tokens in the input, and the previous two tokens on the stack. Corpus pre-processing The original BBN corpus has its own tokenization which often does not reflect the Penn Treebank tokenization; e.g., when an entity intersects an hyphenated compound, thus \"third-highest\" becomes \"third ORDIN AL -highest\". This is problematic for combining entity annotation and dependency trees. Since our main focus is parsing we re-aligned the BBN Corpus with the Treebank tokenization. Thus, for example, when an entity splits a Treebank token we extend the entity boundary to contain the whole original Treebank token, thus obtaining \"third-highest ORDIN AL \" in the example above. Semantic tagger We treated semantic tags as POS tags. A tagger was trained on the BBN gold standard annotation and used it to annotate development and evaluation data. We briefly describe the tagger (see (Ciaramita & Altun, 2006) for more details), a Hidden Markov Model trained with the perceptron algorithm introduced in (Collins, 2002) . The tagger uses Viterbi decoding. Label to label dependencies are limited to the previous tag (first order HMM). A generic feature set for NER based on words, lemmas, POS tags, and word shape features was used. The tagger is trained on sections 2-21 of the BBN corpus. As before, section 22 of the BBN corpus is used for choosing the perceptron's parameter T . The tagger's model is regularized as described for Algorithm 2. The full BBN tagset is comprised of 105 classes organized hierarchically, we ignored the hierarchical organization and treated each tag as an independent class in the standard BIO encoding. The tagger evaluated on section 23 achieves an Fscore of 86.8%. The part of speech for the evaluation/development sections was produced with Tree-Tagger. As a final remark we notice that the tagger's complexity, linear in the length of the sentence, preserves the parser's complexity. Parsing experiments Data and setup We used the standard partitions of the Wall Street Journal Penn Treebank (Marcus et al., 1993) ; i.e., sections 2-21 for training, section 22 for develop-ment and section 23 for evaluation. The constituent trees were transformed into dependency trees by means of a program created by Joakim Nivre that implements the rules proposed by Yamada and Matsumoto, which in turn are based on the head rules of Collins' parser (Collins, 1999) 5 . The lemma for each token was produced using the \"morph\" function of the WordNet (Fellbaum, 1998 ) library 6 . The data in the WSJ sections 22 and 23, both for the parser and for the semantic tagger, was POS-tagged using TreeTagger 7 , which has an accuracy of 97.0% on section 23. Training a parsing model on the Wall Street Journal requires a set of 22 classes: 10 of the 11 labels in the dependency corpus generated from the Penn Treebank (e.g., subj, obj, sbar, vmod, nmod, root, etc.) are paired with both a Left and Right actions. In addition, there is in one rule for the \"root\" label and one for the Shift action. The total number of features found in training ranges from two hundred thousand for the 1st-order model to approximately 20 million of the 2nd-order models. We evaluated several models, each trained with 1st-order and 2nd-order features. The base model (BASE) only uses the traditional set of features (cf. Table 1 ). Models EOS, BIO and TAG each use only one type of semantic feature with the configuration described in Table 3 . Models AS-0, AS-1, and AS-2 use all three semantic features for the token on the stack in AS-0, plus the previous token on the stack and the new token in the input in AS-1, plus an addi- tional token from the stack and an additional token from the input for AS-2 (cf. Table 3 ). Results of 2nd-order models Table 4 summarizes the results of all experiments. We report the following scores, obtained with the CoNLL-X scoring script: labeled attachment score (LAS), unlabeled attachment score (UAS) and label accuracy score (LAC). For the UAS score, the most frequently reported, we include the improvement in relative error reduction. The 2nd-order base model improves on all measures over the 1st-order model by approximately 5%. The UAS score is 90.55%, with an improvement of 4.9%. The magnitude of the improvement is remarkable and reflects the 4.6% improvement that Yamada and Matsumoto (Yamada & Matsumoto, 2003) report going from the linear SVM to the polynomial of degree two. Our base model's accuracy (90.55% UAS) compares well with the accuracy of the parsers based on the polynomial kernel trained with SVM of Yamada and Matsumoto (UAS 90.3%), and Hall et al. (2006) (UAS 89.4%). We notice in particular that, given the lack of nonprojective cases/rules, the parser of Hall et al. (2006) is almost identical to our parser, hence the difference in accuracy (+1.1%) might effectively be due to a better classifier. Yamada & Matsumoto's parser is slightly more complex than our parser, and has quadratic worst-case complexity. Overall, the accuracy of the 2nd-order parser is comparable to that of the 1st-order MST parser (90.7%). There is no direct evidence that our perceptron produces better classifiers than SVM. Rather, the pattern of results produced by the perceptron seems comparable to that of SVM (Yamada & Matsumoto, 2003) . This is a useful finding in itself, given that the former is more efficient: perceptron's update is linear while SVM solves a quadratic problem at each update. However, one major difference between the two approaches lies in the fact that learning with the primal model does not require splitting the model by Part-of-Speech, or other means. As a consequence, beyond the greater simplicity, our method might benefit from not depending so strongly on the quality of POS tagging. POS information is encoded as a feature and contributes its weight to the selection of the parsing action, together with all additionally available information. In the SVM-trained methods the model that makes the prediction for the parsing rule is essentially chosen by an oracle, the prediction of the POS tagger. Furthermore, it might be argued that learning a single model makes a better use of the training data by exploiting the correlations between all datapoints, while in the dual split-training case the interaction is limited to datapoints in the same partition. In any case, secondorder feature maps could be used also with SVM or other classifiers. The advantage of using the perceptron lies in the unchallenged accuracy/efficiency trade-off. Finally, we recall that training in the primal model can be performed fully on-line without affecting the resulting model nor the complexity of the algorithm. Results of models with semantic features All models based on semantic features improve over the base model on all measures. In Table 4 we also evaluate the gain obtained by adding one semantic feature type at a time (cf. rows EOS/BIO/TAG). These results show that all semantic features provide some improvement (with the dubious case of EOS in the 2nd-order model). The BIO encoding seems to produce the most accurate features. This could be promising because it suggests that the benefit does not depend only on the specific tags, but that the segmentation in itself is important. Hence tagging could improve the adaptation of parsers to new domains even if only generic tagging methods are available. Remarks on efficiency All experiments were performed on a 2.4GHz AMD Opteron CPU machine with 32GB RAM. The architecture of the model presented here offers several options for optimization. For example, implementing the \u03b1 models with full vectors rather than hash tables speeds up parsing by a factor of three, at the expense of memory. Alternatively, memory load in training can be reduced, at the expense of time, by using on-line training. However, the most valuable option for space need reduction might be to filter out low-frequency second-order features. Since the frequency of such features seems to follow a power law distribution, this reduces significantly the feature space size even for low thresholds at small accuracy expense. In this paper however we focused on the full model, no approximations were required to run the experiments. Conclusion We explored the design space of a dependency parser by modeling and extending the feature representation, while adopting one of the simplest parsing architecture: a single-pass deterministic shift-reduce algorithm trained with a regularized multiclass perceptron. We showed that with the perceptron it is possible to adopt higher-order feature maps equivalent to polynomial kernels without need of approximating the model (although this remains an option for optimization). The resulting models achieve accuracies comparable (or better) to more complex architectures based on dual SVM training, and faster parsing on unseen data. With respect to learning, it is possible that more sophisticated formulations of the perceptron (e.g. MIRA (Crammer & Singer, 2003) ) could provide further gains in accuracy, as shown with the MST parser (McDonald et al., 2005) . We also experimented with novel types of semantic features, extracted from the annotations produced by an entity tagger trained on the BBN corpus. This model further improves over the standard model yielding an additional 5.8% relative error reduction. Although the magnitude of the improvement is not striking, to the best of our knowledge this is the first encouraging evidence that annotated semantic information can improve parsing and suggests several options for further research. For example, this finding might indicate that this type of approach, which combines semantic tagging and parsing, is viable for the adaptation of parsing to new domains for which semantic taggers exist. Semantic features could be also easily included in other types of dependency parsing algorithms, e.g., MST, and in current methods for constituent parse reranking (Collins, 2000; Charniak & Johnson, 2005) . For future research several issues concerning the semantic features could be tackled. We notice that more complex semantic features can be designed and evaluated. For example, it might be useful to guess the \"head\" of segments with simple heuristics, i.e., the guess the node which is more likely to connect the segment with the rest of the tree, which all internal components of the entity depend upon. It would be also interesting to extract semantic features from taggers trained on different datasets and based on different tagsets. Acknowledgments The first author would like to thank Thomas Hofmann for useful inputs concerning the presentation of the issue of higher-order feature representations of Section 3.4. We would also like to thank Brian Roark and the anonymous reviewers for useful comments and pointers to related work.",
    "abstract": "This paper investigates new design options for the feature space of a dependency parser. We focus on one of the simplest and most efficient architectures, based on a deterministic shift-reduce algorithm, trained with the perceptron. By adopting second-order feature maps, the primal form of the perceptron produces models with comparable accuracy to more complex architectures, with no need for approximations. Further gains in accuracy are obtained by designing features for parsing extracted from semantic annotations generated by a tagger. We provide experimental evaluations on the Penn Treebank.",
    "countries": [
        "Italy",
        "Spain"
    ],
    "languages": [],
    "numcitedby": "20",
    "year": "2007",
    "month": "June",
    "title": "Dependency Parsing with Second-Order Feature Maps and Annotated Semantic Information"
}