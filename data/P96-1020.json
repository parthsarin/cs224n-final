{
    "article": "This paper proposes the use of \"patternbased\" context-free grammars as a basis for building machine translation (MT) systems, which are now being adopted as personal tools by a broad range of users in the cyberspace society. We discuss major requirements for such tools, including easy customization for diverse domains, the efficiency of the translation algorithm, and scalability (incremental improvement in translation quality through user interaction), and describe how our approach meets these requirements. Introduction With the explosive growth of the World-Wide Web (WWW) as information source, it has become routine for Internet users to access textual data written in foreign languages. In Japan, for example, a dozen or so inexpensive MT tools have recently been put on the market to help PC users understand English text in WWW home pages. The MT techniques employed in the tools, however, are fairly conventional. For reasons of affordability, their designers appear to have made no attempt to tackle the well-known problems in MT, such as how to ensure the learnability of correct translations and facilitate customization. As a result, users are forced to see the same kinds of translation errors over and over again, except they in cases where they involve merely adding a missing word or compound to a user dictionary, or specifying one of several word-to-word translations as a correct choice. There are several alternative approaches that might eventually liberate us from this limitation on the usability of MT systems: Unification-based grammar formalisms and lexical-semantics formalisms (see LFG (Kaplan and Bresnan, 1982) , HPSG (Pollard and Sag, 1987) , and Generative Lexicon (Pustejovsky, 1991) , for example) have been proposed to facilitate computationally precise description of natural-language syntax and semantics. It is possible that, with the descriptive power of these grammars and lexicons, individual usages of words and phrases may be defined specifically enough to give correct translations. Practical implementation of MT systems based on these formalisms, on the other hand, would not be possible without much more efficient parsing and disambiguation algorithms for these formalisms and a method for building a lexicon that is easy even for novices to use. Corpus-based or example-based MT (Sato and Nagao, 1990; Sumita and Iida, 1991) and statistical MT (Brown et al., 1993) systems provide the easiest customizability, since users have only to supply a collection of source and target sentence pairs (a bilingual corpus). Two open questions, however, have yet to be satisfactorily answered before we can confidently build commercial MT systems based on these approaches: \u2022 Can the system be used for various domains without showing severe degradation of translation accuracy? \u2022 What is the minimum number of examples (or training data) required to achieve reasonable MT quality for a new domain? TAG-based MT (Abeill~, Schabes, and Joshi, 1990 ) 1 and pattern-based translation (Maruyama, 1993) share many important properties for successful implementation in practical MT systems, namely: \u2022 The existence of a polynomial-time parsing algorithm \u2022 A capability for describing a larger domain of locality (Schabes, Abeill~, and Joshi, 1988) \u2022 Synchronization (Shieber and Schabes, 1990) of the source and target language structures ing algorithm for TAGs has O(IGIn6) 2 worst case time complexity (Vijay-Shanker, 1987) , and that the \"patterns\" in Maruyama's approach are merely context-free grammar (CFG) rules. Thus, it has been a challenge to find a framework in which we can enjoy both a grammar formalism with better descriptive power than CFG and more efficient parsing/generation algorithms than those of TAGs. 3 In this paper, we will show that there exists a class of \"pattern-based\" grammars that is weakly equivalent to CFG (thus allowing the CFG parsing algorithms to be used for our grammars), but that it facilitates description of the domain of locality. Furthermore, we will show that our framework can be extended to incorporate example-based MT and a powerful learning mechanism. 1. Head constraints: The nonterminal symbol V in the source rule must have the verb miss as a syntactic head. The symbol V in the target rule must have the verb manquer as a syntactic head. The head of symbol S in the source (target) rule is identical to the head of symbol V in the source (target) rule as they are co-indexed. 2. Link constraints: Nonterminal symbols in source and target CFG rules are linked if they 2Where ]G] stands for the size of grammar G, and n is the length of an input string. 3Lexicalized CFG, or Tree Insertion Grammar (TIG) (Schabes and Waters, 1995) , has been recently introduced to achieve such efficiency and lexicalization. 4and its inflectional variants --we will discuss inflections and agreement issues later. 5The meaning of the word \"synchronized\" here is exactly the same as in STAG (Shieber and Schabes, 1990) . See also bilingual signs (Tsujii and Fujita, 1991) for a discussion of the importance of combining the appropriate domain of locality and synchronization. are given the same index \":i\". Linked nonterminal must be derived from a sequence of synchronized pairs. Thus, the first NP (NP:I) in the source rule corresponds to the second NP (NP:I) in the target rule, the Vs in both rules correspond to each other, and the second NP (NP:3) in the source rule corresponds to the first NP (NP:3) in the target rule. The source and target rules are called CFG skeleton of the pattern. The notion of a syntactic head is similar to that used in unification grammars, although the heads in our patterns are simply encoded as character strings rather than as complex feature structures. A head is typically introduced 6 in preterminal rules such as leave ---* V V *--partir where two verbs, \"leave\" and \"partir,\" are associated with the heads of the nonterminal symbol V. This is equivalently expressed as leave:l --~ V:I V:I ~ partir:l which is physically implemented as an entry of an English-French lexicon. A set T of translation patterns is said to accept an input s iff there is a derivation sequence Q for s using the source CFG skeletons of T, and every head constraint associated with the CFG skeletons in Q is satisfied. Similarly, T is said to translate s iff there is a synchronized derivation sequence Q for s such that T accepts s, and every head and link constraint associated with the source and target CFG skeletons in Q is satisfied. The derivation Q then produces a translation t as the resulting sequence of terminal symbols included in the target CFG skeletons in Q. Translation of an input string s essentially consists of the following three steps: 1. Parsing s by using the source CFG skeletons 2. Propagating link constraints from source to target CFG skeletons to build a target CFG derivation sequence Generating t from the target CFG derivation sequence The third step is a trivial procedure when the target CFG derivation is obtained. Theorem 1 Let T be a PCFG. Then, there exists a CFG GT such that for two languages L(T) and L(GT) accepted by T and GT, respectively, L(T) = L(GT) holds. That is, T accepts a sentence s iff GT accepts s. Proof: We can construct a CFG GT as follows: 1. GT has the same set of terminal symbols as T. 6A nonterminal symbol X in a source or target CFG rule X --* X1 ... Xk can only be constrained to have one of the heads in the RHS X1 ... X~. Thus, monotonicity of head constraints holds throughout the parsing process. 2. For each nonterminal symbol X in T, GT ineludes a set of nonterminal symbols {X~ ]w is either a terminal symbol in T or a special symbol e}. 3. For each preterminal rule X:i --+ wl:l w2:2 ... wk:k (1 < i < k), GT includes z Xwi --~ wl w2 ... wk (1 < i < k). If X is not co-indexed with any of wl, GT includes Xe ~Wl w2 ... Wk. 4. For each source CFG rule with head constraints (hi, h2, ..., hk) and indexes (il, i2,..., ik) , Y :ij ---* hl :Xl :il ... hk :Xk :ik (1 <_ j < k), GT includes Yhj ---* Xhl Xh2 ... Xhk. If Y is not co-indexed with any of its children, we have Y~ --* Xh~ Xh2 ... Xhk. If Xj has no head constraint in the above rule, GT includes a set of (N + 1) rules, where Xhj above is replaced with Xw for every terminal symbol w and Xe (Yhj will also be replaced if it is co-indexed with Xj).s Now, L(T) C_ L(GT) is obvious, since GT can simulate the derivation sequence in T with corresponding rules in GT. L(GT) C L(T) can be proven, with mathematical induction, from the fact that every valid derivation sequence of GT satisfies head constraints of corresponding rules in T. [3 Proposition 1 Let a CFG G be a set of source CFG skeletons in T. Then, L(T) C n(c). Since a valid derivation sequence in T is always a valid derivation sequence in G, the proof is immediate. Similarly, we have Proposition 2 Let a CFG H be a subset of source CFG skeletons in T such that a source CFG skeleton k is in H iffk has no head constraints associated with it. Then, L(H) C L(T). THead constraints ate trivially satisfied or violated in preterminal rules. Hence, we assume, without loss of generality, that no head constraint is given in pretetminal rules. We also assume that \"X ---* w\" implies \"X:I w:l\". STherefore, a single rule in T can be mapped to as many as (N + 1) k rules in GT, where N is the number of terminal symbols in T. GT could be exponentially larger than T. Two CFGs G and H define the range of CFL L(T). These two CFGs can be used to measure the \"default\" translation quality, since idioms and collocational phrases are typically translated by patterns with head constraints. Theorem 2 Let a CFG G be a set of source CFG skeletons in T. Then, L(T) C L(G) is undecidable. Proof\" The decision problem, L(T) C L(G), of two CFLs such that L(T) C L(G) is solvable iff L(T) = L(G) is solvable. This includes a known undecidable problem, L(T) = E*?, since we can choose a grammar U with L(U) = E*, nullify the entire set of rules in U by defining T to be a vacuous set {S:I a:Sb:l, Sb:l --+ b:Su:l} U U (Sv and S are start symbols in U and T, respectively), and, finally, let T further include an arbitrary CFG F. L(G) = E* is obvious, since G has {S --* Sb, Sb --* Sv} U U. Now, we have L(G) = L(T) iff L(F) = E*. [3 Theorem 2 shows that the syntactic coverage of T is, in general, only computable by T itself, even though T is merely a CFL. This may pose a serious problem when a grammar writer wishes to know if there is a specific expression that is only acceptable by using at least one pattern with head constraints, for which the answer is \"no\" iff L(G) = L(T). One way to trivialize this problem is to let T include a pattern with a pair of pure CFG rules for every pattern with head constraints, which guarantees that L(H) = L(T) = L(G). In this case, we know that the coverage of \"default\" patterns is always identical to L(T). Although our \"patterns\" have no more theoretical descriptive power than CFG, they can provide considerably better descriptions of the domain of locality than ordinary CFG rules. For example, be:V:l year:NP:2 old ---* VP:I VP:I *-avoir:V:l an:NP:2 can handle such NP pairs as \"one year\" and \"un an,\" and \"more than two years\" and \"plus que deux ans,\" which would have to be covered by a large number of plain CFG rules. TAGs, on the other hand, are known to be \"mildly context-sensitive\" grammars, and they can capture a broader range of syntactic dependencies, such as cross-serial dependencies. The computational complexity of parsing for TAGs, however, is O(IGIn6), which is far greater than that of CFG parsing. Moreover, defining a new STAG rule is not as easy for the users as just adding an entry into a dictionary, because each STAG rule has to be specified as a pair of tree structures. Our patterns, on the other hand, concentrate on specifying linear ordering of source and target constituents, and can be written by the users as easily as 9 9By sacrificing linguistic accuracy for the description of syntactic structures. to leave * --de quitter * to be year:* old = d'avoir an:* Here, the wildcard \"*\" stands for an NP by default. The preposition \"to\" and \"de\" are used to specify that the patterns are for VP pairs, and \"to be\" is used to show that the phrase is the BE-verb and its complement. A wildcard can be constrained with a head, as in \"house:*\" and \"maison:*\". The internal representations of these patterns are as follows: leave:V:l NP:2 ~ VP:I VP:I ~--quitter:V:l NP:2 be:V:l year:NP:2 old --+ VP:I VP:I ~ avoir:V:l an:NP:2 These patterns can be associated with an explicit nonterminal symbol such as \"V:*\" or \"ADJP:*\" in addition to head constraints (e.g., \"leave:V:*'). By defining a few such notations, these patterns can be successfully converted into the formal representations defined in this section. Many of the divergences (Doff, 1993) in source and target language expressions are fairly collocational, and can be appropriately handled by using our patterns. Note the simplicity that results from using a notation in which users only have to specify the surface ordering of words and phrases. More powerful grammar formalisms would generally require either a structural description or complex feature structures. 3 The Translation Algorithm The parsing algorithm for translation patterns can be any of known CFG parsing algorithms including CKY and Earley algorithms 1\u00b0 At this stage, head and link constraints are ignored. It is easy to show that the number of target charts for a single source chart increases exponentially if we build target charts simultaneously with source charts. For example, the two patterns Our strategy is thus to find a candidate set of source charts in polynomial time. We therefore apply heuristic measurements to identify the most promising patterns for generating translations. In 1\u00b0Our prototype implementation was based on the Earley algorithm, since this does not require lexicalization of CFG rules. this sense, the entire translation algorithm is not guaranteed to run in polynomial time. Practically, a timeout mechanism and a process for recovery from unsuccessful translation (e.g., applying the idea of fitted parse (Jensen and Heidorn, 1983) to target CFG rules) should be incorporated into the translation algorithm. Some restrictions on patterns must be imposed to avoid infinitely many ambiguities and arbitrarily long translations. The following patterns are therefore not allowed: The basic strategy for choosing a candidate derivation sequence from ambiguous parses is as follows. 11 A simplified view of the Earley algorithm (Earley, 1970) consists of three major components, predict(i), complete(i), and scan(i), which are called at each position i = 0, 1,..., n in an input string I = sls2...sn. Predict(i) returns a set of currently applicable CFG rules at position i. Complete(i) combines inactive charts ending at i with active charts that look for the inactive charts at position i to produce a new collection of active and inactive charts. Scan(i) tries to combine inactive charts with the symbol si+l at position i. Complete(n) gives the set of possible parses for the input I. Now, for every inactive chart associated with a nonterminal symbol X for a span of (i~) (1 ~ i, j <_ n), there exists a set P of patterns with the source CFG skeleton, ... --* X. We can define the following ordering of patterns in P; this gives patterns with which we can use head and link constraints for building target charts and translations. These candidate patterns can be arranged and associated with the chart in the complete() procedure. 1. A--*XY~--B 2. A + X Y ~-C1...B...C~ if 1. Prefer a pattern p with a source CFG skeleton X --~ X1...X~ over any other pattern q with the same source CFG skeleton X --~ X1 ..' Xk, such that p has a head constraint h:Xi if q has h:Xi (i = 1,...,k). The pattern p is said to be more specific than q. For example, p = 11 This strategy is similar to that of transfer-driven MT (TDMT) (Furuse and Iida, 1994) . TDMT, however, is based on a combination of declarative/procedural knowledge sources for MT, and no clear computational properties have been investigated. \"leave:V:1 house:NP --+ VP:I\" is preferred to q = \"leave:V:l NP --* VP:I\". Prefer a pattern p with a source CFG skeleton to any pattern q that has fewer terminal symbols in the source CFG skeleton than p. For example, prefer \"take:V:l a walk\" to \"take:V:l NP\" if these patterns give the VP charts with the same span. 3. Prefer a pattern p which does not violate any head constraint over those which violate a head constraint. 4. Prefer the shortest derivation sequence for each input substring. A pattern for a larger domain of locality tends to give a shorter derivation sequence. These preferences can be expressed as numeric values (cost) for patterns. 12 Thus, our strategy favors lexicalized (or head constrained) and collocational patterns, which is exactly what we are going to achieve with pattern-based MT. Selection of patterns in the derivation sequence accompanies the construction of a target chart. Link constraints are propagated from source to target derivation trees. This is basically a bottom-up procedure. Since the number M of distinct pairs (X,w), for a nonterminal symbol X and a subsequence w of input string s, is bounded by Kn 2, we can compute the mbest choice of pattern candidates for every inactive chart in time O(ITIKn 3) as claimed by Maruyama (Maruyama, 1993) , and Schabes and Waters (Schabes and Waters, 1995) . Here, K is the number of distinct nonterminal symbols in T, and n is the size of the input string. Note that the head constraints associated with the source CFG rules can be incorporated in the parsing algorithm, since the number of triples (X,w,h), where h is a head of X, is bounded by Kn 3. We can modify the predict(), complete(), and scan() procedures to run in O([T[Kn 4) while checking the source head constraints. Construction of the target charts, if possible, on the basis of the m best candidate patterns for each source chart takes O(Kn~m) time. Here, m can be larger than 2 n if we generate every possible translation. The reader should note critical differences between lexicalized grammar rules (in the sense of LTAG and TIG) and translation patterns when they are used for MT. Firstly, a pattern is not necessarily lexicalized. An economical way of organizing translation patterns is to include non-lexicalized patterns as \"default\" translation rules. 12A similar preference can be defined for the target part of each pattern, but we found many counterexamples, where the number of nontermina] symbols shows no specificity of the patterns, in the target part of English-to-Japanese translation patterns. Therefore, only the head constraint violation in the target part is accounted for in our prototype. Secondly, lexicalization might increase the size of STAG grammars (in particular, compositional grammar rules such as ADJP NP --* NP) considerably when a large number of phrasal variations (adjectives, verbs in present participle form, various numeric expressions, and so on) multiplied by the number of their translations, are associated with the ADJP part. The notion of structure sharing (Vijay-Shanker and Schabes, 1992 ) may have to be extended from lexical to phrasal structures, as well as from monolingual to bilingual structures. Thirdly, a translation pattern can omit the tree structure of a collocation, and leave it as just a sequence of terminal symbols. The simplicity of this helps users to add patterns easily, although precise description of syntactic dependencies is lost. 4 Features and Agreements Translation patterns can be enhanced with unification and feature structures to give patterns additional power for describing gender, number, agreement, and so on. Since the descriptive power of unification-based grammars is considerably greater than that of CFG (Berwick, 1982) , feature structures have to be restricted to maintain the efficiency of parsing and generation algorithms. Shieber and Schabes briefly discuss the issue (Shieber and Schabes, 1990) . We can also extend translation patterns as follows: Each nonterminal node in a pattern can be associated with a fixed-length vector of binary features. This will enable us to specify such syntactic dependencies as agreement and subcategorization in patterns. Unification of binary features, however, is much simpler: unification of a feature-value pair succeeds only when the pair is either (0,0) or (1,1/. Since the feature vector has a fixed length, unification of two feature vectors is performed in a constant time. For example, the patterns 13 where \"-OBJ\" is a local feature for head VPs in LIISs, while \"+OBJ\" is a local feature for VPs in 13Again, these patterns can be mapped to a weakly equivalent set of CFG rules. See GPSG (Gazdar, Pullum, and Sag, 1985) for more details. the RHSs. Unification of a local feature with +OBJ succeeds since it is not bound. Agreement on subjects (nominative NPs) and finite-form verbs (VPs, excluding the BE verb) is disjunctively specified as Another way to extend our grammar formalism is to associate weights with patterns. It is then possible to rank the matching patterns according to a linear ordering of the weights rather than the pairwise partial ordering of patterns described in the previous section. In our prototype system, each pattern has its original weight, and according to the preference measurement described in the previous section, a penalty is added to the weight to give the effective weight of the pattern in a particular context. Patterns with the least weight are to be chosen as the most preferred patterns. Numeric weights for patterns are extremely useful as means of assigning higher priorities uniformly to user-defined patterns. Statistical training of patterns can also be incorporated to calculate such weights systematically (Fujisaki et al., 1989) . Figure I shows a sample translation of the input \"He knows me well,\" using the following patterns. In the above example, the Earley-based algorithm with source CFG rules is used in Phase 1. In Phase 2, head and link constraints are examined, and unification of feature structures is performed by using the charts obtained in Phase 1. Candidate patterns are ordered by their weights and preferences. Finally, in Phase 3, the target charts are built to generate translations based on the selected patterns. 5 Integration of Bilingual Corpora Integration of translation patterns with translation examples, or bilingual corpora, is the most important extension of our framework. There is no dis-crete line between patterns and bilingual corpora. Rather, we can view them together as a uniform set of translation pairs with varying degrees of lexicalization. Sentence pairs in the corpora, however, should not be just added as patterns, since they are often redundant, and such additions contribute to neither acquisition nor refinement of non-sentential patterns. Therefore, we have been testing the integration method with the following steps. Let T be a set of translation patterns, B be a bilingual corpus, and (s,t) be a pair of source and target sentences. The grammar acquisition scheme described above has not yet been automated, but has been manually simulated for a set of 770 English-Japanese simple sentence pairs designed for use in MT system evaluation, which is available from JEIDA (the Japan Electronic Industry Development Association) ((the Japan Electronic Industry Development Association), 1995), including: #100: Any question will be welcomed. ~200: He kept calm in the face of great danger. #300: He is what is called \"the man in the news\". ~400: Japan registered a trade deficit of $101 million, reflecting the country's economic sluggishness, according to government figures. #500: I also went to the beach 2 weeks earlier. At an early stage of grammar acquisition, [Addition of New Patterns] was primarily used to enrich the set T of patterns, and many sentences were unambiguously and correctly translated. At a later stage, however, JEIDA sentences usually gave several translations, and [Lexicalization] with careful assignment of weights was the most critical task. Although these sentences are intended to test a system's ability to translate one basic linguistic phenomenon in each simple sentence, the result was strong evidence for our claim. Over 90% of JEIDA sentences were correctly translated. Among the failures were: ~95: I see some stamps on the desk . #171: He is for the suggestion, but I'm against it. ~244: She made him an excellent wife. #660: He painted the walls and the floor white. Some (prepositional and sentential) attachment ambiguities needs to be resolved on the basis of semantic information, and scoping of coordinated structures would have to be determined by using not only collocational patterns but also some measures of balance and similarities among constituents. 6 Conclusions and Future Work Some assumptions about patterns should be reexamined when we extend the definition of patterns. The notion of head constraints may have to be extended into one of a set membership constraint if we need to handle coordinated structures (Kaplan and Maxwell III, 1988) . Some light-verb phrases cannot be correctly translated without \"exchanging\" several feature values between the verb and its object. A similar problem has been found in be-verb phrases. Grammar acquisition and corpus integration are fundamental issues, but automation of these processes (Watanabe, 1993) is still not complete. Development of an efficient translation algorithm, not just an efficient parsing algorithm, will make a significant contribution to research on synchronized grammars, including STAGs and our PCFGs. prototype. Their technical discussions and suggestions greatly helped me shape the idea of patternbased CFGs. I would also like to thank Taijiro Tsutsumi, Masayuki Morohashi, Hiroshi Nomiyama, Tetsuya Nasukawa, and Naohiko Uramoto for their valuable comments. Michael McDonald, as usual, helped me write the final version. Acknowledgments Hideo Watanabe designed and implemented a prototype MT system for pattern-based CFGs, while Shiho Ogino developed a Japanese generator of the",
    "abstract": "This paper proposes the use of \"patternbased\" context-free grammars as a basis for building machine translation (MT) systems, which are now being adopted as personal tools by a broad range of users in the cyberspace society. We discuss major requirements for such tools, including easy customization for diverse domains, the efficiency of the translation algorithm, and scalability (incremental improvement in translation quality through user interaction), and describe how our approach meets these requirements.",
    "countries": [
        "Japan"
    ],
    "languages": [
        "Japanese",
        "English",
        "French"
    ],
    "numcitedby": "36",
    "year": "1996",
    "month": "June",
    "title": "Pattern-Based Context-Free Grammars for Machine Translation"
}