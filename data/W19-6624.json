{
    "article": "Neural machine translation (NMT) systems operate primarily on words (or subwords), ignoring lower-level patterns of morphology. We present a characteraware decoder designed to capture such patterns when translating into morphologically rich languages. We achieve character-awareness by augmenting both the softmax and embedding layers of an attention-based encoder-decoder model with convolutional neural networks that operate on the spelling of a word. To investigate performance on a wide variety of morphological phenomena, we translate English into 14 typologically diverse target languages using the TED multi-target dataset. In this low-resource setting, the character-aware decoder provides consistent improvements with BLEU score gains of up to +3.05. In addition, we analyze the relationship between the gains obtained and properties of the target language and find evidence that our model does indeed exploit morphological patterns. 1 The dropout rate was found to be critical in Cherry et al. (2018) , and each tuning run takes much longer due to longer sequence lengths. 2 Also referred to as generator, final output layer or final linear Introduction Traditional attention-based encoder-decoder neural machine translation (NMT) models learn wordlevel embeddings, with a continuous representation for each unique word type (Bahdanau et al., 2015) . However, this results in a long tail of rare words for which we do not learn good representations. More recently, it has become standard pracc 2019 The authors. This article is licensed under a Creative Commons 4.0 licence, no derivative works, attribution, CC-BY-ND. * Equal Contribution tice to mitigate the vocabulary size problem with Byte-Pair Encoding (BPE) (Gage, 1994; Sennrich et al., 2016) . BPE iteratively merges consecutive characters into larger chunks based on their frequency, which results in the breaking up of less common words into \"subword units.\" While BPE addresses the vocabulary size problem, the spellings of the subword units are still ignored. On the other hand, purely character-level NMT translates one character at a time and can implicitly learn about morphological patterns within words as well as generalize to unseen vocabulary. Recently, Cherry et al. (2018) show that very deep character-level models can outperform BPE, however, the smallest data size evaluated was 2 million sentences, so it is unclear if the results hold for low-resource settings and when translating into a range of different morphologically rich languages. Furthermore, tuning deep character-level models is expensive, even for low-resource settings. 1  A middle-ground alternative is character-aware word-level modeling. Here, the NMT system operates over words but uses word embeddings that are sensitive to spellings and thereby has the ability to learn morphological patterns in the language. Such character-aware approaches have been applied successfully in NMT to the source-side word embedding layer (Costa-juss\u00e0 and Fonollosa, 2016) , but surprisingly, similar gains have not been achieved on the target side (Belinkov et al., 2017) . While source-side character-aware models only need to make the source embedding layer character-aware, on the target-side we require both the target embedding layer and the softmax layer 2 to be character-aware, which presents additional challenges. We find that the trivial application of methods from Costa-juss\u00e0 and Fonollosa (2016) to these target-side embeddings results in significant drop in performance. Instead, we propose mixing compositional and standard word embeddings via a gating function. While simple, we find it is critical to successful target-side character awareness. It is worth noting that unlike some purely character-level methods our aim is not to generate novel words, though this method can function on top of subword methods which do so (Shapiro and Duh, 2018) . Rather, the character-aware representations decrease the sparsity of embeddings for rare words or subwords, which are a problem in low-resource morphologically rich settings. We summarize our contribution as follows: 1. We propose a method for utilizing characteraware embeddings in an NMT decoder that can be used over word or subword sequences. 2. We explore how our method interacts with BPE over a range of merge operations (including word-level and purely characterlevel) and highlight that there is no \"typical BPE\" setting for low-resource NMT. 3. We evaluate our model on 14 target languages and observe consistent improvements over baselines. Furthermore, we analyze to what extent the success of our method corresponds to improved handling of target language morphology. Related Work NMT has benefited from character-aware word representations on the source side (Costa-juss\u00e0 and Fonollosa, 2016) , which follows language modeling work by Kim et al. (2016) and generate sourceside input embeddings using a CNN over the character sequence of each word. Further analysis revealed that hidden states of such character-aware models have increased knowledge of morphology (Belinkov et al., 2017) . They additionally try using character-aware representations in the target side embedding layer, leaving the softmax matrix with standard word representations, and found no improvements. Our work is also aligned with the characteraware models proposed in (Kim et al., 2016) , but projection. we additionally employ a gating mechanism between character-aware representations and standard word representations similar to language modeling work by (Miyamoto and Cho, 2016) . However, our gating is a learned type-specific vector rather than a fixed hyperparameter. There is additionally a line of work on purely character-level NMT, which generates words one character at a time (Ling et al., 2015; Chung et al., 2016; Passban et al., 2018) . While initial results here were not strong, Cherry et al. (2018) revisit this with deeper architectures and sweeping dropout parameters and find that they outperform BPE across settings of the merge hyperparameter. They examine different data sizes and observe improvements in the smaller data size settingshowever, the smallest size is about 2 million sentence pairs. In contrast, we look at a smaller order of magnitude data size and present an alternate approach which doesn't require substantial tuning of parameters across different languages. Finally, Byte-Pair Encoding (BPE) (Sennrich et al., 2016) has become a standard preprocessing step in NMT pipelines and provides an easy way to generate sequences with a mixture of full words and word fragments. Note that BPE splits are agnostic to any morphological pattern present in the language, for example the token politely in our dataset is split into pol+itely, instead of the linguistically plausible split polite+ly. 3 Our approach can be applied to word-level sequences and sequences at any BPE merge hyperparameter greater than 0. Increasing the hyperparameter results in more words and longer subwords that can exhibit morphological patterns. Our goal is to exploit these morphological patterns and enrich the word (or subword) representations with characterawareness. 3 Encoder-Decoder NMT An attention-based encoder-decoder network (Bahdanau et al., 2015; Luong et al., 2015) models the probability of a target sentence y of length J given a source sentence x as: p(y | x) = J j=1 p(y j | y 0:j\u22121 , x; \u03b8) (1) where \u03b8 represents all the parameters of the network. At each time-step the j th output token is generated by: p(y j | y 0:j\u22121 , x) = softmax(W o s j ) (2) where s j \u2208 R D\u00d71 is the decoder hidden state at time j and W o \u2208 R |V|\u00d7D is the weight matrix of the softmax layer, which provides a continuous representation for target words. s j is computed using the following recurrence: s j = tanh(W c [c j ; sj ]) (3) sj = f ([s j\u22121 ; w s y j\u22121 ; sj\u22121 ]) (4) where f is an LSTM cell. 4 W s \u2208 R |V|\u00d7E is the target-side embedding matrix, which provides continuous representations for the previous target word when used as input to the RNN. Here, w s y j\u22121 \u2208 R 1\u00d7E is a row vector from the embedding matrix W s corresponding to the value of y j\u22121 . V is the target vocabulary set, D is the is the RNN size and E is embedding size. Often these matrices W o and W s are tied. The context vector c j is obtained by taking a weighted average over the concatenation of a bidirectional RNN encoder's hidden states. c j = I i=1 \u03b1 i , h i (5) \u03b1 i = exp (s j W a h i ) l exp (s j W a h l ) (6) The attention matrix W a \u2208 R D\u00d7H is learned jointly with the model, multiplying with the previous decoder state and bidirectional encoder state h i \u2208 R H\u00d71 , normalized over encoder hidden states via the softmax operation. Character-Aware Extension In this section we detail the incorporation of character-awareness into the two decoder embedding matrices W o and W s . To begin, we consider an example target side word (or subword in the case of preprocessing with BPE), cat. In both W o and W s , there exist row vectors, w o cat and w s cat that contain the continuous vector representation for the word cat. In a traditional NMT system, these vectors are learned as the entire network tries to maximize the objective in Equation 1. The objective does not require the vectors and w s cat to model any aspect of the spelling of the word. Figure 1a illustrates a simple noncompositional word embedding. w o cat w v std v = cat (a) c t a highway 1 highway 2 /s s w v comp v = cat (b) At a high level, we can view our notion of character-awareness as a composition function comp(.; \u03c9), parameterized by \u03c9, that takes the character sequence that makes up a word (i.e. its spelling) as input and then produces a continuous vector representation: w cat comp = comp( s , c, a, t, /s ; \u03c9) (7) \u03c9 is learned jointly with the overall objective. Special characters s and /s denote the beginning and end of sequence respectively. Figure 1b illustrates our compositional approach to generating embeddings (Kim et al., 2016) . First, a character-embedding layer converts the spelling of a word into a sequence of character embeddings. Next, we apply 4 convolution operations, with kernel sizes 3, 4, 5 and 6, over the character sequence and the resulting output matrix is max-pooled. We set the output channel size of each convolution to 1 4 of the final desired embedding size. The maxpooled vector from each convolution is concatenated to create the composed word representation. Finally, we add highway layers to obtain the final embeddings. Composed & Standard Gating The composition is applied to every type in the vocabulary and thus generates a complete embedding matrix (and softmax matrix). In doing so, we assume that every word in the vocabulary has a vector representation that can be composed from its spelling sequence. This is a strong assumption as many words, in particular high frequency words, are not normally compositional, e.g. the substring ing in thing is not compositional in the way that it is in running. Thus, we mix the compositional and standard embedding vectors. We expect standard embeddings to better represent the meaning of certain words, such has function words and other high-frequency words. For each word v in the vocabulary we also learn a gating vector g v \u2208 [0, 1] 1\u00d7D . g v = \u03c3(w v gate ) (8) Where, \u03c3 is a sigmoid operation and type-specific parameters w v gate are jointly learned along with all the other parameters of the composition function. These parameters are regularized to remain close to 0 using dropout. 5 Our final mixed word representation for each word v \u2208 V is given by: w v mix = g v w v std + (1. \u2212 g v ) w v comp (9) Where w v mix is the final word embedding, w v std is the standard word embedding, w v comp is the embedding by the composition function and g v is the type-specific gating vector for the v'th word. The weight matrix is obtained by stacking the word vectors for each word v \u2208 V. The same representation is used for the target embedding layer and the softmax layer i.e. we set w o cat = w s cat = w cat mix , when v = cat. Thus, tying the composition function parameters for the softmax weight matrix and the target-side embedding matrix. Experiments comparing the standard embedding model and the compositional embedding model with and without gating are summarized in Table 1 . Row \"C\" shows the performance of naively using the composition function (which works in the source-side) on the target-side. We observe a catastrophic drop in BLEU (\u221214.62) compared to a standard NMT encoder-decoder. The Character-aware gated model(CG), however, outperforms the baseline by 0.91 BLEU points suggesting that the CNN composition function and standard embeddings work in a complementary fashion. Large Vocabulary Approximation In Equation 2 of the general NMT framework, the softmax operation generates a distribution over the output vocabulary. Our character-aware model requires a much larger computation graph as we apply convolutions (and highway layers) over the To make our character-aware model accommodate large target vocabulary sizes, we incorporate an approximation mechanism based on (Jean et al., 2015) . Instead of computing the softmax over the entire vocabulary, we uniformly sample 20k vocabulary types and the vocabulary types that are present in the training batch. During decoding, we compute the forward pass W o s j in Equation 2 in several splits of the target vocabulary. As no backward pass is required we clear the memory (i.e. delete the computation graph) after each split is computed. Experiments We evaluate our character aware model on 14 different languages in a low-resource setting. Additionally, we sweep over several BPE merge hyperparameter settings from character-level to fully word-level for both our model and the baseline and find consistent gains in the character-aware model over the baseline. These gains are stable across all BPE merge hyperparameters all the way up to word-level where they are the highest. Datasets We use a collection of TED talk transcripts (Duh, 2018; Cettolo et al., 2012) . This dataset has languages with a variety of morphological typologies, which allows us to observe how the success of our character-aware decoder relates to morphological complexity. We keep the source language fixed as English and translate into 14 different languages, since our focus is on the decoder. Ukrainian to around 174k sentences pairs for Russian (provided in Appendix A), but the validation and test sets are \"multi-way parallel\", meaning the English sentences (the source side in our experiments) are the same across all 14 languages, and are about 2k sentences each. We filter out training pairs where the source sentence was longer that 50 tokens (before applying BPE). For word-level results, we used a vocabulary size of 100k (keeping the most frequent types) and replaced rare words by an <UNK> token. NMT Setup We work with OpenNMT-py (Klein et al., 2017) , and modify the target-side embedding layer and softmax layer to use our proposed character-aware composition function. A 2 layer encoder and decoder, with 1000 recurrent units were used in all experiments The embeddings sizes were made to match the RNN recurrent size. We set the character embedding size to 50 and use four CNNs with kernel widths 3, 4, 5 and 6. The four CNN outputs are concatenated into a compositional embeddings and gated with a standard word embedding. The same composition function (with shared parameters) was used for the target embedding layer and the softmax layer. We optimize the NMT objective (Equation 1 ) using SGD. 6 An initial learning rate of 1.0 was used for the first 8 epochs and then decayed with a decay rate of 0.5 until the learning rate reached a minimum threshold of 0.001. We use a batch size 6 SGD outperformed both Adam and Adadelta. Others have found similar trends, see Bahar et al. (2017) and Maruf and Haffari (2018) . Lang Char Results We provide case insensitive BLEU scores for our main experiments, comparing our character-aware model (CG) against a baseline model that uses only standard word (and subword) embeddings. We divide the results of our model's performance into three parts: (i) over a sweep of BPE merge operations, including a commonly used setting of 30k merge operations (ii) with word-level source and target sequences and finally, (iii) against a purely character-level model. BPE Results Part 1 of Table 2 compares the best BLEU score obtained by the baseline model, after performing a BPE sweep from 1.6k to 60k, to the best BLEU obtained by CG after sweeping over the same BPE range. While our study focuses on the target side, BPE (with the same number of merge operations) was applied to both source and target for our experiments. We find that after this sweep, CG outperforms the baseline in all 14 languages. The exhaustive table of results for these experiments is presented in Appendix A. No Typical BPE Setting Additionally, we see that the BPE setting that achieves best BLEU in the baseline model varies considerably from 1.6k to 30k depending on the target language, indicating that there is no \"typical\" BPE for low-resource settings. In the CG model, however, performance was usually best at 30k. Part 2 of Table 2 compares the baseline and CG at BPE of 30k where CG performs optimally. We find that our CG model consistently outperforms the baseline for almost all BPE merge hyperparameters across all 14 languages. Figure 2 shows the gains observed by the CG model as we sweep over BPE merge operations. While the baseline model does slightly better than CG at small BPE settings for a few languages (all points below the 0 value), a majority of the points show positive gains. Word-Level Results In Part 3 of Table 2 we show results with our approximation for word level. While our best results are generally with BPE, we note that we get the biggest relative gains using our method at the word level, which we expect is due to always having the whole word to learn character patterns over. For the CG model, in 60k BPE and word-level settings we used the large vocabulary approximation discussed in Section 4.2. Character-Level Results Finally, in Table 3 , we compare two characterlevel models against our CG model at 30k BPE. The shallow character-level model used 2 encoder and decoder layers with 1000 recurrent units, while the deep model used 6 encoder and decoder   layers with 512 recurrent units . 7 Furthermore, the improved results from the deep model were only attainable using the Fairseq toolkit with Noam optimization and 100 warmup steps (Gehring et al., 2017) . As Table 3 shows, our CG model with 30k BPE compares favorably to even deep characterlevel models for this low-resource setting. Analysis We are interested in understanding whether our character-aware model is exploiting morphological patterns in the target language. We investigate this by inspecting the relationship between a set of hand-picked features and improvements obtained by our model over the baseline at wordlevel inputs. These features fall into two categories, corpus-dependent and corpus-independent. We following Bentz et al. (2016) , and extract features known to correlate with human judgments of morphological complexity. The following corpusdependent features were used: (i) Type-Token Ratio (TT): the ratio of the number of word types to the total number of word tokens in the target side. We note that a large corpus tends to have a smaller type-token ratio compared to small corpus. (ii) Word-Alignment Score (A): computed as A = |many-to-one|\u2212|one-to-many| |all-alignments| . One-toone, one-to-many and many-to-one alignment types are illustrated in Figure 3 . 8 We intuit that a morphologically poor source language (like English) paired with a richer target language should exhibit more many-toone alignments-a single word in the target will contain more information (via morphological phenomena) that can only be translated using multiple words in the source. (iii) Word-Level Entropy (H): computed as H = v\u2208V p(v) log p(v) where v is a word type. This metric reflects the average information content of the words in a corpus. Languages with more dependence on having a large number of word types rather than word order or phrase structure will score higher. s 1 s 0 s 2 s 3 s 4 t 1 t 0 t 2 t 3 Figure 3 : Example of one-to-many (s0 to t0, t1), one-to-one (s1 to t2) and many-to-one (s2, s3, s4 to t3) alignments. For this example A = (3 \u2212 2)/6. For the corpus-independent features we used a morphological annotation corpus called Uni-Morph (Sylak-Glassman et al., 2015) . The Uni-Morph corpus contains a large list of inflected words (in several languages) along with the word's lemma and a set of morphological tags. For example, the French UniMorph corpus contains the word marchai (walked), which is associated with its lemma, marcher and a set of morphological tags {V,IND,PST,1,SG,PFV}. There are 19 such tags in the French UniMorph corpus. A morphologically richer language like Hungarian, for example, has 36 distinct tags. We used the number of distinct tags (UT) and the number of different tag combinations (UTC) that appear in the UniMorph corpus for each language. Note that we do not filter out words (and its associated tags) from the UniMorph corpus that are absent in our parallel data. This ensures that the UT and UTC features are completely corpus independent. The Pearson's correlation between these handpicked features and relative gain observed by our model is shown in Table 4 . For this analysis we used the relative gain obtained from the wordlevel experiments. Concretely, the relative gain for Czech was computed as 21.49\u221218.44   18.44   We see a strong correlation between the corpus-independent feature (UT) and our model's gain. Alignment score and Word Entropy are also moderately correlated. Surprisingly, we see no correlation to typetoken ratio. As the correlation analysis only examines the relation between BLEU gains and an individual feature, we further analyzed how the features jointly relate to BLEU gains. We fitted a linear regression model, setting the relative gains as the predicted variable y and the feature values as the input variables x, with the goal of studying the linear regression weights \u03c6. 9 We used feature-augmented domain adaptation where we consider each language as a domain (Daum\u00e9 III, 2007) , allowing the model to find a set of \"general\" weights as well language-specific weights that best fit the data (Equation 11 ). The general feature weights can be interpreted as being indicative of the overall trends in the dataset across all the languages, while the language-specific weights indicate language deviation from the overall trend. L(\u03c6) = i\u2208I | y i \u2212 \u1ef9i | 2 \u2212\u03bb | \u03c6 | 2 (10) \u1ef9i = \u03c6 T ALL x i + \u03c6 T i x i (11) Where, y is the true relative gain in BLEU, \u1ef9 is the predicted gain, x is a vector of input feature values, \u03c6 ALL and \u03c6 i are the general and language-specific weights, and i indexes into the set of languages in our analysis. We set \u03bb to 0.05. The matrix of learned weights \u03c6 is visualized in Figure 4 . The first row of weights correspond to the \"general\" weights that are used for all the languages, followed by language-specific weights sorted by relative gain. While the general weights align with the correlation results (Table 4 ), this analysis also shows that the UTC weight for Czech and Turkish are much larger than any of the other languages' and indeed we can verify that these languages have 194 and 300 different tag combinations while the average tag combinations is \u2248 110. From the corpus-dependent features, word alignment score strongly predicts the gain in BLEU scores. For Czech, Ukrainian, Turkish, Hungarian, and Polish we see additional weight placed on this feature. A similar trend can be seen for the word-entropy feature. While type-token ratio does not exhibit a strong overall trend, we see that Ukrainian and Farsi are outliers. Our correlation and regression analysis strongly suggest that CG character-aware modeling helps the most when the target language has inherent morphological complexity and that it does indeed have the ability to handle morphological patterns present in the target languages. Qualitative Examples We additionally look at specific examples of where our model is outperforming the baseline in the case of 30k BPE in En-Ar. We see a few trends, which we show examples of in Table 5 . The first trend, corresponding to the first example, is that it gets names better. This might be because Arabic is not written in the Latin alphabet, and the spellingaware model may be able to transliterate better. Another trend is that CG gets the endings of rare words correct, in particular when the BPE segmentation is not according to morpheme boundaries. The second example illustrates this, where the word for \"Mexican\" appears in the training data broken up by BPE with various morphological endings, all of which are spelled beginning Table 5 : Examples from En-Ar, transliterated with the Buckwalter schema. We show the version of our model and the English using '+' to denote where BPE splits words up, while BPE has not been applied to the target reference. with \"ky\" in the second subword. The morpheme boundaries here would be \"Al+mksyk+y.\" Note that CG also gets the definite article \"Al\" correct while the baseline does not. Finally, we see a pattern where our model does better for words which are rare and appear both with and without the definite article \"Al.\" Our third example in Table 5 illustrates this with an infrequent word, the word for \"referendum\", which gets broken up into subwords. In particular, the first subword sometimes has an \"Al\" attached in the training data. Our model is able to translate this subword, while the baseline skips the subword altogether, outputting two subwords that alone are not a valid word. Again, the word is not broken up along morpheme boundaries by BPE. Here there would be no way to break this word up into morphological segments-it consists of nonconcatenative derivational morphology. This occurs again in the fourth example in the word for \"heroes,\" where the baseline predicts the word for \"friends.\" In this case the word was not split up by BPE, but similarly it is rare but occurs with the definite article attached in the training data as well. Conclusion We extend character-aware word-level modeling to the decoder for translation into morphologically rich languages. Our improvements were attained by augmenting the softmax and the target embedding layers with character-awareness. We also find it critical to add a gating function to balance compositional embeddings with standard embeddings. We evaluate our method on a low-resource dataset translating from English into 14 languages, and on top of a spectrum of BPE merge operations. Furthermore, for word-level and higher merge hyperparameter settings, we introduced an approximation to the softmax layer. We achieve consistent performance gains across languages and subword granularities, and perform an analysis indicating that the gains for each language correspond to morphological complexity. For future work, we would like to explore how our methods might be of use in higher-resource settings. Furthermore, it would be interesting to see how these methods might interact with multilingual systems and if they might be able to improve what information is shared between related languages. A More Detailed Results In Table 6 , we provide the number of training sentences for each language. In Table 7 , we provide the full experiments of our sweep of BPE for both standard and our CG embeddings. In our baseline, we see a divergence in trends across languages while sweeping over BPE merge hyperparameters-Czech (cs), Turkish (tr), and Ukrainian (uk) for example, are highly sensitive to the BPE merge hyperparameter. On the other hand, for languages like French (fr) and Farsi (fa), the performance is mostly consistent across different BPE merge hyperparameters. Acknowledgements This project originated at the Machine Translation Marathon 2018. We thank the organizers and attendees for their support, feedback and helpful discussions during the event. This work is supported in part by the Office of the Director of National Intelligence, IARPA. The views contained herein are those of the authors and do not necessarily reflect the position of the sponsors.",
    "abstract": "Neural machine translation (NMT) systems operate primarily on words (or subwords), ignoring lower-level patterns of morphology. We present a characteraware decoder designed to capture such patterns when translating into morphologically rich languages. We achieve character-awareness by augmenting both the softmax and embedding layers of an attention-based encoder-decoder model with convolutional neural networks that operate on the spelling of a word. To investigate performance on a wide variety of morphological phenomena, we translate English into 14 typologically diverse target languages using the TED multi-target dataset. In this low-resource setting, the character-aware decoder provides consistent improvements with BLEU score gains of up to +3.05. In addition, we analyze the relationship between the gains obtained and properties of the target language and find evidence that our model does indeed exploit morphological patterns. 1 The dropout rate was found to be critical in Cherry et al. (2018) , and each tuning run takes much longer due to longer sequence lengths. 2 Also referred to as generator, final output layer or final linear",
    "countries": [
        "United States"
    ],
    "languages": [
        "French",
        "Ukrainian",
        "English"
    ],
    "numcitedby": "3",
    "year": "2019",
    "month": "August",
    "title": "Character-Aware Decoder for Translation into Morphologically Rich Languages"
}