{
    "article": "Comprehending action preconditions and effects is an essential step in modeling the dynamics of the world. In this paper, we express the semantics of precondition relations extracted from text in terms of planning operations. The challenge of modeling this connection is to ground language at the level of relations. This type of grounding enables us to create high-level plans based on language abstractions. Our model jointly learns to predict precondition relations from text and to perform high-level planning guided by those relations. We implement this idea in the reinforcement learning framework using feedback automatically obtained from plan execution attempts. When applied to a complex virtual world and text describing that world, our relation extraction technique performs on par with a supervised baseline, yielding an F-measure of 66% compared to the baseline's 65%. Additionally, we show that a high-level planner utilizing these extracted relations significantly outperforms a strong, text unaware baseline -successfully completing 80% of planning tasks as compared to 69% for the baseline. 1 Introduction Understanding action preconditions and effects is a basic step in modeling the dynamics of the world. For example, having seeds is a precondition for growing wheat. Not surprisingly, preconditions have been extensively explored in various sub-fields of AI. However, existing work on action models has largely focused on tasks and techniques specific to individual sub-fields with little or no interconnection between them. In NLP, precondition relations have been studied in terms of the linguistic mechanisms A pickaxe, which is used to harvest stone, can be made from wood. (a) Low Level Actions for: wood \u2192 pickaxe \u2192 stone step 1: move from (0,0) to (2,0) step 2: chop tree at: (2,0) step 3: get wood at: (2,0) step 4: craft plank from wood step 5: craft stick from plank step 6: craft pickaxe from plank and stick \u2022 \u2022 \u2022 step N-1: pickup tool: pickaxe step N: harvest stone with pickaxe at: (5,5) ( that realize them, while in classical planning, these relations are viewed as a part of world dynamics. In this paper, we bring these two parallel views together, grounding the linguistic realization of these relations in the semantics of planning operations. The challenge and opportunity of this fusion comes from the mismatch between the abstractions of human language and the granularity of planning primitives. Consider, for example, text describing a virtual world such as Minecraft 2 and a formal description of that world using planning primitives. Due to the mismatch in granularity, even the simple relations between wood, pickaxe and stone described in the sentence in Figure 1a results in dozens of lowlevel planning actions in the world, as can be seen in Figure 1b . While the text provides a high-level description of world dynamics, it does not provide sufficient details for successful plan execution. On the other hand, planning with low-level actions does not suffer from this limitation, but is computationally intractable for even moderately complex tasks. As a consequence, in many practical domains, planning algorithms rely on manually-crafted high-level abstractions to make search tractable (Ghallab et al., 2004; Lekav\u00fd and N\u00e1vrat, 2007) . The central idea of our work is to express the semantics of precondition relations extracted from text in terms of planning operations. For instance, the precondition relation between pickaxe and stone described in the sentence in Figure 1a indicates that plans which involve obtaining stone will likely need to first obtain a pickaxe. The novel challenge of this view is to model grounding at the level of relations, in contrast to prior work which focused on objectlevel grounding. We build on the intuition that the validity of precondition relations extracted from text can be informed by the execution of a low-level planner. 3 This feedback can enable us to learn these relations without annotations. Moreover, we can use the learned relations to guide a high level planner and ultimately improve planning performance. We implement these ideas in the reinforcement learning framework, wherein our model jointly learns to predict precondition relations from text and to perform high-level planning guided by those relations. For a given planning task and a set of candidate relations, our model repeatedly predicts a sequence of subgoals where each subgoal specifies an attribute of the world that must be made true. It then asks the low-level planner to find a plan between each consecutive pair of subgoals in the sequence. The observed feedback -whether the lowlevel planner succeeded or failed at each step -is utilized to update the policy for both text analysis and high-level planning. We evaluate our algorithm in the Minecraft virtual world, using a large collection of user-generated online documents as our source of textual information. Our results demonstrate the strength of our relation extraction technique -while using planning feedback as its only source of supervision, it achieves a precondition relation extraction accuracy on par with that of a supervised SVM baseline. Specifically, it yields an F-score of 66% compared to the 65% of the baseline. In addition, we show that these extracted relations can be used to improve the performance of a high-level planner. As baselines for this evaluation, we employ the Metric-FF planner (Hoffmann and Nebel, 2001), 4 as well as a textunaware variant of our model. Our results show that our text-driven high-level planner significantly outperforms all baselines in terms of completed planning tasks -it successfully solves 80% as compared to 41% for the Metric-FF planner and 69% for the text unaware variant of our model. In fact, the performance of our method approaches that of an oracle planner which uses manually-annotated preconditions. Related Work Extracting Event Semantics from Text The task of extracting preconditions and effects has previously been addressed in the context of lexical semantics (Sil et al., 2010; Sil and Yates, 2011) . These approaches combine large-scale distributional techniques with supervised learning to identify desired semantic relations in text. Such combined approaches have also been shown to be effective for identifying other relationships between events, such as causality (Girju and Moldovan, 2002; Chang and Choi, 2006; Blanco et al., 2008; Beamer and Girju, 2009; Do et al., 2011) . Similar to these methods, our algorithm capitalizes on surface linguistic cues to learn preconditions from text. However, our only source of supervision is the feedback provided by the planning task which utilizes the predictions. Additionally, we not only identify these relations in text, but also show they are valuable in performing an external task. Learning Semantics via Language Grounding Our work fits into the broad area of grounded language acquisition, where the goal is to learn linguistic analysis from a situated context (Oates, 2001; Siskind, 2001; Yu and Ballard, 2004; Fleischman and Roy, 2005; Mooney, 2008a; Mooney, 2008b; Branavan et al., 2009; Liang et al., 2009; Vogel and Jurafsky, 2010) . Within this line of work, we are most closely related to the reinforcement learning approaches that learn language by interacting with an external environment (Branavan et al., 2009; Branavan et al., 2010; Vogel and Jurafsky, 2010; Branavan et al., 2011) . Text (input): A pickaxe, which is used to harvest stone, can be made from wood. Precondition Relations: The key distinction of our work is the use of grounding to learn abstract pragmatic relations, i.e. to learn linguistic patterns that describe relationships between objects in the world. This supplements previous work which grounds words to objects in the world (Branavan et al., 2009; Vogel and Jurafsky, 2010) . Another important difference of our setup is the way the textual information is utilized in the situated context. Instead of getting step-by-step instructions from the text, our model uses text that describes general knowledge about the domain structure. From this text, it extracts relations between objects in the world which hold independently of any given task. Task-specific solutions are then constructed by a planner that relies on these relations to perform effective high-level planning. Hierarchical Planning It is widely accepted that high-level plans that factorize a planning problem can greatly reduce the corresponding search space (Newell et al., 1959; Bacchus and Yang, 1994) . Previous work in planning has studied the theoretical properties of valid abstractions and proposed a number of techniques for generating them (Jonsson and Barto, 2005; Wolfe and Barto, 2005; Mehta et al., 2008; Barry et al., 2011) . In general, these techniques use static analysis of the lowlevel domain to induce effective high-level abstractions. In contrast, our focus is on learning the abstraction from natural language. Thus our technique is complementary to past work, and can benefit from human knowledge about the domain structure. Problem Formulation Our task is two-fold. First, given a text document describing an environment, we wish to extract a set of precondition/effect relations implied by the text. Second, we wish to use these induced relations to determine an action sequence for completing a given task in the environment. We formalize our task as illustrated in Figure 2 . As input, we are given a world defined by the tuple S, A, T , where S is the set of possible world states, A is the set of possible actions and T is a deterministic state transition function. Executing action a in state s causes a transition to a new state s according to T (s | s, a). States are represented using propositional logic predicates x i \u2208 X, where each state is simply a set of such predicates, i.e. s \u2282 X. The objective of the text analysis part of our task is to automatically extract a set of valid precondition/effect relationships from a given document d. Given our definition of the world state, preconditions and effects are merely single term predicates, x i , in this world state. We assume that we are given a seed mapping between a predicate x i , and the word types in the document that reference it (see Table 3 for examples). Thus, for each predicate pair x k , x l , we want to utilize the text to predict whether x k is a precondition for x l ; i.e., x k \u2192 x l . For example, from the text in Figure 2 , we want to predict that possessing a pickaxe is a precondition for possessing stone. Note that this relation implies the reverse as well, i.e. x l can be interpreted as the effect of an action sequence performed on state x k . Each planning goal g \u2208 G is defined by a starting state s g 0 , and a final goal state s g f . This goal state is represented by a set of predicates which need to be made true. In the planning part of our task our objective is to find a sequence of actions a that connect s g 0 to s g f . Finally, we assume document d does not contain step-by-step instructions for any individual task, but instead describes general facts about the given world that are useful for a wide variety of tasks. Model The key idea behind our model is to leverage textual descriptions of preconditions and effects to guide the construction of high level plans. We define a highlevel plan as a sequence of subgoals, where each subgoal is represented by a single-term predicate, x i , that needs to be set in the corresponding world state -e.g. have(wheat)=true. Thus the set of possible subgoals is defined by the set of all possible single-term predicates in the domain. In contrast to low-level plans, the transition between these subgoals can involve multiple low-level actions. Our algorithm for textually informed high-level planning operates in four steps: 1. Use text to predict the preconditions of each subgoal. These predictions are for the entire domain and are not goal specific. 2. Given a planning goal and the induced preconditions, predict a subgoal sequence that achieves the given goal. 3. Execute the predicted sequence by giving each pair of consecutive subgoals to a low-level planner. This planner, treated as a black-box, computes the low-level plan actions necessary to transition from one subgoal to the next. 4. Update the model parameters, using the lowlevel planner's success or failure as the source of supervision. We formally define these steps below. Modeling Precondition Relations Given a document d, and a set of subgoal pairs x i , x j , we want to predict whether subgoal x i is a precondition for x j . We assume that precondition relations are generally described within single sentences. We first use our seed grounding in a preprocessing step where we extract all predicate pairs where both predicates are mentioned in the same sentence. We call this set the Candidate Relations. Note that this set will contain many invalid relations since co-occurrence in a sentence does not necessarily imply a valid precondition relation. 5 Thus for each sentence, w k , associated with a given Candidate Relation, x i \u2192 x j , our task is to predict whether the sentence indicates the relation. We model this decision via a log linear distribution as follows: p(x i \u2192 x j | w k , q k ; \u03b8 c ) \u221d e \u03b8c\u2022\u03c6c(x i ,x j , w k ,q k ) , (1) where \u03b8 c is the vector of model parameters. We compute the feature function \u03c6 c using the seed for i = 1 \u2022 \u2022 \u2022 T do Sample valid preconditions: C \u2190 \u2205 foreach x i , x j \u2208 C all do foreach Sentence w k containing x i and x j do v \u223c p(x i \u2192 x j | w k , q k ; \u03b8 c ) if v = 1 then C = C \u222a x i , x j end end Predict subgoal sequences for each task g. foreach g \u2208 G do Sample subgoal sequence x as follows: for t = 1 \u2022 \u2022 \u2022 n do Sample next subgoal: x t \u223c p(x | x t\u22121 , s g 0 , s g f , C; \u03b8 x ) Construct low-level subtask from x t\u22121 to x t Execute low-level planner on subtask end Update subgoal prediction model using Eqn. 2 end Update text precondition model using Eqn. 3 end Algorithm 1: A policy gradient algorithm for parameter estimation in our model. grounding, the sentence w k , and a given dependency parse q k of the sentence. Given these per-sentence decisions, we predict the set of all valid precondition relations, C, in a deterministic fashion. We do this by considering a precondition x i \u2192 x j as valid if it is predicted to be valid by at least one sentence. Modeling Subgoal Sequences Given a planning goal g, defined by initial and final goal states s g 0 and s g f , our task is to predict a sequence of subgoals x which will achieve the goal. We condition this decision on our predicted set of valid preconditions C, by modeling the distribution over sequences x as: p( x | s g 0 , s g f , C; \u03b8 x ) = n t=1 p(x t | x t\u22121 , s g 0 , s g f , C; \u03b8 x ), p(x t | x t\u22121 , s g 0 , s g f , C; \u03b8 x ) \u221d e \u03b8x\u2022\u03c6x(xt,x t\u22121 ,s g 0 ,s g f ,C) . Here we assume that subgoal sequences are Markovian in nature and model individual subgoal predictions using a log-linear model. Note that in con-trast to Equation 1 where the predictions are goalagnostic, these predictions are goal-specific. As before, \u03b8 x is the vector of model parameters, and \u03c6 x is the feature function. Additionally, we assume a special stop symbol, x \u2205 , which indicates the end of the subgoal sequence. Parameter Update Parameter updates in our model are done via reinforcement learning. Specifically, once the model has predicted a subgoal sequence for a given goal, the sequence is given to the low-level planner for execution. The success or failure of this execution is used to compute the reward signal r for parameter estimation. This predict-execute-update cycle is repeated until convergence. We assume that our reward signal r strongly correlates with the correctness of model predictions. Therefore, during learning, we need to find the model parameters that maximize expected future reward (Sutton and Barto, 1998) . We perform this maximization via stochastic gradient ascent, using the standard policy gradient algorithm (Williams, 1992; Sutton et al., 2000) . We perform two separate policy gradient updates, one for each model component. The objective of the text component of our model is purely to predict the validity of preconditions. Therefore, subgoal pairs x k , x l , where x l is reachable from x k , are given positive reward. The corresponding parameter update, with learning rate \u03b1 c , takes the following form: \u2206\u03b8 c \u2190 \u03b1 c r \u03c6 c (x i , x j , w k , q k ) \u2212 E p(x i \u2192x j |\u2022) \u03c6 c (x i , x j , w k , q k ) . (2) The objective of the planning component of our model is to predict subgoal sequences that successfully achieve the given planning goals. Thus we directly use plan-success as a binary reward signal, which is applied to each subgoal decision in a sequence. This results in the following update: \u2206\u03b8 x \u2190 \u03b1 x r t \u03c6 x (x t , x t\u22121 , s g 0 , s g f , C) \u2212 E p(x t |\u2022) \u03c6 x (x t , x t\u22121 , s g 0 , s g f , C) , (3) where t indexes into the subgoal sequence and \u03b1 x is the learning rate. Applying the Model We apply our method to Minecraft, a grid-based virtual world. Each grid location represents a tile of either land or water and may also contain resources. Users can freely move around the world, harvest resources and craft various tools and objects from these resources. The dynamics of the world require certain resources or tools as prerequisites for performing a given action, as can be seen in Figure 3 . For example, a user must first craft a bucket before they can collect milk. Defining the Domain In order to execute a traditional planner on the Minecraft domain, we define the domain using the Planning Domain Definition Language (PDDL) (Fox and Long, 2003) . This is the standard task definition language used in the International Planning Competitions (IPC). 6 We define as predicates all aspects of the game state -for example, the location of resources in the world, the resources and objects possessed by the player, and the player's location. Our subgoals x i and our task goals s g f map directly to these predicates. This results in a domain with significantly greater complexity than those solvable by traditional low-level planners. Table 1 compares the complexity of our domain with some typical planning domains used in the IPC. Low-level Planner As our low-level planner we employ Metric-FF (Hoffmann and Nebel, 2001) , the state-of-the-art baseline used in the 2008 International Planning Competition. Metric-FF is a forward-chaining heuristic state space planner. Its main heuristic is to simplify the task by ignoring operator delete lists. The number of actions in the solution for this simplified task is then used as the goal distance estimate for various search strategies. Features The two components of our model leverage different types of information, and as a result, they each use distinct sets of features. The text component features \u03c6 c are computed over sentences and their dependency parses. The Stanford parser (de Marneffe et al., 2006) was used to generate the dependency parse information for each sentence. Examples of these features appear in Table 2 . The sequence prediction component takes as input both the preconditions induced by the text component as well as the planning state and the previous subgoal. Thus \u03c6 x contains features which check whether two subgoals are connected via an induced precondition relation, in addition to features which are simply the Cartesian product of domain predicates. Experimental Setup Datasets As the text description of our virtual world, we use documents from the Minecraft Wiki, 7 the most popular information source about the game. Our manually constructed seed grounding of predicates contains 74 entries, examples of which can be seen in Table 3 . We use this seed grounding to identify a set of 242 sentences that reference predicates in the Minecraft domain. This results in a set of 694 Candidate Relations. We also manually annotated the relations expressed in the text, identifying 94 of the Candidate Relations as valid. Our corpus contains 979 unique word types and is composed of sentences with an average length of 20 words. We test our system on a set of 98 problems that involve collecting resources and constructing objects in the Minecraft domain -for example, fishing, cooking and making furniture. To assess the complexity of these tasks, we manually constructed high-level plans for these goals and solved them using the Metric-FF planner. On average, the execu-7 http://www.minecraftwiki.net/wiki/Minecraft Wiki/ Words Dependency Types Dependency Type \u00d7 Direction Word \u00d7 Dependency Type Word \u00d7 Dependency Type \u00d7 Direction Table 2 : Example text features. A subgoal pair x i , x j is first mapped to word tokens using a small grounding table. Words and dependencies are extracted along paths between mapped target words. These are combined with path directions to generate the text features. Domain Predicate Noun Phrases have(plank) wooden plank, wood plank have(stone) stone, cobblestone have(iron) iron ingot tion of the sequence of low-level plans takes 35 actions, with 3 actions for the shortest plan and 123 actions for the longest. The average branching factor is 9.7, leading to an average search space of more than 10 34 possible action sequences. For evaluation purposes we manually identify a set of Gold Relations consisting of all precondition relations that are valid in this domain, including those not discussed in the text. Evaluation Metrics We use our manual annotations to evaluate the type-level accuracy of relation extraction. To evaluate our high-level planner, we use the standard measure adopted by the IPC. This evaluation measure simply assesses whether the planner completes a task within a predefined time. Baselines To evaluate the performance of our relation extraction, we compare against an SVM classifier 8 trained on the Gold Relations. We test the SVM baseline in a leave-one-out fashion. To evaluate the performance of our text-aware high-level planner, we compare against five baselines. The first two baselines -  The two remaining baselines constitute the upper bound on the performance of our model. The first, Manual Text, is a variant of our model which directly uses the links derived from manual annotations of preconditions in text. The second, Gold, has access to the Gold Relations. Note that the connections available to Manual Text are a subset of the Gold links, because the text does not specify all relations. Experimental Details All experimental results are averaged over 200 independent runs for both our model as well as the baselines. Each of these trials is run for 200 learning iterations with a maximum subgoal sequence length of 10. To find a low-level plan between each consecutive pair of subgoals, our high-level planner internally uses Metric-FF. We give Metric-FF a one-minute timeout to find such a low-level plan. between the high-level planners and the FF baseline is fair, the FF baseline is allowed a runtime of 2,000 minutes. This is an upper bound on the time that our high-level planner can take over the 200 learning iterations, with subgoal sequences of length at most 10 and a one minute timeout. Lastly, during learning we initialize all parameters to zero, use a fixed learning rate of 0.0001, and encourage our model to explore the state space by using the standard -greedy exploration strategy (Sutton and Barto, 1998) . Results Relation Extraction Figure 5 shows the performance of our method on identifying preconditions in text. We also show the performance of the supervised SVM baseline. As can be seen, after 200 learning iterations, our model achieves an F-Measure of 66%, equal to the supervised baseline. These results support our hypothesis that planning feedback is a powerful source of supervision for analyzing a given text corpus. Figure 4 shows some examples of sentences and the corresponding extracted relations. The difference in performance of 2.35% between Manual Text and Gold shows the importance of the precondition information that is missing from the text. Note that Gold itself does not complete all tasks -this is largely because the Markov assumption made by our model does not hold for all tasks. 9  Figure 6 breaks down the results based on the difficulty of the corresponding planning task. We measure problem complexity in terms of the low-level steps needed to implement a manually constructed high-level plan. Based on this measure, we divide the problems into two sets. As can be seen, all of the high-level planners solve almost all of the easy problems. However, performance varies greatly on the more challenging tasks, directly correlating with planner sophistication. On these tasks our model outperforms the No Text baseline by 28% and the All Text baseline by 11%. Planning Performance As shown in Feature Analysis Figure 7 shows the top five positive features for our model and the SVM baseline. Both models picked up on the words that indicate precondition relations in this domain. For instance, the word use often occurs in sentences that describe the resources required to make an object, such as \"bricks are items used to craft brick blocks\". In addition to lexical features, dependency information is also given high weight by both learners. An example path has word \"craft\" path has dependency type \"partmod\" path has word \"equals\" path has word \"use\" path has dependency type \"xsubj\" path has word \"use\" path has word \"fill\" path has dependency type \"dobj\" path has dependency type \"xsubj\" path has word \"craft\" of this is a feature that checks for the direct object dependency type. This analysis is consistent with prior work on event semantics which shows lexicosyntactic features are effective cues for learning text relations (Blanco et al., 2008; Beamer and Girju, 2009; Do et al., 2011) . Conclusions In this paper, we presented a novel technique for inducing precondition relations from text by grounding them in the semantics of planning operations. While using planning feedback as its only source of supervision, our method for relation extraction achieves a performance on par with that of a supervised baseline. Furthermore, relation grounding provides a new view on classical planning problems which enables us to create high-level plans based on language abstractions. We show that building highlevel plans in this manner significantly outperforms traditional techniques in terms of task completion. Acknowledgments The authors acknowledge the support of the NSF (CAREER grant IIS-0448168, grant IIS-0835652), the DARPA Machine Reading Program (FA8750-09-C-0172, PO#4910018860), and Batelle (PO#300662). Thanks to Amir Globerson, Tommi Jaakkola, Leslie Kaelbling, George Konidaris, Dylan Hadfield-Menell, Stefanie Tellex, the MIT NLP group, and the ACL reviewers for their suggestions and comments. Any opinions, findings, conclusions, or recommendations expressed in this paper are those of the authors, and do not necessarily reflect the views of the funding organizations.",
    "abstract": "Comprehending action preconditions and effects is an essential step in modeling the dynamics of the world. In this paper, we express the semantics of precondition relations extracted from text in terms of planning operations. The challenge of modeling this connection is to ground language at the level of relations. This type of grounding enables us to create high-level plans based on language abstractions. Our model jointly learns to predict precondition relations from text and to perform high-level planning guided by those relations. We implement this idea in the reinforcement learning framework using feedback automatically obtained from plan execution attempts. When applied to a complex virtual world and text describing that world, our relation extraction technique performs on par with a supervised baseline, yielding an F-measure of 66% compared to the baseline's 65%. Additionally, we show that a high-level planner utilizing these extracted relations significantly outperforms a strong, text unaware baseline -successfully completing 80% of planning tasks as compared to 69% for the baseline. 1",
    "countries": [
        "United States"
    ],
    "languages": [],
    "numcitedby": "66",
    "year": "2012",
    "month": "July",
    "title": "Learning High-Level Planning from Text"
}