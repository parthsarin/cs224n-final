{
    "article": "Existing studies show that a weighted context-free transduction of reasonable quality can be effectively learned from examples. This paper investigates the approximation of such transduction by means of weighted rational transduction. The advantage is increased processing speed, which benefits realtime applications involving spoken language. Introduction Several studies have investigated automatic or partly automatic learning of transductions for machine translation. Some of these studies have concentrated on finite-state or extended finite-state machinery, such as (Vilar and others, 1999) , others have chosen models closer to context-free grammars and context-free transduction, such as (Alshawi et al., 2000; Watanabe et al., 2000; Yamamoto and Matsumoto, 2000) , and yet other studies cannot be comfortably assigned to either of these two frameworks, such as (Brown and others, 1990 ) and (Tillmann and Ney, 2000) . In this paper we will investigate both contextfree and finite-state models. The basis for our study is context-free transduction since that is a powerful model of translation, which can in many cases adequately describe the changes of word \u00a1 The second address is the current contact address; supported by the Royal Netherlands Academy of Arts and Sciences; current secondary affiliation is the German Research Center for Artificial Intelligence (DFKI) . order between two languages, and the selection of appropriate lexical items. Furthermore, for limited domains, automatic learning of weighted context-free transductions from examples seems to be reasonably successful. However, practical algorithms for computing the most likely context-free derivation have a cubic time complexity, in terms of the length of the input string, or in the case of a graph output by a speech recognizer, in terms of the number of nodes in the graph. For certain lexicalized context-free models we even obtain higher time complexities when the size of the grammar is not to be considered as a parameter (Eisner and Satta, 1999) . This may pose problems, especially for real-time speech systems. Therefore, we have investigated approximation of weighted context-free transduction by means of weighted rational transduction. The finite-state machinery for implementing the latter kind of transduction in general allows faster processing. We can also more easily obtain robustness. We hope the approximating model is able to preserve some of the accuracy of the context-free model. In the next section, we discuss preliminary definitions, adapted from existing literature, making no more than small changes in presentation. In Section 3 we explain how context-free transduction grammars can be represented by ordinary context-free grammars, plus a phase of postprocessing. The approximation is discussed in Section 4. As shown in Section 5, we may easily process input in a robust way, ensuring we always obtain output. Section 6 discusses empirical results, and we end the paper with conclusions. Preliminaries hierarchical alignment The input to our algorithm is a corpus consisting of pairs of sentences related by an hierarchical alignment (Alshawi et al., 2000) . In what follows, the formalization of this concept has been slightly changed with respect to the above reference, to suit our purposes in the remainder of this article. The hierarchically aligned sentence pairs in the corpus are 5-tuples  ; this means that positions can only be related if their respective \"mother\" positions are related. \u00a2 \u00a4\u00a3 \u00a6\u00a5 \u00a8 \u00a7 \u00a9\u00a3 \u00a7 \u00a5 \u00a7 \u00a8 \u00a7 ! Note that this paper does not discuss how hierarchical alignments can be obtained from unannotated corpora of bitexts. This is the subject of existing studies, such as (Alshawi et al., 2000) . context-free transduction Context-free transduction was originally called syntax-directed transduction in (Lewis II and Stearns, 1968 ), but since in modern formal language theory and computational linguistics the term \"syntax\" has a much wider range of meanings than just \"context-free syntax\", we will not use the original term here. A (context-free) transduction grammar is a 5tuple \u00a2 Dd \u00a7 2e 7\u00a5 \u00a8 \u00a7 2e f \u00a7 2g h \u00a7 2i h , where d is a finite set of nonterminals, the source language can be related to a parse for the target language, and this defines a transduction between the languages in an obvious way. An example of a transduction grammar is: s k \u00a2 Subj-IObj \"like\" Obj-Subj \u00a7 Obj-Subj Subj-IObj \"pla\u00eet\" Subj-IObj k \u00a2 \"I\" \u00a7 \"me\" Obj-Subj k \u00a2 \"him\" \u00a7 \"il\" This transduction defines that a sentence \"I like him\" can be translated by \"il me pla\u00eet\". We can reduce the generative power of contextfree transduction grammars by a syntactic restriction that corresponds to the bilexical context-free grammars (Eisner and Satta, 1999) . Let us define a bilexical transduction grammar as a transduction grammar which is such that: t there is a mapping from the set of nonterminals to e 7\u00a5 ue f . Due to this property, we may write each nonterminal as j H q \u00a7 2v I to indicate that it is mapped to the pair \u00a2 q \u00a7 2v \u00a8 , where q &e 7\u00a5 and v a &e f , where j is a so called delexicalized nonterminal. We may write i as j H w x \u00a7 2w I , where w is a dummy symbol at the dummy string position 9 . Further, t each production is of one of the following five forms: j H q \u00a7 2v I k \u00a2 Dy zH q \u00a7 2v I { H | \u00a8 \u00a7 2} I \u00a7 uy ~H q \u00a7 2v I { H | \u00a8 \u00a7 2} I j H q \u00a7 2v I k \u00a2 Dy zH q \u00a7 2v I { H | \u00a8 \u00a7 2} I \u00a7 { H | \u00a8 \u00a7 2} I y zH q \u00a7 2v I j H q \u00a7 2v I k \u00a2 { H | \u00a8 \u00a7 2} I y zH q \u00a7 2v I \u00a7 uy ~H q \u00a7 2v I { H | \u00a8 \u00a7 2} I j H q \u00a7 2v I k \u00a2 { H | \u00a8 \u00a7 2} I y zH q \u00a7 2v I \u00a7 { H | \u00a8 \u00a7 2} I y zH q \u00a7 2v I j H q \u00a7 2v I k \u00a2 q \u00a7 2v \u00a8 For convenience, we also allow productions of the form: j H q \u00a7 2v I k \u00a2 \u00a4 \u00a5 Sy zH q \u00a7 2v I 2 \u00a5 \u00a8 \u00a7 ' fy zH q \u00a7 2v I 2 where \u00a5 \u00a7 \u00a5 ne \u00a5 and e \u00a7 U e . In the experiments in Section 6, we also consider nonterminals that are lexicalized only by the source alphabet, which means that these nonterminals can be written as j H q I , where q $e 7\u00a5 . The motivation is to restrict the grammar size and to increase the coverage. Bilexical transduction grammars are equivalent to the dependency transduction model from (Alshawi et al., 2000) . obtaining a context-free transduction from the corpus We extract a context-free transduction grammar from a corpus of hierarchical alignments, by locally translating each hierarchical alignment into a set of productions. The union of all these sets for the whole corpus is then the transduction grammar. Counting the number of times that identical productions are generated allows us to assign probabilities to the productions by maximum likelihood estimation. We will consider a method that uses only one delexicalized nonterminal j . For a pair \u00a9 \u00a2 B \u00a7 B k \u00a2 h \u00a6 \u00a2 \u00a4T \u00a5 \u00a7 T \u00a5 G 2G 2G h p \u00a9 \u00a2 \u00a4T W bX \u00a7 T W bX \u00a6\u00a3 \u00a5 t B h \u00a6 \u00a2 Dc e\u00a5 \u00a8 \u00a7 2c \u00a5 G 2G 2G h p \u00a9 \u00a2 Dc pW hg \u00a8 \u00a7 2c W g D \u00a7 \u00a9 \u00a2 \u00a4T \u00a5 \u00a7 T \u00a5 G 2G 2G \u00a9 \u00a2 \u00a4T W 7 \u00a7 T W h \u00a9\u00a3 t B h \u00a6 \u00a2 Dc \u00a5 \u00a7 2c \u00a5 @G 2G 2G h p \u00a9 \u00a2 Dc W u \u00a7 2c W u Note that both halves of the RHS contain the same nonterminals but possibly in a different order. However, if any position in \u00a5 \u00a2 B or \u00a8 \u00a2 B is not related to some other position by , then the production above contains, instead of a nonterminal, a substring on which that position is projected by R \u00a5 or R \u00a8 , respectively. E.g. if there is no position T \u00a5 such that \u00a2 \u00a4T \u00a5 \u00a7 T \u00a5 z , then instead of \u00a9 \u00a2 \u00a4T \u00a5 \u00a8 \u00a7 T \u00a5 we have the string \u00a3 \u00a6\u00a5 \u00a8t R \u00a5 `\u00a2 \u00a4T \u00a5 \u00a8 . In general, we cannot adapt the above algorithm to produce transduction grammars that are bilexical. For example, a production of the form: j H q \u00a7 q 5 I k \u00a2 j H v \u00a8 \u00a7 2v I \u00a6j H | \u00a8 \u00a7 2| I \u00a6q \u00a7 j H | \u00a8 \u00a7 2| I \u00a6j H v \u00a8 \u00a7 2v I \u00a6q 5 cannot be broken up into smaller, bilexical productions. 2 However, the hierarchical alignments that we work with were produced by an algorithm that ensures that bilexical grammars suffice. Formally, this applies when the following cannot occur: there are . For example, if the non-bilexical production we would obtain is: j H q \u00a7 q 3 I pk \u00a2 j H v \u00a8 \u00a7 2v I } q j H | \u00a7 2| I \u00a7 j H | \u00a8 \u00a7 2| I ' j H v \u00a8 \u00a7 2v I \u00a6q then the bilexical transduction grammar that our algorithm produces contains: j H q \u00a7 q I k \u00a2 j H q \u00a7 q I 'j H | \u00a8 \u00a7 2| I \u00a7 j H | \u00a8 \u00a7 2| I \u00a6j H q \u00a7 q I j H q \u00a7 q I k \u00a2 j H q \u00a7 q I \u00a7 j H q \u00a7 q I j H q \u00a7 q I k \u00a2 j H v \u00a8 \u00a7 2v I 'j H q \u00a7 q I \u00a7 j H v \u00a7 2v I 'j H q \u00a7 q I j H q \u00a7 q I k \u00a2 D} j H q \u00a7 q I \u00a7 j H q \u00a7 q I j H q \u00a7 q I k \u00a2 q \u00a7 q 3 Reordering as postprocessing In the following section we will discuss an algorithm that was devised for context-free grammars. To make it applicable to transduction, we propose a way to represent bilexical transduction grammars as ordinary context-free grammars. In the new productions, symbols from the source and target alphabets occur side by side, but whereas source symbols are matched by the parser to the input, the target symbols are gathered into output strings. In our case, the unique output string the parser eventually produces from an input string is obtained from the most likely derivation that matches that input string. That the nonterminals in both halves of a RHS in the transduction grammar may occur in a different order is solved by introducing three special symbols, the reorder operators, which are interpreted after the parsing phase. These three operators will be written as \" H \", \" % \" and \"I \". In a given string, there should be matching triples of these operators, in such a way that if there are two such triples, then they either occur in two isolated substrings, or one occurs nested between the \" H \" and the \" % \" or nested between the \" % \" and the \"I \" of the other triple. The interpretation of an occurrence of a triple, say in an output string \u00a3 \u00a6\u00a5 H \u00a3 % \u00a3 I \u00a3 , is that the two enclosed substrings should be reordered, so that we obtain \u00a3 \u00a6\u00a5 \u00a3 `\u00a3 \u00a8\u00a3 . Both the reorder operators and the symbols of the target alphabet will here be marked by a horizontal line to distinguish them from the source alphabet. For example, the two productions j H q \u00a7 q I k \u00a2 j H q \u00a7 q I 'j H | \u00a8 \u00a7 2| I \u00a7 j H | \u00a8 \u00a7 2| I \u00a6j H q \u00a7 q I j H q \u00a7 q I k \u00a2 q \u00a7 q from the transduction grammar are represented by the following two context-free productions: j H q \u00a7 q I k H j H q \u00a7 q I % j H | \u00a8 \u00a7 2| I % j H q \u00a7 q I k q q In the first production, the RHS nonterminals occur in the same order as in the left half of the original production, but reorder operators have been added to indicate that, after parsing, some substrings of the output string are to be reordered. Our reorder operators are similar to the two operators and from (Vilar and others, 1999) , but the former are more powerful, since the latter allow only single words to be moved instead of whole phrases. Finite-state approximation There are several methods to approximate context-free grammars by regular languages (Nederhof, 2000) . We will consider here only the so called RTN method, which is applied in a simplified form. 3  A finite automaton is constructed as follows. For each nonterminal j from the grammar we introduce two states x . The resulting automaton is determinized and minimized to allow fast processing of input. Note that if we apply the approximation to the type of context-free grammar discussed in Section 3, the transitions include symbols from both source and target alphabets, but we treat both uniformly as input symbols for the purpose of determinizing and minimizing. This means that the driver for the finite automaton still encounters nondeterminism while processing an input string, since a state may have several outgoing transitions for different output symbols. Furthermore, we ignore any weights that might be attached to the context-free productions, since determinization is problematic for weighted automata in general and in particular for the type of automaton that we would obtain when carrying over the weights from the context-free grammar onto the approximating language following (Mohri and Nederhof, 2001) . Instead, weights for the transitions of the finite automaton are obtained by training, using strings that are produced as a side effect of the computation of the grammar from the corpus. These strings contain the symbols from both the source and target strings mixed together, plus occurrences of the reorder operators where needed. A English/French example might be: H I me like pla\u00eet % him il I The way these strings were obtained ensures that they are included in the language generated by the context-free grammar, and they are therefore also accepted by the approximating automaton due to properties of the RTN approximation. The weights are the negative log of the probabilities obtained by maximum likelihood estimation. Robustness The approximating finite automaton cannot ensure that the reorder operators \" H \", \" % \" and \"I \" occur in matching triples in output strings. There are two possible ways to deal with this problem. First, we could extend the driver of the finite automaton to only consider derivations in which the operators are matched. This is however counter to our need for very efficient processing, since we are not aware of any practical algorithms for finding matching brackets in paths in a graph of which the complexity is less than cubic. Therefore, we have chosen a second approach, viz. to make the postprocessing robust, by inserting missing occurrences of \" H \" or \"I \" and removing redundant occurrences of brackets. This means that any string containing symbols from the target alphabet and occurrences of the reorder operators is turned into a string without reorder operators, with a change of word order where necessary. Both the transduction grammar and, to a lesser extent, the approximating finite automaton suffer from not being able to handle all strings of symbols from the source alphabet. With finite-state processing however, it is rather easy to obtain robustness, by making the following three provisions: 1. To the nondeterministic finite automaton we add one epsilon transition from the initial state to , for each nonterminal j . This means that from the initial state we may recognize an arbitrary phrase generated by some nonterminal from the grammar. After the training phase of the weighted (minimal deterministic) automaton, all transitions that have not been visited obtain a fixed high (but finite) weight. This means that such transitions are only applied if all others fail. 3. The driver of the automaton is changed so that it restarts at the initial state when it gets stuck at some input word, and when necessary, that input word is deleted. The out-put string with the lowest weight obtained so far (preferably attached to final states, or to other states with outgoing transitions labelled by input symbols) is then concatenated with the output string resulting from processing subsequent input. Experiments We have investigated a corpus of English/Japanese sentence pairs, related by hierarchical alignment (see also (Bangalore and Riccardi, 2001) ). We have taken the first 500, 1000, 1500, . . . aligned sentence pairs from this corpus to act as training corpora of varying sizes; we have taken 300 other sentence pairs to act as test corpus. We have constructed a bilexical transduction grammar from each training corpus, in the form of a context-free grammar, and this grammar was approximated by a finite automaton. The input sentences from the test corpus were then processed by context-free and finite-state machinery (in the sequel referred to by cfg and fa, respectively). We have also carried out experiments with robust finite-state processing, as discussed in Section 5, which is referred to by robust fa. The reorder operators from the resulting output strings were applied in a robust way as explained in Section 5. The output strings were then compared to the reference output from the corpus, resulting in Figure 1 . Our metric is word accuracy, which is based on edit distance. For a pair of strings, the edit distance is defined as the minimum number of substitutions, insertions and deletions needed to turn one string into the other. The word accuracy of a string \u00a3 with regard to a string is defined to be 0 \u00af\u00ae r , where } is the edit distance between \u00a3 and and \" is the length of . To allow a comparison with more established techniques (see e.g. (Bangalore and Riccardi, 2001 )), we also take into consideration a simple bigram model, trained on the strings comprising both source and target sentences and reorder operators, as explained in Section 4. For the purposes of predicting output symbols, a series of consecu-tive target symbols and reorder operators following a source symbol in the training sentences are treated as a single symbol by the bigram model, and only those may be output after that source symbol. Since our construction is such that target symbols always follow source symbols they are a translation of (according to the automatically obtained hierarchical alignment), this modification to the bigram model prevents output of totally unrelated target symbols that could otherwise result from a standard bigram model. It also ensures that a bounded number of output symbols per input symbol are produced. The fraction of sentences that were transduced (i.e. that were accepted by the grammar or the automaton), is indicated in Figure 2 . Since robust fa(2) and bigram are able to transduce all input, they are not represented here. Note that the average word accuracy is computed only with respect to the sentences that could be transduced, which explains the high accuracy for small training corpora in the cases of cfg(2) and fa(2), where the few sentences that can be transduced are mostly short and simple. Figure 3 presents the time consumption of transduction for the entire test corpus. These data support our concerns about the high costs of context-free processing, even though our parser relies heavily on lexicalization. 4  Figure 4 shows the sizes of the automata after determinization and minimization. Determinization for the largest automata indicated in the Figure took more than 24 hours for both fa(2) and robust fa(2) , which suggests these methods become unrealistic for training corpus sizes considerably larger than 10,000 bitexts. Conclusions For our application, context-free transduction has a relatively high accuracy, but it also has a high time consumption, and it may be difficult to obtain robustness without further increasing the time costs. These are two major obstacles for use in spoken language systems. We have tried to obtain a rational transduction that approximates a context-free transduction, preserving some of its accuracy. Our experiments show that the automata we obtain become very large for training corpora of increasing sizes. This poses a problem for determinization. We conjecture that the main source of the excessive growth of the automata lies in noise in the bitexts and their hierarchical alignments. It is a subject for further study whether we can reduce the impact of this noise, e.g. by clustering of source symbols, or by removing some infrequent, idiosyncratic rules from the obtained transduction grammar. Also, other methods of regular approximation of context-free grammars may be considered. In comparison to a simpler model, viz. bigrams, our approximating transductions do not have a very high accuracy, which is especially worrying since the off-line costs of computation are much higher than in the case of bigrams. The relatively low accuracy may be due to sparseness of data when attaching weights to transitions: the size of the minimal deterministic automaton grows much faster than the size of the training corpus it is constructed from, and the same training corpus is used to train the weights of the transitions of the automaton. Thereby, many transitions do not obtain accurate weights, and unseen input sentences are not translated accurately. The problems described here may be avoided by leaving out the determinization of the automaton. This however leads to two new problems: training of the weights requires more sophisticated algorithms, and we may expect an increase in the time needed to transduce input sentences, since now both source and target symbols give rise to nondeterminism. Whether these problems can be overcome requires further study. Acknowledgements This work is a continuation of partly unpublished experiments by Srinivas Bangalore, which includes regular approximation of grammars obtained from hierarchical alignments. Many ideas in this paper originate from frequent discussions with Hiyan Alshawi, Srinivas Bangalore and Mehryar Mohri, for which I am very grateful.",
    "abstract": "Existing studies show that a weighted context-free transduction of reasonable quality can be effectively learned from examples. This paper investigates the approximation of such transduction by means of weighted rational transduction. The advantage is increased processing speed, which benefits realtime applications involving spoken language.",
    "countries": [
        "United States"
    ],
    "languages": [
        "English",
        "German",
        "Japanese",
        "French"
    ],
    "numcitedby": "2",
    "year": "2001",
    "month": "",
    "title": "Approximating Context-Free by Rational Transduction for Example-Based {MT}"
}