{
    "article": "Prepositional phrase attachment is a common source of ambiguity in natural language processing. We present an unsupervised corpus-based approach to prepositional phrase attachment that achieves similar performance to supervised methods. Unlike previous unsupervised approaches in which training data is obtained by heuristic extraction of unambiguous examples from a corpus, we use an iterative process to extract training data from an automatically parsed corpus. Attachment decisions are made using a linear combination of features and low frequency events are approximated using contextually similar words. Introduction Prepositional phrase attachment is a common source of ambiguity in natural language processing. The goal is to determine the attachment site of a prepositional phrase in a sentence. Consider the following examples: 1. Mary ate the salad with a fork. 2. Mary ate the salad with croutons. In both cases, the task is to decide whether the prepositional phrase headed by the preposition with attaches to the noun phrase (NP) headed by salad or the verb phrase (VP) headed by ate. In the first sentence, with attaches to the VP since Mary is using a fork to eat her salad. In sentence 2, with attaches to the NP since it is the salad that contains croutons. Formally, prepositional phrase attachment is simplified to the following classification task. Given a 4-tuple of the form (V, N 1 , P, N 2 ), where V is the head verb, N 1 is the head noun of the object of V, P is a preposition, and N 2 is the head noun of the prepositional complement, the goal is to classify as either adverbial attachment (attaching to V) or adjectival attachment (attaching to N 1 ). For example, the 4-tuple (eat, salad, with, fork) has target classification V. In this paper, we present an unsupervised corpus-based approach to prepositional phrase attachment that outperforms previous unsupervised techniques and approaches the performance of supervised methods. Unlike previous unsupervised approaches in which training data is obtained by heuristic extraction of unambiguous examples from a corpus, we use an iterative process to extract training data from an automatically parsed corpus. The attachment decision for a 4-tuple (V, N 1 , P, N 2 ) is made as follows. First, we replace V and N 2 by their contextually similar words and compute the average adverbial attachment score. Similarly, the average adjectival attachment score is computed by replacing N 1 and N 2 by their contextually similar words. Attachment scores are obtained using a linear combination of features of the 4-tuple. Finally, we combine the average attachment scores with the attachment score of N 2 attaching to the original V and the attachment score of N 2 attaching to the original N 1 . The proposed classification represents the attachment site that scored highest. 1 Previous Work Altmann and Steedman (1988) showed that current discourse context is often required for disambiguating attachments. Recent work shows that it is generally sufficient to utilize lexical information (Brill and Resnik, 1994; Collins and Brooks, 1995; Hindle and Rooth, 1993; Ratnaparkhi et al., 1994) . One of the earliest corpus-based approaches to prepositional phrase attachment used lexical preference by computing co-occurrence frequencies (lexical associations) of verbs and nouns with prepositions (Hindle and Rooth, 1993) . Training data was obtained by extracting all phrases of the form (V, N 1 , P, N 2 ) from a large parsed corpus. Supervised methods later improved attachment accuracy. Ratnaparkhi et al. (1994) used a maximum entropy model considering only lexical information from within the verb phrase (ignoring N 2 ). They experimented with both word features and word class features, their combination yielding 81.6% attachment accuracy. Later, Collins and Brooks (1995) achieved 84.5% accuracy by employing a backed-off model to smooth for unseen events. They discovered that P is the most informative lexical item for attachment disambiguation and keeping low frequency events increases performance. A non-statistical supervised approach by Brill and Resnik (1994) yielded 81.8% accuracy using a transformation-based approach (Brill, 1995) and incorporating word-class information. They report that the top 20 transformations learned involved specific prepositions supporting Collins and Brooks' claim that the preposition is the most important lexical item for resolving the attachment ambiguity. The state of the art is a supervised algorithm that employs a semantically tagged corpus (Stetina and Nagao, 1997) . Each word in a labelled corpus is sense-tagged using an unsupervised word-sense disambiguation algorithm with WordNet (Miller, 1990) . Testing examples are classified using a decision tree induced from the training examples. They report 88.1% attachment accuracy approaching the human accuracy of 88.2% (Ratnaparkhi et al., 1994) . The current unsupervised state of the art achieves 81.9% attachment accuracy (Ratnaparkhi, 1998) . Using an extraction heuristic, unambiguous prepositional phrase attachments of the form (V, P, N 2 ) and (N 1 , P, N 2 ) are extracted from a large corpus. Co-occurrence frequencies are then used to disambiguate examples with ambiguous attachments. Resources The input to our algorithm includes a collocation database and a corpus-based thesaurus, both available on the Internet 2 . Below, we briefly describe these resources. Collocation database Given a word w in a dependency relationship (such as subject or object), the collocation database is used to retrieve the words that occurred in that relationship with w, in a large corpus, along with their frequencies (Lin, 1998a) . Figure 1 shows excerpts of the entries in Corpus-based thesaurus Using the collocation database, Lin (1998b) used an unsupervised method to construct a corpusbased thesaurus consisting of 11839 nouns, 3639 verbs and 5658 adjectives/adverbs. Given a word w, the thesaurus returns a set of similar words of w along with their similarity to w. For example, the 20 most similar words of eat and salad are shown in Table 1 . Training Data Extraction We parsed a 125-million word newspaper corpus with Minipar 3 , a descendent of Principar (Lin, 1994) . Minipar outputs dependency trees (Lin, 1999) from the input sentences. For example, the following sentence is decomposed into a dependency tree: Occasionally, the parser generates incorrect dependency trees. For example, in the above sentence, the prepositional phrase headed by with should attach to saw (as opposed to dog). Two separate sets of training data were then extracted from this corpus. Below, we briefly describe how we obtained these data sets. Ambiguous Data Set For each input sentence, Minipar outputs a single dependency tree. For a sentence containing one or more prepositions, we use a program to detect any alternative prepositional attachment sites. For example, in the above sentence, the program would detect that with could attach to saw. Using an iterative algorithm, we initially create a table of cooccurrence frequencies for 3-tuples of the form (V, P, N 2 ) and (N 1 , P, N 2 ). For each k possible attachment site of a preposition P, we increment the frequency of the corresponding 3-tuple by 1/k. For example, Table 2 shows the initial cooccurrence frequency table for the corresponding 3-tuples of the above sentence. 3 Available at www.cs.ualberta.ca/~lindek/minipar.htm. In the following iterations of the algorithm, we update the frequency table as follows. For each k possible attachment site of a preposition P, we refine its attachment score using the formulas described in Section 4: VScore(V k , P k , N 2k ) and NScore(N 1k , P k , N 2k ). For any tuple (W k , P k , N 2k ), where W k is either V k or N 2k , we update its frequency as: ( ) ( ) ( ) \u2211 = = k i i i i k k k k N k P k W N P W Score N P W Score fr 1 2 2 2 , , , , , , where Score(W k , P k , N 2k ) = VScore(W k , P k , N 2k ) if W k = V k ; otherwise Score(W k , P k , N 2k ) = NScore(W k , P k , N 2k ). Suppose that after the initial frequency table is set NScore(man, in, park) = 1.23, VScore(saw, with, telescope) = 3.65, and NScore(dog, with, telescope) = 0.35. Then, the updated cooccurrence frequencies for (man, in, park) and (saw, with, telescope) are: Table 3 shows the updated frequency table after the first iteration of the algorithm. The resulting database contained 8,900,000 triples. Unambiguous Data Set As in (Ratnaparkhi, 1998) , we constructed a training data set consisting of only unambiguous attachments of the form (V, P, N 2 ) and (N 1 , P, N 2 ). We only extract a 3-tuple from a sentence when our program finds no alternative attachment site for its preposition. Each extracted 3-tuple is assigned a frequency count of 1. For example, in the previous sentence, (man, in, park) is extracted since it contains only one attachment site; (dog, with, telescope) is not extracted since with has an alternative attachment site. The resulting database contained 4,400,000 triples. Classification Model Roth (1998) presented a unified framework for natural language disambiguation tasks. Essentially, several language learning algorithms (e.g. na\u00efve Bayes estimation, back-off estimation, transformation-based learning) were successfully cast as learning linear separators in their feature space. Roth modelled prepositional phrase attachment as linear combinations of features. The features consisted of all 15 possible sub-sequences of the 4-tuple (V, N 1 , P, N 2 ) shown in Table 4 . The asterix (*) in features represent wildcards. Roth used supervised learning to adjust the weights of the features. In our experiments, we only considered features that contained P since the preposition is the most important lexical item (Collins and Brooks, 1995) . Furthermore, we omitted features that included both V and N 1 since their co-occurrence is independent of the attachment decision. The resulting subset of features considered in our system is shown in bold in Table 4 (equivalent to assigning a weight of 0 or 1 to each feature). Let |head, rel, mod| represent the frequency, obtained from the training data, of the head occurring in the given relationship rel with the modifier. We then assign a score to each feature as follows: 1, 2, and 3 are the prior probabilities of P, V P N 2 , and N 1 P N 2 respectively. 4, 5, and 6 represent conditional probabilities P(V, P | V), P(N 1 , P | N 1 ), and P(P N 2 | N 2 ) respectively. We estimate the adverbial and adjectival attachment scores, VScore(V, P, N 2 ) and NScore(N 1 , P, N 2 ), as a linear combination of these features: For example, the attachment scores for (eat, salad, with, fork) are VScore(eat, with, fork) = -3.47 and NScore(salad, with, fork) = -4.77. The model correctly assigns a higher score to the adverbial attachment. Contextually Similar Words The contextually similar words of a word w are words similar to the intended meaning of w in its context. Below, we describe an algorithm for constructing contextually similar words and we present a method for approximating the attachment scores using these words. Algorithm For our purposes, a context of w is simply a dependency relationship involving w. For example, a dependency relationship for saw in the example sentence of Section 3 is saw:obj:dog. Figure 2 gives the data flow diagram for our algorithm for constructing the contextually similar words of w. We retrieve from the collocation database the words that occurred in the same dependency relationship as w. We refer to this set of words as the cohort of w for the dependency relationship. Consider the words eat and salad in the context eat salad. The cohort of eat consists of verbs that appeared with object salad in Figure 1 (e.g. add, consume, cover, \u2026) and the cohort of salad consists of nouns that appeared as object of eat in Figure 1 (e.g. almond, apple, bean, \u2026). Intersecting the set of similar words and the cohort then forms the set of contextually similar words of w. For example, Table 5 shows the contextually similar words of eat and salad in the context eat salad and the contextually similar words of fork in the contexts eat with fork and salad with fork. The words in the first row are retrieved by intersecting the similar words of eat in Table 1 with the cohort of eat while the second row represents the intersection of the similar words of salad in Table 1 and the cohort of salad. The third and fourth rows are determined in a similar manner. In the nonsensical context salad with fork (in row 4), no contextually similar words are found. While previous word sense disambiguation algorithms rely on a lexicon to provide sense inventories of words, the contextually similar words provide a way of distinguishing between different senses of words without committing to any particular sense inventory. Attachment Approximation Often, sparse data reduces our confidence in the attachment scores of Section 4. Using contextually similar words, we can approximate these scores. Given the tuple (V, N 1 , P, N 2 ), adverbial attachments are approximated as follows. We first construct a list CS V containing the contextually similar words of V in context V:obj:N 1 and a list CS N2V containing the contextually similar words of N 2 in context V:P:N 2 (i.e. assuming adverbial attachment). For each verb v in CS V , we compute VScore(v, P, N 2 ) and set S V as the average of the largest k of these scores. Similarly, for each noun n in CS N2V , we compute VScore(V, P, n) and set S N2V as the average of the largest k of these scores. Then, the approximated adverbial attachment score, Vscore', is: VScore'(V, P, N 2 ) = max(S V , S N2V ) We approximate the adjectival attachment score in a similar way. First, we construct a list CS N1 containing the contextually similar words of N 1 in context V:obj:N 1 and a list CS N2N1 containing the contextually similar words of N 2 in context N 1 :P:N 2 (i.e. assuming adjectival attachment). Now, we compute S N1 as the average of the largest k of NScore(n, P, N 2 ) for each noun n in CS N1 and S N2N1 as the average of the largest k of NScore(N 1 , P, n) for each noun n in CS N2N1 . Then, the approximated adjectival attachment score, NScore', is: NScore'(N 1 , P, N 2 ) = max(S N1 , S N2N1 ) For example, suppose we wish to approximate the attachment score for the 4-tuple (eat, salad, with, fork) . First, we retrieve the contextually similar words of eat and salad in context eat salad, and the contextually similar words of fork in contexts eat with fork and salad with fork as shown in Table 5 . Let k = 2. Table 6 shows the calculation of S V and S N2V while the calculation of S N1 and S N2N1 is shown in Table 7 . Only the  Hence, the approximation correctly prefers the adverbial attachment to the adjectival attachment. Attachment Algorithm Figure 3 describes the prepositional phrase attachment algorithm. As in previous approaches, examples with P = of are always classified as adjectival attachments. Suppose we wish to approximate the attachment score for the 4-tuple (eat, salad, with, fork). From the previous section, Step 1 returns average V = -2.92 and average N1 = -4.87. From Section 4, Step 2 gives a V = -3.47 and a N1 = -4.77. In our training data, f V = 2.97 and f N1 = 0, thus Step 3 gives f = 0.914. In Step 4, we compute: S(V) = -3.42 and S(N 1 ) = -4.78 Since S(V) > S(N 1 ), the algorithm correctly classifies this example as an adverbial attachment. Given the 4-tuple (eat, salad, with, croutons), the algorithm returns S(V) = -4.31 and S(N 1 ) = -3.88. Hence, the algorithm correctly attaches the prepositional phrase to the noun salad. Experimental Results In this section, we describe our test data and the baseline for our experiments. Finally, we present our results. Test Data The test data consists of 3097 examples derived from the manually annotated attachments in the Penn Treebank Wall Street Journal data (Ratnaparkhi et al., 1994) 4 . Each line in the test data consists of a 4-tuple and a target classification: V N 1 P N 2 target. The data set contains several erroneous tuples and attachments. For instance, 133 examples contain the word the as N 1 or N 2 . There are also improbable attachments such as (sing, birthday, to, you) with the target attachment birthday. = NScore(N 1 , P, N 2 ) Step 3: Retrieve from the training data set the frequency of the 3-tuples (V, P, N 2 ) and (N 1 , P, N 2 ) \u00e0 f V and f N1 , respectively. Let f = (f V + f N1 + 0.2) / (f V + f N1 +0.5) Step 4: Combine the scores of Steps 1-3 to obtain the final attachment scores: S(V) = fa v + (1 \u2212 f)average v S(N 1 ) = fa n1 + (1 \u2212 f)average n1 Output: The attachment decision: N 1 if S(N 1 ) > S(V) or P = of; V otherwise. Figure 3 . The prepositional phrase attachment algorithm. Baseline Choosing the most common attachment site, N 1 , yields an accuracy of 58.96%. However, we achieve 70.39% accuracy by classifying each occurrence of P = of as N 1 , and V otherwise. Human accuracy, given the full context of a sentence, is 93.2% and drops to 88.2% when given only tuples of the form (V, N 1 , P, N 2 ) (Ratnaparkhi et al., 1994) . Assuming that human accuracy is the upper bound for automatic methods, we expect our accuracy to be bounded above by 88.2% and below by 70.39%. Results We used the 3097-example testing corpus described in Section 7.1. Table 8 presents the precision and recall of our algorithm and Table 9 presents a performance comparison between our system and previous supervised and unsupervised approaches using the same test data. We describe the different classifiers below: cl base : the baseline described in Section 7.2 cl R1 : uses a maximum entropy model (Ratnaparkhi et al., 1994 ) cl BR 5 : uses transformation-based learning (Brill and Resnik, 1994 ) cl CB : uses a backed-off model (Collins and Brooks, 1995 ) cl SN : induces a decision tree with a sense-tagged corpus, using a semantic dictionary (Stetina and Nagao, 1997) cl HR 6 : uses lexical preference (Hindle and Rooth, 1993 ) cl R2 : uses a heuristic extraction of unambiguous attachments (Ratnaparkhi, 1998 ) cl PL : uses the algorithm described in this paper Our classifier outperforms all previous unsupervised techniques and approaches the performance of supervised algorithm. We reconstructed the two earlier unsupervised classifiers cl HR and cl R2 . Table 10 presents the accuracy of our reconstructed classifiers. The originally reported accuracy for cl R2 is within the 95% confidence interval of our reconstruction. Our reconstruction of cl HR achieved slightly higher accuracy than the original report. Our classifier used a mixture of the two training data sets described in Section 3. In Table 11 , we compare the performance of our system on the following training data sets: The concatenation of UNAMB and EM1 Table 11 illustrates a slight but consistent increase in performance when using contextually similar words. However, since the confidence intervals overlap, we cannot claim with certainty  Table 10 . Accuracy of our reconstruction of (Hindle & Rooth, 1993) and (Ratnaparkhi, 1998) . that the contextually similar words improve performance. In Section 7.1, we mentioned some testing examples contained N 1 = the or N 2 = the. For supervised algorithms, the is represented in the training set as any other noun. Consequently, these algorithms collect training data for the and performance is not affected. However, unsupervised methods break down on such examples. In Table 12 , we illustrate the performance increase of our system when removing these erroneous examples. Conclusion and Future Work The algorithms presented in this paper advance the state of the art for unsupervised approaches to prepositional phrase attachment and draws near the performance of supervised methods. Currently, we are exploring different functions for combining contextually similar word approximations with the attachment scores. A promising approach considers the mutual information between the prepositional relationship of candidate attachments and N 2 . As the mutual information decreases, our confidence in the attachment score decreases and the contextually similar word approximation is weighted higher. Also, improving the construction algorithm for contextually similar words would possibly improve the accuracy of the system. One approach first clusters the similar words. Then, dependency relationships are used to select the most representative clusters as the contextually similar words. The assumption is that more representative similar words produce better approximations. Acknowledgements The authors wish to thank the reviewers for their helpful comments. This research was partly supported by Natural Sciences and Engineering Research Council of Canada grant OGP121338 and scholarship PGSB207797. ",
    "abstract": "Prepositional phrase attachment is a common source of ambiguity in natural language processing. We present an unsupervised corpus-based approach to prepositional phrase attachment that achieves similar performance to supervised methods. Unlike previous unsupervised approaches in which training data is obtained by heuristic extraction of unambiguous examples from a corpus, we use an iterative process to extract training data from an automatically parsed corpus. Attachment decisions are made using a linear combination of features and low frequency events are approximated using contextually similar words.",
    "countries": [
        "Canada"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "100",
    "year": "2000",
    "month": "October",
    "title": "An Unsupervised Approach to Prepositional Phrase Attachment using Contextually Similar Words"
}