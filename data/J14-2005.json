{
    "article": "Recent research has shown clear improvement in translation quality by exploiting linguistic syntax for either the source or target language. However, when using syntax for both languages (\"tree-to-tree\" translation), there is evidence that syntactic divergence can hamper the extraction of useful rules (Ding and Palmer 2005). Smith and Eisner ( 2006 ) introduced quasi-synchronous grammar, a formalism that treats non-isomorphic structure softly using features rather than hard constraints. Although a natural fit for translation modeling, its flexibility has proved challenging for building real-world systems. In this article, we present a tree-to-tree machine translation system inspired by quasi-synchronous grammar. The core of our approach is a new model that combines phrases and dependency syntax, integrating the advantages of phrase-based and syntax-based translation. We report statistically significant improvements over a phrasebased baseline on five of seven test sets across four language pairs. We also present encouraging preliminary results on the use of unsupervised dependency parsing for syntax-based machine translation. Introduction Building translation systems for many language pairs requires addressing a wide range of translation divergence phenomena. Several researchers have studied divergence between languages in corpora and found it to be considerable, even for closely related languages (Dorr 1994; Fox 2002; Wellington, Waxmonsky, and Melamed 2006; S\u00f8gaard and Kuhn 2009) . To address this, many have incorporated linguistic syntax into translation model design. The statistical natural language processing (NLP) community has developed automatic parsers that can produce syntactic analyses for sentences in several languages (Klein and Manning 2003; Buchholz and Marsi 2006; Nivre et al. 2007 ). The availability of these parsers, and gains in their accuracy, triggered research interest in syntax-based statistical machine translation (Yamada and Knight 2001) . Syntax-based translation models are diverse, using different grammatical formalisms and features. Some use a parse tree for the source sentence (\"tree-to-string\"), others produce a parse when generating the target sentence (\"string-to-tree\"), and others combine both (\"tree-to-tree\"). We focus on the final category in this article. Tree-to-tree translation has proved to be a difficult modeling problem, as initial attempts at it underperformed systems that used no syntax at all (Cowan, Ku\u010derov\u00e1, and Collins 2006; Ambati and Lavie 2008; Liu, L \u00fc, and Liu 2009) . Subsequent research showed that substantial performance gains can be achieved if hard constraintsspecifically, isomorphism between a source sentence's parse and the parse of its translation-are relaxed (Liu, L \u00fc, and Liu 2009; Chiang 2010; Zhang, Zhai, and Zong 2011; Hanneman and Lavie 2011) . This suggests that constraints must be handled with care. Yet the classic approach to tree-to-tree translation imposes hard constraints through the use of synchronous grammars developed for programming language compilation (Aho and Ullman 1969). A synchronous grammar derives two strings simultaneously: one in the source language and one in the target language. A single derivation is used for both strings, which limits the divergence phenomena that can be captured. As a result, researchers have developed synchronous grammars with larger rules that, rule-internally, capture more phenomena, typically at increased computational expense (Shieber and Schabes 1990; Eisner 2003; Gildea 2003; Ding and Palmer 2005) . We take a different approach. We take inspiration from a family of formalisms called quasi-synchronous grammar (QG; Smith and Eisner 2006) . Unlike synchronous grammar, QG assumes the entire input sentence and some syntactic parse of it are provided and fixed. QG then defines a monolingual grammar whose language is a set of translations inspired by the input sentence and tree. The productions in this monolingual grammar generate a piece of the translation's tree and align it to a piece of the fixed input tree. Therefore, arbitrary non-isomorphic structures are possible between the two trees. A weighted QG uses feature functions to softly penalize or encourage particular types of syntactic divergence. In this article, we present a statistical tree-to-tree machine translation system inspired by quasi-synchronous grammar. We exploit the flexibility of QG to develop a new syntactic translation model that seeks to combine the benefits of both phrase-based and syntax-based translation. Our model organizes phrases into a tree structure inspired by dependency syntax (Tesni\u00e8re 1959) . Instead of standard dependency trees in which words are vertices, our trees have phrases as vertices. The result captures phenomena like local reordering and idiomatic translations within phrases, as well as long-distance relationships among the phrases in a sentence. We use the term phrase dependency tree when referring to this type of dependency tree; phrase dependencies have also been used by Wu et al. (2009) for opinion mining and previously for machine translation by Hunter and Resnik (2010) . Because we combine phrase dependencies with features from quasi-synchronous grammar, we refer to our model as a quasi-synchronous phrase dependency (QPD) translation model. Our tree-to-tree approach requires parsers for both the source and target languages. For two of the language pairs we consider (Chinese\u2192English and German\u2192English), treebanks of hand-annotated parse trees are available (e.g., the Penn Treebank; Marcus, Santorini, & Marcinkiewitz 1993) , allowing the use of highly accurate statistical parsers (Levy and Manning 2003; Rafferty and Manning 2008; Martins, Smith, and Xing 2009) . We also want to apply our model to languages that do not have tree-banks (e.g., Urdu and Malagasy), and for this we turn to unsupervised parsing. The NLP community has developed a range of statistical algorithms for building unsupervised parsers (Klein and Manning 2002, 2004; Smith 2006; Blunsom and Cohn 2010; Naseem et al. 2010; Spitkovsky, Alshawi, and Jurafsky 2010; Cohen 2011) . They require only raw, unannotated text in the language of interest, making them ideal for use in translation. Unsupervised shallow syntactic analysis has been used successfully for translation modeling by Zollmann and Vogel (2011) , who showed that unsupervised part-of-speech tags could be used to label the hierarchical translation rules of Chiang (2005) to match the performance of a system that uses supervised full syntactic parses. We take additional steps in this direction, leveraging state-of-the-art unsupervised models for full syntactic analysis (Klein and Manning 2004; Berg-Kirkpatrick et al. 2010; Gimpel and Smith 2012a ) to obtain improvements in translation quality. We find that replacing a supervised parser for Chinese with an unsupervised one has no effect on performance, and using an unsupervised English parser only hurts slightly. We use unsupervised parsing to apply our full model to Urdu\u2192English and English\u2192Malagasy translation, reporting statistically significant improvements over our baselines. These initial results offer promise for researchers to apply syntactic translation models to the thousands of languages for which we do not have manually annotated corpora, and naturally suggest future research directions. The rest of this article is laid out as follows. In Section 2, we discuss quasisynchronous grammar and dependency syntax and motivate our modeling choices. We present our translation model in Section 3, describe how we extract rules in Section 4, and list our feature functions in Section 5. Decoding algorithms are given in Section 6. We present experiments measuring our system's performance on translation tasks involving four language pairs and several test sets in Section 7. We find statistically significant improvements over a strong phrase-based baseline on five out of seven test sets across four language pairs. We also perform a human evaluation to study how our system improves translation quality. This article is a significantly expanded version of Gimpel and Smith (2011) , containing additional features, a new decoding algorithm, and a more thorough experimental evaluation. It presents key material from Gimpel (2012) , to which readers seeking further details are referred. Background and Motivation We begin by laying groundwork for the rest of the article. We define notation in Section 2.1. Section 2.2 discusses how synchronous and quasi-synchronous grammar handle syntactic divergence. In Section 2.3, we introduce dependency syntax and review prior work that has used it for machine translation. Section 2.4 presents two examples of syntactic divergence that motivate the model we develop in Section 3. Notation We use boldface for vectors and we denote individual elements in vectors using subscripts; for example, the source and target sentences are denoted x x x = x 1 , . . . , x n and y y y = y 1 , . . . , y m . We denote sequences of elements in vectors using subscripts and superscripts; for example, the sequence from source word i to source word j (inclusive) is denoted x x x j i , and therefore x x x i i = x i . We denote the set containing the first k positive integers as [k] . This notation is summarized in Table 1 . Table 1 Notation used in this article. i, j, k, l integers x x x, y y y vectors x i entry i in vector x x x x x x j i sequence from entry i to entry j (inclusive) in vector x x x [i] the set containing the first i positive integers |x x x| length of vector x x x Synchronous and Quasi-Synchronous Grammars To model syntactic transformations, researchers have developed powerful grammatical formalisms, many of which are variations of synchronous grammars. The most widely used is synchronous context-free grammar (Wu 1997; Gildea 2003; Chiang 2005; Melamed 2003 ), an extension of context-free grammar to a bilingual setting where two strings are generated simultaneously with a single derivation. Synchronous context-free grammars are computationally attractive but researchers have shown that they cannot handle certain phenomena in manually aligned parallel data (Wellington, Waxmonsky, and Melamed 2006; S\u00f8gaard and Kuhn 2009) . Figure 1 shows two such examples of word alignment patterns in German-English data. These patterns were called \"crossserial discontinuous translation units\" (CDTUs) by S\u00f8gaard and Kuhn (2009) . CDTUs cannot even be handled by the more sophisticated synchronous formalisms given by Eisner (2003) and Ding and Palmer (2005) . CDTUs can be handled by synchronous tree adjoining grammar (STAG; Shieber and Schabes 1990) , but STAG comes with substantially heftier computational requirements. Furthermore, S\u00f8gaard and Kuhn (2009) found examples in parallel data that even STAG cannot handle. Smith and Eisner (2006) noted that these limitations of synchronous grammars result from an emphasis on generating the two strings. However, for many real-world applications, such as translation, one of the sentences is provided. The model only needs to score translations of the given source sentence, not provide a generative account for sentence pairs. Smith and Eisner proposed an alternative to synchronous grammarquasi-synchronous grammar (QG)-that exploits this fact for increased flexibility in translation modeling. A QG assumes the source sentence and a parse are given and scores possible translations of the source sentence along with their parses. That is, a quasi-synchronous grammar is a monolingual grammar that derives strings in the target language. The strings' derivations are scored using feature functions on an alignment from nodes in the target tree to nodes in the source tree. The quasi-synchronous dependency grammars of Smith and Eisner (2006) and Gimpel and Smith (2009b) can generate the translations in Figure 1 , as can phrase-based models like Moses (Koehn et al. 2007) and the phrase dependency model we present in Section 3. wir durchleben keine wiederholung des jahres 1938 . we are not living a replay of 1938 . wir wollen keinen . we do not want one . Figure 1 Examples of word alignment patterns in German-English that require the increased expressive power of synchronous tree adjoining grammar. Quasi-synchronous grammar, like synchronous grammar, can in principle be instantiated for a wide range of formalisms. Dependency syntax (which we discuss in Section 2.3) has been used in most previous applications of QG, including word alignment (Smith and Eisner 2006) and machine translation (Gimpel and Smith 2009b) . Aside from translation, QG has been used for a variety of applications involving relationships among sentences, including question answering (Wang, Smith, and Mitamura 2007) , paraphrase identification (Das and Smith 2009) , parser projection and adaptation (Smith and Eisner 2009) , title generation (Woodsend, Feng, and Lapata 2010) , sentence simplification (Woodsend and Lapata 2011) , information retrieval (Park, Croft, and Smith 2011) , and supervised parsing from multiple treebanks with different annotation conventions (Li, Liu, and Che 2012) . Dependency Syntax and Machine Translation Many syntactic theories have been applied to translation modeling, but we focus in this article on dependency syntax (Tesni\u00e8re 1959). Dependency syntax is a lightweight formalism that builds trees consisting of a set of directed arcs from words to their syntactic heads (also called \"parents\"). Examples of dependency trees are shown in Figure 2 . Each word has exactly one parent, and $ is a special \"wall\" symbol that is located at position 0 in the sentence and acts as parent to words that have no other parent in the sentence. Formally, a dependency tree on an m-word sentence y y y is a function \u03c4 y y y : {1, . . . , m} \u2192 {0, . . . , m} where \u03c4 y y y (i) is the index of the parent of word y i . If \u03c4 y y y (i) = 0, we say word y i is a root of the tree. The function \u03c4 y y y is not permitted to have cycles. We restrict our attention to projective dependency trees in this article. Projective dependency trees are informally defined as having no crossing arcs when all dependencies are drawn on one side of the sentence. See K \u00fcbler, McDonald, and Nivre (2009) for formal definitions of these terms. Researchers have shown that dependency trees are better preserved when projecting across word alignments than phrase structure trees (Fox 2002) . This makes dependency syntax appealing for translation modeling, but to date there are not many tree-to-tree translation models that use dependency syntax on both sides. One exception is the system of Ding and Palmer (2005) , who used a synchronous tree substitution grammar designed for dependency syntax, capturing non-isomorphic structure within rules using elementary trees. Another is the system of Riezler and Maxwell III (2006) , who used lexical-functional dependency trees on both sides and also include phrase translation rules. Relatedly, Quirk, Menezes, and Cherry (2005) used a source-side dependency parser and projected automatic parses across word alignments in order to model dependency syntax on phrase pairs. $ konnten sie es \u00fcbersetzen ? $ could you translate it ? Figure 2 Examples of dependency trees with word alignment. Arrows are drawn from children to parents. A child word is a modifier of its parent. Each word has exactly one parent and $ is a special \"wall\" symbol that serves as the parent of all root words in the tree (i.e., those with no other parent). But most who have used dependency syntax have done so either on the source side in tree-to-string systems (Lin 2004; Xiong, Liu, and Lin 2007; Xie, Mi, and Liu 2011) or the target side in string-to-tree systems (Shen, Xu, and Weischedel 2008; Carreras and Collins 2009; Galley and Manning 2009; Hunter and Resnik 2010; Su et al. 2010; Tu et al. 2010) . Others have added features derived from source dependency parses to phrasebased or hierarchical phrase-based translation models (Gimpel and Smith 2008; Gao, Koehn, and Birch 2011) . Motivating Examples Although Fox (2002) found that dependencies are more often preserved across handaligned bitext than constituents, there are still several concerns when using dependency syntax for tree-to-tree translation. First, we only have hand-aligned sentence pairs for small data sets and few language pairs, so in practice we must deal with the noise in automatic word aligners and parsers. Second, not all dependencies are preserved in hand-aligned data, so we would need to be able to handle non-isomorphic structure even if we did have perfect tools. The model we present in Section 3 avoids isomorphism constraints from synchronous grammar and encourages dependency preservation across languages by using dependencies on phrases-flat multi-word units-rather than words. To motivate these choices, we now give two frequently occurring examples of dependency tree-to-tree divergence in German-English data. 1 We consider the German-English parallel corpus used in our experiments (and described in Appendix A). We parsed the English side using TurboParser (Martins et al. 2010) , a state-of-the-art dependency parser. TurboParser was trained on the Penn Treebank (Marcus, Santorini, and Marcinkiewicz 1993) converted to dependencies using the Yamada-Matsumoto head rules (Yamada and Matsumoto 2003) . We parsed the German side using the factored model in the Stanford parser (Rafferty and Manning 2008), which is trained from the NEGRA phrase-structure treebank (Skut et al. 1997) . The Stanford parser's source code defines a set of head rules for converting the phrase-structure parse output to dependencies. 2  The first example is shown in Figure 3 . The bold words illustrate a \"sibling\" relationship, meaning that the source words aligned to the parent and child in the English sentence have the same parent on the German side. Many sibling configurations appear when the English dependency is DET\u2192N within a PP. By convention, the NEGRA treebank uses flat structures for PPs like \"P DET N\" rather than using a separate NP for DET N. When the parser converts this to a dependency tree, the DET and N are made children of the P. In English dependency parsing, due to the Penn Treebank conventions, the DET is made a child of the N, which is a child of the P. There are many other instances like this one that frequently lie within PPs, like the\u2192us and recent\u2192years. However, if we tokenized the us as a phrase and also den usa, then both would be children of the preposition, and the dependency would be preserved. $ auch die mietm\u00e4rkte in den usa sind flexibler $ rental markets are also more flexible in the us Figure 3 Example of a sentence pair containing a frequently-observed \"sibling\" relationship in German-English data: in the the\u2192us dependency, the aligned German words are siblings in the source dependency tree. This occurs due to differences in treebank and head rule conventions between the two data sets. The German parser produces flat PPs with little internal structure, so when the dependency tree is generated, each word in the PP attaches to the P, the head of the phrase. The second example is shown in Figure 4 , which gives an example of a \"grandparent-grandchild\" relationship. In the English dependency until\u2190recently, the aligned source words are in a grandparent relationship in the source sentence's dependency tree. We note, however, that if vor kurzem is tokenized as a phrase, then we might let the entire phrase be the child of bis, preserving the dependency across languages. By considering phrasal structure and dependencies among phrases, we can reduce some of the syntactic divergence in real-world data. The model we develop in the next section is based on this idea. Model In the previous section we noted two examples in which flattening dependency tree structure into \"phrasal dependencies\" could improve dependency preservation between German and English. This idea is compatible with the well-known principle that translation quality is improved when larger units are modeled within translation rules. For example, improvements were found by moving from word-based models to socalled phrase-based translation models. Modern phrase-based translation systems are typified by the Moses system (Koehn et al. 2007) , based on the approach presented by Koehn, Och, and Marcu (2003) . Phrase-based models excel at capturing local reordering phenomena and memorizing multi-word translations. $ bis vor kurzem hielten sich beide seiten an diesen stillschweigenden vertrag $ until recently , both sides adhered to this tacit contract Figure 4 Example of a sentence pair containing a frequently-observed \"grandparent-grandchild\" relationship in German-English data: the English parent and child words in the until\u2190recently dependency are aligned to German words in a grandparent-grandchild relationship. On the other hand, models that use rules employing syntax (Yamada and Knight 2001) or syntax-like representations (Chiang 2005 ) handle long-distance reordering better than phrase-based systems (Birch, Blunsom, and Osborne 2009) , and therefore perform better for certain language pairs (Zollmann et al. 2008) . In order to better handle syntactic divergence and obtain the benefits of these two types of models, we use rules that combine phrases and syntax. In particular, our rules use dependencies between phrases rather than words; we call them phrase dependencies. When adding in source syntax, we eschew the constraints of synchronous grammar in favor of the feature-based approach of quasi-synchronous grammar. So we call our model a quasi-synchronous phrase dependency (QPD) translation model. In Section 3.1, we define phrase dependency trees and in Section 3.2 we present our model. We discuss rule extraction in Section 4 and define the feature functions in the model in Section 5. Decoding is discussed in Section 6 and an empirical evaluation is given in Section 7. Key definitions used throughout this section and the remaining sections are listed in Table 2 . Phrase Dependencies In Section 2.3 we defined dependency trees. Now we provide an analogous definition for phrase dependency trees. We first define a segmentation of a sentence into phrases. Given a sentence y y y, where m = |y y y|, we define a phrase \u03c6 as a word sequence y y y k j , for j and Table 2 Key definitions for our model. x x x = x 1 , . . . , x n source language sentence y y y = y 1 , . . . , y m target language sentence, translation of x x x \u03c0 = x x x k j source-sentence phrase: subsequence of words in the source sentence x x x, i.e., 1 \u2264 j \u2264 k \u2264 n; the number of words in \u03c0 is |\u03c0| \u03c6 = y y y k j target-sentence phrase: subsequence of words in the target sentence y y y, i.e., 1 \u2264 j \u2264 k \u2264 m \u03c0 = \u03c0 1 , . . . , \u03c0 n segmentation of x x x into phrases such that for i \u2208 [n ], \u03c0 i = x x x k j is a source-sentence phrase and \u03c0 1 \u2022 . . . \u2022 \u03c0 n = x x x \u03c6 = \u03c6 1 , . . . , \u03c6 n segmentation of y y y into phrases such that for i \u2208 [n ], \u03c6 i = y y y k j is a target-sentence phrase and \u03c6 1 \u2022 . . . \u2022 \u03c6 n = y y y b b b : {1, . . . , n } \u2192 {1, . . . , n } one-to-one alignment (bijection) from phrases in \u03c6 to phrases in \u03c0; for all i \u2208 [n ], if b b b(i) = j, then \u03c0 j is a subsequence of x x x and \u03c6 i is a subsequence of y y y \u03c4 x x x : {1, . . . , n} \u2192 {0, . . . , n} dependency tree on source words x x x, where \u03c4 x x x (i) is the index of the parent of word x x x i (0 is the wall symbol $) \u03c4 \u03c6 : {1, . . . , n } \u2192 {0, . . . , n } dependency tree on target phrases \u03c6, where \u03c4 \u03c6 (i) is the index of the parent of phrase \u03c6 i (0 is the wall symbol $) h h h = h h h , h h h vector of feature functions; h h h holds the Moses feature functions and h h h holds the QPD feature functions \u03b8 \u03b8 \u03b8 = \u03b8 \u03b8 \u03b8 , \u03b8 \u03b8 \u03b8 vector of feature weights for h h h k such that 1 \u2264 j \u2264 k \u2264 m. The number of words in phrase \u03c6 is denoted |\u03c6|. We define a phrase segmentation of y y y as \u03c6 = \u03c6 1 , . . . , \u03c6 n such that for i \u2208 [n ], \u03c6 i = y y y k j is a phrase and \u03c6 1 \u2022 . . . \u2022 \u03c6 n = y y y, where \u2022 denotes string concatenation. Given a phrase segmentation \u03c6, we define a phrase dependency tree as a function \u03c4 \u03c6 : [n ] \u2192 {0} \u222a [n ] where \u03c4 \u03c6 (i) is the index of the parent of phrase \u03c6 i . If \u03c4 \u03c6 (i) = 0, we say phrase \u03c6 i is the root of the phrase dependency tree; we require there to be exactly one root phrase. As with dependency trees, \u03c4 \u03c6 cannot have cycles. 3 To distinguish phrase dependency trees from the ordinary dependency trees defined in Section 2.3, we will sometimes refer to the latter as \"lexical dependency trees.\" Phrase dependency trees have also been used by Wu et al. (2009) to extract features for opinion mining and a similar formalism was used previously for machine translation by Hunter and Resnik (2010) . Phrase dependencies allow us to capture phenomena like local reordering and idiomatic translations within each phrase as well as longer-distance relationships among the phrases in a sentence. Quasi-Synchronous Phrase Dependency Translation Let X denote the set of all strings in a source language and, for a particular x x x \u2208 X , let Y x x x denote the set of its possible translations (correct and incorrect) in the target language. Given a sentence x x x and its lexical dependency tree \u03c4 x x x , we formulate the translation problem as finding the target sentence y y y * , the phrase segmentation \u03c0 * of x x x, the phrase segmentation \u03c6 * of y y y * , the phrase dependency tree \u03c4 * \u03c6 on the target phrases \u03c6 * where h h h is a vector of feature functions and \u03b8 \u03b8 \u03b8 is a vector of feature weights. The sourcelanguage dependency parse \u03c4 x x x is optional and can be omitted if no source dependency parser is available. If \u03c4 x x x is provided, we include tree-to-tree configurational features from QG, which are described in Section 5.3. Hence we call the model defined in Equation (1) a quasi-synchronous phrase dependency (QPD) translation model. Our model extends the phrase-based translation model of Koehn, Och, and Marcu (2003) . The phrase segmentation variables \u03c6 and the one-to-one phrase alignment b b b : [n ] \u2192 [n ] are taken directly from phrase-based translation. For all i \u2208 [n ], if b b b(i) = j, then \u03c0 j is a subvector of x x x and \u03c6 i is a subvector of y y y. If \u03c4 x x x is not given and the features ignore \u03c4 \u03c6 , then the remaining variables (x x x, y y y, \u03c0, \u03c6, and b b b) are defined in the same way as in phrase-based models. Computational tractability requires that the feature functions h h h decompose across \"parts\" of the output structures in the model. The feature functions that look only at the phrase-based variables (x x x, y y y, \u03c0, \u03c6, and b b b) are identical to the features used in the Moses phrase-based system (Koehn et al. 2007 ), so they decompose in the same way as in Moses. 4 For clarity, we partition the features and weights into two parts, namely, \u03b8 \u03b8 \u03b8 = \u03b8 \u03b8 \u03b8 , \u03b8 \u03b8 \u03b8 and h h h = h h h , h h h , where \u03b8 \u03b8 \u03b8 are the weights for the phrase-based features h h h and \u03b8 \u03b8 \u03b8 are the weights for the QPD features h h h . So we rewrite the right-hand side of Equation (1) as the following: argmax y y y,\u03c0,\u03c6,\u03c4 \u03c6 ,b b b \u03b8 \u03b8 \u03b8 \u2022 h h h (x x x, y y y, \u03c0, \u03c6, b b b) + \u03b8 \u03b8 \u03b8 \u2022 h h h (x x x, \u03c4 x x x , y y y, \u03c0, \u03c6, \u03c4 \u03c6 , b b b) (2) Furthermore, we assume an additive decomposition across individual phrase dependencies in the phrase dependency tree \u03c4 \u03c6 , allowing us to rewrite Equation (2) as + n i=1 \u03b8 \u03b8 \u03b8 \u2022 f f f (x x x, \u03c4 x x x , i, \u03c4 \u03c6 (i), \u03c6 i , \u03c6 \u03c4 \u03c6 (i) , b b b(i), b b b(\u03c4 \u03c6 (i)), \u03c0 b b b(i) , \u03c0 b b b(\u03c4 \u03c6 (i)) ) (3) where we introduce new notation f f f to represent the feature vector that operates on a single phrase dependency at a time in the \"arc-factored\" decomposition of h h h . Each feature in f f f can look at the entirety of x x x and \u03c4 x x x because they are inputs, but can only look at a single target-side phrase dependency \u03c6 i , \u03c6 \u03c4 \u03c6 (i) at a time (along with their aligned source phrases \u03c0 b b b(i) and \u03c0 b b b(\u03c4 \u03c6 (i)) and the indices). Example. Figure 5 shows an example. The inputs to the model are a segmented Chinese sentence and its lexical dependency tree. We used the Stanford Chinese word segmenter (Chang, Galley, and Manning 2008) to segment the Chinese data and the Stanford parser (Levy and Manning 2003) to get Chinese dependency trees. The outputs references: annan to hold talks with us , russia and eu over situation in middle east annan will discuss middle east situation with u.s. , russia and european union annan to discuss mideast situation with us , russia and eu annan to meeting the us , russia and eu to discuss middle east crisis annan will hold talks with the united states , russia and the european union to discuss the middle east situation $ $ Figure 5 Example output of our model for Chinese\u2192English translation. The word-segmented Chinese sentence and dependency tree are inputs. Our model's outputs include the English translation, phrase segmentations for each sentence (a box surrounds each phrase), a one-to-one alignment between the English and Chinese phrases, and a projective dependency tree on the English phrases. Note that the Chinese dependency tree is on words whereas the English dependency tree is on phrases. of the model include a segmentation of the Chinese sentence into phrases, the English translation, its segmentation into phrases, a projective dependency tree on the English phrases, and a one-to-one alignment between the English phrases and Chinese phrases. Four reference translations are also shown. In this example, the model correctly moved the phrase hold talks and also noted its connection to to discuss by making the latter a phrasal dependent. Rule Extraction In typical statistical machine translation (SMT) models, the space of allowable translations is constrained by a set of rules. Informally, a rule consumes part of the input text and emits text in the output language. Building an SMT system typically requires collecting a massive set of rules from parallel text, a process called rule extraction. For phrase-based translation, these rules are phrase pairs and the translation space is constrained by the phrase pairs in the phrase table. 5 In our model, even though we have additional structure (i.e., the phrase dependency tree \u03c4 \u03c6 ), we do not want to enforce any additional constraints on the search space. That is, the space of valid translations is still constrained solely by a standard phrase table. We allow \u03c4 \u03c6 to be any projective phrase dependency tree on \u03c6, so the structure of \u03c4 \u03c6 merely affects how translations are scored, not what translations are permitted. We made this decision because we did not want to reduce the coverage of phrase-based models, which is one of their strengths. Rather, we wanted to better score their translations. 6  So, even though our phrase dependency rules do not consume parts of the input, we still speak in terms of \"rule extraction\" because our procedure is similar to rule extraction in other systems and we define feature functions on our rules in a standard way. In particular, we use the extracted rule instances to compute relative frequency estimates for many of the features presented in Section 5. The rest of this section is organized as follows. In Section 4.1 we describe how we extract rules that only look at target-side words and syntactic structure. In Section 4.2 we extract rules that also look at the source sentence, but not its syntax. (Although our system uses unlexicalized features based on source-side syntax, they do not derive from rules; we turn to features in Section 5). This lets us avoid the computational expense of parsing the source side of the parallel training corpus. Target-Tree Rules We first extract rules that only consider the target side: y y y, \u03c6, and \u03c4 \u03c6 . These rules can be used as the basis for \"dependency language model\" features (Shen, Xu, and Weischedel 2008; Galley and Manning 2009; Zhang 2009) , though unlike previous work, our features model both the phrase segmentation and dependency structure. Typically, these sorts of features are relative frequencies from a corpus parsed using a supervised parser. However, there do not currently exist treebanks with annotated phrase dependency trees. Our solution is to use a standard lexical dependency parser and extract phrase dependencies using bilingual information. 7 Essentially, we combine phrases from the standard phrase extraction pipeline with selected lexical dependencies from the output of a dependency parser. We first give an overview of our approach and then describe it more formally. We begin by obtaining word alignments and extracting phrase pairs using the standard heuristic approach of Koehn, Och, and Marcu (2003) . We then parse the target sentence with a projective dependency parser to obtain a projective dependency tree \u03c4 y y y for a sentence y y y. Note that \u03c4 y y y is a tree on words, not phrases (cf. \u03c4 \u03c6 ). For each pair of targetside phrases in the phrase pairs from phrase extraction, we extract a phrase dependency (along with its direction) if the phrases do not overlap and there is at least one lexical dependency between them. If there is only a dependency in one direction, we extract a single phrase dependency with that direction. If there are lexical dependencies in both directions, we extract a phrase dependency only for the single longest lexical dependency, and in its direction. Because we use a projective dependency parser, the longest lexical dependency between two phrases is guaranteed to be unique. If a phrase contains a root word in \u03c4 y y y , we extract a phrase dependency with the wall symbol as its head. We now present the procedure more formally. Given word-aligned sentence pairs, we extract phrase pairs that are p-consistent with (i.e., do not violate) the word alignments. Let R denote a relation between the two sets [n] and [m] , where n = |x x x| and m = |y y y|. If a pair (i, j) belongs to R for some i \u2208 [n] and j \u2208 [m], then we say that x i is aligned to y j . We define new notation R here instead of using b b b because R allows manyto-many word alignments, which are typically used for phrase extraction. 8 A phrase pair x x x j i , y y y l k is p-consistent with R if, for all u such that i \u2264 u \u2264 j, and all v such that (u, v) belongs to R, it is the case that k \u2264 v \u2264 l. So far this is identical to the phrase extraction pipeline used in Moses. Given word alignments R and a dependency tree \u03c4 y y y on y y y, we extract (target-side) phrase dependencies. We say a phrase dependency y y y j i , y y y l k with y y y l k as the parent phrase is d-consistent with \u03c4 y y y and R if: 1. \u2203x x x j i , x x x l k such that x x x j i , y y y j i and x x x l k , y y y l k are p-consistent with R 2. y y y j i and y y y l k do not overlap: (1 \u2264 i \u2264 j < k \u2264 l \u2264 m) \u2228 (1 \u2264 k \u2264 l < i \u2264 j \u2264 m) 3. the longest lexical dependency from y y y j i to y y y l k is longer than the longest from y y y l k to y y y j i : max u:i\u2264u\u2264j,k\u2264\u03c4 y y y (u)\u2264l |\u03c4 y y y (u) \u2212 u| > max v:k\u2264v\u2264l,i\u2264\u03c4 y y y (v)\u2264j |\u03c4 y y y (v) \u2212 v| The final condition also implies that there is a lexical dependency from a word in y y y j i to a word in y y y l k : \u2203u, i \u2264 u \u2264 j, such that k \u2264 \u03c4 y y y (u) \u2264 l. 7 Other ways of getting phrase dependencies are possible. For example, for a monolingual task, Wu et al. (2009) used a shallow parser to convert lexical dependencies from a dependency parser into phrase dependencies. 8 Many-to-many word alignments can be obtained from certain alignment models or, more frequently, by using heuristics to combine alignments from one-to-many and many-to-one alignments (Koehn, Och, and Marcu 2003) . We also need to extract root phrase dependencies. We say a root phrase dependency y y y j i , $ is d-consistent with \u03c4 y y y and R if: 1. \u2203x x x j i such that x x x j i , y y y j i is p-consistent with R 2. \u2203u, i \u2264 u \u2264 j, such that \u03c4 y y y (u) = 0 We extract all phrase dependencies that are d-consistent with the word alignments and target-side lexical dependency trees. We note that while extracting phrase dependencies we never explicitly commit to any single phrase dependency tree for a target sentence. Rather, we extract phrase dependencies from all phrase dependency trees compatible with the word alignments and the lexical dependency tree. Thus we treat phrase dependency trees analogously to phrase segmentations in phrase extraction. When actually extracting phrase dependencies, we record additional information from the sentence pairs in which we found them. Specifically, for d-consistent phrase dependencies y y y j i , y y y l k (where y y y l k is the parent), we extract tuples of the following form: y y y j i , y y y l k , y u * , y \u03c4 y y y (u * ) , I j < k (4) where I [P] is the indicator function that returns 1 if P evaluates to true and 0 otherwise. The index u * is chosen to make y u * , y \u03c4 y y y (u * ) the longest lexical dependency within the phrase dependency: u * = argmax u:i\u2264u\u2264j,k\u2264\u03c4 y y y (u)\u2264l |\u03c4 y y y (u) \u2212 u| (5) This lexical dependency is recorded for use in back-off features, analogous to the lexical weighting in phrase-based models. The fifth field in Equation ( 4 ) holds the direction of the phrase dependency, which is also the direction of the longest lexical dependency. Root phrase dependencies use k = l = 0 in the parent phrase and designate $ as y 0 . The direction of root phrase dependencies is inconsequential and can remain as I j < k . Examples. What do typical phrase dependencies look like? Tables 3 and 4 show some of the most frequent examples of root phrases and parent-child phrase dependencies extracted by this technique on our German-English (DE\u2192EN) corpus. The English side of the parallel corpus was parsed using TurboParser (Martins et al. 2010) . Naturally, there are many phrase dependencies with a single word in each phrase, but because these are very similar to lists of frequent lexical dependencies in a parsed corpus, we have only shown dependencies with phrases containing more than one word. Root phrases (Table 3 ) frequently contain a subject along with a verb (it is, i would like, etc.), though the lexical root is typically a verb or auxiliary. These are examples of how we can get syntactic information for phrases that typically would not correspond to constituents in phrase structure trees. Table 4 shows frequent phrase dependencies from the same corpus; because this corpus is mostly European Parliamentary proceedings, certain formulaic and domainspecific phrases appear with large counts. When phrases attach to each other, they typically behave like their heads. For example, in the phrase dependency of the\u2190union, the word union is the child phrase because of the is behaving like of . There is likely also a Table 3 Top 60 most frequent root phrases in DE\u2192EN data with at least two words, shown with their counts. Shown in bold are the actual root words in the lexical dependency trees from which these phrases were extracted; these are extracted along with the phrases and used for back-off features. dependency from the to union whenever the longer phrase dependency is extracted, but due to our practice of following the longest lexical dependency in deciding the direction, of \u2190union is favored over the\u2192union. We note that even though these phrase dependencies only contain words from the target language (English), the presence and counts of the phrase dependencies will Table 4 Most frequent phrase dependencies in DE\u2192EN data, shown with their counts and attachment directions. Child phrases point to their parents. To focus on interesting phrase dependencies, we only show those in which one phrase has at least two tokens and neither phrase is entirely punctuation. The words forming the longest lexical dependency in each extracted phrase dependency are shown in bold; these are used for back-off features. depend on the source language through the word alignments. For example, when of the union is expressed in German, the preposition will often be dropped and the definite article chosen to express genitive case. In our corpus, the most common translation of the English union is the German noun union, which is feminine. The genitive feminine definite article is der and, indeed, we find in the phrase table that the translation of of the union with highest probability is der union. 9 Thus the dominance of the phrase dependency of the\u2190union (6,897 occurrences) as compared with of \u2190the union (142 occurrences) is caused by the German translation. 4.1.2 Word Clusters. When trying to compute feature functions for dependencies between long phrases, we expect to face problems of data sparseness. Long phrases do not occur very often, so pairs of long phrases will occur less often still. One way to address this is to also extract rules that use part-of-speech (POS) tags in place of words. However, since words can have multiple POS tags, we would then need to infer POS tags for the words in order to determine which rule is applicable. So we instead use hard word clusters, which provide a deterministic mapping from words to cluster identifiers. Furthermore, certain types of hard word clusters, such as Brown clusters (Brown et al. 1992) , have been shown to correspond well to POS tag categories (Christodoulopoulos, Goldwater, and Steedman 2010). We chose Brown clusters for this reason. Brown clustering uses a bigram hidden Markov model (HMM) in which states are hard cluster labels and observations are words. The emission distributions are constrained such that each word has a nonzero emission probability from at most one cluster label. Clusters can be obtained efficiently through a greedy algorithm that approximately maximizes the HMM's log-likelihood by alternately proposing new clusters and merging existing ones. This procedure actually produces a hierarchical clustering, but we discard the hierarchy information and simply use unique IDs for each cluster. The number of clusters is specified as an input to the algorithm; we used 100 clusters for all experiments in this article. Additional details on cluster generation for our data sets are provided in Appendix B. Given Brown clusters, we extract tuples like those above in which we replace each word by its Brown cluster ID: clust(y y y j i ), clust(y y y l k ), clust(y u * ), clust(y \u03c4 y y y (u * ) ), I j < k (6) where clust() is a function that takes a sequence of words and replaces each by its Brown cluster ID. The index u * is defined as in Equation ( 5 ). Examples of frequent Brown cluster phrase dependencies, including root dependencies, are shown in Table 5 . String-to-Tree Rules Our simplest probability features use the information in these tuples, but we also extract tuples with more information to support richer features. In particular, we record aligned source phrases and details about reordering and the presence of gaps between phrases. That is, for d-consistent phrase dependencies y y y j i , y y y l k , we extract tuples y y y j i , y y y l k , x x x j i , x x x l k , I j < k , I I j < k) = I j < k , I (j + 1 = k) \u2228 (l + 1 = i) , I (j + 1 = k ) \u2228 (l + 1 = i ) (7) for all i , j , k , and l such that the phrase pairs x x x j i , y y y j i and x x x l k , y y y l k are p-consistent with R, and such that x x x j i does not overlap with x x x l k . 10 Again, I [P] is the indicator function that returns 1 if P evaluates to true and 0 otherwise. That is, we include the two target phrases, their aligned source phrases, the direction of the target attachment, the orientation between the source and target phrases (whether the two target phrases are in the same order as their aligned source phrases or swapped), whether a gap is present between the two target phrases, and finally whether a gap is present between the two source phrases. When y y y l k = $, all of the additional fields are irrelevant except the aligned source phrase x x x j i . We now note some examples of the phenomena that we can model with these richer tuples. A common cause of reordering in German-to-English translation relates to verbs. Figure 6 shows two examples of frequently extracted phrase dependencies that model verb movement. Figure 6 (a) gives an example of how German reorders the finite verb to the end of a dependent clause, whereas English keeps it next to the subject. The extracted rule, shown below the sentence pair, only applies when intervening words appear on the German side and no intervening words appear on the English side. This is indicated by the presence (absence) of an ellipsis on the German (English) side of the rule. Figure 6 (b) shows an example of how German moves an infinitive (danken, \"to thank\") to the end of an independent clause when a modal verb (m\u00f6chte, \"would like\") is present. The ellipses on both sides indicate that other words must be present between both the source and target phrase pairs. We note that this rule says nothing about what fills the gap. In particular, the gap-filling material does not have to be translationally equivalent, and indeed in the given sentence pair it is not. As opposed to rules in hierarchical phrase-based models (Chiang 2005) , which typically specify translationally equivalent substructures, this rule simply models the reordering and long-distance movement of the infinitive. Much prior work has found phrase pairs with gaps to be useful for machine translation (Simard et al. 2005; Crego and Yvon 2009; Galley and Manning 2010) , and we extract tuples as in Equation ( 7 ) so that we can model such structures, even though we do not directly model gap-filling like hierarchical models and other models based on synchronous context-free grammar (Zollmann and Venugopal 2006, inter alia) . ich meine deshalb , dass es eine frage der geeigneten methodik ist . i think that it is consequently a question of the appropriate methodologies . Examples of illustrative sentence pairs and frequently extracted rules that model verb movement between German and English. An ellipsis indicates that there must be material between the two phrases for the rule to apply. (a) Example of movement of the finite verb to the end of a dependent clause. (b) Example of movement of an infinitive to the end of an independent clause following a modal verb (m\u00f6chte, 'would like'). Discussion of the features used to score these string-to-tree rules is given in Section 5.2. The tuples described here are used to compute all of the lexicalized phrase dependency features in our model. We extract each tuple with a count of 1 each time it is observed, aggregate the counts across all sentence pairs in the parallel corpus, and use the counts to compute the statistical features we present in the next section. We also have structural features that consider string-to-tree and tree-to-tree configurations, but these do not require any rule extraction. In the next section we describe the full set of features in our model. Features Our model extends the phrase-based translation model of Moses (Koehn et al. 2007 ), so we include all of its features in our model. These include four phrase table probability features, a phrase penalty feature, an n-gram language model, a distortion cost, six lexicalized reordering features, and a word penalty feature. These features are contained in h h h in Equation (3), reproduced here: argmax y y y,\u03c0,\u03c6,\u03c4 \u03c6 ,b b b \u03b8 \u03b8 \u03b8 \u2022 h h h (x x x, y y y, \u03c0, \u03c6, b b b) + n i=1 \u03b8 \u03b8 \u03b8 \u2022 f f f (x x x, \u03c4 x x x , i, \u03c4 \u03c6 (i), \u03c6 i , \u03c6 \u03c4 \u03c6 (i) , b b b(i), b b b(\u03c4 \u03c6 (i)), \u03c0 b b b(i) , \u03c0 b b b(\u03c4 \u03c6 (i)) ) (8) We now describe in detail the additional features f f f that are used to score phrase dependency trees. Each operates on a single phrase dependency and takes the arguments x x x, \u03c4 x x x , c, d, \u03c6 c , \u03c6 d , c , d , \u03c0 c , \u03c0 d , which are, in order, the source sentence (x x x), the source dependency tree (\u03c4 x x x ), the target child phrase index (c), the target parent phrase index (d), the target child phrase (\u03c6 c ), the target parent phrase (\u03c6 d ), the index of the source phrase aligned to the target child (c ), the index of the source phrase aligned to the target parent (d ), the child-aligned source phrase (\u03c0 c ), and the parent-aligned source phrase (\u03c0 d ). Like the phrase probability features in Moses, many of our feature functions are conditional probabilities computed using relative frequency estimation given the full collection of extracted tuples. That is, for a tuple \u03b1, \u03b2 , the conditional probability of field \u03b1 given field \u03b2 is estimated as p(\u03b1 | \u03b2) = #{ \u03b1, \u03b2 } \u03b2 #{ \u03b1, \u03b2 } (9) where #{ \u03b1, \u03b2 } denotes the count of the tuple \u03b1, \u03b2 in the multiset of extracted tuples. We use the notation p in the following to indicate that relative frequency estimates are being used. 11 Target-Tree Features We first include features that only consider the target-side words and phrase dependency tree; these are computed based on the rules extracted in Section 4.1. The first feature is the sum of the scaled log-probabilities of each phrase dependency attachment in \u03c4 \u03c6 : f pdep (x x x, \u03c4 x x x , c, d, \u03c6 c , \u03c6 d , c , d , \u03c0 c , \u03c0 d ) = max 0, C + log p(\u03c6 c | \u03c6 d , dir(c, d)) (10) where dir(c, d) is defined dir(c, d) = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 root if d = 0 left if d > c right otherwise (11) and returns the direction of the attachment for head index d and child index c, that is, the direction in which the child resides; root indicates that phrase c is the root. Although we use log-probabilities in this feature function, we add a constant C, chosen to ensure the feature value is never negative. The reasoning here is that whenever we use a phrase dependency that we have observed in the training data, we want to boost the score of the translation. If we used log-probabilities, each observed dependency would incur a penalty. The max expression prevents unseen parent-child phrase dependencies from causing the score to be negative infinity. Our motivation is a desire for the features to prefer one derivation over another but not to rule out a derivation completely if it merely happens to contain an unseen phrase dependency. Because we will use this same practice for all other probability features, we introduce some shorthand for simplicity of presentation. We first redefine this feature: f pdep (x x x, \u03c4 x x x , c, d, \u03c6 c , \u03c6 d , c , d , \u03c0 c , \u03c0 d ) = max 0, C pdep + log g pdep (x x x, \u03c4 x x x , c, d, \u03c6 c , \u03c6 d , c , d , \u03c0 c , \u03c0 d ) ( 12 ) where g pdep (x x x, \u03c4 x x x , c, d, \u03c6 c , \u03c6 d , c , d , \u03c0 c , \u03c0 d ) = p(\u03c6 c | \u03c6 d , dir(c, d)) (13) In what follows, we will restrict our attention to defining the g-style functions for probability features, and assume that there is always a corresponding f that has the same subscript and takes the same inputs, as in Equation ( 12 ). Furthermore, when presenting the remaining features, we will suppress the arguments of each for clarity; all take the same arguments as f pdep and g pdep . We will assume C is chosen appropriately for each g based on the minimum logprobability for the feature. For example, C pdep = 0.01 \u2212 min \u03c6,\u03c6 ,r log p(\u03c6 | \u03c6 , r) (14) that is, the minimum log-probability is found, negated, and a small positive value (0.01) is added to ensure the feature is greater than zero. This ensures that, if a phrase dependency has been seen, its contribution is at least 0.01. To counteract data sparseness, we include other features that are less specific than g pdep . First, we include a version of this feature with words replaced by Brown clusters: g pdep clust = p(clust(\u03c6 c ) | clust(\u03c6 d ), dir(c, d)) (15) We also include lexical weighting features similar to those used in phrase-based machine translation (Koehn, Och, and Marcu 2003) . These use the longest lexical dependencies extracted during rule extraction. First, for all child, parent, direction lexical dependency tuples y, y , r in the parsed target side of the parallel corpus, we estimate conditional probabilities plex (y | y , r) using relative frequency estimation. Then, assuming the given phrase dependency \u03c6 c , \u03c6 d has longest child-parent lexical dependency y, y for direction dir(c, d), we include the feature: g ldep = plex (y | y , dir(c, d)) (16) We include an analogous feature with words replaced by Brown clusters. Different instances of a phrase dependency may have different lexical dependencies extracted with them. We only use the lexical weight for the most frequent, breaking ties by choosing the lexical dependency that maximizes plex (y | y , r), as was done similarly by Koehn, Och, and Marcu (2003) . So far we described four features that consider y y y, \u03c6, and \u03c4 \u03c6 : one for phrase dependencies, one for lexical dependencies, and the same two features computed on a transformed version of the corpus in which each word is replaced by its Brown cluster ID. String-to-Tree Features We next discuss features that consider properties of the source sentence x x x, its phrase segmentation \u03c0, and the phrase alignment b b b, in addition to y y y, \u03c6, and \u03c4 \u03c6 . However, these features still do not depend on the source tree \u03c4 x x x , so they can be included even when a parser for the source language is not available. We will discuss features that use \u03c4 x x x in Section 5.3. These features are similar to the previously defined g pdep , but condition on additional pieces of structure. All features condition on direction. The first pair of features condition on the source phrase (\u03c0 c ) aligned to the child phrase (\u03c6 c ) in the target phrase dependency ( \u03c6 c , \u03c6 d ): g pdep child = p(\u03c6 c | \u03c6 d , dir(c, d), \u03c0 c ) ( 17 ) g pdep child clust = p(\u03c6 c | clust(\u03c6 d ), dir(c, d), \u03c0 c ) (18) In the second feature, we condition on word clusters for the parent phrase \u03c6 d , but on words in the aligned source phrase \u03c0 c . Because Brown clusters often correspond to syntactic clusters, even at times resembling part-of-speech tags (Christodoulopoulos, Goldwater, and Steedman 2010), it did not seem logical to model translation probabilities between source-and target-language word clusters. This is why we did not include a feature like the above with word clusters for \u03c6 c and \u03c0 c . Our use of these clusters is a simple kind of backoff or smoothing that allows some sharing across specific phrases, since statistics on phrase pairs are expected to be sparse. The next set of features includes those that condition on the orientation between the source-and target-side phrases. The ori function returns the orientation of the aligned source phrases in a target phrase dependency attachment, namely, whether the aligned source phrases are in the same order as the target phrases (\"same\") or if they are in the opposite order (\"swap\"): ori(c, d, c , d ) = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 root if d = 0 same if dir(c, d) = dir(c , d ) swap otherwise (19) Given this definition of ori, we define the following features that condition on orientation (in addition to other fields): g pdep orient = p(\u03c6 c | \u03c6 d , dir(c, d), ori(c, d, c , d )) ( 20 ) g pdep orient clust = p(clust(\u03c6 c ) | clust(\u03c6 d ), dir(c, d), ori(c, d, c , d )) (21) g pdep child orient = p(\u03c6 c | \u03c6 d , dir(c, d), \u03c0 c , ori(c, d, c , d )) (22) g pdep child orient clust = p(\u03c6 c | clust(\u03c6 d ), dir(c, d), \u03c0 c , ori(c, d, c , d )) ( 23 ) where the last two features condition on the aligned child phrase \u03c0 c in addition to the direction and orientation. We next give features that condition on the presence of gaps between the child and parent target phrases and gaps between the aligned phrases on the source side. The gap(c, d) function indicates whether there is a gap between the phrases indexed by c and d: gap(c, d) = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 root if d = 0 yes if |d \u2212 c| \u2265 1 no otherwise (24) Given this gap function, we define the following features: g pdep orient gap = p(\u03c6 c | \u03c6 d , dir(c, d), ori(c, d, c , d ), gap(c, d), gap(c , d )) ( 25 ) g pdep orient gap clust = p(clust(\u03c6 c ) | clust(\u03c6 d ), dir(c, d), ori(c, d, c , d ), gap(c, d), gap(c , d )) (26) All the features mentioned so far have the child phrase on the left-hand side of the conditioning bar. We now present features that have both the child and parent phrases on the left-hand side: g pdep pc = p(\u03c6 c , \u03c6 d , dir(c, d) | \u03c0 c , \u03c0 d ) ( 27 ) g pdep pc orient = p(\u03c6 c , \u03c6 d , dir(c, d) | \u03c0 c , \u03c0 d , ori(c, d, c , d )) (28) g pdep pc orient gap = p(\u03c6 c , \u03c6 d , dir(c, d), gap(c, d) | \u03c0 c , \u03c0 d , ori(c, d, c , d ), gap(c , d )) (29) These last features score larger rules composed of two phrase pairs from the phrase table. Including direction, orientation, and gaps enables us to model longer-distance reorderings; we showed some examples of such frequently extracted phrase dependencies in Section 4.2. In all, we introduced 11 features in this section, giving us a total of 15 so far. For the feature ablation experiments in Section 7, we will partition these features into two parts: We refer to the six features with subscript clust as CLUST and the other nine as WORD. String-to-Tree Configurations (CFG) . We now present features that count instances of local reordering configurations involving phrase dependencies. We refer to the features described in this section and the next section as CFG. These features consider the target segmentation \u03c6, the target phrase dependency tree \u03c4 \u03c6 , and the phrase alignment b b b, but not the target words y y y or the source words x x x, segmentation \u03c0, or dependency tree \u03c4 x x x . Our first set of features only looks at configurations involving direction and orientation. The first feature value is incremented if the child is to the left and the aligned source-side phrases are in the same order: f left same = I dir(c, d) = left \u2227 ori(c, d, c , d ) = same (30) Another feature fires if the aligned source phrases are in the opposite order: f left swap = I dir(c, d) = left \u2227 ori(c, d, c , d ) = swap (31) Analogous features are used when the child is to the right of the parent: f right same = I dir(c, d) = right \u2227 ori(c, d, c , d ) = same ( 32 ) f right swap = I dir(c, d) = right \u2227 ori(c, d, c , d ) = swap (33) These four configuration features are shown in order in the leftmost column in Figure 7 . They are agnostic as to the presence of gaps between the two target phrases and between the two source phrases. We include 16 features that add gap information to these four coarse configurations, as shown in the remainder of the table. Four gap configurations are possible, constructed from one binary variable indicating the presence or absence of a source gap paired with a binary variable indicating the presence or absence of a target gap. We replicate the four coarse features for each gap configuration, giving us a total of 20 string-to-tree configuration features, all shown in Figure 7 . ? ? no gaps source gap target gap source and target gaps coarse configurations (only direction and orientation) x i x j x k x i x j x k x l x i x j x k x l x i x j x k x l x i x j x k x l x i x j x k x l x i x j x k x l x i x j x k x l x i x j x k x l x i x j x k x i x j x k x i x j x k x i x j x k x i x j x k x i x j x k x i x j x k x i x j x k 5.2.2 Dependency Length Features. Related to the string-to-tree configurations are features that score source-and target-side lengths (i.e., number of words crossed) of target-side phrase dependencies. These lengths can also be useful for hard constraints to speed up inference; we return to this in Section 6. These features and constraints are similar to those used in vine grammar (Eisner and Smith 2005) . We first include a feature that counts the number of source-side words between the aligned source phrases in each attachment in \u03c4 \u03c6 . Letting \u03c0 c = x x x j i and \u03c0 d = x x x l k : fsrc vine = I dir(c , d ) = left k \u2212 (j + 1) + I dir(c , d ) = right i \u2212 (l + 1) (34) Although this feature requires the segmentation of the source sentence in order to determine the number of source words crossed, the actual identities of those words are not needed, so the feature does not depend on x x x. We would expect this feature's weight to be negative for most language pairs, encouraging closeness in the source sentence of phrases aligned to each phrase dependency in the target. We would like to use a similar feature for target-side dependency lengths, for example, where \u03c6 c = y y y j i and \u03c6 d = x x x l k : I [dir(c, d) = left] k \u2212 (j + 1) + I [dir(c, d) = right] (i \u2212 (l + 1)) (35) However, such a feature could require looking at the entire phrase segmentation being generated to score a single phrase dependency (e.g., if \u03c4 \u03c6 (1) = n ). Using this feature would prevent us from being able to use dynamic programming for decoding (we discuss our approach to decoding in Section 6). Instead, we use a feature that considers bounds on the number of target words crossed by each phrase dependency. In particular, the feature sums the maximum number of target words that could be crossed by a particular phrase dependency. We will discuss how this feature is computed when we discuss decoding in Section 6. We use CFG to refer to the set containing the 20 string-to-tree configuration features and the 2 string-to-tree dependency length features. Adding these 22 features to the 15 from Sections 5.1 and 5.2 gives us 37 QPD features so far. Tree-to-Tree Features (TREETOTREE) The last two sets of features consider the source-side dependency tree \u03c4 x x x in addition to x x x, \u03c0, b b b, y y y, \u03c6, and \u03c4 \u03c6 . These are the only features that use source and target syntax simultaneously. We use TREETOTREE to refer to these features. 5.3.1 Quasi-Synchronous Tree-to-Tree Configurations. We begin with features based on the quasi-synchronous configurations from Smith and Eisner (2006) , shown for lexical dependency trees in Figure 8 . For a child-parent dependency on the target side, these configurations consider the relationship between the aligned source words. For example, if the aligned source words form a child-parent dependency in the source tree, then we have a \"parent-child\" configuration. There is also an \"other\" category for those that do not fit any of the named categories. However, for our model we need to score configurations involving phrase dependencies. That is, for a child-parent phrase dependency \u03c6 c , \u03c6 d in \u03c4 \u03c6 , we consider the relationship between \u03c0 c and \u03c0 d , the source-side phrases to which \u03c6 c and \u03c6 d align. Figure 8 Quasi-synchronous tree-to-tree configurations from Smith and Eisner (2006) . There are additional configurations involving NULL alignments and an \"other\" category for those that do not fit into any of the named categories. There are several options for computing configuration features for our model, since we use a phrase dependency tree for the target sentence, a lexical dependency tree for the source sentence, and a phrase alignment. We use a heuristic approach. First we find the full set of configurations that are present between any word in one source phrase and any word in the other source phrase. That is, given a pair of source words, one with index j in source phrase d and the other with index k in source phrase c , we have a parent-child configuration if \u03c4 x x x (k) = j; if \u03c4 x x x (j) = k, a child-parent configuration is present. In order for the grandparent-grandchild configuration to be present, the intervening parent word must be outside both phrases. For sibling configurations, the shared parent must also be outside both phrases. In lieu of standard (non-sibling) c-command relationships, we define a modified c-command category as follows. We first find the highest ancestors of words j and k that are still in their respective phrases. Of these two ancestors, if neither is an ancestor of the other and if they are not siblings, then the \"c-command\" feature fires. After obtaining a list of all configurations present for each pair of words j, k , we fire the feature for the single configuration corresponding to the maximum distance |j \u2212 k|. If no configurations are present between any pair of words, the \"other\" feature fires. Therefore, only one configuration feature fires for each extracted phrase dependency attachment. For the six configurations other than \"root-root,\" we actually include multiple instances of each configuration feature: one set includes direction (6 \u00d7 2 = 12 features), another set includes orientation (12 features), and the final set includes both source-and target-side gap information (24 features). There are therefore 49 features in this category (including the single \"root-root\" feature). 5.3.2 Tree-to-Tree Dependency Path Length Features. Finally, we include features that consider the dependency path length between the source phrases aligned to the target phrases in each phrase dependency. The features in Section 5.2.2 considered distance along the source sentence (the number of words crossed). Now we add features that consider distance along the source tree (the number of lexical dependency arcs crossed). We expect the learned weights for these features to encourage short dependency path lengths on the source side. We first include a feature that sums, for each target phrase i, the inverse of the minimum undirected path length between each word in \u03c0 c = x x x j i and each word in \u03c0 d = x x x l k : f undir path = j j=i l k=k 1 minUndirPathLen(x x x, \u03c4 x x x , j, k) (36) where minUndirPathLen(x x x, \u03c4 x x x , j, k) returns the shortest undirected dependency path length from x j to x k in \u03c4 x x x . The shortest undirected path length is defined as the number of dependency arcs that must be crossed to travel from one word to the other along the arcs in \u03c4 x x x . Assuming an analogous function minDirPathLen(x x x, \u03c4 x x x , j, k) that computes the minimum directed dependency path length, we also include the following feature: f dir path = j j=i l k=k 1 minDirPathLen(x x x, \u03c4 x x x , j, k) (37) If there is no directed path from x j to x k , minDirPathLen returns \u221e. Adding these two features gives us a total of 88 QPD features. Along with the 14 phrase-based features there are a total of 102 features in our model. Decoding For our model, decoding consists of solving Equation (1)-that is, finding the highestscoring tuple y y y, \u03c0, \u03c6, \u03c4 \u03c6 , b b b for an input sentence x x x and its parse \u03c4 x x x . This is a challenging search problem, because it is at least as hard as the search problem for phrase-based models, which is intractable (Koehn, Och, and Marcu 2003) . Because of this we use a coarse-to-fine strategy for decoding (Charniak and Johnson 2005; Petrov 2009 ). Coarseto-fine inference is a general term for procedures that make two (or more) passes over the search space, pruning the space with each pass. Typically, feature complexity is increased in each pass, as richer features can often be computed more easily in the smaller search space. One simple coarse-to-fine procedure for our model would start by generating a k-best list of derivations using a phrase-based decoder. This \"coarse model\" would account for all of the phrase-based features. Then we could parse each derivation to incorporate the QPD features and rerank the k-best list with the modified scores; this is the \"fine model.\" The advantage of this approach is its simplicity, but other research has shown that k-best lists for structured prediction tend to have very little diversity (Huang 2008) , and we expect even less diversity in cases like machine translation where latent variables are almost always present. Instead, we generate a phrase lattice (Ueffing, Och, and Ney 2002) in a coarse pass and perform lattice dependency parsing as the fine pass. The remainder of this section is laid out as follows. We begin by reviewing phrase lattices in Section 6.1. In Section 6.2 we present our basic lattice dependency parsing algorithm. We give three ways to speed it up in Section 6.3; one enables a more judicious search without affecting the search space, and the other two prune the search space in different ways. In Section 6.4, we discuss how decoding affects learning of the feature weights \u03b8 \u03b8 \u03b8, and we describe the structured support vector machine reranking formulation from Yadollahpour, Batra, and Shakhnarovich (2013) that we use. We close Figure 9 Example phrase lattice for the source sentence shown. Each node contains an n-gram history for computing n-gram language model features and a coverage vector representing the source words that have been translated so far. For clarity, the n-gram history (n = 2) and coverage vector are only shown for three nodes. in Section 6.5 with a brief discussion of how this decoder differs from earlier versions published in Gimpel and Smith (2009b, 2011) . Phrase Lattices The most common decoding strategy for phrase-based models is to use beam search (Koehn, Och, and Marcu 2003) . The search is performed by choosing phrase pairs from the phrase table and applying them to translate source phrases into the target language. Coverage vectors are maintained during decoding to track which words have been translated so far. They are used to enforce the constraint that each source word appear in exactly one phrase pair. It is often convenient to build a packed representation of the (pruned) search space explored during decoding. For phrase-based models, this representation takes the form of a phrase lattice (Ueffing, Och, and Ney 2002) , a finite-state acceptor in which each path corresponds to a derivation. Figure 9 shows an example. The source sentence and a reference translation are shown at the top of the figure. Each path from the start node on the left to a final node corresponds to a complete output in the model's output space. Each lattice edge corresponds to a phrase pair used in the output. All paths leading to a given node in the lattice must agree in the set of source words that have been translated thus far. So, every node in the lattice is annotated with the coverage vector of all paths that end there. This is shown for three of the nodes in the figure . The lattice is constructed such that all features in the model are locally computable on individual lattice edges. To make n-gram language model features local, all paths leading to a given node must end in the same n \u2212 1 words. 12 In the example, there are two nodes with equivalent coverage vectors that are separated because they end in different words (you vs. could). Decoders like Moses can output phrase lattices like these; the lattice simply encodes the paths explored during the beam search. Lattice Dependency Parsing Each path in a phrase lattice corresponds to a tuple y y y, \u03c0, \u03c6, b b b for the input x x x. To also maximize over \u03c4 \u03c6 , we perform lattice dependency parsing, which allows us to search over the space of tuples y y y, \u03c0, \u03c6, b b b, \u03c4 \u03c6 . Lattice parsing jointly maximizes over paths through a lattice and parse structures on those paths. Because we use an arc-factored phrase dependency model (Equation ( 3 )), the lattice dependency parsing algorithm we use is a straightforward generalization of the arcfactored dynamic programming algorithm from Eisner (1996) . The algorithm is shown in Figure 10 . It is shown as a set of recursive equations in which shapes are used in place of function names and shape indices are used in place of function arguments. The equations ground out in functions edgeScore and arcScore that score individual lattice edges and phrase dependency arcs, respectively. 13 A semiring-generic format is used; for decoding, the semiring \"plus\" operator (\u2295) would be defined as max and the semiring \"times\" operator (\u2297) would be defined as +. The entry point when executing the algorithm is to build GOAL, which in turn requires building the other structures. We use a simple top-down implementation with memoization. Our style of specifying dynamic programming algorithms is similar to weighted deduction, but additionally specifies indices and ranges of iteration, which are useful for a top-down implementation. Top-down dynamic programming avoids the overhead of maintaining a priority queue that is required by bottom-up agenda algorithms (Nederhof 2003; Eisner, Goldlust, and Smith 2005) . The disadvantage of top-down dynamic programming is that wasted work can be done; structures can be built that are never used in any full parse. This problem appears when parsing with context-free grammars, and so the CKY algorithm works bottomup, starting with the smallest constituents and incrementally building larger ones. This is because context-free grammars may contain rules with only non-terminals. Topdown execution may consider the application of such rules in sequence, producing long derivations of non-terminals that never \"ground out\" in any symbols in the string. A dependency model, on the other hand, always works directly on words when building items, so a top-down implementation can avoid wasted effort. However, this situation changes with lattice dependency parsing. It is possible for a top-down lattice dependency parser to consider some dependencies that are never used in a full parse. We address this issue in the next section. Computational Complexity and Speeding Up Decoding The lattice parsing algorithm requires O(E 2 V) time and O(E 2 + VE) space, where E is the number of edges in the lattice and V is the number of nodes. Typical phrase lattices might easily contain tens of thousands of nodes and edges, making exact search prohibitively expensive for all but the smallest lattices. So we use three techniques to speed up decoding: (1) avoiding construction of items that are inconsequential (i.e., Figure 10 Lattice dependency parsing using an arc-factored dependency model. Lone indices like p and i denote nodes in the lattice, and an ordered pair like (i, j) denotes the lattice edge from node i to node j. START is the single start node in the lattice and FINAL is a set of final nodes. We use edgeScore(i, j) to denote the model score of crossing lattice edge (i, j), which only includes the phrase-based features h h h . We use arcScore((i, j), (l, m)) to denote the score of building the dependency arc from lattice edge (i, j) to its parent (l, m); arcScore only includes the QPD features h h h . that could never be contained in a full parse), (2) pruning the lattices, and (3) limiting the maximum length of a phrase dependency. Avoiding Construction of Inconsequential Items . By design, our phrase lattices impose several types of natural constraints on allowable dependency arcs. For example, each node in the phrase lattice is annotated with a coverage vector-a bit vector indicating which words in the source sentence have been translated-which implies a topological ordering of the nodes. Once a word in the source sentence has been covered (i.e., translated), it cannot be uncovered later. This can tell us whether certain nodes are unreachable from other nodes. For example, for a three-word source sentence, there cannot exist a directed path from a node with coverage vector 0, 1, 0 to a node with coverage vector 0, 0, 1 . However, there may or may not be a path from a node with vector 0, 1, 0 to one with 0, 1, 1 . Generally, we need an efficient way to determine, for any two nodes in the lattice, whether there exists a path from one to the other. If there is no path, we can avoid wasting time figuring out the best way to build items that would end at the two nodes. To discover this, we use an all-pairs shortest paths algorithm to find the score of the best path between each pair of nodes in the lattice. The algorithm also tells us whether each edge is reachable from each other edge, allowing us to avoid drawing dependencies that will never ground out in a lattice path. We use the Floyd-Warshall algorithm (Floyd 1962) . This adds some initial overhead to decoding, but in preliminary experiments we found that it saves more time than it costs. We actually run a modified version of the algorithm that computes the length (in words) of the longest path between any two nodes. If the maximum length between two nodes is \u221e, the nodes are unreachable from each other. Before we build an item in the algorithm in Figure 10 , we check reachability of the item endpoints and only proceed if one can reach the other. We modified the algorithm to output maximum lengths because we use the maximum lengths to compute the target-side vine grammar features and constraints, as mentioned in Section 5.2.2. In particular we use a feature f tgt vine that is a target-side analog to fsrc vine but using the Floyd-Warshall maximum path lengths in place of the actual lengths. Lattice Pruning. To reduce phrase lattice sizes, we prune lattice edges using forward-backward pruning (Sixtus and Ortmanns 1999), which has also been used by Tromble et al. (2008) . This pruning method computes the max-marginal for each lattice edge, which is the score of the best full path that uses that edge, then prunes edges whose max-marginal is below a certain fraction of the best path score in the lattice. Maxmarginals have been used for other coarse-to-fine learning frameworks (Weiss, Sapp, and Taskar 2010) and offer the advantage that the best path in the lattice is preserved during pruning. We only use the score contribution from the phrase-based features when computing these max-marginals. For each lattice, we use a grid search to find the most liberal threshold that leaves fewer than 2,000 edges in the resulting lattice. As complexity is quadratic in E, forcing E to be less than 2,000 improves runtime substantially. After pruning, the lattices contain more than 10 16 paths on average and oracle BLEU scores are typically 10-15 points higher than the model-best paths. Maximum Dependency Lengths. We can easily adapt our vine grammar features to function as hard constraints on allowable dependency trees, as originally done by Eisner and Smith (2005) for monolingual dependency parsing. We use two simple constraints on the maximum length of a phrase dependency used during translation. One constrains the number of source words that are crossed from one aligned source phrase to the other aligned source phrase by the phrase dependency. The other constrains the maximum number of target-side words crossed by any path from one target phrase to the other target phrase in a phrase dependency. During translation, we never build items that would require using dependency arcs that violate these constraints. In Section 7 we discuss the values we used in our primary experiments and also compare translation quality and decoding speed for several values of these hyperparameters. Interaction with Learning The use of a coarse-to-fine decoding procedure affects how we learn the parameters of our model. We use two separate versions of the phrase-based feature weights: one for lattice generation and one for lattice dependency parsing. This is common with coarse-to-fine strategies-separate instances of coarser parameters are required for each subsequent pass. We first learn parameters for the coarse phrase-based model used to generate phrase lattices. Then, after generating the lattices, we prune them (Section 6.3.2) and use a second round of tuning to learn parameters of the fine model, which includes all phrase-based and QPD feature weights. We initialized the phrase-based feature weights using the default Moses weights. For the QPD features, we initialized the phrase dependency probability feature weights to 0.002 and the weights for all other features to 0. For tuning, we need the k-best outputs, for which efficient dynamic programming algorithms are available. We use Algorithm 3 from Huang and Chiang (2005) , which lazily finds the k best derivations efficiently. In preliminary testing, we found that the k-best lists tended to be dominated by repeated translations with different derivations, so we used the technique presented by Huang, Knight, and Joshi (2006) , which finds a unique k-best list, returning the highest-scoring derivation for each of k unique translations. This modification requires the maintenance of additional data structures to store all of the previously found string yields for each item built during parsing. This incurs additional overhead but allows us to obtain a far more diverse k-best list given a fixed time and memory budget. For the first round of tuning, we use RAMPION (Gimpel and Smith 2012b) , which performs competitively with minimum error rate training (Och 2003) but is more stable. For training the fine model, however, we found that RAMPION did not lead to substantial improvements over the output of the coarse phrase-based model alone. We found better performance by using a fine learner designed for the k-best reranking setting, in particular the structured support vector machine reranker described by Yadollahpour, Batra, and Shakhnarovich (2013) . Though we are doing lattice reranking rather than k-best reranking, the learning problem for our fine model is similar to that for k-best reranking in that the decoder is exact (i.e., there is no pruning that could lead to different patterns of search error as the parameters change). That is, phrase lattice generation and pruning (described in Section 6.3.2) only depend on the coarse phrase-based feature weights and the maximum dependency length constraints (described in Section 6.3.3); they do not depend on the fine model parameters. We now briefly describe how we learn parameters for the fine model via lattice reranking. For simplicity, we will only write the source sentence x x x and its translation y y y when describing the reranker and omit the additional input and output variables \u03c4 x x x , \u03c0, \u03c6, \u03c4 \u03c6 , and b b b, but they are always present and used for computing features. We assume a tuning set with N source sentences: {x x x i } N i=1 . Let Y R i be the set of reference translations for source sentence x x x i . Let Y i = {y y y (1)  i . . . y y y (k) i } denote the set of k candidate translations (outputs of our lattice dependency parsing decoder) for x x x i . Let y y y * i denote the highest-quality translation in the set, that is, y y y * i = argmin y y y\u2208Y i (Y R i , y y y), where (Y R i , y y y) is the negated BLEU+1 score (Lin and Och 2004) of y y y evaluated against references Y R i . We use the following cost function for sentence i and candidate translation y y y: L(Y R i , y y y) = (Y R i , y y y) \u2212 (Y R i , y y y * i ) (38) that is, the negated BLEU+1 score of translation y y y i relative to that of the best translation (y y y * i ) in the set. Yadollahpour, Batra, and Shakhnarovich (2013) formulate the reranking learning problem as an L 2 -regularized slack-rescaled structured support vector machine (SSVM; Tsochantaridis et al. 2005) . The feature weights \u03b8 \u03b8 \u03b8 for the fine model are learned by solving the following quadratic program: min \u03b8 \u03b8 \u03b8,\u03be i ||\u03b8 \u03b8 \u03b8|| 2 2 + \u03bb i\u2208[N] \u03be i (39a) s.t. \u03b8 \u03b8 \u03b8 h h h(x x x i , y y y * i ) \u2212 h h h(x x x i , y y y) \u2265 1 \u2212 \u03be i L(Y R i , y y y) (39b) \u03be i \u2265 0, \u2200y y y \u2208 Y i \\ y y y * i , (39c) In Equation (39b), the violation in the margin \u03be i is scaled by the cost of the translation. Thus if in addition to y y y * i there are other good solutions in the set, the margin for such solutions will not be tightly enforced. On the other hand, the margin between y y y * i and bad solutions will be very strictly enforced. Equation ( 39 ) is solved via the 1-slack cutting-plane algorithm of Joachims, Finley, and Yu (2009) . 14 During the execution of the cutting-plane algorithm, we compute the tuning set BLEU score with all parameter vector values that are considered. At convergence we return the parameters that led to the highest tuning BLEU score. This helps to bridge the discrepancy between our use of sentence-level BLEU+1 in the loss function and corpus BLEU for final evaluation. We alternate between generating k-best lists using our lattice parser and solving Equation (39) on the fixed lists, each time pooling all previous iterations' lists. We repeat until the parameters do not change, up to a maximum of 15 iterations. We used k-best lists of size 150 and a fixed, untuned value of \u03bb = 0.1 for all experiments. Comparison to Earlier Work The decoder described above represents some advances over those presented in earlier papers. Our original decoder was designed for a lexical dependency model; we used lattice dependency parsing on lattices in which each edge contained a single sourcetarget word pair (Gimpel and Smith 2009b) . Inference was approximated using cube decoding (Gimpel and Smith 2009a) , an algorithm that incorporates non-local features in a way similar to cube pruning (Chiang 2007) . After developing our QPD model, we moved to phrase lattices but still approximated inference using an agenda algorithm (Nederhof 2003; Eisner, Goldlust, and Smith 2005) with pre-pruning of dependency edges in a coarse pass (Gimpel and Smith 2011) . All decoders used lattice dependency parsing, but our current decoder uses an exact algorithm once two simple approximations are made: the pruning of the lattice and the use of maximum dependency length constraints. Hyperparameters control the severity of these two approximations and the use of an exact parsing algorithm allows us to measure their effects on runtime and accuracy. Experiments and Analysis We now present experimental results using our QPD model. Because our model extends phrase-based translation models with features on source-and target-side syntactic structures, we can conduct experiments that simulate phrase-based, string-to-tree, and tree-to-tree translation, merely by specifying which feature sets to include. This suggests an additional benefit of using a quasi-synchronous approach for machine translation. By using features rather than constraints, we can simulate a range of translation systems in a single framework, allowing clean experimental comparisons among modeling strategies and combining strengths of diverse approaches. We describe our experimental setup in Section 7.1 and present our main results in Section 7.2. We measure the impact of using unsupervised parsing in Section 7.2.1 and include feature ablation experiments in Section 7.2.2. We present the results of a manual evaluation in Section 7.3 and give examples. We conclude in Section 7.4 with a runtime analysis of our decoder and show the impact of decoding constraints on speed and translation quality. Experimental Setup In this section we describe details common to the experiments reported in this section. Details about decoding and learning were described in Section 6. Full details about language pairs, data sets, and baseline systems are given in Appendix A and Appendix B. We repeat important details here. We use case-insensitive IBM BLEU (Papineni et al. 2002) for evaluation. To measure significance, we use a paired bootstrap (Koehn 2004 ) with 100,000 samples (p \u2264 0.05). 7.1.1 Language Pairs. We consider German\u2192English (DE\u2192EN), Chinese\u2192English (ZH\u2192EN), Urdu\u2192English (UR\u2192EN), and English\u2192Malagasy (EN\u2192MG) translation. These four languages exhibit a range of syntactic divergence from English. They also vary in the availability of resources like parallel data, monolingual target-language data, and treebanks. It is standard practice to evaluate unsupervised parsers on languages that do actually have treebanks, which are used for evaluation. We consider this case as well, comparing supervised parsers for English and Chinese to our unsupervised parsers, but we also want to evaluate our ability to exploit unsupervised parsing for languages that have small or nonexistent treebanks, hence our inclusion of Urdu and Malagasy. 7.1.2 Baselines. We compare our model to several baselines: r Moses, RAMPION, S = 200: This is a standard Moses phrase-based system, trained with RAMPION. The Moses default stack size S of 200 was used during tuning and testing. This is the result one would obtain with an off-the-shelf Moses phrase-based system on these data sets (and trained using RAMPION). r Moses, RAMPION, S = 500: This baseline trains a model in the same way as the previous using S = 200, but then uses a larger stack size (S = 500) when decoding the test sets. This larger stack size was used for generating phrase lattices for lattice reranking, so it provides a more appropriate baseline for comparing to our model. r Moses, SSVM reranking: Using phrase lattices generated with the preceding configuration, this baseline uses the SSVM reranker from Section 6.4 on the phrase lattices with only the Moses phrase-based features, that is, without any QPD features. This baseline helps to separate out the gains achieved through SSVM reranking and the addition of QPD features. r Hiero, RAMPION: This is a standard hierarchical phrase-based system (Chiang 2007) , as implemented in the Moses toolkit and trained using RAMPION. We see the three Moses systems as our primary baselines because Moses was used to generate phrase lattices for our system. Our model adds new syntactic structures and features to Moses, but because our decoder use Moses' phrase lattices, our approach can be viewed as rescoring Moses' search space. There are pros and cons to this choice. It lets us build on a strong baseline rather than building a system from scratch. Also, by comparing the third baseline (\"Moses, SSVM reranking\") to our model, we are able to cleanly measure the contribution of our QPD features. However, Hiero has been shown to perform better than phrase-based systems for certain language pairs (Chiang 2007; Zollmann et al. 2008; Birch, Blunsom, and Osborne 2009) , and in these cases Hiero proves to be a strong baseline for our model to beat as well. We note that our QPD features could also be used to rescore Hiero's search space to potentially yield further improvements, but we leave this to future work. 7.1.3 Parsers. Our full QPD model requires parsers for both source and target languages. For each language pair, the target-language parser is only used to parse the target side of the parallel corpus and the source-language parser is only used to parse the source side of the tuning and test sets. We have access to supervised parsers for Chinese, German, and English, which we used for our experiments. In particular, we used the Stanford parser (Levy and Manning 2003; Rafferty and Manning 2008) for Chinese and German and TurboParser (Martins et al. 2010) for English (see Appendix A for details). The Stanford parser is fundamentally a phrase-structure parser and generates dependency trees via head rules, but we chose it for our experiments for its ease of use and compatibility with the tokenization we used, particularly the Chinese segmentation which we obtained from the Stanford Chinese segmenter. 15  For Urdu and Malagasy, we turn to unsupervised parsing. To measure the impact of using unsupervised parsers, we also performed experiments in which we replaced supervised parsers for Chinese and English with unsupervised counterparts. We now describe how we trained unsupervised parsers for these four languages. The most common approach to unsupervised parsing is to train models on sentences from treebanks (without using the annotated trees, of course) along with their gold standard POS tags. This practice must be changed if we wish to use unsupervised parsing for machine translation, because we do not have gold standard POS tags for our data. Fortunately, Smith (2006) and Spitkovsky et al. (2011) have shown that using automatic POS tags for dependency grammar induction can work as well as or better than gold standard POS tags. For syntax-based translation, Zollmann and Vogel (2011) showed that unsupervised tags could work as well as those from a supervised POS tagger. For Urdu and Malagasy, we use fully unsupervised POS tagging, using the approach from Berg-Kirkpatrick et al. ( 2010 ) with 40 tags. We use the \"direct gradient\" version optimized by L-BFGS (Liu and Nocedal 1989) . For Chinese and English, we use the gold standard POS tags from their respective treebanks for training the parser, then use the Stanford POS tagger (Toutanova et al. 2003) to tag the parallel data, tuning, and test sets. As our dependency parsing model, we use the dependency model with valence (Klein and Manning 2004) initialized with a convex initializer (Gimpel and Smith 2012a) . The training procedure is described in Gimpel (2012) . Our Chinese and English unsupervised parsers are roughly 30 percentage points worse than supervised parsers in dependency attachment accuracy on standard treebank test sets. We also compared the supervised and unsupervised parsers to a uniform-at-random parser. Well-known algorithms exist for sampling derivations under a context-free grammar for a sentence (Johnson, Griffiths, and Goldwater 2007) . These algorithms can be used to sample projective dependency trees by representing a projective dependency grammar using a context-free grammar (Smith 2006; Johnson 2007) . We used cdec (Dyer et al. 2010) to sample projective dependency trees uniformly at random for each sentence. 16  We only compared the random parser for source-side parsing. Swapping parsers for the target language requires parsing the target side of the parallel corpus, rerunning rule extraction and feature computation with the new parses, and finally re-tuning to learn new feature weights. By contrast, changing the source-side parser only requires re-parsing the source side of the tuning and test sets and re-tuning. Results We now present our main results, shown in Tables 6-9 . We see that enlarging the search space results in gains in BLEU, as Moses with stack size 500 typically outperforms Moses with stack size 200. For DE\u2192EN (Table 6 ), SSVM reranking improves performance even without adding any more features, pushing the numbers close to that of Hiero; and adding our QPD features does not provide any additional improvement. For the other language pairs, however, we do see significant gains over the Moses baselines. For ZH\u2192EN (Table 7 ), we see an average gain of 0.5 BLEU over the best Moses baseline when using target syntactic features (TGTTREE), and a total average gain of 0.7 BLEU with the full QPD model (TGTTREE + TREETOTREE). The QPD numbers still lag behind the Hiero results on average, but are statistically indistinguishable from Hiero on two of the three test sets. Our QPD features are able to mostly close the %BLEU on tune and test sets for DE\u2192EN translation, comparing the baselines to our QPD model with target syntactic features (TGTTREE) and then also with source syntax (+ TREETOTREE). Here, merely using the additional round of tuning with the SSVM reranker improves the BLEU score to 19.9, which is statistically indistinguishable from the two QPD feature sets. Differences between Hiero and the three 19.9 numbers are at the border of statistical significance; the first two are statistically indistinguishable from Hiero but the third is different at p = 0.04. performance gap between Moses and Hiero, suggesting that the Moses search space (and even our heavily pruned Moses phrase lattices) has the potential for significant improvements when using the right features. German\u2192English Results for UR\u2192EN translation are shown in Table 8 . Here we only have a supervised parser for English, so the TREETOTREE features are incorporated using our unsupervised Urdu parser. All QPD results are significantly better than all Moses baseline results, but there is no significant difference between the two QPD feature sets. This may be due to our use of unsupervised parsing; perhaps the Urdu parses are too noisy for us to see any benefit from the TREETOTREE features. In Section 7.2.1 we measure the impact of using unsupervised parsing for ZH\u2192EN translation. Hiero still significantly outperforms the QPD model, although we have halfway closed the gap between Moses and Hiero. For EN\u2192MG translation (Table 9 ), we see significant gains in BLEU over both Moses and Hiero when using the full QPD model. 17 We used unsupervised parsing to incorporate TGTTREE features but we only see a statistically significant improvement when we add TREETOTREE features, which use a supervised English parser. 7.2.1 Impact of Unsupervised Parsing. Table 10 shows results when comparing parsers for ZH\u2192EN translation. We pair supervised and unsupervised parsers for English and Chinese. The final row shows the Moses BLEU scores for comparison. When using supervised English parsing, we find that using our unsupervised Chinese parser in place of the Stanford parser leads to the same average test set BLEU score. When instead using random Chinese parses, we see a significant drop on two of the three test sets and an average decrease of 0.5 BLEU. When pairing unsupervised English parsing with supervised Chinese parsing, we see an average drop of just 0.2 BLEU compared to the fully supervised case. When both parsers are unsupervised, BLEU scores drop further but are still above the best Moses baseline on average. One idea that we have not explored is to parse our parallel corpus using each parser (unsupervised and supervised), then extract rules consistent with any of the parses. This might give us some of the benefits of forest-based rule extraction, which has frequently been shown to improve translation quality (Liu et al. 2007; Mi, Huang, and Liu 2008; Mi and Huang 2008) . Similarly, because we train systems for several language pairs, we could pool the rules extracted from all parallel corpora for computing targetsyntactic features. For example, adding the English phrase dependency rules from the DE\u2192EN corpus could improve performance of our ZH\u2192EN and UR\u2192EN systems. Moving beyond translation, we could use the pool of extracted rules from all systems (and using all parsers) to build monolingual phrase dependency parsers for use in other applications (Wu et al. 2009) . 7.2.2 Feature Ablation. We performed feature ablation experiments for UR\u2192EN translation, shown in Table 11 . Starting with TGTTREE features, which consist of word (WORD), cluster (CLUST), and configuration (CFG) feature sets, we alternately removed each of the three. We find only a small (and statistically insignificant) drop in BLEU when omitting word features, but a larger drop when omitting word cluster features. This may be due to the small size of our training data for UR\u2192EN (approximately 1 million words of parallel text). With limited training data, it is not surprising that unlexicalized features like the cluster and configuration features would show a stronger effect than the lexicalized features. Human Evaluation We focused on UR\u2192EN and ZH\u2192EN translation for our manual evaluation, as these language pairs showed the largest gains in BLEU when using our QPD model. We began by performing a human evaluation using Amazon Mechanical Turk (MTurk) in order to validate the BLEU differences against human preference judgments and to identify translations that were consistently judged better under each model for followup manual evaluation. 7.3.1 Procedure. We first removed sentences with unknown words, as we feared they would only confuse judges. 18 We then randomly selected 500 sentences from UR\u2192EN test 2 and 500 from the concatenation of ZH\u2192EN test 1 and test 2. For each of the 1,000 sentences, we chose a single reference translation from among the four references to show to judges. 19 All text was detokenized. Judges were shown the reference translation, the translation from the Moses system with SSVM reranking, and the translation from our QPD system with the full feature set. We randomized the order in which the two machine translations were presented. Judges were asked to select which translation was closer in meaning to the reference; alternatively, they could indicate that they were of the same quality. We obtained judgments like these from three judges for each of the 1,000 sentences. Results and Analysis. Table 12 shows the results of our MTurk experiments. If a sentence was judged to be translated better by one system more often than the other, it was counted as a victory for that system. The QPD translations for 40-43% of the sentences were preferred over Moses, but for 28-33% of the sentences, the reverse was true. We can use these judgments to study when and how our system improves over Moses, and also when Moses still performs better. For a follow-up manual evaluation, we looked at ZH\u2192EN sentences for which all three judges selected either Moses or the QPD model; these should be the clearest examples of success for each system. In Table 12 Results of human evaluation performed via Amazon Mechanical Turk. The percentages represent the portion of sentences for which one system had more preference judgments than the other system. If a sentence had an equal number of judgments for the two systems, it was counted in the final row (\"neither preferred\"). looking at these sentences, we attempted to categorize the primary reasons why all three judges would have preferred one system's output over the other. We began with two broad categories of improvement: word choice and word order. We divided word choice improvements into two subcategories: those involving verbs and those involving words other than verbs. The reason we made this distinction is because some differences in non-verb translation are not as crucial for understanding a sentence as differences in verb translation or word order. Anecdotally, we observed that when one sentence has a better verb translation and the other has a better preposition translation, judges tend to prefer the translation with the better verb. We noted some sentences that fit multiple categories, but in our analysis we chose a single category that we deemed to be the most important factor in the judges' decisions. Of the 26 sentences for which Moses output was preferred unanimously, we agreed with the consensus on 25 and found that 19 of these improved due to better word choice, most frequently (13 out of 19) for words other than verbs. Only 6 of the 25 were determined to be preferred due to word order. The top section of Table 13 shows representative examples when Moses' translations were unanimously preferred. Moses handles prepositions and other function words better than the QPD model in these examples. This may occur due to the reliance of phrase-based systems upon strong n-gram language models to ensure local fluency. The QPD model uses all of Moses' features, including the same n-gram language model, but it adds many other features that score longer-distance word order and may be overwhelming the n-gram model in certain cases. % of sentences For the 44 sentences for which QPD output was unanimously preferred, we agreed with the judges on 42. Of these, we found that 15 had improved word order, 14 had improvements in verb word choice, and 13 had improved word choice for non-verbs. So the QPD model's improvements were due to word order on 36% of unanimous sentences, compared with Moses' 24%, suggesting that the QPD model's strength is in improving word order. The lower section of Table 13 shows representative examples. Consider the final example in the table. The Moses translation has better local fluency, but mixes words across clauses, confusing the meaning. The QPD translation has two local disfluencies (\"because law-abiding citizen hopes to\" and \"don't need to fear will attack\"), but has no erroneous word reordering across clause boundaries. Decoding Speed So far we have reported BLEU scores for various feature sets and parsers, but we have not discussed decoding speed. BLEU improvements may not be worth substantial reductions in translation speed. In this section we report decoding speeds and BLEU scores for UR\u2192EN translation as pruning thresholds are varied. Our lattice dependency parsing decoding algorithm is exact, but two pruning stages precede lattice parsing, as discussed in Section 6.3: (1) pruning the phrase lattices based on the phrase-based model Table 13 Examples from manual evaluation of ZH\u2192EN output, selected from sentences with unanimous preference judgments for Moses (top) and our QPD model (bottom). R = reference; M = Moses, SSVM reranking; Q = QPD, TGTTREE + TREETOTREE. Moses preferred: R the purpose of cheney's trip is to win supports of middle east countries in case of a u.s. attack on iraq. M cheney's trip is to lobby the middle east countries to support the us attack on iraq. Q cheney's trip was to lobby the middle east countries support us attacks on iraq. R he said, \"after this conference, our position is clear to all.\" M he said: \"this time after the talks, our position is well known.\" Q he said: \"this round of talks, our position is well known.\" R ukraine condemned us for interfering its internal affairs. M ukraine condemned the united states for interfering in its internal affairs. Q ukraine condemned the united states of interfering in its internal affairs. R former serbian interior minister, vlajko stojiljkovic, attempts to commit suicide. M yugoslavia, a former serbian interior minister tried to commit suicide. Q interior minister tried to commit suicide before the serbian republic of yugoslavia. R arafat died in a french hospital of an unknown illness on november 11. M arafat died in a french hospital on nov. 11, due to an unidentified disease. Q arafat died on nov. 11 in a french hospital, an unidentified disease. QPD preferred: R bush: nato must forge a new relationship with russia M bush said that the establishment of a new type of relationship between russia and nato must Q bush says nato must build new relations with russia R that would portend increased flows of glacial ice from antarctica and a rise in global sea levels, endangering low-lying land areas. M this bodes well for the antarctica ice flow will increase, the global sea level will rise in the lowlands, will cause harm to the region. Q this indicates that the antarctica's ice flow will increase, global sea level will rise, and will cause harm to the lowlands region. R this is the first sandstorm in north korea since spring this year. M this is the first since the spring of this year the sandstorms. Q this is the first sandstorm of the korean experience since spring this year. R \"we really have to tackle the problem of street-crime. law-abiding citizens want to feel safe when they walk on the street. they want a peaceful life and untroubled by attack,\" he said. M he said: \"we really should rectify the order because of law-abiding citizens, in the hope of peace and security on the streets and on the living, not to be afraid of attacks.\" Q he said: \"we really should rectify the order in the streets, because law-abiding citizen hopes to secure a safe life on the streets, and don't need to fear will attack.\" scores, and (2) pruning the search space deterministically based on source-and targetside limits on dependency lengths. In this section, we measure the impact of the latter type of pruning only. 20  We vary maximum dependency lengths and we report BLEU scores and decoding speeds. We find that we can set these limits to be relatively strict and get similar BLEU scores in less time. In all previous experiments, we used a source-side limit \u03c9 x x x of 15 and a target-side limit \u03c9 y y y of 20. That is, all target-side phrase dependencies may cover a maximum of 20 words in the target sentence, and the number of words between the aligned source phrases can be at most 15. We often use a larger value of \u03c9 y y y because it is constraining an upper bound on the number of words crossed in the translation, whereas \u03c9 x x x constraints the exact number of source words crossed by a dependency (see Section 6.3.3 for details). For timing experiments, we ran a single decoding thread on a Sun Fire X2200 M2 x64 server with two 2.6-GHz dual-core CPUs. Decoding during tuning is time-consuming, because we generate unique 150-best lists for each iteration, so we only use two max dependency length settings for tuning. But given trained models, finding the 1-best output on the test data is much faster. So we experimented with more pruning settings for decoding. Table 14 shows our results. The upper table reminds us of the baseline BLEU scores. The lower table shows what happens when we train with two pruning settings: (\u03c9 x x x = 10, \u03c9 y y y = 15) and (\u03c9 x x x = 15, \u03c9 y y y = 20), and test with many others. The times reported only include the time required for running the Floyd-Warshall algorithm on the lattice and performing lattice dependency parsing. We use the Moses decoder for lattice generation; this typically takes only slightly longer than ordinary decoding, which is generally in the range of a couple seconds per sentence, depending on how the phrase table and language model are accessed. The average time required to run the Floyd-Warshall algorithm on the lattices is approximately 0.8 seconds per sentence, so it begins to dominate the total time as the pruning thresholds go below (5, 5). The earlier numbers in this section used (\u03c9 x x x = 15, \u03c9 y y y = 20) for both tuning and testing, which causes test-time decoding to take approximately 6 seconds per sentence, as shown in the table. We can see that we can use stricter constraints during testtime decoding only (e.g., (\u03c9 x x x = 5, \u03c9 y y y = 10)) and speed this up by a factor of 3 while only losing 0.1 BLEU. The only severe drops in BLEU appear when using thresholds below (5, 5). Conclusion and Future Work We presented a new approach to machine translation that combines phrases, dependency syntax, and quasi-synchronous tree-to-tree relationships. We introduced several categories of features for dependency-based translation, including string-to-tree and tree-to-tree features. We proposed lattice dependency parsing to solve the decoding problem and presented ways to speed up the search and prune the search space. We presented experimental results on seven test sets across four language pairs, finding statistically significant improvements over strong phrase-based baselines on five of the seven. Manual inspection reveals improvement in the translation of verbs, an important component in preserving the meaning of the source text. We showed that unsupervised in machine translation. Relatedly, DeNero and Uszkoreit (2011) tailored unsupervised learning of syntactic structure in parallel text to target reordering phenomena. In addition, we may not need full monolingual syntactic parses to obtain the benefits of syntax-based translation modeling. Indeed, the widely used hierarchical phrase-based model of Chiang (2005) induces a synchronous grammar from parallel text without any linguistic annotations. Zollmann and Vogel (2011) and Zollmann (2011) showed that using a supervised POS tagger to label these synchronous rules can improve performance up to the level of a model that uses a supervised full syntactic parser. They further showed that unsupervised POS taggers could be effectively used in place of supervised taggers. These results suggest that it may be fruitful to explore the use of simpler annotation tools such as POS taggers, whether supervised or unsupervised, in order to apply syntax-based translation to new language pairs. Appendix A. Language Pairs We consider four language pairs in this article, two for which large amounts of parallel data are available and two involving low-resource languages. The large-data language pairs we consider are Chinese\u2192English (ZH\u2192EN) and German\u2192English (DE\u2192EN). The two low-resource language pairs are Urdu\u2192English (UR\u2192EN) and English\u2192Malagasy (EN\u2192MG). For all language pairs, English text was parsed using TurboParser version 0.1 (Martins et al. 2010) . We used a second-order model with sibling and grandparent features that was trained to maximize conditional log-likelihood. The following sections describe the procedures used to prepare the data for each language pair. The line and token counts are summarized in Tables A.1-A.3. Chinese\u2192English. For ZH\u2192EN, we used 303k sentence pairs from the FBIS corpus (LDC2003E14). We segmented the Chinese data using the Stanford Chinese segmenter (Chang, Galley, and Manning 2008) in \"CTB\" mode, giving us 7.9M Chinese tokens and 9.4M English tokens. For tuning and testing, we used MT03 (\"tune\"), MT02 (\"test 1\"), MT05 (\"test 2\"), and MT06 (\"test 3\"). The Chinese text was parsed using the Stanford parser (Levy and Manning 2003). German\u2192English. We started with the Europarl corpus provided for the WMT12 shared task. We tokenized both sides, filtered sentences with more than 50 words, and downcased the text. We then discarded every other sentence, beginning with the second, leaving half of the corpus remaining. We did this to speed our experiment cycle. The corpus still has about 850k sentence pairs. We did the same processing with the news commentary corpus, but did not discard half of the sentences. There were about 150k news commentary sentences, giving us a total of about 1M lines of DE\u2192EN parallel training data. For tuning, we used the first 1,300 sentences from the 2008 2,051-sentence test set (\"tune\"). For testing, we used the 2009 test set (\"test 1\"). The tuning/test sets are from the newswire domain. The German text was parsed using the factored model in the Stanford parser (Rafferty and Manning 2008). Urdu\u2192English. For UR\u2192EN, we used parallel data from the NIST MT08 evaluation. Although there are 165,159 lines of parallel data, there are many dictionary and otherwise short entries, so it is close to an order of magnitude smaller than ZH\u2192EN. We used half of the documents (882 sentences) from the MT08 test set for tuning (\"tune\"). We used the remaining half for one test set (\"test 1\") and MT09 as a second test set (\"test 2\"). The Urdu text was parsed using an unsupervised dependency parser as described in Section 7.1.3. English\u2192Malagasy. For EN\u2192MG translation, we used data obtained from the Global Voices weblogging community (http://globalvoicesonline.org), prepared by Victor Chahuneau. 21 We used release 12.06 along with its recommended training, development (tuning), and test set. Like Urdu, the Malagasy text was parsed using an unsupervised dependency parser as described in Section 7.1.3. Translation Models. For phrase-based models, we used the Moses machine translation toolkit (Koehn et al. 2007 ). We mostly used default settings and features, including the default lexicalized reordering model. Word alignment was performed using GIZA++ (Och and Ney 2003) in both directions, the grow-diag-final-and heuristic was used to symmetrize the alignments, and a max phrase length of 7 was used for phrase extraction. The only exception to the defaults was setting the distortion limit to 10 in all experiments. Language Models. Language models were trained using the target side of the parallel corpus in each case augmented with 24,760,743 lines (601,052,087 tokens) of randomly selected sentences from the Gigaword v4 corpus (excluding the New York Times and Los Angeles Times). The minimum count cutoff for unigrams, bigrams, and trigrams was one and the cutoff for fourgrams and fivegrams was three. Language models were estimated using the SRI Language Modeling toolkit (Stolcke 2002) with modified Kneser-Ney smoothing (Chen and Goodman 1998) . Language model inference was performed using KenLM (Heafield 2011) within Moses. For EN\u2192MG, we estimated a 5-gram language model using only the target side of the parallel corpus, which contained 89,107 lines with 2,031,814 tokens. We did not use any additional Malagasy data for estimating the EN\u2192MG language models in order to explore a scenario in which target-language text is limited or expensive to obtain. Word Clustering. Brown clusters (Brown et al. 1992) were generated using code provided by Liang (2005) . For each language pair, 100 word clusters were generated for the target language. The implementation allows the use of a token count cutoff, which causes the algorithm to only cluster words appearing more times than the cutoff. When the clusters are used, all words with counts below the cutoff are assigned a special \"unknown word\" cluster. So in practice, if a clustering with 100 clusters is generated, there are 101 clusters used when the clusters are applied. For ZH\u2192EN, DE\u2192EN, and UR\u2192EN, the target side of the parallel data was used along with 412,000 lines of randomly selected Gigaword data comprising 10,001,839 words. This data was a subset of the Gigaword data used for language modeling. The count cutoff was 2. For EN\u2192MG, only the target side of the parallel corpus was used. The count cutoff was 1. In all cases, the data was tokenized and downcased prior to cluster generation.  ? x i x j x k ? x i x j x k ? x i x j x k y k' y i' y j' y k' y i' y j' y k' y i' y j' y l' y k' y i' y j' y l' y k' y i' y j' Figure 7 String-to-tree configurations; each is associated with a feature that counts its occurrences in a derivation. Appendix B. Experimental Details Appendix A contains details about the data sets used in our experiments. Other experimental details are given here.",
    "abstract": "Recent research has shown clear improvement in translation quality by exploiting linguistic syntax for either the source or target language. However, when using syntax for both languages (\"tree-to-tree\" translation), there is evidence that syntactic divergence can hamper the extraction of useful rules (Ding and Palmer 2005). Smith and Eisner ( 2006 ) introduced quasi-synchronous grammar, a formalism that treats non-isomorphic structure softly using features rather than hard constraints. Although a natural fit for translation modeling, its flexibility has proved challenging for building real-world systems. In this article, we present a tree-to-tree machine translation system inspired by quasi-synchronous grammar. The core of our approach is a new model that combines phrases and dependency syntax, integrating the advantages of phrase-based and syntax-based translation. We report statistically significant improvements over a phrasebased baseline on five of seven test sets across four language pairs. We also present encouraging preliminary results on the use of unsupervised dependency parsing for syntax-based machine translation.",
    "countries": [
        "United States"
    ],
    "languages": [
        "English",
        "German"
    ],
    "numcitedby": "13",
    "year": "2014",
    "month": "June",
    "title": "Phrase Dependency Machine Translation with Quasi-Synchronous Tree-to-Tree Features"
}