{
    "article": "Ubuntu's Internet Relay Chat technical support channel has bots that output specific messages in response to command words from other channel users. These messages can be used to answer frequently-asked questions instead of requiring an expert to (repeatedly) type a lengthy reply. We describe an approach to automatically distinguish bot-answerable questions, which would mitigate this problem. To the best of our knowledge, this is the first work on investigating question answering in a multiparticipant chat domain. Our results indicate that for some types of questions, supervised learning algorithms perform well on this task and, in addition, that character n-grams are a better representation than traditional bag-of-words for this task and domain. Introduction Ubuntu (a Linux-based operating system) maintains multiple Internet Relay Chat (IRC) channels for technical support. Some of these channels contain bots, which are automated agents pre-programmed to perform certain tasks. One of the bots can output pre-written messages, called factoids, in response to command words. For example, if a user types \"!flash\", then the bot would output \"To install Flash see https://help.ubuntu....mats/Flash -See also !Restricted and !Gnash\". These factoids are used to answer common questions, enforce channel guidelines, direct non-English speakers (in their native tongue) to Ubuntu's foreign language support channels, and query Ubuntu's repository of packages. While useful, this bot must be manually invoked. Automating the bot to self-detect and answer questions that it can answer could reduce the workload for knowledgeable experts trying to help other users. This is applicable to not only Ubuntu's technical support channels, but to other IRC channels providing technical support (e.g., Debian's support channels) and to channels that use similar bots (e.g., Eggdrop and Infobot) for other purposes. We describe initial steps on a self-invoking bot. We begin by investigating the multi-classification task of which questions are bot-answerable questions (BAQ) and which are human-answerable questions (HAQ), which requires a human to answer due to the question's complexity. We implemented a baseline non-learning approach and supervised support vector machines (SVM) and knearest neighbor (k-NN) algorithms. Our results show that a bot can answer with confidence some types of questions, especially those directing users to more appropriate channels for help on certain topics. Our contributions are as follows: \u2022 Problem: We identified a real-world problem that has not been investigated, despite bots having been around for years on IRC channels. \u2022 Data: We created an annotated multiparticipant chat corpus that is publicly available. \u2022 Empirical study: We report on our investigation of applying supervised learning algorithms and leveraging different feature representations, whose results will be used as a foundation for a larger case-based reasoning approach. \u2022 Discussion: We describe how some types of automatically-answerable questions can be easy or difficult to classify. Related Work Chat is a difficult medium to analyze: its characteristics make it difficult to apply traditional natural language processing techniques. It has uncommon features such as frequent use of abbreviations, acronyms, missing subject pronouns, emoticons, abbreviated nicknames, words stripped of vowels to reduce number of keystrokes, and entangled conversation threads (Uthus and Aha, 2013a). In the multiparticipant chat domain, there has been some work in creating a bot that can answer questions with Cobot (Isbell et al., 2006) . This bot was limited in capability -it could only respond to questions directed at it. Another recent work resulted in a bot which could respond to utterances through word matching and used templates for output (Shaikh et al., 2010) . Also related in this domain are a few military research efforts that have focused on classifying chat messages. One examined profile-driven information extraction from chat using regular expressions and entity classes (Berube et al., 2007) . Another examined identifying uncertainty and urgency within a chat message using rule-based approaches and statistical analysis (Budlong et al., 2009) . A third, whose work is most similar to ours, compared several supervised algorithms for classifying chat utterances (Dela Rosa and Ellen, 2009) . Using an artificial chat log, they classified messages as either non-important filler messages or as messages containing Navy ship updates. Their results showed k-NN and SVM performed best for this task. Our task differs from these previous investigations in that we are applying supervised learning algorithms to a multi-labeled corpus composed of real chat messages. This problem is also related to the larger field of question answering, such as pertaining to discussion boards (Hong and Davison, 2009; Kim et al., 2007) , frequently asked question files (Burke et al., 1997) , and community-based question answering (Zhou et al., 2012) . An important difference between this body of related work and what we are investigating is the medium. Multiparticipant chat is more difficult to work with compared to other mediums due to entangled conversation threads -a researcher cannot easily automatically analyze the messages of a single conversation. In prior work, researchers could usually isolate individual conversations automatically, making it possible to identify (to some extent) the question and the answer. Another important difference is the temporal scale -chat is in real-time, and a chat user expects to receive an answer quickly. A chat user can only see messages while they are logged in (in the case where there is no archive being stored offline). Both of these differences results in new challenges not seen in other mediums for question answering. Ubuntu's IRC Channels The IRC channel #ubuntu is Ubuntu's primary technical support channel. It provides support for those who have problems using Ubuntu; it is not used for socializing or for receiving help with other Linux distributions (e.g., Debian, Linux Mint, Fedora) or software. The channel's traffic level varies throughout the year and day (see Figure 1 ). During the year, it experiences heavy traffic during Ubuntu's semiannual new releases in April and October and generally experiences heavy traffic during the North American and European evening hours. Heavy traffic creates difficulties for users trying to get answers to their questions. ubottu 1 is the bot that can access 1234 factoids, corresponding to 2324 commands (some factoids are mapped to multiple commands). It can also provide information about any software package found in Ubuntu's software repository. A channel user (oftentimes an expert) can task ubottu to answer another user's question (see [13:19] Figure 2 ). Automating ubottu would allow experts to focus their valuable time on responding to more challenging requests. Corpus We created an annotated corpus by pulling questions from the Ubuntu Chat Corpus, specifically from the #ubuntu channel logs (Uthus and Aha, 2013b). This corpus has 4577 messages, including 2002 HAQs and 2575 BAQs from 68 factoid categories. These messages were taken from chat logs from 28 April 2011 (the day Ubuntu 11.04 was released) to 13 October 2011 (the day before Ubuntu 11.10 was released). We looked for messages in which a question is answered with a factoid, or a question required a human to answer. To judge between these two types, we relied on the expertise of users and how they answered the questions. To reduce noise, we limited HAQs to conversations in which the first reply came from a user who invoked ubottu frequently (i.e., experts). These ubottu invokers are considered a better judge of what is a BAQ or HAQ compared to someone who rarely invokes ubottu to answer questions. For the BAQs, we restricted questions to those with at least ten examples mapped to a factoid. Figure 3 shows the distribution of BAQs to factoids in our corpus. Some of the corpus' messages are not in English. In such cases, users will be directed to one of Ubuntu's foreign-language support channels (though a user can re-ask their question in English). Some languages present in the corpus include Spanish, French, Chinese, Russian, German, Polish, and Portuguese. Additionally, some of these messages are written with non-Latin characters, such as Chinese and Russian. Approach We are using k-NN and SVM algorithms for classifying messages. This builds on results by Dela Rosa and Ellen (2009) , who had found these two supervised learning algorithms to work best on chat messages. Implementation of these algorithms were obtained from Scikit-learn (Pedregosa et al., 2011) . For preprocessing, text was normalized by lowering the case for each term. We examined different representations for encoding the questions. These include bag-of-words, bigrams, and character n-grams. With the character n-grams, we examined n-grams which overlap words and n-grams which are restricted to within word boundaries. We used tf \u2212 idf to weigh the features and \u03c7 2 for feature selection. Empirical Study We have two hypothesis we are testing: H1: Supervised learning algorithms will outperform a non-learning baseline approach for classifying BAQs. H2: Using character n-grams for this domain will allow for better precision and recall when compared to more traditional representations of bag-of-words and bigrams. Our intuition for H2 is that we believe that character n-grams will allow for better representation of misspelled words commonly seen in chat messages when compared to bag-of-words and bigrams. Baseline Our non-learning baseline algorithm maps questions to factoids by checking if the question contains the factoid command as a word token. As a reminder, multiple factoids can map to the same response. If a question contains multiple factoids, then the most frequently invoked factoid is applied (ties are broken by alphabetical ordering question contains no factoids, then it is considered a HAQ. Metrics We used a 10-fold cross evaluation protocol and precision, recall, and the F 0.5 score as our evaluation metrics. For this work, we consider precision to be more important than recall because a bot that frequently answers questions incorrectly could anger chat users and cause them to ignore the bots. Therefore, F 0.5 is more appropriate here than the standard F score because it places more emphasis on precision. Additionally, as these are multi-classification problems, we used the macro version of these metrics to average over the different labels. When calculating precision, recall, and F 0.5 , we omit the HAQ scores when calculating the macro scores for this multi-classification problem. We also omitted any questions that are incorrectly labeled as HAQ for calculating precision and recall scores because a HAQ can be answered by a human expert. Essentially, we do not penalize for erring on the side of caution. Results Table 1 summarizes the results of the application of our baseline and learning algorithms. We ap-plied all variations of the two learning algorithms, testing on all combinations of representations and \u03c7 2 feature size limits. For the feature size limits, we tried values between [400:4000] in steps of 400. The results display the best configuration for each representation. As shown, the learning algorithms outperformed the baseline for all three metrics, supporting hypothesis H1. This shows that some questions cannot be easily distinguished by simply looking for factoid commands within the questions. In regards to the second hypothesis, both learning algorithms performed best when using character n-grams, especially when restricted by word boundaries, thus supporting H2. We believe this is due to the character n-grams being able to better handle noisy nature of chat, especially with the misspellings and abbreviations. We next examine what type of questions do these learning algorithms perform well on, especially when compared to our baseline. For this, we focus on the results of applying SVMs. Figure 4 compares the difference of F 0.5 scores between SVM and the baseline. For most factoids, SVMs performed better or had similar performance to the baseline. The small number of factoids it performed worse on were generally factoids both SVM and the baseline performed poorly, finding low F 0.5 scores. Figure 5 shows the F 0.5 scores achieved by SVM for each individual factoid category. These are ordered by their distribution in the corpus (see Figure 3 ). One fact shown by this figure is that there is not a strong correlation between the distribution size and the result achieved by the SVM. While having more examples within a category does help, there are plenty of factoids where SVM performed poorly. This shows that it is the difficulty of the questions themselves, and not the amount of examples, which causes difficulty for the SVMs, let alone learning algorithms for this domain. One set of questions SVMs performs well on are questions where users are subsequently directed to another channel. This includes Ubuntu's non-English channels and channels that provide support for other Linux distributions. SVMs did well on all the non-English factoids, with F 0.5 scores ranging between 0.88 (for Chinese) and 0.99 (for Russian). This is probably due to these questions having uncommon features, such as non-English words or software that is not supposed to be discussed in #ubuntu. One similar pair of questions, which are addressed by two factoids, caused some confusion for the learners -asking for permission to ask a question (e.g., \"Can I ask a question?\") or asking if anyone can help without stating their problem (e.g., \"Can anyone help me?\"). This commonly happens with first time visitors to the channel, as they do not know the channel guidelines and will then ask for permission to ask a question or if someone could help them. The channel operators try to encourage users to just ask their question -this happens frequently enough that there are two factoids (labels ask and anyone in the corpus) to answer these similar questions. Unfortunately, there is a lack of consistency in invoking these two factoids, and as such the learning algorithms we tested had difficulty with these questions. Some other types of questions that SVMs struggle with are those that cover a wide-range of possible questions. For example, #ubuntu can be used either in cases to explain what the channel topic is (for those asking), or to get users on topic (with the possible off-topic message types being wideranging); details, which can be used whenever someone asks a question or for help without providing enough details for anyone to begin to help; and wine to help users with problems running any type of Windows program under Linux. These types of questions may require a human to aid in answering, as it would be difficult to learn all possible types of questions that are covered by these factoids. Conclusions We have investigated applying supervised learning algorithms to classify questions as HAQ or BAQ, and our results show that these algorithms can outperform a non-learning baseline approach. We also show that character n-grams are a better representation than traditional bag-of-words for our task. More importantly, the learning algorithms can answer some types of questions well, indicating that a self-invoking bot can be created that can answer common questions with confidence. Future work to extend this is to apply unsupervised methods for finding additional questions to match with the factoids. This would greatly extend what we have presented, as we were restricted to the manually-labeled messages to match questions with answers. We plan on applying a case-based reasoning framework (Richter and Weber, 2013) to achieve such a goal. A final area to investigate is an extension of ubottu that can learn to update its knowledge. Currently, only a few users are allowed to edit or add new factoids to ubottu. It would be advantageous if it could add new commands and factoids itself by summarizing common answers, or update outdated factoids should it see a common pattern of answers conflicting with its knowledge. Acknowledgments Thanks to NRL for funding this research. David Uthus performed this work while an NRC postdoctoral fellow located at the Naval Research Laboratory. The views and opinions contained in this paper are those of the authors and should not be interpreted as representing the official views or policies, either expressed or implied, of NRL or the DoD.",
    "funding": {
        "defense": 1.0,
        "corporate": 0.0,
        "research agency": 4.320199066265573e-07,
        "foundation": 0.0,
        "none": 0.0
    },
    "reasoning": "Reasoning: The acknowledgments section thanks NRL for funding this research. NRL (Naval Research Laboratory) is a part of the United States Department of the Navy, which is a branch of the country's armed forces. Therefore, the research was funded by a defense source. There is no mention of funding from corporate entities, research agencies, foundations, or an indication that there were no other funding sources.",
    "abstract": "Ubuntu's Internet Relay Chat technical support channel has bots that output specific messages in response to command words from other channel users. These messages can be used to answer frequently-asked questions instead of requiring an expert to (repeatedly) type a lengthy reply. We describe an approach to automatically distinguish bot-answerable questions, which would mitigate this problem. To the best of our knowledge, this is the first work on investigating question answering in a multiparticipant chat domain. Our results indicate that for some types of questions, supervised learning algorithms perform well on this task and, in addition, that character n-grams are a better representation than traditional bag-of-words for this task and domain.",
    "countries": [
        "United States"
    ],
    "languages": [
        "Russian",
        "Chinese"
    ],
    "numcitedby": 4,
    "year": 2013,
    "month": "October",
    "title": "Detecting Bot-Answerable Questions in {U}buntu Chat"
}