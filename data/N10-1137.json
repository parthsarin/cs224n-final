{
    "article": "Datasets annotated with semantic roles are an important prerequisite to developing highperformance role labeling systems. Unfortunately, the reliance on manual annotations, which are both difficult and highly expensive to produce, presents a major obstacle to the widespread application of these systems across different languages and text genres. In this paper we describe a method for inducing the semantic roles of verbal arguments directly from unannotated text. We formulate the role induction problem as one of detecting alternations and finding a canonical syntactic form for them. Both steps are implemented in a novel probabilistic model, a latent-variable variant of the logistic classifier. Our method increases the purity of the induced role clusters by a wide margin over a strong baseline. Introduction Semantic role labeling (SRL, Gildea and Jurafsky 2002) is the task of automatically classifying the arguments of a predicate with roles such as Agent, Patient or Location. These labels capture aspects of the semantics of the relationship between the predicate and the argument while abstracting over surface syntactic configurations. SRL has received much attention in recent years (Surdeanu et al., 2008; M\u00e0rquez et al., 2008) , partly because of its potential to improve applications that require broad coverage semantic processing. Examples include information extraction (Surdeanu et al., 2003) , question answering (Shen and Lapata, 2007) , summarization (Melli et al., 2005) , and machine translation (Wu and Fung, 2009) . Given sentences (1-a) and (1-b) as input, an SRL system would have to identify the verb predicate (shown in boldface), its arguments (Michael and sandwich) and label them with semantic roles (Agent and Patient). Here, sentence (1-b) is an alternation of (1-a). The verbal arguments bear the same semantic role, even though they appear in different syntactic positions: sandwich is the object of eat in sentence (1-a) and its subject in (1-b) but it is in both instances assigned the role Patient. The example illustrates the passive alternation. The latter is merely one type of alternation, many others exist (Levin, 1993) , and their computational treatment is one of the main challenges faced by semantic role labelers. Most SRL systems to date conceptualize semantic role labeling as a supervised learning problem and rely on role-annotated data for model training. Prop-Bank (Palmer et al., 2005) has been widely used for the development of semantic role labelers as well as FrameNet (Fillmore et al., 2003) . Under the Prop-Bank annotation framework (which we will assume throughout this paper) each predicate is associated with a set of core roles (named A0, A1, A2, and so on) whose interpretations are specific to that predicate 1 and a set of adjunct roles (e.g., Location or Time) whose interpretation is common across predicates. In addition to large amounts of role-annotated data, SRL systems often make use of a parser to obtain syntactic analyses which subsequently serve as input to a pipeline of components concerned with identifying predicates and their arguments (argument identification) and labeling them with semantic roles (argument classification). Supervised SRL methods deliver reasonably good performance (a system will recall around 81% of the arguments correctly and 95% of those will be assigned a correct semantic role; see M\u00e0rquez et al. 2008 for details) . Unfortunately, the reliance on labeled training data, which is both difficult and highly expensive to produce, presents a major obstacle to the widespread application of semantic role labeling across different languages and text genres. And although corpora with semantic role annotations exist nowadays in other languages (e.g., German, Spanish, Catalan, Chinese, Korean), they tend to be smaller than their English equivalents and of limited value for modeling purposes. Moreover, the performance of supervised systems degrades considerably (by 10%) on out-of-domain data even within English, a language for which two major annotated corpora are available. Interestingly, Pradhan et al. (2008) find that the main reason for this are errors in the assignment of semantic roles, rather than the identification of argument boundaries. Therefore, a mechanism for inducing the semantic roles observed in the data without additional manual effort would enhance the robustness of existing SRL systems and enable their portability to languages for which annotations are unavailable or sparse. In this paper we describe an unsupervised approach to argument classification or role induction 2 that does not make use of role-annotated data. Role induction can be naturally formalized as a clustering problem where argument instances are assigned to clusters. Ideally, each cluster should contain arguments corresponding to a specific semantic role and each role should correspond to exactly one cluster. A key insight in our approach is that many predicates are associated with a standard linking. A linking is a deterministic mapping from semantic roles onto syntactic functions such as subject, or object. Most predicates will exhibit a standard linking, i.e., they will be predominantly used with a specific mapping. Alternations occur when a different linking is used. In sentence (1-a) the predicate eat is used with its standard linking (the Agent role is mapped onto the subject function and the Patient onto the object), whereas in sentence (1-b) eat is used with its passive-linking (the Patient is mapped onto subject and the Agent appears as a prepositional phrase). When faced with such alternations, we will attempt to determine for each argument the syntactic function it would have had, had the standard linking been used. We will refer to this function as the arguments' canonical function, and use the term canonicalization to describe the process of inferring these canonical functions in the case of alternations. So, in sentence (1-b) the canonical functions of the arguments by Michael and sandwich are subject and object, respectively. Since linkings are injective, i.e., no two semantic roles are mapped onto the same syntactic function, the canonical function of an argument uniquely references a specific semantic role. We define a probabilistic model for detecting non-standard linkings and for canonicalization. The model specifies a distribution p(F) over the possible canonical functions F of an argument. We present an extension of the logistic classifier with the addition of latent variables which crucially allow to learn generalizations over varying syntactic configurations. Rather than using manually labeled data, we train our model on observed syntactic functions which can be obtained automatically from a parser. These training instances are admittedly noisy but readily available and as we show experimentally a useful data source for inducing semantic roles. Application of the model to a benchmark dataset yields improvements over a strong baseline. Related Work Much previous work on SRL relies on supervised learning methods for both argument identification and argument classification (see M\u00e0rquez et al. 2008 for an overview). Most systems use manually annotated resources to train separate classifiers for different SRL subtasks (e.g., Surdeanu et al. 2008) . A few approaches adopt semi-supervised learning methods. The idea here is to to alleviate the data requirements for semantic role labeling by extending existing resources through the use of unlabeled data. Swier and Stevenson (2004) induce role labels with a bootstrapping scheme in which the set of labeled instances is iteratively expanded using a classifier trained on previously labeled instances. Pad\u00f3 and Lapata (2009) project role-semantic annotations from an annotated corpus in one language onto an unannotated corpus in another language. And F\u00fcrstenau and Lapata (2009) propose a method in which annotations are projected from a source corpus onto a target corpus, however within the same language. Unsupervised approaches to SRL have been few and far between. Early work on lexicon acquisition focuses on identifying verbal alternations rather than their linkings. This is often done in conjunction with hand-crafted resources such as a taxonomy of possible alternations (McCarthy and Korhonen, 1998) or WordNet (McCarthy, 2002) . Lapata (1999) proposes a corpus-based method that is less reliant on taxonomic resources, however focuses only on two specific verb alternations. Other work attempts to cluster verbs into semantic classes (e.g., Levin 1993) on the basis of their alternation behavior (Schulte im Walde and Brew, 2002) . More recently, Abend et al. (2009) propose an unsupervised algorithm for argument identification that relies only on part-of-speech annotations, whereas Grenager and Manning (2006) focus on role induction which they formalize as probabilistic inference in a Bayesian network. Their model defines a joint probability distribution over the particular linking used together with a verb instance and for each verbal argument, its lemma, syntactic function as well as semantic role. Parameters in this model are estimated using the EM algorithm as the training instances include latent variables, namely the semantic roles and linkings. To make inference tractable they limit the set of linkings to a small number and do not distinguish between different types of adjuncts. Our own work also focuses on inducing the semantic roles and the linkings used by each verb. Our approach is conceptually simpler and computationally more tractable. Our model is a straightforward extension of the logistic classifier with latent variables applied to all roles not just coarse ones. Problem Formulation We treat role induction as a clustering problem. The goal is to assign argument instances (i.e., specific arguments, occurring in an input sentence) into clusters such that each cluster contains instances with the same semantic role, and each semantic role is found in exactly one cluster. As we assume PropBank-style roles (Palmer et al., 2005) , our model will allocate a separate set of clusters for each predicate and assign the arguments of a specific predicate to one of the clusters associated with it. As mentioned earlier (Section 1) a linking is a de-  terministic mapping from semantic roles onto syntactic functions. Table 1 shows how frequently individual semantic roles map onto certain syntactic functions. The frequencies were obtained from the CoNLL 2008 dataset (see Surdeanu et al. 2008 for details) and constitute an aggregate across predicates. As can be seen, there is a clear tendency for a semantic role to be mapped onto a single syntactic function. This is true across predicates and even more so for individual predicates. For example, A0 is commonly mapped onto subject (SBJ), whereas A1 is often realized as object (OBJ). There are two reasons for this. Firstly, a predicate is often associated with a standard linking which is most frequently used. Secondly, the alternate linkings of a given predicate often differ from the standard linking only with respect to a few roles. Importantly, we do not assume that a single standard linking is valid for all predicates. Rather, each predicate has its own standard linking. For example, in the standard linking for the predicate fall, A1 is mapped onto subject position, whereas in the standarad linking for eat, A1 is mapped onto object position. When an argument is attested with a non-standard linking, we wish to determine the syntactic function it would have had if the standard linking had been used. This canonical function of the argument uniquely references a specific semantic role, i.e., the semantic role that is mapped onto the function under the standard linking. We can now specify an indirect method for partitioning argument instances into clusters: 1. Detect arguments that are linked in a nonstandard way (detection). 2. Determine the canonical function of these arguments (canonicalization). For arguments with standard linkings, their syntactic function corresponds directly to the canonical function. 3. Assign arguments to a cluster according to their canonical function. We distinguish between detecting non-standard linkings and canonicalization because in principle two separate models could be used. In our probabilistic formulation, both detection and canonicalization rely on an estimate of the probability distribution p(F) over the canonical function F of an argument. When the most likely canonical function differs from the observed syntactic function this indicates that a non-standard linking has been used (detection). This most likely canonical function can be taken as the canonical function of the argument (canonicalization). Arguments are assigned to clusters based on their inferred canonical function. Since we assume predicate-specific roles, we induce a separate cluster for each predicate. Given K clusters, we use the following scheme for determining the mapping from functions to clusters: 1. Order the functions by occurrence frequency. 2. For each of the K \u2212 1 most frequent functions allocate a separate cluster. 3. Assign all remaining functions to the K-th cluster. Model The detection of non-standard linkings and canonicalization both rely on a probabilistic model p(F) which specifies the distribution over the canonical functions F of an argument. As is the case with most SRL approaches, we assume to be given a syntactic parse of the sentence from which we can extract labeled dependencies, corresponding to the syntactic functions of arguments. To train the model we exploit the fact that most observed syntactic functions will correspond to canonical functions. This enables us to use the parser's output for training even though it does not contain semantic role annotations. Critically, the features used to determine the canonical function must be restricted so that they give no cues about possible alternations. If they would, the model could learn to predict alternations, and therefore produce output closer to the observed syntactic rather than canonical function of an argument. To avoid this pitfall we only use features at or below the node representing the argument head in the parse tree apart from the predicate lemma (see Section 5 for details). Given these local argument features, a simple solution would be to use a standard classifier such as the logistic classifier (Berger et al., 1996) to learn the canonical function of arguments. However, this is problematic, because in our setting the training and application of the classifier happen on the same dataset. The model will over-adapt to the observed targets (i.e., the syntactic functions) and fail to learn appropriate canonical functions. Lexical sparsity is a contributing factor: the parameters associated with sparse lexical features will be unavoidably adjusted so that they are highly indicative of the syntactic function they occur with. One way to improve generalization is to incorporate a layer of latent variables into the logistic classifier, which mediates between inputs (features defined over parse trees) and target (the canonical function). As a result, inputs and target are no longer directly connected and the information conveyed by the features about the target must be transferred via the latent layer. The model is shown in plate notation in Figure 1a . Here, X i represents the observed input features, Y the observed target, and Z j the latent variables. The number of latent variables influences the generalization properties of the model. With too few latent variables too little information will be transferred via the latent variables, whereas with too many latent variables generalization will degrade. The model defines a probability distribution over the target variable Y and the latent variables Z, con- Y Z j M X i N Y Z 1 Z 2 X 2 X 1 X 3 (a) (b) Figure 1 : The logistic classifier with latent variables (shaded nodes) illustrated as a graphical model using (a) plate notation and (b) in unrolled form for M = 2 and N = 3. ditional on the input variables X: p(y, z|x, \u03b8) = 1 P(x, \u03b8) exp \u2211 k \u03b8 k \u03c6 k (x, y, z) (1) We will assume that the latent variables Z i are binary. Each of the feature functions \u03c6 k is associated with a parameter \u03b8 k . The partition function normalizes the distribution: P(x, \u03b8) = \u2211 y \u2211 z exp \u2211 k \u03b8 k \u03c6 k (x, y, z) (2) Note that this model is a special case of a conditional random field with latent variables (Sutton and Mc-Callum, 2007) and resembles a neural network with one hidden layer (Bishop, 2006) . Let (c, d) denote a training set of inputs and corresponding targets. The maximum-likelihood parameters can then be obtained by finding the \u03b8 maximizing: l(\u03b8) = log p(d|c) = \u2211 i log \u2211 z p(d i , z|c i ) = \u2211 i log \u2211 z exp(\u2211 k \u03b8 k \u03c6 k (c i ,d i ,z)) P(c i ,\u03b8) (3) And the gradient is given by: (\u2207l) k = \u2202 \u2202\u03b8 k l(\u03b8) = \u2211 i \u2211 z p(z|d i , c i )\u03c6 k (c i , d i , z) \u2212 \u2211 i \u2211 y,z p(y, z|c i )\u03c6 k (c i , y, z) (4) where the first term is the conditional expected feature count and the second term is the expected feature count. Thus far, we have written the equations in a generic form for arbitrary conditional random fields with latent variables (Sutton and McCallum, 2007) . In our model we have two types of pairwise sufficient statistics: \u03b2(x, z) : R \u00d7 {0, 1} \u2192 R, between a single input variable and a single latent variable, and \u03b3(y, z) : Y \u00d7 {0, 1} \u2192 R, between the target and a latent variable. Then, we can more specifically write the gradient component of a parameter associated with a sufficient statistic \u03b2(x j , z k ) as: \u2211 i \u2211 z k p(z k |d i , c i )\u03b2(c i, j , z k )\u2212 \u2211 i \u2211 z k p(z k |c i )\u03b2(c i, j , z k ) (5) And the gradient component of a parameter associated with a sufficient statistic \u03b3(y, z k ) is: \u2211 i \u2211 z k p(z k |d i , c i )\u03b3(d i , z k )\u2212 \u2211 i \u2211 y,z k p(y, z k |c i )\u03b3(y, z k ) (6) To obtain maximum-a-posteriori parameter estimates we regularize the equations. Like for the standard logistic classifier this results in an additional term of the target function and each component of the gradient (see Sutton and McCallum 2007) . Computing the gradient requires computation of the marginals which can be performed efficiently using belief propagation (Yedidia et al., 2003) . Note that due to the fact, that there are no edges between the latent variables, the inference graph is tree structured and therefore inference yields exact results. We use a stochastic gradient optimization method (Bottou, 2004) to optimize the target. Optimization is likely to result in a local maximum, as the likelihood function is not convex due to the latent variables. Experimental Design In this section we discuss the experimental design for assessing the performance of the model described above. We give details on the dataset, features and evaluation measures employed and present the baseline methods used for comparison with our model. Data Our experiments were carried out on the CoNLL 2008 (Surdeanu et al., 2008) training dataset which contains both verbal and nominal predicates. However, we focused solely on verbal predicates, following most previous work on semantic role labeling (M\u00e0rquez et al., 2008) . The CoNLL dataset is taken form the Wall Street Journal portion of the Penn Treebank corpus (Marcus et al., 1993) . Role semantic annotations are based on PropBank and have been converted from a constituent-based to a dependency-based representation (see Surdeanu et al. 2008) . For each argument of a predicate only the head word is annotated with the corresponding semantic role, rather than the whole constituent. In this paper we are only concerned with role induction, not argument identification. Therefore, we identify the arguments of each predicate by consulting the gold standard. The CoNLL dataset also supplies an automatic dependency parse of each input sentence obtained from the MaltParser (Nivre et al., 2007) . The target and features used in our model are extracted from these parses. Syntactic functions occurring more than 1, 000 times in the gold standard are shown in Table 1 (for more details we refer the interested reader to Surdeanu et al. 2008) . Syntactic functions were further modified to include prepositions if specified, resulting in a set of functions with which arguments can be distinguished more precisely. This was often the case with functions such as ADV, TMP, LOC, etc. Also, instead of using the preposition itself as the argument head, we used the actual content word modifying the preposition. We made no attempt to treat split arguments, namely instances where the semantic argument of a predicate has several syntactic heads. These are infrequent in the dataset, they make up for less than 1% of all arguments. Model Setup The specific instantiation of the model used in our experiments has 10 latent variables. With 10 binary latent variables we can en-code 1024 different target values, which seems reasonable for our set of syntactic functions which comprises around 350 elements. Features representing argument instances were extracted from dependency parses like the one shown in Figure 2 . We used a relatively small feature set consisting of: the predicate lemma, the argument lemma, the argument part-of-speech, the preposition involved in dependency between predicate and argument (if there is one), the lemma of left-most/rightmost child of the argument, the part-of-speech of left-most/right-most child of argument, and a key formed by concatenating all syntactic functions of the argument's children. The features for the argument maker in Figure 2 are [sell, maker, NN, -, the, auto, DT, NN, NMOD+NMOD]. The target for this instance (and observed syntactic function) is SBJ. Evaluation Evaluating the output of our model is no different from other clustering problems. We can therefore use well-known measures from the clustering literature to assess the quality of our role induction method. We first created a set of gold-standard role labeled argument instances which were obtained from the training partition of the CoNLL 2008 dataset (corresponding to sections 02-21 of PropBank). We used 10 clusters for each predicate and restricted the set of predicates to those attested with more than 20 instances. This rules out simple cases with only few instances relative to the number of clusters, which trivially yield high scores. We compared the output of our method against the gold-standard using the following common measures. Let K denote the number of clusters, c i the set of instances in the i-th cluster and g j the set of instances having the j-th gold standard semantic role label. Cluster purity (PU) is defined as: PU = 1 K \u2211 i max j |c i \u2229 g j | (7) We also used cluster accuracy (CA, Equation 8 ), UpperBndG 98.8 99.4 99.9 99.9 99.7 99.9 100 100 99.8 100 Table 2 : Clustering results using our model (LogLV) against the baseline (SyntFunc) and upper bounds (UpperBndS and UpperBndG). cluster precision (CP, Equation 9 ), and cluster recall (CR, Equation 9 ). Cluster F1 (CF1) is the harmonic mean of precision and recall. Baselines and Upper Bound We compared our model against a baseline that assigns arguments to clusters based on their syntactic function. Here, no attempt is made to correct the roles of arguments in non-standard linkings. We would also like to compare our model against a supervised system. Unfortunately, this is not possible, as we are using the designated CoNLL training set as our test set, and any supervised system trained on this data would achieve unfairly high scores. Therefore, we approximate the performance of a supervised system by clustering instances according to their gold standard role after introducing some noise. Specifically, we randomly selected 5% of the gold standard roles and mapped them to an erroneous role. This roughly corresponds to the clustering which would be induced by a stateof-the-art supervised system with 95% precision. Finally, we also report the results of the true upper bound obtained by clustering the arguments, based on their gold standard semantic role (again using 10 clusters per verb). Results Our results are summarized in Table 2 . We report cluster purity, accuracy, precision, recall, and F1 for our latent variable logistic classifier (LogLV) and a baseline that assigns arguments to clusters according to their syntactic function (SyntFunc). The table also includes the gold standard upper bound (Up-perBndG) and its supervised proxy (UpperBndS). We report micro-and macro-average scores. 3  Model scores are quite similar to the baseline, which might suggest that the model is simply replicating the observed data. However, this is not the case: canonical functions differ from observed functions for approximately 27% of the argument instances. If the baseline treated these instances correctly, we would expect it to outperform our model. The fact that it does not, indicates that the baseline error rate is higher precisely on these instances. In other words, the model can help in detecting alternate linkings and thus baseline errors. We further analyzed our model's ability to detect alternate linkings. Specifically, if we assume a standard linking where model and observation agree and an alternate linking where they disagree, we obtain the following. We can therefore increase cluster purity by clustering only those instances where the model does not indicate an alternation. The results are shown in Table 3 . Using less instances while keeping the number of clusters the same will by itself tend to increase performance. To compensate for this, we also report results for the baseline on a reduced dataset. The latter was obtained from the original dataset by randomly removing the same number of instances. 5 By using the model to detect alternations, scores improve over the baseline across the board. We observe performance gains for purity which increases by 8.7% (micro-average; compare Tables 2 and 3 ). F1 also improves considerably by 13% (micro-average). These results are encouraging indicating that detecting alternate linkings is an important first step towards more accurate role induction. We also conducted a more detailed error analysis to gain more insight into the behavior of our model. In most cases, alternate linkings where A1 occurs in subject position and A0 in object position are canonicalized correctly (with 96% and 97% precision, respectively). Half of the detected non-standard linkings involve adjunct roles. Here, the model has much more difficulty with canonicalization and is successful approximately 25% of the time. For example, in the phrase occur at dawn the model canonicalizes LOC to ADV, whereas TMP would be the correct function. About 75% of all false negatives are due to core roles and only 25% due to adjunct roles. Many false negatives are due to parser errors, which are reproduced by the model. This indicates overfitting, and indeed many of the false negatives involve infrequent lexical items (e.g., juxtapose or Odyssey). Finally, to put our evaluation results into context, we also wanted to compare against Grenager and Manning's (2006) related system. A direct comparison is somewhat problematic due to the use of dif-ferent datasets and the fact that we induce labels for all roles whereas they collapse adjunct roles to a single role. Nevertheless, we made a good-faith effort to evaluate our system using their evaluation setting. Specifically, we ran our system on the same test set, Section 23 of the Penn Treebank (annotated with PropBank roles), using gold standard parses with six clusters for each verb type. Our model achieves a cluster purity score of 90.3% on this dataset compared to 89.7% reported in Grenager and Manning. Conclusions In this paper we have presented a novel framework for unsupervised role induction. We conceptualized the induction problem as one of detecting alternate linkings and finding their canonical syntactic form, and formulated a novel probabilistic model that performs these tasks. The model extends the logistic classifier with latent variables and is trained on parsed output which is used as a noisy target for learning. Experimental results show promise, alternations can be successfully detected and the quality of the induced role clusters can be substantially enhanced. We argue that the present model could be usefully employed to enhance the performance of other models. For example, it could be used in an active learning context to identify argument instances that are difficult to classify for a supervised or semisupervised system and would presumably benefit from additional (manual) annotation. Importantly, the framework can incorporate different probabilistic models for detection and canonicalization which we intend to explore in the future. We also aim to embed and test our role induction method within a full SRL system that is also concerned with argument identification. Eventually, we also intend to replace the treebank-trained parser with a chunker."
}