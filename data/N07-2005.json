{
    "article": "Suppose we have a large dictionary of strings. Each entry starts with a figure of merit (popularity). We wish to find the kbest matches for a substring, s, in a dictinoary, dict. That is, grep s dict | sort -n | head -k, but we would like to do this in sublinear time. Example applications: (1) web queries with popularities, (2) products with prices and (3) ads with click through rates. This paper proposes a novel index, k-best suffix arrays, based on ideas borrowed from suffix arrays and kdtrees. A standard suffix array sorts the suffixes by a single order (lexicographic) whereas k-best suffix arrays are sorted by two orders (lexicographic and popularity). Lookup time is between log N and sqrt N. This program is simple to describe (but inefficient, at least in theory) because strcmp can take O(N) time in the worst case (where the corpus contains two copies of an arbitrarily long string). See http://cm.bell-labs.com/cm/cs/who/doug/ssort.c for an implementation of the O(N log N) Manber and Myers algorithm. However, in practice, when the corpus is a dictionary of relatively short entries (such as web queries), the worst case is unlikely to come up. In which case, the simple make_suf program above is good enough, and maybe even better than the O(N log N) solution. Standard Suffix Array Lookup To compute the frequency and locations of a substring s, use a pair of binary searches to find i and j, the locations of the first and last suffix in the suffix array that start with s. Each suffix between i and j point to a location of s in the corpus. The frequency is simply: j \u2212 i + 1. Here is some simple code. We show how to find the first suffix. The last suffix is left as an exercise. As above, we ignore the unlikely worst case (two copies of a long string). See references mentioned above for worst case solutions. K-Best Suffix Arrays K-best suffix arrays are like standard suffix arrays, except there are two orders instead of one. In addition to lexicographic order, we assume a figure of merit, which we will refer to as popularity. For example, the popularity of a string could be its frequency in a search log. The code below assumes that the corpus is a sequence of strings that comes pre-sorted by popularity, and then the popularities have been stripped off. These assumptions make it very easy to compare two strings by popularity. All popcomp has to do is to compare the two positions in the corpus. 1  The make_kbest_suf program below is similar to the make_standard_suf program above except we now sort by the two orders at alternating depths in the tree. First we sort lexicographically and then we sort by popularity and so on, using a construction similar to KD-Trees (Bentley, 1975) . The code below is simple to describe (though there are more efficient implementations that avoid unnecessary qsorts). ;} int popcomp(int* a, int* b) { if (*a > *b) return 1; if (*a < *b) return \u22121; return 0;} K-Best Suffix Array Lookup To find the k-best matches for a particular substring s, we do what we would normally do for standard suffix arrays on lexicographic splits. However, on popularity splits, we search the more popular half first and then we search the less popular half, if necessary. An implementation of kbest-lookup is given below. D denotes the depth of the search thus far. Kbest-lookup is initially called with D of 0. Propose maintains a heap of the k-best matches found thus far. Done returns true if its argument is less popular than the k th best match found thus far. A Short Example: To be or not to be Suppose we were given the text, \"to be or not to be.\" We could then generate the following dictionary with frequencies (popularities). Popularity Word 2 to 2 be 1 or 1 not The dictionary is sorted by popularity. We treat the second column as an N=13 byte corpus (with underscores at record boundaries): to_be_or_not_ The standard suffix array is the 1 st column of the table above. For illustrative convenience, we show the corresponding strings in the 2 nd column. Note that the 2 nd column is sorted lexicographically. Standard K-Best suf corpus + suf[i] suf corpus + suf[i] The k-best suffix array is the 3 rd column with the corresponding strings in the 4 th column. The first split is a lexicographic split at 9 (\"not_\"). On both sides of that split we have a popularity split at 5 (\"_or_not_\") and 7 (\"r_not_\"). (Recall that relative popularity depends on corpus position.) Following there are 4 lexicographic splits, and so on. If k-best lookup were given the query string s = \"o,\" then it would find 1 (o_be_or_not_), 6 (or_not_) and 10 (ot_) as the best choices (in that order). The first split is a lexicographic split. All the matches are below 9 (not_). The next split is on popularity. The matches above this split (1&6) are as popular as the matches below this split (10). It is often desirable to output matching records (rather than suffixes). Records are output in popularity order. The actual popularity can be output, using the side table mentioned in footnote 1: Popularity Record 2 to 1 or 1 not Time and Space Complexity The space requirements are the same for both standard and k-best suffix arrays. Both indexes are permutations of the same suffixes. The time requirements are quite different. Standard suffix arrays were designed to find all matches, not the k-best. Standard suffix arrays can find all matches in O(log N) time. However, if we attempt to use standard suffix arrays to find the kbest, something they were not designed to do, then it could take a long time to sort through the worst case (an embarrassment of riches with lots of matches). When the query matches every string in the dictionary, standard suffix arrays do not help us find the best matches. K-best suffix arrays were designed to handle an embarrassment of riches, which is quite common, especially when the substring s is short. Each popularity split cuts the search space in half when there are lots of lexicographic matches. The best case for k-best suffix arrays is when the popularity splits always work in our favor and we never have to search the less popular half. The worst case is when the popularity splits always fail, such as when the query string s is not in the corpus. In this case, we must always check both the popular half and the unpopular half at each split, since the failure to find a lexicographic match in the first tells us nothing about the existence of matches in the second. Asymptotically, k-best lookup takes between log N and sqrt N time. To see this complexity result, let P(N) be the work to process N items starting with a popularity splits and let L(N) be the work to process N items starting with a lexicographic splits. Thus, P(N) = \u03b1L(N/2) + C 1 L(N) = P(N/2) + C 2 where \u03b1 = 2\u2212p, when p is the probability that the popular half contains sufficient matches. \u03b1 lies between 1 (best case) and 2 (worst case). C 1 and C 2 are constants. Thus, P(N) = \u03b1 P(N/4) + C (1) where C = C 1 + \u03b1C 2 . Using the master method (Cormen et al, 2001) , P(N) = O(log 2 N) in the best case (\u03b1=1). In the worst case (\u03b1=2), P(N) = O(sqrt N). In general, for \u03b1 > 1, P(N) = O(N (log2 \u03b1)/2 ). In practical applications, we expect popularity splits to work more often than not, and therefore we expect the typical case to be closer to the best case than the worst case. Empirical Study The plot below shows the k-best lookup time as a function of square root of corpus size. We extracted sub-corpora from a 150 MB collection of 8M queries, sorted by popularity, according to the logs from Microsoft www.live.com. All experiments were performed on a Pentium 4, 3.2GHz dual processor machine with enough memory to avoid paging. The line of diamonds shows the worst case, where we the query string is not in the index. Note that the diamonds fit the regression line quite well, confirming the theory in the previous section: The worst case lookup is O(sqrt N). To simulate a more typical scenario, we constructed random samples of queries by popularity, represented by squares in the figure. Note that the squares are well below the line, demonstrating that these queries are considerably easier than the worst case. K-best suffix arrays have been used in autocomplete applications (Church and Thiesson, 2005) . The triangles with the fastest lookup times demonstrate the effectiveness of the index for this application. We started with the random sample above, but replaced each query q in the sample with a substring of q (of random size). Conclusion A new data structure, k-best suffix arrays, was proposed. K-best suffix arrays are sorted by two orders, lexicographic and popularity, which make it convenient to find the most popular matches, especially when there are lots of matches. In many applications, such as the web, there are often embarrassments of riches (lots of matches). Lookup time varies from log N to sqrt N, depending on the effectiveness of the popularity splits. In the best case (e.g., very short query strings that match nearly everything), the popularity splits work nearly every time and we rarely have to search the less popular side of a popularity split. In this case, the time is close to log N. On the other hand, in the worst case (e.g., query strings that match nothing), the popularity splits never work, and we always have to search both sides of a popularity split. In this case, lookup time is sqrt N. In many cases, popularity splits work more often than not, and therefore, performance is closer to log N than sqrt N.",
    "abstract": "Suppose we have a large dictionary of strings. Each entry starts with a figure of merit (popularity). We wish to find the kbest matches for a substring, s, in a dictinoary, dict. That is, grep s dict | sort -n | head -k, but we would like to do this in sublinear time. Example applications: (1) web queries with popularities, (2) products with prices and (3) ads with click through rates. This paper proposes a novel index, k-best suffix arrays, based on ideas borrowed from suffix arrays and kdtrees. A standard suffix array sorts the suffixes by a single order (lexicographic) whereas k-best suffix arrays are sorted by two orders (lexicographic and popularity). Lookup time is between log N and sqrt N.",
    "countries": [
        "United States"
    ],
    "languages": [
        ""
    ],
    "numcitedby": "6",
    "year": "2007",
    "month": "April",
    "title": "{K}-Best Suffix Arrays"
}