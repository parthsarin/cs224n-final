{
    "article": "The Layered Domain Class system (LDC) is an experimental natural language processor being developed at Duke University which reached the prototype stage in May of 1983. Its primary goals are (I) to provide English-language retrieval capabilities for structured but unnormaUzed data files created by the user, (2) to allow very complex semantics, in terms of the information directly available from the physical data file; and (3) to enable users to customize the system to operate with new types of data. In this paper we shall discuss (a) the types of modifiers LDC provides for; (b) how information about the syntax and semantics of modifmrs is obtained from users; and (c) how this information is used to process English inputs. I INTRODUCTION The Layered Domain Class system (LDC) is an experimental natural language processor being developed at Duke .University. In this paper we concentrate on the typ.~s of modifiers provided by LDC and the methods by which the system acquires information about the syntax and semantics of userdefined modifiers. A more complete description is available in [4, 5] , and further details on matters not discussed in this paper can be found in [1,2,6,8,9]. The LDC system is made up of two primary components. First, the Ic'nowledge aeTui.~i2ion component, whose job is to find out about the vocabulary and semantics of the language to be used for a new domain, then inquire about the composition of the underlying input file. Second, the User-Phase Processor, which enables a user to obtain statistical reductions on his or her data by typed English inputs. The top-level design of the User-Phase processor involves a linear sequence of modules for scavtvtir~g the input and looking up each token in the dictionary; pars/rig the scanned input to determine its syntactic structure; translatiort of the parsed input into an appropriate formal query; and finally query processing. At the time of this writing, LDC has been completely customized for two fairly complex domains. from which examples are drawn in the remainder of the paper, and several simpler ones. The complex domains are a 2~al gTz, des domain, giving course grades for students in an academic department, and a bu~di~tg ~rgsvtizatiovt domain, containing information on the floors, wings, corridors, occupants, and so forth for one or more buildings. Among the simpler domains LDC has been customized for are files giving employee information and stock market quotations. II MODIFIER TYPES PROVIDED FOR As shown in [4] . LDC handles inputs about as complicated as students who were given a passing grade by an instructor Jim took a graduate course from As suggested here, most of the syntactic and semantic sophistication of inputs to LDC are due to noun phrase modifiers, including a fairly broad coverage of relative clauses. For example, if LDC is told that \"students take courses from instructors\", it will accept such relative clause forms as students who took a graduate course from Trivedi courses Sarah took from Rogers instructors Jim took a graduate course from courses that were taken by Jim students who did not take a course from Rosenberg We summarize the modifier types distinguished by LDC in Table i . which is divided into four parts roughly corresponding to pre-norninal, nominal, post-nominal, and negating modifiers. We have included several modifier types, most of them anaphorie, which are processed syntactically, and methods for whose semantic processing are being implemented along the lines suggested in [7] . Most of the names we give to modifier types are selfexplanatory, but the reader will notice that we have chosen to categorize verbs, based upon their semantics, as tr~Isial verbs, irrtplied para~ter verbs; and operational verbs. \"Trivial\" verbs, which involve no semantics to speak of, can be roughly paraphrased as \"be associated with\". For example, students who take a certain course are precisely those students associated ~ith the database records related to the course. \"Implied parameter\" verbs can be paraphrased as a longer \"trivial\" verb phrase by adding a parameter and requisite noise words for syntactic acceptability. For example, students who fai/a course are those students who rrmlce a grade of F in the course. Finally, \"operational\" verbs require an operation to be performed on one or more of its noun phrase arguments, rather than simply asking for a comparison of its noun phrase referent(s) against values in specified fields of the physical data file. For example, the students who oz~tscure Jim are precisely those students who Trtake a grade h~gher than the grade of Jirm At present, prepositions are treated semantically as trivial verbs, so that \"students in AI\" is interpreted as \"students associated with records related to the AI course\". 2. There need not be any correlation between the type of modifier being defined and the way in which its rr~eaTt/rtg relates to the underlying data file. For this reason, Prep acquires the meanings of all user-defined modifiers in the same manner by providing such primitives as id, the identity function; va2, which retrieves a specified field of a record; vzzern, which returns the size of its argument, which is assumed to be a set; sum, which returns the sum of '.'-s list of inputs; aug, which returns the average of its list of inputs; and pct, which returns the percentage of its list of boolean arguments which are true. Other userdefined adjectives may also be used. Thus, a \"desirable instructor\" might be defined as an instructor who gave a good grade to more than half his students, where a \"good grade\" is defined as a grade of B or above. These two adjectives may be specified as shown below. (2) a list of furtcticvts corresponding to the arcs on the path from the primary to the target nodes; and finally (3) a pred/cate to be applied to the numerical value obtained from the series of function calls just acquired. ACQUIRING SEMANTICS FOR IV UTILIZATION OF THE INFORMATION ACQUIRED DURING PREPROCESSING As shown in Figure i , the English-language processor of LDC achieves domain independence by restricting itself to (a) a domain-independent. linguistically-motivated phrase-structure grammar [6] and (b) and the domain-specific files produced by the knowledge acquisition module. The simplest file is the pattern file, which captures the morphology of domain-specific proper nouns, e.g. the entity type \"room\" may have values such as X-238 and A-22, or \"letter, dash. digits\". This information frees us from having to store all possible field values in the dictionary, as some systems do, or to make reference to the physical data file when new data values are typed by the user, as other systems do. The domain-specific d/ctlon~ry file contains some standard terms (articles, ordinals, etc.) and also both root words and inflections for terms acquired from the user. The sample dictionary entry (longest Superl long (nt meeting week)) says that \"longest\" is the superlative form of the adjective \"long\", and may occur in noun phrases whose 'head noun refers to entities of type meeting or week. By having this information in the dictionary, the parser can perform \"local\" compatibility checks to assure the integrity of a noun phrase being built up, i.e. to assure all words in the phrase can go together on nonsyntactic grounds. This aids in disambiguation, yet avoids expensive interaction with a subsequent semantics module. related to negation Interestingly, most meaningful interpretations of phrases containing \"non\" or \"not\" can be obtained by inserting the retrieval r2.odule's Not command at an appropriate point in the macro body for the modifier in question. For example, An opportunity to perform \"non-local\" compatibility checking is provided for by the eompat file, which tells (a) the case structure of each verb, i.e. which prepositions may occur and which entity types may fill each noun phrase \"slot\", and (b) which pairs of entity types may be linked by each preposition. The former information will have been acquired directly from the user, while the latter is predicted by heuristics based upon the sorts of conceptual relationships that can occur in the \"layered\" domains of interest [1]. I User Finally, the macro file contains the meanings of modifiers, roughly in the form in which they were acquired using the specification language discussed in the previous section. Although this required us to formulate our own retrieval query language [3], having complex modifier meanings directly exceutable by the retrieval module enables us to avoid many of the problems typically arising in the translation from parse structures to formal retrieval queries\u2022 Furthermore, some modifier meanings can be derived by the system from the meanings of other modifiers, rather than separately acquired from the user\u2022 For example, if the meaning of the adjective \"large\" has been given by the user, the system automatically processes \"largest\" and \"larger than ...\" by appropriately interpreting the macro body for \"large\". A partially unsolved problem in macro processing involves the resolution of scope ambiguities students who were not failed by Rosenberg might or might not be intended to include students who did not take a course from Rosenberg. The retrieval query commands generated by the positive usage of \"fail\", as in students that Rosenberg failed would be the sequence instructor --Rosenberg; student -> fail so the question is whether to introduce \"not\" at the phrase level not iinstructor = Rosenberg; student -> fail~ or instead at the verb level instructor = Rosenberg; not ~student -> fail] Our current system takes the literal reading, and thus generates the first interpretation given\u2022 The example points out the close relationship between negation scope and the important problem of \"presupposition\", in that the user may be interested only in students who had a chance to be failed\u2022",
    "abstract": "The Layered Domain Class system (LDC) is an experimental natural language processor being developed at Duke University which reached the prototype stage in May of 1983. Its primary goals are (I) to provide English-language retrieval capabilities for structured but unnormaUzed data files created by the user, (2) to allow very complex semantics, in terms of the information directly available from the physical data file; and (3) to enable users to customize the system to operate with new types of data. In this paper we shall discuss (a) the types of modifiers LDC provides for; (b) how information about the syntax and semantics of modifmrs is obtained from users; and (c) how this information is used to process English inputs.",
    "countries": [
        "United States"
    ],
    "languages": [
        "English"
    ],
    "numcitedby": "10",
    "year": "1984",
    "month": "July",
    "title": "The Syntax and Semantics of User-Defined Modifiers in Transportable Natural Language Processor"
}