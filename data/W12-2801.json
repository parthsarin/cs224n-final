{
    "article": "This paper addresses the problem of training an artificial agent to follow verbal instructions representing high-level tasks using a set of instructions paired with demonstration traces of appropriate behavior. From this data, a mapping from instructions to tasks is learned, enabling the agent to carry out new instructions in novel environments. Introduction Learning to interpret language from a situated context has become a topic of much interest in recent years (Branavan et al., 2009; Branavan et al., 2010; Branavan et al., 2011; Clarke et al., 2010; Chen and Mooney, 2011; Vogel and Jurafsky, 2010; Goldwasser and Roth, 2011; Liang et al., 2011; Atrzi and Zettlemoyer, 2011; Tellex et al., 2011) . Instead of using annotated training data consisting of sentences and their corresponding logical forms (Zettlemoyer and Collins, 2005; Kate and Mooney, 2006; Wong and Mooney, 2007; Zettlemoyer and Collins, 2009; Lu et al., 2008) , most of these approaches leverage non-linguistic information from a situated context as their primary source of supervision. These approaches have been applied to various tasks such as following navigational instructions (Vogel and Jurafsky, 2010; Chen and Mooney, 2011; Tellex et al., 2011) , software control (Branavan et al., 2009; Branavan et al., 2010) , semantic parsing (Clarke et al., 2010; Liang et al., 2011) and learning to play games based on text (Branavan et al., 2011; Goldwasser and Roth, 2011) . In this paper, we present an approach to interpreting language instructions that describe complex multipart tasks by learning from pairs of instructions and behavioral traces containing a sequence of primitive actions that result in these instructions being properly followed. We do not assume a oneto-one mapping between instructions and primitive actions. Our approach uses three main subcomponents: (1) recognizing intentions from observed behavior using variations of Inverse Reinforcement Learning (IRL) methods; (2) translating instructions to task specifications using Semantic Parsing (SP) techniques; and (3) creating generalized task specifications to match user intentions using probabilistic Task Abstraction (TA) methods. We describe our system architecture and a learning scenario. We present preliminary results for a simplified version of our system that uses a unigram language model, minimal abstraction, and simple inverse reinforcement learning. Early work on grounded language learning used features based on n-grams to represent the natural language input (Branavan et al., 2009; Vogel and Jurafsky, 2010) . More recent methods have relied on a richer representation of linguistic data, such as syntactic dependency trees (Branavan et al., 2011; Goldwasser and Roth, 2011) and semantic templates (Tellex et al., 2011) to address the complexity of the natural language input. Our approach uses a flexible framework that allows us to incorporate various degrees of linguistic knowledge available at different stages in the learning process (e.g., from dependency relations to a full-fledged semantic model of the domain learned during training). 1 System Architecture We represent tasks using the Object-oriented Markov Decision Process (OO-MDP) formalism (Diuk et al., 2008) , an extension of Markov Decision Processes (MDPs) to explicitly capture relationships between objects. Specifically, OO-MDPs add a set of classes C, each with a set of attributes T C . Each OO-MDP state is defined by an unordered set of instantiated objects. In addition to these object definitions, an OO-MDP also defines a set of propositional functions that operate on objects. For instance, we might have a propositional function toyIn(toy, room) that operates on an object belonging to class \"toy\" and an object belonging to class \"room,\" returning true if the specified \"toy\" object is in the specific \"room\" object. We extend OO-MDPs to include a set of propositional function classes (F) associating propositional functions that describe similar properties. In the context of defining a task corresponding to a particular goal, an OO-MDP defines a subset of states \u03b2 \u2282 S called termination states that end an action sequence and that need to be favored by the task's reward function. Example Domain. To illustrate our approach, we present a simple domain called Cleanup World, a 2D grid world defined by various rooms that are connected by open doorways and can contain various objects (toys) that the agent can push around to different positions in the world. The Cleanup World domain can be represented as an OO-MDP with four object classes: agent, room, doorway, and toy, and a set of propositional functions that specify whether a toy is a specific shape (such as isStar(toy)), the color of a room (such as isGreen(room)), whether a toy is in a specific room (toyIn(toy, room)), and whether an agent is in a specific room (agentIn(room)). These functions belong to shape, color, toy position or agent position classes. Interaction among IRL, SP and TA The training data for the overall system is a set of pairs of verbal instructions and behavior. For example, one of these pairs could be the instruction Push the star to the green room with a demonstration of the task being accomplished in a specific environment containing various toys and rooms of different colors. We assume the availability of a set of fea-tures for each state represented using the OO-MDP propositional functions descibed previously. These features play an important role in defining the tasks to be learned. For example, a robot being taught to move furniture around would have information about whether or not it is currently carrying a piece of furniture, what piece of furniture it needs to be moving, which room it is currently in, which room contains each piece of furniture, etc. We present briefly the three components of our system (IRL, SP and TA) and how they interact with each other during learning. Inverse Reinforcement Learning. Inverse Reinforcement Learning (Abbeel and Ng, 2004) addresses the task of learning a reward function from demonstrations of expert behavior and information about the state-transition function. Recently, more data-efficient IRL methods have been proposed, including the Maximum Likelihood Inverse Reinforcement Learning (Babes \u00b8- Vroman et al., 2011) or MLIRL approach, which our system builds on. Given even a small number of trajectories, MLIRL finds a weighting of the state features that (locally) maximizes the probability of these trajectories. In our system, these state features consist of one of the sets of propositional functions provided by the TA component. For a given task and a set of sets of state features, MLIRL evaluates the feature sets and returns to the TA component its assessment of the probabilities of the various sets. Semantic Parsing. To address the problem of mapping instructions to semantic parses, we use a constraint-based grammar formalism, Lexicalized Well-Founded Grammar (LWFG), which has been shown to balance expressiveness with practical learnability results (Muresan and Rambow, 2007; Muresan, 2011) . In LWFG, each string is associated with a syntactic-semantic representation, and the grammar rules have two types of constraints: one for semantic composition (\u03a6 c ) and one for semantic interpretation (\u03a6 i ). The semantic interpretation constraints, \u03a6 i , provide access to a semantic model (domain knowledge) during parsing. In the absence of a semantic model, however, the LWFG learnability result still holds. This fact is important if our agent is assumed to start with no knowledge of the task and domain. LWFG uses an ontology-based semantic representation, which is a logical form repre-2 sented as a conjunction of atomic predicates. For example, the representation of the phrase green room is X 1 .is=green, X.P 1 = X 1 , X.isa=room . The semantic representation specifies two conceptsgreen and room-connected through a property that can be uninstantiated in the absence of a semantic model, or instantiated via the \u03a6 i constraints to the property name (e.g, color) if such a model is present. During the learning phase, the SP component, using an LWFG grammar that is learned offline, provides to TA the logical forms (i.e., the semantic parses, or the unlabeled dependency parses if no semantic model is given) for each verbal instruction. For example, for the instruction Move the chair into the green room, the semantic parser knows initially that move is a verb, chair and room are nouns, and green is an adjective. It also has grammar rules of the form S \u2192 Verb NP PP: \u03a6 c1 , \u03a6 i1 , 1 but it has no knowledge of what these words mean (that is, to which concepts they map in the domain model). For this instruction, the LWFG parser returns the logical form: (X 1 .isa=move, X 1 .Arg1= X 2 ) move , (X 2 .det=the) the , (X 2 .isa=chair) chair , (X 1 .P 1 = X 3 , P 2 .isa=into) into , (X 3 .det=the) the , (X 4 .isa=green, X 3 .P 2 = X 2 ) green , (X 3 .isa=room) room . The subscripts for each atomic predicate indicate the word to which that predicate corresponds. This logical form corresponds to the simplified logical form move(chair1,room1), P1(room1,green), where predicate P1 is uninstantiated. A key advantage of this framework is that the LWFG parser has access to the domain (semantic) model via \u03a6 i constraints. As a result, when TA provides feedback about domain-specific meanings (i.e., groundings), the parser can incorporate those mappings via the \u03a6 i constraints (e.g., move might map to the predicate blockToRoom with a certain probability). Task Abstraction. The termination conditions for an OO-MDP task can be defined in terms of the propositional functions. For example, the Cleanup World domain might include a task that requires the agent to put a specific toy (t 1 ) in a specific room (r 1 ). In this case, the termination states would be defined by states that satisfy toyIn(t 1 , r 1 ) and the reward function would be defined as R a (s, s ) = {1 : toyIn(t s 1 , r s 1 ); \u22121 : otherwise}. However, such a task definition is overly specific and cannot be evaluated in a new environment that contains different objects. To remove this limitation, we define abstract task descriptions using parametric lifted reward and termination functions. A parametric lifted reward function is a first-order logic expression in which the propositional functions defining the reward can be selected as parameters. This representation allows much more general tasks to be defined; these tasks can be evaluated in any environment that contains the necessary object classes. For instance, the reward function for an abstract task that encourages an agent to take a toy of a certain shape to a room of a certain color (resulting in a reward of 1) would be represented as R a (s, s ) = {1 : \u2203 t s \u2208toy \u2203 r s \u2208room P1(t) \u2227 P2(r) \u2227 toyIn(t, r); \u22121 : otherwise}, where P1 is a propositional function that operates on toy objects and P2 is a propositional function that operates on room objects. An analogous definition can be made for termination conditions. Given the logical forms provided by SP, TA finds candidate tasks that might match each logical form, along with a set of possible groundings of those tasks. A grounding of an abstract task is the set of propositional functions to be applied to the specific objects in a given training instance. TA then passes these grounded propositional functions as the features to use in IRL. (If there are no candidate tasks, then it will pass all grounded propositional functions of the OO-MDP to IRL.) When IRL returns a reward function for these possible groundings and their likelihoods of representing the true reward function, TA determines whether any abstract tasks it has defined might match. If not, TA will either create a new abstract task that is consistent with the received reward functions or it will modify one of its existing definitions if doing so does not require significant changes. With IRL indicating the intended goal of a trace and with the abstract task indicating relevant parameters, TA can then inform SP of the task/domain specific meanings for the logical forms. A Learning from Scratch Scenario. Our system is trained using a set of sentence-trajectory pairs ((S 1 , T 1 ), ..., (S N , T N )). Initially, the system does not know what any of the words mean and there are no pre-existing abstract tasks. Let's assume that S 1 is Push the star into the green room.This sentence is first processed by the SP component, yielding the following logical forms: L 1 is push(star1, room1), amod(room1, green) and L 2 is push(star1), amod(room1, green), into(star1, room1). These logical forms and their likelihoods are passed to the TA component, and TA induces incomplete abstract tasks, which define only the number and kinds of objects that are relevant to the corresponding reward function. TA can send to IRL a set of features involving these objects, together with T 1 , the demonstration attached to S 1 . This set of features might include: agentTouchToy(t 1 ), toyIn(t 1 , r 1 ), toyIn(t 1 , r 2 ), agentIn(r 1 ). IRL sends back a weighting of the features, and TA can select the subset of features that have the highest weights (e.g, (1.91, toyIn(t 1 , r 1 )), (1.12, agentTouchToy(t 1 )), (0.80, agentIn(r 1 )). Using information from SP and IRL, TA can now create a new abstract task, perhaps called blockToRoom, adjust the probabilities of the logical forms based on the relevant features obtained from IRL, and send these probabilities back to SP, enabling it to adjust its semantic model. The entire system proceeds iteratively. While it is designed, not all features are fully implemented to be able to report experimental results. In the next section, we present a simplified version of our system and show preliminary results. A Simplified Model and Experiments In this section, we present a simplified version of our system with a unigram language model, inverse reinforcement learning and minimal abstraction. We call this version Model 0. The input to Model 0 is a set of verbal instructions paired with demonstrations of appropriate behavior. It uses an EM-style algorithm (Dempster et al., 1977) to estimate the probability distribution of words conditioned on reward functions (the parameters). With this information, when the system receives a new command, it can behave in a way that maximizes its reward given the posterior probabilities of the possible reward functions given the words. Algorithm 1 shows our EM-style Model 0. For all possible reward-demonstration pairs, the E-step of EM estimates z ji = Pr(R j |(S i , T i )), the probability that reward function R j produced sentencetrajectory pair (S i , T i ), This estimate is given by the equation below: zji = Pr(R j |(S i , T i )) = Pr(R j ) Pr(S i , T i ) Pr((S i , T i )|R j ) = Pr(R j ) Pr(S i , T i ) Pr(T i |R j ) w k \u2208S i Pr(w k |R j ) where S i is the i th sentence, T i is the trajectory demonstrated for verbal command S i , and w k is an element in the set of all possible words (vocabulary). If the reward functions R j are known ahead of time, Pr(T i |R j ) can be obtained directly by solving the MDP and estimating the probability of trajectory T i under a Boltzmann policy with respect to R j . If the R j s are not known, EM can estimate them by running IRL during the M-step (Babes \u00b8- Vroman et al., 2011) . The M-step in Algorithm 1 uses the current estimates of z ji to further refine the probabilities x kj = Pr(w k |R j ): x kj = Pr(w k |R j ) = 1 X \u03a3 w k \u2208S i Pr(R j |S i ) + \u03a3 i N (S i )z ji + where is a smoothing parameter, X is a normalizing factor and N (S i ) is the number of words in sentence S i . To illustrate our Model 0 performance, we selected as training data six sentences for two tasks (three sentences for each task) from a dataset we have collected using Amazon Mechanical Turk for the Cleanup Domain. We show the training data in Figure 1 . We obtained the reward function for each task using MLIRL, computed the Pr(T i |R j ), then ran Algorithm 1 and obtained the parameters Pr(w k |R j ). After this training process, we presented the agent with a new task. She is given the instruction S N : Go to green room. and a starting state, somewhere in the same grid. Using parameters Pr(w k |R j ), the agent can estimate: We have presented a three-component architecture for interpreting natural language instructions, where the learner has access to natural language input and demonstrations of appropriate behavior. Our future work includes fully implementing the system to be able to build abstract tasks from language information and feature relevance. Acknowledgments The authors acknowledge the support of the National Science Foundation (collaborative grant IIS-00006577 and IIS-1065195). The authors thank the anonymous reviewers for their feedback. Any opinions, findings, conclusions, or recommendations expressed in this paper are those of the authors, and do not necessarily reflect the views of the funding organization. . until target number of iterations completed. and choose the optimal policy corresponding to reward R 2 , thus successfully carrying out the task. Note that R 1 and R 2 corresponded to the two target tasks, but this mapping was determined by EM. We illustrate the limitation of the unigram model by telling the trained agent to Go with the star to green, (we label this sentence S N ). Using the learned parameters, the agent computes the following esti- Pr(w k |R 2 ) = 2.10 \u00d7 10 \u22125 . The agent wrongly chooses reward R 2 and goes to the green room instead of taking the star to the green room. The problem with the unigram model in this case is that it gives too much weight to word frequencies (in this case go) without taking into account what the words mean or how they are used in the context of the sentence. Using the system described in Section 2, we can address these problems and also move towards more complex scenarios."
}